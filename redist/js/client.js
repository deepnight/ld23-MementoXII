(function ($global) { "use strict";
var $hxClasses = {},$estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var hxd_Res = function() { };
$hxClasses["hxd.Res"] = hxd_Res;
hxd_Res.__name__ = "hxd.Res";
hxd_Res.load = function(name) {
	return hxd_Res.get_loader().load(name);
};
hxd_Res.get_loader = function() {
	var l = hxd_res_Loader.currentInstance;
	if(l == null) {
		throw haxe_Exception.thrown("Resource loader not initialized: call to hxd.Res.initXXX() required");
	}
	return l;
};
hxd_Res.set_loader = function(l) {
	return hxd_res_Loader.currentInstance = l;
};
var hxd_res_Loader = function(fs) {
	this.fs = fs;
	this.cache = new haxe_ds_StringMap();
};
$hxClasses["hxd.res.Loader"] = hxd_res_Loader;
hxd_res_Loader.__name__ = "hxd.res.Loader";
hxd_res_Loader.prototype = {
	load: function(path) {
		return new hxd_res_Any(this,this.fs.get(path));
	}
	,loadCache: function(path,c) {
		var res = this.cache.h[path];
		if(res == null) {
			var entry = this.fs.get(path);
			var old = hxd_res_Loader.currentInstance;
			hxd_res_Loader.currentInstance = this;
			res = Type.createInstance(c,[entry]);
			hxd_res_Loader.currentInstance = old;
			this.cache.h[path] = res;
		} else if((js_Boot.__downcastCheck(res,c) ? res : null) == null) {
			throw haxe_Exception.thrown(path + " has been reintrepreted from " + Std.string(js_Boot.getClass(res)) + " to " + Std.string(c));
		}
		return res;
	}
	,__class__: hxd_res_Loader
};
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
$hxClasses["EReg"] = EReg;
EReg.__name__ = "EReg";
EReg.prototype = {
	match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	,matched: function(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw haxe_Exception.thrown("EReg::matched");
		}
	}
	,matchedPos: function() {
		if(this.r.m == null) {
			throw haxe_Exception.thrown("No string matched");
		}
		return { pos : this.r.m.index, len : this.r.m[0].length};
	}
	,matchSub: function(s,pos,len) {
		if(len == null) {
			len = -1;
		}
		if(this.r.global) {
			this.r.lastIndex = pos;
			this.r.m = this.r.exec(len < 0 ? s : HxOverrides.substr(s,0,pos + len));
			var b = this.r.m != null;
			if(b) {
				this.r.s = s;
			}
			return b;
		} else {
			var b = this.match(len < 0 ? HxOverrides.substr(s,pos,null) : HxOverrides.substr(s,pos,len));
			if(b) {
				this.r.s = s;
				this.r.m.index += pos;
			}
			return b;
		}
	}
	,__class__: EReg
};
var dn_heaps_assets_SfxDirectory = function() { };
$hxClasses["dn.heaps.assets.SfxDirectory"] = dn_heaps_assets_SfxDirectory;
dn_heaps_assets_SfxDirectory.__name__ = "dn.heaps.assets.SfxDirectory";
var dn_heaps_Sfx = function(s) {
	this.sound = s;
	this.volume = 1;
	if(this.lastChannel != null && !(this.lastChannel != null && this.lastChannel.pause)) {
		this.applyVolume();
	}
	this.spatialRangeMul = 1.0;
	this.groupId = dn_heaps_Sfx.DEFAULT_GROUP_ID;
	var path = this.sound == null || this.sound.entry == null ? null : this.sound.entry.get_path();
	if(!Object.prototype.hasOwnProperty.call(dn_heaps_Sfx.FILEPATH_TO_UID.h,path)) {
		dn_heaps_Sfx.FILEPATH_TO_UID.h[path] = dn_heaps_Sfx.UNIQ++;
	}
	this.soundUid = dn_heaps_Sfx.FILEPATH_TO_UID.h[path];
};
$hxClasses["dn.heaps.Sfx"] = dn_heaps_Sfx;
dn_heaps_Sfx.__name__ = "dn.heaps.Sfx";
dn_heaps_Sfx.getGlobalGroup = function(id) {
	if(!dn_heaps_Sfx.GLOBAL_GROUPS.h.hasOwnProperty(id)) {
		var this1 = dn_heaps_Sfx.GLOBAL_GROUPS;
		var value = new dn_heaps__$Sfx_GlobalGroup(id);
		this1.h[id] = value;
	}
	return dn_heaps_Sfx.GLOBAL_GROUPS.h[id];
};
dn_heaps_Sfx.prototype = {
	onLoop: function() {
	}
	,play: function(loop,vol) {
		if(loop == null) {
			loop = false;
		}
		if(vol != null) {
			this.volume = vol < 0 ? 0 : vol > 1 ? 1 : vol;
			if(this.lastChannel != null && !(this.lastChannel != null && this.lastChannel.pause)) {
				this.applyVolume();
			}
		}
		if(this.lastChannel != null && !(this.lastChannel != null && this.lastChannel.pause)) {
			this.stop();
		}
		if(dn_heaps_Sfx.SOUND_DEFAULT_GROUPS.h.hasOwnProperty(this.soundUid)) {
			this.groupId = dn_heaps_Sfx.SOUND_DEFAULT_GROUPS.h[this.soundUid];
		}
		var c = this.sound.play(loop,this.volume,null,dn_heaps_Sfx.getGlobalGroup(this.groupId).soundGroup);
		var _gthis = this;
		this.onEndCurrent = null;
		this.lastChannel = c;
		this.lastChannel.onEnd = function() {
			if(_gthis.lastChannel.loop) {
				_gthis.onLoop();
			}
			if(_gthis.onEndCurrent != null) {
				var cb = _gthis.onEndCurrent;
				_gthis.onEndCurrent = null;
				cb();
			}
		};
		this.applyVolume();
		if(dn_heaps_Sfx.ON_PLAY_CB.h.hasOwnProperty(this.soundUid)) {
			dn_heaps_Sfx.ON_PLAY_CB.h[this.soundUid](this);
		}
		return this;
	}
	,applyVolume: function() {
		if(this.lastChannel == null || this.lastChannel.isReleased() ? false : true) {
			this.lastChannel.set_volume(this.getMixedVolumeFactor() * this.volume);
		}
	}
	,getMixedVolumeFactor: function() {
		var spatial = 1.0;
		var tmp;
		var v = this.spatialX;
		if(v != null && !isNaN(v) && isFinite(v)) {
			var v = this.spatialY;
			tmp = v != null && !isNaN(v) && isFinite(v);
		} else {
			tmp = false;
		}
		if(tmp) {
			var dist = Math.sqrt((this.spatialX - dn_heaps_Sfx.SPATIAL_LISTENER_X) * (this.spatialX - dn_heaps_Sfx.SPATIAL_LISTENER_X) + (this.spatialY - dn_heaps_Sfx.SPATIAL_LISTENER_Y) * (this.spatialY - dn_heaps_Sfx.SPATIAL_LISTENER_Y));
			var x = 1 - dist / (dn_heaps_Sfx.SPATIAL_LISTENER_RANGE * this.spatialRangeMul);
			var f = x < 0 ? 0 : x > 1 ? 1 : x;
			spatial = f * f * f;
		}
		var overrideVol = dn_heaps_Sfx.SOUND_VOLUMES_OVERRIDE.h.hasOwnProperty(this.soundUid) ? dn_heaps_Sfx.SOUND_VOLUMES_OVERRIDE.h[this.soundUid] : 1;
		var _this = dn_heaps_Sfx.getGlobalGroup(this.groupId);
		return (_this.muted ? 0 : _this.volume) * spatial * overrideVol;
	}
	,stop: function() {
		if(this.lastChannel != null) {
			this.lastChannel.stop();
		}
		this.lastChannel = null;
	}
	,__class__: dn_heaps_Sfx
};
var dn_heaps_RandomSfxList = function(sounds,resSoundsPaths) {
	if((sounds == null || sounds.length == 0) && (resSoundsPaths == null || resSoundsPaths.length == 0)) {
		throw haxe_Exception.thrown("One of the arrays must not be empty");
	}
	if(sounds != null && sounds.length > 0) {
		var result = new Array(sounds.length);
		var _g = 0;
		var _g1 = sounds.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = (function(snd) {
				return function() {
					return new dn_heaps_Sfx(snd[0]);
				};
			})([sounds[i]]);
		}
		this.getters = result;
	} else if(resSoundsPaths != null && resSoundsPaths.length > 0) {
		var result = new Array(resSoundsPaths.length);
		var _g = 0;
		var _g1 = resSoundsPaths.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = (function(path) {
				return function() {
					return new dn_heaps_Sfx(hxd_Res.load(path[0]).toSound());
				};
			})([resSoundsPaths[i]]);
		}
		this.getters = result;
	}
};
$hxClasses["dn.heaps.RandomSfxList"] = dn_heaps_RandomSfxList;
dn_heaps_RandomSfxList.__name__ = "dn.heaps.RandomSfxList";
dn_heaps_RandomSfxList.prototype = {
	__class__: dn_heaps_RandomSfxList
};
var Assets = function() { };
$hxClasses["Assets"] = Assets;
Assets.__name__ = "Assets";
Assets.init = function() {
	var t = hxd_Res.get_loader().loadCache("tiles.png",hxd_res_Image).toTile();
	Assets.tiles = new dn_heaps_slib_SpriteLib([t]);
	var this1 = hxd_Res.get_loader();
	Assets.font = this1.loadCache("fonts/04b03.fnt",hxd_res_BitmapFont).toFont();
	var _this = Assets.tiles;
	_this.defaultCenterX = 0;
	_this.defaultCenterY = 0;
	Assets.tiles.slice("collision",0,0,32,8,8);
	Assets.tiles.slice("separator",0,0,48,128,16,2);
	Assets.tiles.slice("cell",0,0,64,112,80,1,4);
	Assets.tiles.slice("picPart1",0,112,80,16,16);
	Assets.tiles.slice("calendar",0,112,96,16,16);
	Assets.tiles.slice("picPart3",0,112,112,16,16);
	Assets.tiles.slice("framed",0,112,128,16,16);
	Assets.tiles.slice("ringBack",0,128,96,16,16);
	Assets.tiles.slice("reflections",0,144,96,16,16);
	Assets.tiles.sliceGrid("sinkWater",0,8,5);
	Assets.tiles.sliceAnimGrid("flow",0,2,8,5,4);
	Assets.tiles.slice("kitchenDoor",0,112,160,16,16);
	Assets.tiles.slice("kitchenKnife",0,112,176,16,16);
	Assets.tiles.slice("kitchenTable",0,112,192,16,16,2);
	Assets.tiles.slice("kitchenChest",0,112,208,16,16,2);
	Assets.tiles.slice("cupDoors",0,128,160,16,20);
	Assets.tiles.slice("phone",0,112,240,16,16);
	Assets.tiles.slice("finalLetter",0,112,256,16,16);
	var _this = Assets.tiles;
	_this.gridX = 16;
	_this.gridY = 16;
	Assets.tiles.slice("player",0,0,0,16,16,16,2);
	Assets.tiles.sliceAnimGrid("wakeWait",0,1,10,0);
	Assets.tiles.sliceAnimGrid("wakeUp",0,1,10,0,4);
	Assets.tiles.sliceAnimGrid("standDown",0,1,0,0);
	Assets.tiles.sliceAnimGrid("standUp",0,1,5,0);
	Assets.tiles.sliceGrid("walkDown",0,0,0,5);
	Assets.tiles.__defineAnim("walkDown",[0,1,2,1,0,3,4,3]);
	Assets.tiles.sliceGrid("walkUp",0,5,0,5);
	Assets.tiles.__defineAnim("walkUp",[0,1,2,1,0,3,4,3]);
	Assets.tiles.sliceAnimGrid("read",0,25,14,0,2);
	Assets.tiles.sliceGrid("cry",0,0,1,5);
	Assets.tiles.__defineAnim("cry",[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4]);
	Assets.tiles.sliceAnimGrid("afterCry",0,100,0,1);
	Assets.tiles.slice("heroFade",0,0,400,192,144);
};
var h3d_IDrawable = function() { };
$hxClasses["h3d.IDrawable"] = h3d_IDrawable;
h3d_IDrawable.__name__ = "h3d.IDrawable";
h3d_IDrawable.__isInterface__ = true;
var hxd_App = function() {
	var _gthis = this;
	var engine = h3d_Engine.CURRENT;
	if(engine != null) {
		this.engine = engine;
		engine.onReady = $bind(this,this.setup);
		haxe_Timer.delay($bind(this,this.setup),0);
	} else {
		hxd_System.start(function() {
			engine = new h3d_Engine();
			_gthis.engine = engine;
			engine.onReady = $bind(_gthis,_gthis.setup);
			engine.init();
		});
	}
};
$hxClasses["hxd.App"] = hxd_App;
hxd_App.__name__ = "hxd.App";
hxd_App.__interfaces__ = [h3d_IDrawable];
hxd_App.staticHandler = function() {
};
hxd_App.prototype = {
	onResize: function() {
	}
	,onContextLost: function() {
		if(this.s3d != null) {
			this.s3d.onContextLost();
		}
	}
	,render: function(e) {
		this.s3d.render(e);
		this.s2d.render(e);
	}
	,setup: function() {
		var _gthis = this;
		var initDone = false;
		this.engine.onReady = hxd_App.staticHandler;
		this.engine.onContextLost = $bind(this,this.onContextLost);
		this.engine.onResized = function() {
			if(_gthis.s2d == null) {
				return;
			}
			_gthis.s2d.checkResize();
			if(initDone) {
				_gthis.onResize();
			}
		};
		this.s3d = new h3d_scene_Scene();
		this.s2d = new h2d_Scene();
		this.sevents = new hxd_SceneEvents();
		this.sevents.addScene(this.s2d);
		this.sevents.addScene(this.s3d);
		this.loadAssets(function() {
			initDone = true;
			_gthis.init();
			hxd_Timer.skip();
			_gthis.mainLoop();
			hxd_System.setLoop($bind(_gthis,_gthis.mainLoop));
			hxd_Key.initialize();
		});
	}
	,loadAssets: function(onLoaded) {
		onLoaded();
	}
	,init: function() {
	}
	,mainLoop: function() {
		hxd_Timer.update();
		this.sevents.checkEvents();
		if(this.isDisposed) {
			return;
		}
		this.update(hxd_Timer.dt);
		if(this.isDisposed) {
			return;
		}
		var dt = hxd_Timer.dt;
		if(this.s2d != null) {
			this.s2d.setElapsedTime(dt);
		}
		if(this.s3d != null) {
			this.s3d.setElapsedTime(dt);
		}
		this.engine.render(this);
	}
	,update: function(dt) {
	}
	,__class__: hxd_App
};
var Boot = function() {
	hxd_App.call(this);
};
$hxClasses["Boot"] = Boot;
Boot.__name__ = "Boot";
Boot.main = function() {
	new Boot();
};
Boot.__super__ = hxd_App;
Boot.prototype = $extend(hxd_App.prototype,{
	init: function() {
		Boot.ME = this;
		new Main(this.s2d);
		this.onResize();
	}
	,onResize: function() {
		hxd_App.prototype.onResize.call(this);
		dn_Process.resizeAll();
	}
	,update: function(deltaTime) {
		hxd_App.prototype.update.call(this,deltaTime);
		dn_legacy_Controller.beforeUpdate();
		var currentTmod = hxd_Timer.dt * hxd_Timer.wantedFPS;
		dn_Process.updateAll(currentTmod);
	}
	,__class__: Boot
});
var Const = function() { };
$hxClasses["Const"] = Const;
Const.__name__ = "Const";
var h2d_filter_Filter = function() {
	this.useScreenResolution = h2d_filter_Filter.defaultUseScreenResolution;
	this.resolutionScale = 1;
	this.enable = true;
	this.smooth = false;
	this.boundsExtend = 0.;
	this.autoBounds = true;
};
$hxClasses["h2d.filter.Filter"] = h2d_filter_Filter;
h2d_filter_Filter.__name__ = "h2d.filter.Filter";
h2d_filter_Filter.prototype = {
	get_enable: function() {
		return this.enable;
	}
	,sync: function(ctx,s) {
	}
	,bind: function(s) {
	}
	,unbind: function(s) {
	}
	,getBounds: function(s,bounds,scale) {
		s.getBounds(s,bounds);
		bounds.xMin = bounds.xMin * scale.x - this.boundsExtend;
		bounds.xMax = bounds.xMax * scale.x + this.boundsExtend;
		bounds.yMin = bounds.yMin * scale.y - this.boundsExtend;
		bounds.yMax = bounds.yMax * scale.y + this.boundsExtend;
	}
	,draw: function(ctx,input) {
		return input;
	}
	,__class__: h2d_filter_Filter
};
var h2d_filter_Shader = function(shader,textureParam) {
	if(textureParam == null) {
		textureParam = "texture";
	}
	h2d_filter_Filter.call(this);
	var found = false;
	var _g = 0;
	var _g1 = shader.shader.data.vars;
	while(_g < _g1.length) {
		var v = _g1[_g];
		++_g;
		if(v.name == textureParam) {
			found = true;
			break;
		}
	}
	if(!found) {
		throw haxe_Exception.thrown("Shader does not have '" + textureParam + "' variable");
	}
	this.textureParam = textureParam;
	this.pass = new h3d_pass_ScreenFx(shader);
};
$hxClasses["h2d.filter.Shader"] = h2d_filter_Shader;
h2d_filter_Shader.__name__ = "h2d.filter.Shader";
h2d_filter_Shader.__super__ = h2d_filter_Filter;
h2d_filter_Shader.prototype = $extend(h2d_filter_Filter.prototype,{
	get_shader: function() {
		return this.pass.shader;
	}
	,draw: function(ctx,t) {
		var out = ctx.textures.allocTileTarget("shaderTmp",t);
		ctx.engine.pushTarget(out);
		this.get_shader()[this.textureParam + "__"] = t.innerTex;
		if(this.nearest) {
			t.innerTex.set_filter(h3d_mat_Filter.Nearest);
		}
		this.pass.render();
		ctx.engine.popTarget();
		return h2d_Tile.fromTexture(out);
	}
	,__class__: h2d_filter_Shader
});
var DistortFilter = function(offset,waveLength,speed,noise) {
	if(speed == null) {
		speed = 1.0;
	}
	if(waveLength == null) {
		waveLength = 32.;
	}
	if(offset == null) {
		offset = 2.0;
	}
	this.intensity = 1.0;
	h2d_filter_Shader.call(this,new _$DistortFilter_InternalShader(),"tex");
	this.offsetX = this.offsetY = offset;
	this.waveLenX = this.waveLenY = waveLength;
	this.speedX = this.speedY = speed;
	if(noise != null) {
		this.get_shader().noiseTex__ = noise;
	} else {
		var bd = new hxd_BitmapData(32,32);
		var _g = 0;
		var _g1 = bd.ctx.canvas.width;
		while(_g < _g1) {
			var x = _g++;
			var _g2 = 0;
			var _g3 = bd.ctx.canvas.height;
			while(_g2 < _g3) {
				var y = _g2++;
				var hue = null;
				var hue1 = hue == null ? Math.random() : hue;
				var saturation = 1.0;
				var luminosity = 1.0;
				if(luminosity == null) {
					luminosity = 1.0;
				}
				if(saturation == null) {
					saturation = 1.0;
				}
				var h = hue1;
				var tmp;
				if(luminosity <= 0) {
					tmp = 0;
				} else if(saturation <= 0) {
					tmp = ((luminosity < 0 ? 0 : luminosity > 1 ? 1 : luminosity) * 255 | 0) << 16 | ((luminosity < 0 ? 0 : luminosity > 1 ? 1 : luminosity) * 255 | 0) << 8 | ((luminosity < 0 ? 0 : luminosity > 1 ? 1 : luminosity) * 255 | 0);
				} else {
					var r = 0.;
					var g = 0.;
					var b = 0.;
					h *= 6;
					var i;
					if(h >= 0) {
						i = h | 0;
					} else {
						var i1 = h | 0;
						i = h == i1 ? i1 : i1 - 1;
					}
					var c1 = luminosity * (1 - saturation);
					var c2 = luminosity * (1 - saturation * (h - i));
					var c3 = luminosity * (1 - saturation * (1 - (h - i)));
					if(i == 0 || i == 6) {
						r = luminosity;
						g = c3;
						b = c1;
					} else if(i == 1) {
						r = c2;
						g = luminosity;
						b = c1;
					} else if(i == 2) {
						r = c1;
						g = luminosity;
						b = c3;
					} else if(i == 3) {
						r = c1;
						g = c2;
						b = luminosity;
					} else if(i == 4) {
						r = c3;
						g = c1;
						b = luminosity;
					} else {
						r = luminosity;
						g = c1;
						b = c2;
					}
					tmp = ((r < 0 ? 0 : r > 1 ? 1 : r) * 255 | 0) << 16 | ((g < 0 ? 0 : g > 1 ? 1 : g) * 255 | 0) << 8 | ((b < 0 ? 0 : b > 1 ? 1 : b) * 255 | 0);
				}
				bd.setPixel(x,y,tmp);
			}
		}
		this.get_shader().noiseTex__ = h3d_mat_Texture.fromBitmap(bd);
		bd.ctx = null;
		bd.pixel = null;
	}
};
$hxClasses["DistortFilter"] = DistortFilter;
DistortFilter.__name__ = "DistortFilter";
DistortFilter.__super__ = h2d_filter_Shader;
DistortFilter.prototype = $extend(h2d_filter_Shader.prototype,{
	draw: function(ctx,t) {
		this.get_shader().time__ = ctx.time;
		var _this = this.get_shader();
		var x = this.intensity;
		_this.intensity__ = x < 0 ? 0 : x > 1 ? 1 : x;
		this.get_shader().offsetY__ = this.offsetY / t.height;
		this.get_shader().waveLenY__ = this.waveLenY / t.height;
		this.get_shader().speedY__ = this.speedY;
		this.get_shader().offsetX__ = this.offsetX / t.width;
		this.get_shader().waveLenX__ = this.waveLenX / t.width;
		this.get_shader().speedX__ = this.speedX;
		return h2d_filter_Shader.prototype.draw.call(this,ctx,t);
	}
	,__class__: DistortFilter
});
var hxsl_Shader = function() {
	this.priority = 0;
	this.initialize();
};
$hxClasses["hxsl.Shader"] = hxsl_Shader;
hxsl_Shader.__name__ = "hxsl.Shader";
hxsl_Shader.prototype = {
	initialize: function() {
		this.constModified = true;
		if(this.shader != null) {
			return;
		}
		var cl = js_Boot.getClass(this);
		this.shader = cl._SHADER;
		if(this.shader == null) {
			var curClass = cl;
			while(curClass != null && curClass.SRC == null) curClass = curClass.__super__;
			if(curClass == null) {
				throw haxe_Exception.thrown(cl.__name__ + " has no shader source");
			}
			this.shader = curClass._SHADER;
			if(this.shader == null) {
				this.shader = new hxsl_SharedShader(curClass.SRC);
				curClass._SHADER = this.shader;
			}
		}
	}
	,setPriority: function(v) {
		this.priority = v;
	}
	,getParamValue: function(index) {
		throw haxe_Exception.thrown("assert");
	}
	,getParamFloatValue: function(index) {
		throw haxe_Exception.thrown("assert");
	}
	,updateConstants: function(globals) {
		throw haxe_Exception.thrown("assert");
	}
	,updateConstantsFinal: function(globals) {
		var c = this.shader.consts;
		while(c != null) {
			if(c.globalId == 0) {
				c = c.next;
				continue;
			}
			var v = globals.map.h[c.globalId];
			var _g = c.v.type;
			switch(_g._hx_index) {
			case 1:
				var v1 = v;
				if(v1 >>> c.bits != 0) {
					throw haxe_Exception.thrown("Constant " + c.v.name + " is outside range (" + v1 + " > " + ((1 << c.bits) - 1) + ")");
				}
				this.constBits |= v1 << c.pos;
				break;
			case 2:
				var v2 = v;
				if(v2) {
					this.constBits |= 1 << c.pos;
				}
				break;
			case 17:
				var count = _g.size;
				if(v == null) {
					c = c.next;
					continue;
				}
				var v3 = v;
				var sel = v3.channel;
				if(v3.texture == null) {
					sel = hxsl_Channel.Unknown;
				} else if(sel == null || sel == hxsl_Channel.Unknown) {
					switch(count) {
					case 1:
						if(v3.texture.format == h3d_mat_Texture.nativeFormat) {
							sel = hxsl_Channel.PackedFloat;
						} else {
							throw haxe_Exception.thrown("Constant " + c.v.name + " does not define channel select value");
						}
						break;
					case 3:
						if(v3.texture.format == h3d_mat_Texture.nativeFormat) {
							sel = hxsl_Channel.PackedNormal;
						} else {
							throw haxe_Exception.thrown("Constant " + c.v.name + " does not define channel select value");
						}
						break;
					default:
						throw haxe_Exception.thrown("Constant " + c.v.name + " does not define channel select value");
					}
				}
				this.constBits |= (globals.allocChannelID(v3.texture) << 3 | sel._hx_index) << c.pos;
				break;
			default:
				throw haxe_Exception.thrown("assert");
			}
			c = c.next;
		}
		var _this = this.shader;
		var constBits = this.constBits;
		var i = _this.instanceCache.h[constBits];
		this.instance = i == null ? _this.makeInstance(constBits) : i;
	}
	,toString: function() {
		var c = js_Boot.getClass(this);
		return c.__name__;
	}
	,__class__: hxsl_Shader
};
var h3d_shader_ScreenShader = function() {
	this.flipY__ = 0;
	hxsl_Shader.call(this);
};
$hxClasses["h3d.shader.ScreenShader"] = h3d_shader_ScreenShader;
h3d_shader_ScreenShader.__name__ = "h3d.shader.ScreenShader";
h3d_shader_ScreenShader.__super__ = hxsl_Shader;
h3d_shader_ScreenShader.prototype = $extend(hxsl_Shader.prototype,{
	get_flipY: function() {
		return this.flipY__;
	}
	,set_flipY: function(_v) {
		return this.flipY__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	,__class__: h3d_shader_ScreenShader
});
var _$DistortFilter_InternalShader = function() {
	this.offsetY__ = 0;
	this.waveLenY__ = 0;
	this.speedY__ = 0;
	this.offsetX__ = 0;
	this.waveLenX__ = 0;
	this.speedX__ = 0;
	this.intensity__ = 0;
	this.time__ = 0;
	h3d_shader_ScreenShader.call(this);
};
$hxClasses["_DistortFilter.InternalShader"] = _$DistortFilter_InternalShader;
_$DistortFilter_InternalShader.__name__ = "_DistortFilter.InternalShader";
_$DistortFilter_InternalShader.__super__ = h3d_shader_ScreenShader;
_$DistortFilter_InternalShader.prototype = $extend(h3d_shader_ScreenShader.prototype,{
	get_tex: function() {
		return this.tex__;
	}
	,set_tex: function(_v) {
		return this.tex__ = _v;
	}
	,get_noiseTex: function() {
		return this.noiseTex__;
	}
	,set_noiseTex: function(_v) {
		return this.noiseTex__ = _v;
	}
	,get_time: function() {
		return this.time__;
	}
	,set_time: function(_v) {
		return this.time__ = _v;
	}
	,get_intensity: function() {
		return this.intensity__;
	}
	,set_intensity: function(_v) {
		return this.intensity__ = _v;
	}
	,get_speedX: function() {
		return this.speedX__;
	}
	,set_speedX: function(_v) {
		return this.speedX__ = _v;
	}
	,get_waveLenX: function() {
		return this.waveLenX__;
	}
	,set_waveLenX: function(_v) {
		return this.waveLenX__ = _v;
	}
	,get_offsetX: function() {
		return this.offsetX__;
	}
	,set_offsetX: function(_v) {
		return this.offsetX__ = _v;
	}
	,get_speedY: function() {
		return this.speedY__;
	}
	,set_speedY: function(_v) {
		return this.speedY__ = _v;
	}
	,get_waveLenY: function() {
		return this.waveLenY__;
	}
	,set_waveLenY: function(_v) {
		return this.waveLenY__ = _v;
	}
	,get_offsetY: function() {
		return this.offsetY__;
	}
	,set_offsetY: function(_v) {
		return this.offsetY__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.tex__;
		case 2:
			return this.noiseTex__;
		case 3:
			return this.time__;
		case 4:
			return this.intensity__;
		case 5:
			return this.speedX__;
		case 6:
			return this.waveLenX__;
		case 7:
			return this.offsetX__;
		case 8:
			return this.speedY__;
		case 9:
			return this.waveLenY__;
		case 10:
			return this.offsetY__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 3:
			return this.time__;
		case 4:
			return this.intensity__;
		case 5:
			return this.speedX__;
		case 6:
			return this.waveLenX__;
		case 7:
			return this.offsetX__;
		case 8:
			return this.speedY__;
		case 9:
			return this.waveLenY__;
		case 10:
			return this.offsetY__;
		default:
		}
		return 0.;
	}
	,__class__: _$DistortFilter_InternalShader
});
var Entity = function(w,s) {
	this.frict = 0.7;
	this.world = w;
	this.spr = s;
	this.cx = this.cy = 2;
	this.xr = this.yr = 0.5;
	this.dx = this.dy = 0;
	this.dirY = 1;
};
$hxClasses["Entity"] = Entity;
Entity.__name__ = "Entity";
Entity.prototype = {
	moveTo: function(x,y) {
		this.cx = x;
		this.cy = y;
		this.xr = 0.5;
		this.yr = 0.5;
	}
	,lookAt: function(x,y) {
		if(y >= this.cy) {
			this.dirY = 1;
		} else {
			this.dirY = -1;
		}
	}
	,update: function(tmod) {
		var tmp;
		if(this.yr + this.dy > 1) {
			var _this = this.world;
			var x = this.cx;
			var y = this.cy + 1;
			tmp = x < 0 || x >= _this.wid || y < 0 || y >= _this.hei ? true : _this.cmap[x][y];
		} else {
			tmp = false;
		}
		if(tmp) {
			this.yr = 1;
			this.dy = 0;
		}
		var tmp;
		if(this.yr + this.dy < 0.4) {
			var _this = this.world;
			var x = this.cx;
			var y = this.cy - 1;
			tmp = x < 0 || x >= _this.wid || y < 0 || y >= _this.hei ? true : _this.cmap[x][y];
		} else {
			tmp = false;
		}
		if(tmp) {
			this.yr = 0.4;
			this.dy = 0;
		}
		this.yr += this.dy * tmod;
		while(this.yr < 0) {
			this.yr++;
			this.cy--;
		}
		while(this.yr > 1) {
			this.yr--;
			this.cy++;
		}
		var tmp;
		if(this.xr + this.dx > 0.7) {
			var _this = this.world;
			var x = this.cx + 1;
			var y = this.cy;
			tmp = x < 0 || x >= _this.wid || y < 0 || y >= _this.hei ? true : _this.cmap[x][y];
		} else {
			tmp = false;
		}
		if(tmp) {
			this.xr = 0.7;
			this.dx = 0;
		}
		var tmp;
		if(this.xr + this.dx < 0.5) {
			var _this = this.world;
			var x = this.cx - 1;
			var y = this.cy;
			tmp = x < 0 || x >= _this.wid || y < 0 || y >= _this.hei ? true : _this.cmap[x][y];
		} else {
			tmp = false;
		}
		if(tmp) {
			this.xr = 0.5;
			this.dx = 0;
		}
		this.xr += this.dx * tmod;
		while(this.xr < 0) {
			this.xr++;
			this.cx--;
		}
		while(this.xr > 1) {
			this.xr--;
			this.cx++;
		}
		if(this.dy < 0) {
			this.dirY = -1;
		}
		if(this.dy > 0) {
			this.dirY = 1;
		}
		this.dx *= Math.pow(this.frict,tmod);
		this.dy *= Math.pow(this.frict,tmod);
		var x = this.dx;
		if((x < 0 ? -x : x) <= 0.0001) {
			this.dx = 0;
		}
		var x = this.dy;
		if((x < 0 ? -x : x) <= 0.0001) {
			this.dy = 0;
		}
		var _this = this.spr;
		_this.posChanged = true;
		_this.x = this.cx * Const.GRID + this.xr * Const.GRID | 0;
		var _this = this.spr;
		_this.posChanged = true;
		_this.y = this.cy * Const.GRID + this.yr * Const.GRID | 0;
	}
	,__class__: Entity
};
var dn_struct_FixedArray = function(name,maxSize) {
	this.name = name;
	var this1 = new Array(maxSize);
	this.values = this1;
	this.nalloc = 0;
};
$hxClasses["dn.struct.FixedArray"] = dn_struct_FixedArray;
dn_struct_FixedArray.__name__ = "dn.struct.FixedArray";
dn_struct_FixedArray.prototype = {
	iterator: function() {
		return new dn_struct__$FixedArray_FixedArrayIterator(this);
	}
	,toString: function() {
		var a = [];
		var _g_arr = this;
		var _g_i = 0;
		while(_g_i < _g_arr.nalloc) {
			var e = _g_arr.values[_g_i++];
			a.push(e);
		}
		return a.toString() + ("<" + this.nalloc + "/" + this.values.length + ">");
	}
	,dumpContent: function() {
		var sub = [];
		var _g = 0;
		var _g1 = this.nalloc;
		while(_g < _g1) {
			var i = _g++;
			sub[i] = this.values[i];
		}
		return "[ " + sub.join(", ") + " ]";
	}
	,remove: function(e) {
		var found = false;
		var _g = 0;
		var _g1 = this.nalloc;
		while(_g < _g1) {
			var i = _g++;
			if(this.values[i] == e) {
				this.removeIndex(i);
				found = true;
				break;
			}
		}
		return found;
	}
	,removeIndex: function(i) {
		if(i < this.nalloc) {
			this.values[i] = null;
			if(this.nalloc > 1) {
				this.values[i] = this.values[this.nalloc - 1];
				this.values[this.nalloc - 1] = null;
				this.nalloc--;
			} else {
				this.nalloc = 0;
			}
		}
	}
	,__class__: dn_struct_FixedArray
};
var dn_Process = function(parent) {
	this.tmpProfilerTimes = new haxe_ds_StringMap();
	this._initOnceDone = false;
	this._fixedUpdateAccu = 0.;
	this.ignoreTimeMultipliers = false;
	this.baseTimeMul = 1.0;
	this.init();
	if(parent == null) {
		var _this = dn_Process.ROOTS;
		if(_this.nalloc >= _this.values.length) {
			throw haxe_Exception.thrown("FixedArray limit reached (" + _this.values.length + ")");
		}
		_this.values[_this.nalloc] = this;
		_this.nalloc++;
	} else {
		parent.addChild(this);
	}
	dn_Process.resizeAll(false);
};
$hxClasses["dn.Process"] = dn_Process;
dn_Process.__name__ = "dn.Process";
dn_Process._doPreUpdate = function(p,utmod) {
	if(!(!p.isPaused() && !p.destroyed)) {
		return;
	}
	p.utmod = utmod;
	p.ftime += p.utmod * p.getComputedTimeMultiplier();
	p.uftime += p.utmod;
	p.delayer.update(p.utmod * p.getComputedTimeMultiplier());
	if(!p.isPaused() && !p.destroyed) {
		p.udelayer.update(p.utmod);
	}
	if(!p.isPaused() && !p.destroyed) {
		p.cd.update(p.utmod * p.getComputedTimeMultiplier());
	}
	if(!p.isPaused() && !p.destroyed) {
		p.ucd.update(p.utmod);
	}
	if(!p.isPaused() && !p.destroyed) {
		p.tw.update(p.utmod * p.getComputedTimeMultiplier());
	}
	if(!p.isPaused() && !p.destroyed) {
		if(!p._initOnceDone) {
			p.initOnceBeforeUpdate();
			p._initOnceDone = true;
		}
		p.preUpdate();
	}
	if(!p.isPaused() && !p.destroyed) {
		var _g_arr = p.children;
		var _g_i = 0;
		while(_g_i < _g_arr.nalloc) {
			var c = _g_arr.values[_g_i++];
			dn_Process._doPreUpdate(c,p.utmod);
		}
	}
};
dn_Process._doMainUpdate = function(p) {
	if(!(!p.isPaused() && !p.destroyed)) {
		return;
	}
	var id = "update";
	if(dn_Process.PROFILING) {
		var id1;
		if(p.name != null) {
			id1 = p.name;
		} else {
			if(p._cachedClassName == null) {
				var c = js_Boot.getClass(p);
				p._cachedClassName = c.__name__;
			}
			id1 = p._cachedClassName;
		}
		id = id1 + "." + id;
		p.tmpProfilerTimes.h[id] = HxOverrides.now() / 1000;
	}
	p.update();
	if(p.onUpdateCb != null) {
		p.onUpdateCb();
	}
	var id = "update";
	if(dn_Process.PROFILING) {
		var id1;
		if(p.name != null) {
			id1 = p.name;
		} else {
			if(p._cachedClassName == null) {
				var c = js_Boot.getClass(p);
				p._cachedClassName = c.__name__;
			}
			id1 = p._cachedClassName;
		}
		id = id1 + "." + id;
		if(Object.prototype.hasOwnProperty.call(p.tmpProfilerTimes.h,id)) {
			var t = HxOverrides.now() / 1000 - p.tmpProfilerTimes.h[id];
			var _this = p.tmpProfilerTimes;
			if(Object.prototype.hasOwnProperty.call(_this.h,id)) {
				delete(_this.h[id]);
			}
			if(!Object.prototype.hasOwnProperty.call(dn_Process.PROFILER_TIMES.h,id)) {
				dn_Process.PROFILER_TIMES.h[id] = t;
			} else {
				dn_Process.PROFILER_TIMES.h[id] += t;
			}
		}
	}
	if(!p.isPaused() && !p.destroyed) {
		var _g_arr = p.children;
		var _g_i = 0;
		while(_g_i < _g_arr.nalloc) {
			var p = _g_arr.values[_g_i++];
			dn_Process._doMainUpdate(p);
		}
	}
};
dn_Process._doFixedUpdate = function(p) {
	if(!(!p.isPaused() && !p.destroyed)) {
		return;
	}
	var id = "fixed";
	if(dn_Process.PROFILING) {
		var id1;
		if(p.name != null) {
			id1 = p.name;
		} else {
			if(p._cachedClassName == null) {
				var c = js_Boot.getClass(p);
				p._cachedClassName = c.__name__;
			}
			id1 = p._cachedClassName;
		}
		id = id1 + "." + id;
		p.tmpProfilerTimes.h[id] = HxOverrides.now() / 1000;
	}
	p._fixedUpdateAccu += p.utmod * p.getComputedTimeMultiplier();
	while(p._fixedUpdateAccu >= p.getDefaultFrameRate() / dn_Process.FIXED_UPDATE_FPS) {
		p._fixedUpdateAccu -= p.getDefaultFrameRate() / dn_Process.FIXED_UPDATE_FPS;
		if(!p.isPaused() && !p.destroyed) {
			p.fixedUpdate();
			if(p.onFixedUpdateCb != null) {
				p.onFixedUpdateCb();
			}
		}
	}
	var id = "fixed";
	if(dn_Process.PROFILING) {
		var id1;
		if(p.name != null) {
			id1 = p.name;
		} else {
			if(p._cachedClassName == null) {
				var c = js_Boot.getClass(p);
				p._cachedClassName = c.__name__;
			}
			id1 = p._cachedClassName;
		}
		id = id1 + "." + id;
		if(Object.prototype.hasOwnProperty.call(p.tmpProfilerTimes.h,id)) {
			var t = HxOverrides.now() / 1000 - p.tmpProfilerTimes.h[id];
			var _this = p.tmpProfilerTimes;
			if(Object.prototype.hasOwnProperty.call(_this.h,id)) {
				delete(_this.h[id]);
			}
			if(!Object.prototype.hasOwnProperty.call(dn_Process.PROFILER_TIMES.h,id)) {
				dn_Process.PROFILER_TIMES.h[id] = t;
			} else {
				dn_Process.PROFILER_TIMES.h[id] += t;
			}
		}
	}
	if(!p.isPaused() && !p.destroyed) {
		var _g_arr = p.children;
		var _g_i = 0;
		while(_g_i < _g_arr.nalloc) {
			var p = _g_arr.values[_g_i++];
			dn_Process._doFixedUpdate(p);
		}
	}
};
dn_Process._doPostUpdate = function(p) {
	if(!(!p.isPaused() && !p.destroyed)) {
		return;
	}
	var id = "post";
	if(dn_Process.PROFILING) {
		var id1;
		if(p.name != null) {
			id1 = p.name;
		} else {
			if(p._cachedClassName == null) {
				var c = js_Boot.getClass(p);
				p._cachedClassName = c.__name__;
			}
			id1 = p._cachedClassName;
		}
		id = id1 + "." + id;
		p.tmpProfilerTimes.h[id] = HxOverrides.now() / 1000;
	}
	p.postUpdate();
	var id = "post";
	if(dn_Process.PROFILING) {
		var id1;
		if(p.name != null) {
			id1 = p.name;
		} else {
			if(p._cachedClassName == null) {
				var c = js_Boot.getClass(p);
				p._cachedClassName = c.__name__;
			}
			id1 = p._cachedClassName;
		}
		id = id1 + "." + id;
		if(Object.prototype.hasOwnProperty.call(p.tmpProfilerTimes.h,id)) {
			var t = HxOverrides.now() / 1000 - p.tmpProfilerTimes.h[id];
			var _this = p.tmpProfilerTimes;
			if(Object.prototype.hasOwnProperty.call(_this.h,id)) {
				delete(_this.h[id]);
			}
			if(!Object.prototype.hasOwnProperty.call(dn_Process.PROFILER_TIMES.h,id)) {
				dn_Process.PROFILER_TIMES.h[id] = t;
			} else {
				dn_Process.PROFILER_TIMES.h[id] += t;
			}
		}
	}
	if(!p.destroyed) {
		var _g_arr = p.children;
		var _g_i = 0;
		while(_g_i < _g_arr.nalloc) {
			var c = _g_arr.values[_g_i++];
			dn_Process._doPostUpdate(c);
		}
	}
};
dn_Process._garbageCollector = function(plist) {
	var i = 0;
	var p;
	while(i < plist.nalloc) {
		p = i < 0 || i >= plist.nalloc ? null : plist.values[i];
		if(p.destroyed) {
			dn_Process._disposeProcess(p);
		} else {
			dn_Process._garbageCollector(p.children);
			++i;
		}
	}
};
dn_Process._disposeProcess = function(p) {
	var _g_arr = p.children;
	var _g_i = 0;
	while(_g_i < _g_arr.nalloc) {
		var p1 = _g_arr.values[_g_i++];
		p1.destroyed = true;
	}
	dn_Process._garbageCollector(p.children);
	p.delayer.destroy();
	p.udelayer.destroy();
	p.cd.dispose();
	p.ucd.dispose();
	p.tw.destroy();
	if(p.parent != null) {
		p.parent.children.remove(p);
	} else {
		dn_Process.ROOTS.remove(p);
	}
	if(p.root != null) {
		var _this = p.root;
		if(_this != null && _this.parent != null) {
			_this.parent.removeChild(_this);
		}
	}
	p.onDispose();
	if(p.onDisposeCb != null) {
		p.onDisposeCb();
	}
	p.parent = null;
	p.children = null;
	p.cd = null;
	p.ucd = null;
	p.delayer = null;
	p.udelayer = null;
	p.tw = null;
	p.root = null;
};
dn_Process._resizeProcess = function(p) {
	if(!p.destroyed) {
		p.onResize();
		var _g_arr = p.children;
		var _g_i = 0;
		while(_g_i < _g_arr.nalloc) {
			var p = _g_arr.values[_g_i++];
			dn_Process._resizeProcess(p);
		}
	}
};
dn_Process.updateAll = function(utmod) {
	if(dn_Process.BEGINNING_OF_FRAME_CALLBACKS.nalloc > 0) {
		var _g_arr = dn_Process.BEGINNING_OF_FRAME_CALLBACKS;
		var _g_i = 0;
		while(_g_i < _g_arr.nalloc) {
			var cb = _g_arr.values[_g_i++];
			cb();
		}
		dn_Process.BEGINNING_OF_FRAME_CALLBACKS.nalloc = 0;
	}
	var _g_arr = dn_Process.ROOTS;
	var _g_i = 0;
	while(_g_i < _g_arr.nalloc) {
		var p = _g_arr.values[_g_i++];
		if(!p.isPaused() && !p.destroyed) {
			p.utmod = utmod;
			p.ftime += p.utmod * p.getComputedTimeMultiplier();
			p.uftime += p.utmod;
			p.delayer.update(p.utmod * p.getComputedTimeMultiplier());
			if(!p.isPaused() && !p.destroyed) {
				p.udelayer.update(p.utmod);
			}
			if(!p.isPaused() && !p.destroyed) {
				p.cd.update(p.utmod * p.getComputedTimeMultiplier());
			}
			if(!p.isPaused() && !p.destroyed) {
				p.ucd.update(p.utmod);
			}
			if(!p.isPaused() && !p.destroyed) {
				p.tw.update(p.utmod * p.getComputedTimeMultiplier());
			}
			if(!p.isPaused() && !p.destroyed) {
				if(!p._initOnceDone) {
					p.initOnceBeforeUpdate();
					p._initOnceDone = true;
				}
				p.preUpdate();
			}
			if(!p.isPaused() && !p.destroyed) {
				var _g_arr1 = p.children;
				var _g_i1 = 0;
				while(_g_i1 < _g_arr1.nalloc) {
					var c = _g_arr1.values[_g_i1++];
					var utmod1 = p.utmod;
					if(!c.isPaused() && !c.destroyed) {
						c.utmod = utmod1;
						c.ftime += c.utmod * c.getComputedTimeMultiplier();
						c.uftime += c.utmod;
						c.delayer.update(c.utmod * c.getComputedTimeMultiplier());
						if(!c.isPaused() && !c.destroyed) {
							c.udelayer.update(c.utmod);
						}
						if(!c.isPaused() && !c.destroyed) {
							c.cd.update(c.utmod * c.getComputedTimeMultiplier());
						}
						if(!c.isPaused() && !c.destroyed) {
							c.ucd.update(c.utmod);
						}
						if(!c.isPaused() && !c.destroyed) {
							c.tw.update(c.utmod * c.getComputedTimeMultiplier());
						}
						if(!c.isPaused() && !c.destroyed) {
							if(!c._initOnceDone) {
								c.initOnceBeforeUpdate();
								c._initOnceDone = true;
							}
							c.preUpdate();
						}
						if(!c.isPaused() && !c.destroyed) {
							var _g_arr2 = c.children;
							var _g_i2 = 0;
							while(_g_i2 < _g_arr2.nalloc) {
								var c1 = _g_arr2.values[_g_i2++];
								dn_Process._doPreUpdate(c1,c.utmod);
							}
						}
					}
				}
			}
		}
	}
	var _g1_arr = dn_Process.ROOTS;
	var _g1_i = 0;
	while(_g1_i < _g1_arr.nalloc) {
		var p = _g1_arr.values[_g1_i++];
		dn_Process._doMainUpdate(p);
	}
	var _g2_arr = dn_Process.ROOTS;
	var _g2_i = 0;
	while(_g2_i < _g2_arr.nalloc) {
		var p = _g2_arr.values[_g2_i++];
		dn_Process._doFixedUpdate(p);
	}
	var _g3_arr = dn_Process.ROOTS;
	var _g3_i = 0;
	while(_g3_i < _g3_arr.nalloc) {
		var p = _g3_arr.values[_g3_i++];
		if(!p.isPaused() && !p.destroyed) {
			var id = "post";
			if(dn_Process.PROFILING) {
				var id1;
				if(p.name != null) {
					id1 = p.name;
				} else {
					if(p._cachedClassName == null) {
						var c = js_Boot.getClass(p);
						p._cachedClassName = c.__name__;
					}
					id1 = p._cachedClassName;
				}
				id = id1 + "." + id;
				p.tmpProfilerTimes.h[id] = HxOverrides.now() / 1000;
			}
			p.postUpdate();
			var id2 = "post";
			if(dn_Process.PROFILING) {
				var id3;
				if(p.name != null) {
					id3 = p.name;
				} else {
					if(p._cachedClassName == null) {
						var c1 = js_Boot.getClass(p);
						p._cachedClassName = c1.__name__;
					}
					id3 = p._cachedClassName;
				}
				id2 = id3 + "." + id2;
				if(Object.prototype.hasOwnProperty.call(p.tmpProfilerTimes.h,id2)) {
					var t = HxOverrides.now() / 1000 - p.tmpProfilerTimes.h[id2];
					var _this = p.tmpProfilerTimes;
					if(Object.prototype.hasOwnProperty.call(_this.h,id2)) {
						delete(_this.h[id2]);
					}
					if(!Object.prototype.hasOwnProperty.call(dn_Process.PROFILER_TIMES.h,id2)) {
						dn_Process.PROFILER_TIMES.h[id2] = t;
					} else {
						dn_Process.PROFILER_TIMES.h[id2] += t;
					}
				}
			}
			if(!p.destroyed) {
				var _g_arr = p.children;
				var _g_i = 0;
				while(_g_i < _g_arr.nalloc) {
					var c2 = _g_arr.values[_g_i++];
					if(!c2.isPaused() && !c2.destroyed) {
						var id4 = "post";
						if(dn_Process.PROFILING) {
							var id5;
							if(c2.name != null) {
								id5 = c2.name;
							} else {
								if(c2._cachedClassName == null) {
									var c3 = js_Boot.getClass(c2);
									c2._cachedClassName = c3.__name__;
								}
								id5 = c2._cachedClassName;
							}
							id4 = id5 + "." + id4;
							c2.tmpProfilerTimes.h[id4] = HxOverrides.now() / 1000;
						}
						c2.postUpdate();
						var id6 = "post";
						if(dn_Process.PROFILING) {
							var id7;
							if(c2.name != null) {
								id7 = c2.name;
							} else {
								if(c2._cachedClassName == null) {
									var c4 = js_Boot.getClass(c2);
									c2._cachedClassName = c4.__name__;
								}
								id7 = c2._cachedClassName;
							}
							id6 = id7 + "." + id6;
							if(Object.prototype.hasOwnProperty.call(c2.tmpProfilerTimes.h,id6)) {
								var t1 = HxOverrides.now() / 1000 - c2.tmpProfilerTimes.h[id6];
								var _this1 = c2.tmpProfilerTimes;
								if(Object.prototype.hasOwnProperty.call(_this1.h,id6)) {
									delete(_this1.h[id6]);
								}
								if(!Object.prototype.hasOwnProperty.call(dn_Process.PROFILER_TIMES.h,id6)) {
									dn_Process.PROFILER_TIMES.h[id6] = t1;
								} else {
									dn_Process.PROFILER_TIMES.h[id6] += t1;
								}
							}
						}
						if(!c2.destroyed) {
							var _g_arr1 = c2.children;
							var _g_i1 = 0;
							while(_g_i1 < _g_arr1.nalloc) {
								var c5 = _g_arr1.values[_g_i1++];
								dn_Process._doPostUpdate(c5);
							}
						}
					}
				}
			}
		}
	}
	if(dn_Process.RESIZE_REQUESTED) {
		dn_Process.RESIZE_REQUESTED = false;
		var _g4_arr = dn_Process.ROOTS;
		var _g4_i = 0;
		while(_g4_i < _g4_arr.nalloc) {
			var p = _g4_arr.values[_g4_i++];
			if(!p.destroyed) {
				p.onResize();
				var _g_arr = p.children;
				var _g_i = 0;
				while(_g_i < _g_arr.nalloc) {
					var p1 = _g_arr.values[_g_i++];
					if(!p1.destroyed) {
						p1.onResize();
						var _g_arr1 = p1.children;
						var _g_i1 = 0;
						while(_g_i1 < _g_arr1.nalloc) {
							var p2 = _g_arr1.values[_g_i1++];
							dn_Process._resizeProcess(p2);
						}
					}
				}
			}
		}
	}
	dn_Process._garbageCollector(dn_Process.ROOTS);
	if(dn_Process.END_OF_FRAME_CALLBACKS.nalloc > 0) {
		var _g4_arr = dn_Process.END_OF_FRAME_CALLBACKS;
		var _g4_i = 0;
		while(_g4_i < _g4_arr.nalloc) {
			var cb = _g4_arr.values[_g4_i++];
			cb();
		}
		dn_Process.END_OF_FRAME_CALLBACKS.nalloc = 0;
	}
};
dn_Process.resizeAll = function(immediately) {
	if(immediately == null) {
		immediately = false;
	}
	if(immediately) {
		var _g_arr = dn_Process.ROOTS;
		var _g_i = 0;
		while(_g_i < _g_arr.nalloc) {
			var p = _g_arr.values[_g_i++];
			if(!p.destroyed) {
				p.onResize();
				var _g_arr1 = p.children;
				var _g_i1 = 0;
				while(_g_i1 < _g_arr1.nalloc) {
					var p1 = _g_arr1.values[_g_i1++];
					if(!p1.destroyed) {
						p1.onResize();
						var _g_arr2 = p1.children;
						var _g_i2 = 0;
						while(_g_i2 < _g_arr2.nalloc) {
							var p2 = _g_arr2.values[_g_i2++];
							dn_Process._resizeProcess(p2);
						}
					}
				}
			}
		}
	} else {
		dn_Process.RESIZE_REQUESTED = true;
	}
};
dn_Process.prototype = {
	init: function() {
		this.uniqId = dn_Process.UNIQ_ID++;
		this.children = new dn_struct_FixedArray(null,dn_Process.MAX_PROCESSES);
		this._manuallyPaused = false;
		this.destroyed = false;
		this.ftime = 0;
		this.uftime = 0;
		this.utmod = 1;
		this.baseTimeMul = 1;
		this.cd = new dn_Cooldown(this.getDefaultFrameRate());
		this.delayer = new dn_Delayer(this.getDefaultFrameRate());
		this.tw = new dn_Tweenie(this.getDefaultFrameRate());
		this.ucd = new dn_Cooldown(this.getDefaultFrameRate());
		this.udelayer = new dn_Delayer(this.getDefaultFrameRate());
	}
	,initOnceBeforeUpdate: function() {
	}
	,createRoot: function(ctx) {
		if(this.root != null) {
			throw haxe_Exception.thrown(Std.string(this) + ": root already created!");
		}
		if(ctx == null) {
			if(this.parent == null || this.parent.root == null) {
				throw haxe_Exception.thrown(Std.string(this) + ": context required");
			}
			ctx = this.parent.root;
		}
		this.root = new h2d_Layers(ctx);
		var tmp;
		if(this.name != null) {
			tmp = this.name;
		} else {
			if(this._cachedClassName == null) {
				var c = js_Boot.getClass(this);
				this._cachedClassName = c.__name__;
			}
			tmp = this._cachedClassName;
		}
		this.root.name = tmp;
	}
	,preUpdate: function() {
	}
	,update: function() {
	}
	,fixedUpdate: function() {
	}
	,postUpdate: function() {
	}
	,onResize: function() {
	}
	,onDispose: function() {
	}
	,onUpdateCb: function() {
	}
	,onFixedUpdateCb: function() {
	}
	,onDisposeCb: function() {
	}
	,toString: function() {
		var tmp = "#" + this.uniqId + " ";
		var tmp1;
		if(this.name != null) {
			tmp1 = this.name;
		} else {
			if(this._cachedClassName == null) {
				var c = js_Boot.getClass(this);
				this._cachedClassName = c.__name__;
			}
			tmp1 = this._cachedClassName;
		}
		return tmp + tmp1 + (this.isPaused() ? " [PAUSED]" : "");
	}
	,getDefaultFrameRate: function() {
		var x = hxd_Timer.wantedFPS;
		return (x > 0 ? x + .5 : x < 0 ? x - .5 : 0) | 0;
	}
	,getComputedTimeMultiplier: function() {
		if(this.ignoreTimeMultipliers) {
			return 1.0;
		} else {
			var y = this.baseTimeMul * (this.parent == null ? 1 : this.parent.getComputedTimeMultiplier());
			if(0 > y) {
				return 0;
			} else {
				return y;
			}
		}
	}
	,isPaused: function() {
		if(this._manuallyPaused) {
			return true;
		} else if(this.parent != null) {
			return this.parent.isPaused();
		} else {
			return false;
		}
	}
	,addChild: function(p) {
		if(p.parent == null) {
			dn_Process.ROOTS.remove(p);
		} else {
			p.parent.children.remove(p);
		}
		p.parent = this;
		var _this = this.children;
		if(_this.nalloc >= _this.values.length) {
			throw haxe_Exception.thrown("FixedArray limit reached (" + _this.values.length + ")");
		}
		_this.values[_this.nalloc] = p;
		_this.nalloc++;
	}
	,createChildProcess: function(onUpdate,onDispose,runUpdateImmediatly) {
		if(runUpdateImmediatly == null) {
			runUpdateImmediatly = false;
		}
		var p = new dn_Process(this);
		if(onUpdate != null) {
			p.onUpdateCb = function() {
				onUpdate(p);
			};
		}
		if(onDispose != null) {
			p.onDisposeCb = function() {
				onDispose(p);
			};
		}
		if(runUpdateImmediatly) {
			if(!p.isPaused() && !p.destroyed) {
				p.utmod = 1;
				p.ftime += p.utmod * p.getComputedTimeMultiplier();
				p.uftime += p.utmod;
				p.delayer.update(p.utmod * p.getComputedTimeMultiplier());
				if(!p.isPaused() && !p.destroyed) {
					p.udelayer.update(p.utmod);
				}
				if(!p.isPaused() && !p.destroyed) {
					p.cd.update(p.utmod * p.getComputedTimeMultiplier());
				}
				if(!p.isPaused() && !p.destroyed) {
					p.ucd.update(p.utmod);
				}
				if(!p.isPaused() && !p.destroyed) {
					p.tw.update(p.utmod * p.getComputedTimeMultiplier());
				}
				if(!p.isPaused() && !p.destroyed) {
					if(!p._initOnceDone) {
						p.initOnceBeforeUpdate();
						p._initOnceDone = true;
					}
					p.preUpdate();
				}
				if(!p.isPaused() && !p.destroyed) {
					var _g_arr = p.children;
					var _g_i = 0;
					while(_g_i < _g_arr.nalloc) {
						var c = _g_arr.values[_g_i++];
						var utmod = p.utmod;
						if(!c.isPaused() && !c.destroyed) {
							c.utmod = utmod;
							c.ftime += c.utmod * c.getComputedTimeMultiplier();
							c.uftime += c.utmod;
							c.delayer.update(c.utmod * c.getComputedTimeMultiplier());
							if(!c.isPaused() && !c.destroyed) {
								c.udelayer.update(c.utmod);
							}
							if(!c.isPaused() && !c.destroyed) {
								c.cd.update(c.utmod * c.getComputedTimeMultiplier());
							}
							if(!c.isPaused() && !c.destroyed) {
								c.ucd.update(c.utmod);
							}
							if(!c.isPaused() && !c.destroyed) {
								c.tw.update(c.utmod * c.getComputedTimeMultiplier());
							}
							if(!c.isPaused() && !c.destroyed) {
								if(!c._initOnceDone) {
									c.initOnceBeforeUpdate();
									c._initOnceDone = true;
								}
								c.preUpdate();
							}
							if(!c.isPaused() && !c.destroyed) {
								var _g_arr1 = c.children;
								var _g_i1 = 0;
								while(_g_i1 < _g_arr1.nalloc) {
									var c1 = _g_arr1.values[_g_i1++];
									dn_Process._doPreUpdate(c1,c.utmod);
								}
							}
						}
					}
				}
			}
			dn_Process._doMainUpdate(p);
		}
		return p;
	}
	,__class__: dn_Process
};
var Game = function() {
	this.interactiveDebug = false;
	this.uiInteractives = [];
	this.walkAnimSpd = 0.75;
	this.footStep = 0.;
	var _gthis = this;
	dn_Process.call(this,Main.ME);
	this.createRoot(Main.ME.root);
	Game.ME = this;
	new h2d_Bitmap(h2d_Tile.fromColor(Const.BG_COLOR,Const.WID,Const.HEI),this.root);
	this.actions = new haxe_ds_List();
	this.fl_pause = false;
	this.fl_lockControls = false;
	this.fl_ending = false;
	this.skipClick = false;
	this.hotSpots = [];
	this.playerPath = [];
	this.inventory = new haxe_ds_List();
	this.triggers = new haxe_ds_StringMap();
	this.popQueue = new haxe_ds_List();
	this.pathFinder = new dn_pathfinder_AStar(function(x,y) {
		return { cx : x, cy : y};
	});
	this.room = "cell";
	this.wrapper = new h2d_Layers(this.root);
	var _this = this.wrapper;
	_this.posChanged = true;
	_this.x = Const.WID * 0.5 - Const.GAMEZONE_WID * 0.5 | 0;
	this.snapshotTex = new h3d_mat_Texture(dn_Process.CUSTOM_STAGE_WIDTH > 0 ? dn_Process.CUSTOM_STAGE_WIDTH : hxd_Window.getInstance().get_width(),dn_Process.CUSTOM_STAGE_HEIGHT > 0 ? dn_Process.CUSTOM_STAGE_HEIGHT : hxd_Window.getInstance().get_height(),[h3d_mat_TextureFlags.Target]);
	this.distort = new DistortFilter(2,32,4);
	this.distort.intensity = 0;
	this.root.set_filter(this.distort);
	this.initWorld();
	var tmp = this.world;
	var smooth = null;
	var p = null;
	var s = new dn_heaps_slib_HSprite(Assets.tiles,"player",0);
	if(p != null) {
		p.addChild(s);
	}
	var xRatio = 0.;
	var yRatio = 0.;
	if(yRatio == null) {
		yRatio = 0.5;
	}
	if(xRatio == null) {
		xRatio = 0.5;
	}
	var _this = s.pivot;
	_this.centerFactorX = xRatio;
	_this.centerFactorY = yRatio;
	_this.usingFactor = true;
	_this.isUndefined = false;
	if(smooth != null) {
		s.smooth = smooth;
	}
	this.player = new Entity(tmp,s);
	var xRatio = 0.5;
	var yRatio = 0.95;
	if(yRatio == null) {
		yRatio = 0.5;
	}
	if(xRatio == null) {
		xRatio = 0.5;
	}
	var _this = this.player.spr.pivot;
	_this.centerFactorX = xRatio;
	_this.centerFactorY = yRatio;
	_this.usingFactor = true;
	_this.isUndefined = false;
	this.player.moveTo(10,5);
	this.wrapper.add(this.player.spr,5);
	var _this = this.player.spr;
	if(_this._animManager == null) {
		_this._animManager = new dn_heaps_slib_AnimManager(_this);
		if(_this.onAnimManAlloc != null) {
			_this.onAnimManAlloc(_this._animManager);
		}
	}
	_this._animManager.registerStateAnim("walkUp",1,this.walkAnimSpd,function() {
		var tmp;
		if(_gthis.player.dirY == -1) {
			var _this = _gthis.player;
			var x = _this.dx;
			if(!((x < 0 ? -x : x) > 0.01)) {
				var x = _this.dy;
				tmp = (x < 0 ? -x : x) > 0.01;
			} else {
				tmp = true;
			}
		} else {
			tmp = false;
		}
		if(tmp) {
			return !(_gthis.destroyed || _gthis.fl_pause || _gthis.fl_lockControls || _gthis.fl_ending);
		} else {
			return false;
		}
	});
	var _this = this.player.spr;
	if(_this._animManager == null) {
		_this._animManager = new dn_heaps_slib_AnimManager(_this);
		if(_this.onAnimManAlloc != null) {
			_this.onAnimManAlloc(_this._animManager);
		}
	}
	_this._animManager.registerStateAnim("walkDown",1,this.walkAnimSpd,function() {
		var tmp;
		if(_gthis.player.dirY == 1) {
			var _this = _gthis.player;
			var x = _this.dx;
			if(!((x < 0 ? -x : x) > 0.01)) {
				var x = _this.dy;
				tmp = (x < 0 ? -x : x) > 0.01;
			} else {
				tmp = true;
			}
		} else {
			tmp = false;
		}
		if(tmp) {
			return !(_gthis.destroyed || _gthis.fl_pause || _gthis.fl_lockControls || _gthis.fl_ending);
		} else {
			return false;
		}
	});
	var _this = this.player.spr;
	if(_this._animManager == null) {
		_this._animManager = new dn_heaps_slib_AnimManager(_this);
		if(_this.onAnimManAlloc != null) {
			_this.onAnimManAlloc(_this._animManager);
		}
	}
	_this._animManager.registerStateAnim("standDown",0,null,function() {
		return _gthis.player.dirY == 1;
	});
	var _this = this.player.spr;
	if(_this._animManager == null) {
		_this._animManager = new dn_heaps_slib_AnimManager(_this);
		if(_this.onAnimManAlloc != null) {
			_this.onAnimManAlloc(_this._animManager);
		}
	}
	_this._animManager.registerStateAnim("standUp",0,null,function() {
		return _gthis.player.dirY == -1;
	});
	var frame = 0;
	var smooth = null;
	var p = null;
	if(frame == null) {
		frame = 0;
	}
	var s = new dn_heaps_slib_HSprite(Assets.tiles,"separator",frame);
	if(p != null) {
		p.addChild(s);
	}
	var xRatio = 0.;
	var yRatio = 0.;
	if(yRatio == null) {
		yRatio = 0.5;
	}
	if(xRatio == null) {
		xRatio = 0.5;
	}
	var _this = s.pivot;
	_this.centerFactorX = xRatio;
	_this.centerFactorY = yRatio;
	_this.usingFactor = true;
	_this.isUndefined = false;
	if(smooth != null) {
		s.smooth = smooth;
	}
	this.invSep1 = s;
	this.wrapper.add(this.invSep1,3);
	var xRatio = 0;
	var yRatio = 0.7;
	if(yRatio == null) {
		yRatio = 0.5;
	}
	if(xRatio == null) {
		xRatio = 0.5;
	}
	var _this = this.invSep1.pivot;
	_this.centerFactorX = xRatio;
	_this.centerFactorY = yRatio;
	_this.usingFactor = true;
	_this.isUndefined = false;
	this.invSep1.alpha = 0;
	var frame = 1;
	var smooth = null;
	var p = null;
	if(frame == null) {
		frame = 0;
	}
	var s = new dn_heaps_slib_HSprite(Assets.tiles,"separator",frame);
	if(p != null) {
		p.addChild(s);
	}
	var xRatio = 0.;
	var yRatio = 0.;
	if(yRatio == null) {
		yRatio = 0.5;
	}
	if(xRatio == null) {
		xRatio = 0.5;
	}
	var _this = s.pivot;
	_this.centerFactorX = xRatio;
	_this.centerFactorY = yRatio;
	_this.usingFactor = true;
	_this.isUndefined = false;
	if(smooth != null) {
		s.smooth = smooth;
	}
	this.invSep2 = s;
	this.wrapper.add(this.invSep2,3);
	var xRatio = 0;
	var yRatio = 0.3;
	if(yRatio == null) {
		yRatio = 0.5;
	}
	if(xRatio == null) {
		xRatio = 0.5;
	}
	var _this = this.invSep2.pivot;
	_this.centerFactorX = xRatio;
	_this.centerFactorY = yRatio;
	_this.usingFactor = true;
	_this.isUndefined = false;
	this.invSep2.alpha = 0;
	Boot.ME.s2d.addEventListener($bind(this,this.onEvent));
	var smooth = null;
	var p = null;
	var s = new dn_heaps_slib_HSprite(Assets.tiles,"heroFade",0);
	if(p != null) {
		p.addChild(s);
	}
	var xRatio = 0.;
	var yRatio = 0.;
	if(yRatio == null) {
		yRatio = 0.5;
	}
	if(xRatio == null) {
		xRatio = 0.5;
	}
	var _this = s.pivot;
	_this.centerFactorX = xRatio;
	_this.centerFactorY = yRatio;
	_this.usingFactor = true;
	_this.isUndefined = false;
	if(smooth != null) {
		s.smooth = smooth;
	}
	this.heroFade = s;
	var xRatio = 0.5;
	var yRatio = 0.5;
	if(yRatio == null) {
		yRatio = 0.5;
	}
	if(xRatio == null) {
		xRatio = 0.5;
	}
	var _this = this.heroFade.pivot;
	_this.centerFactorX = xRatio;
	_this.centerFactorY = yRatio;
	_this.usingFactor = true;
	_this.isUndefined = false;
	this.heroFade.set_visible(false);
	this.wrapper.add(this.heroFade,5);
	var x = 0;
	var y = 0;
	this.actionsWrapper = new h2d_Object();
	this.wrapper.add(this.actionsWrapper,1);
	this.miscWrapper = new h2d_Flow();
	this.wrapper.add(this.miscWrapper,1);
	this.miscWrapper.set_minWidth(Const.GAMEZONE_WID);
	this.miscWrapper.set_horizontalAlign(h2d_FlowAlign.Middle);
	this.miscWrapper.set_horizontalSpacing(16);
	var _this = this.miscWrapper;
	_this.posChanged = true;
	_this.y = 108;
	var alist = [Game.LOOK,Game.REMEMBER,Game.USE,Game.PICK,Game.OPEN,Game.CLOSE,Game.HELP];
	if(Game.EXTENDED) {
		alist.push(Game.ABOUT);
	}
	var _g = 0;
	while(_g < alist.length) {
		var a = [alist[_g]];
		++_g;
		var tf = [this.makeText(a[0])];
		switch(a[0]) {
		case Game.ABOUT:
			this.miscWrapper.addChild(tf[0]);
			break;
		case Game.HELP:
			this.miscWrapper.addChild(tf[0]);
			break;
		default:
			var w = 40;
			var v = -1 + x * w + w * 0.5 - tf[0].get_textWidth() * 0.5 | 0;
			tf[0].posChanged = true;
			tf[0].x = v;
			tf[0].posChanged = true;
			tf[0].y = 85 + y * 10;
			this.actionsWrapper.addChild(tf[0]);
		}
		if(a[0] == Game.ABOUT) {
			var v1 = tf[0].y + 17;
			tf[0].posChanged = true;
			tf[0].y = v1;
			var v2 = tf[0].x + 45;
			tf[0].posChanged = true;
			tf[0].x = v2;
			tf[0].set_textColor(6718069);
		}
		if(a[0] == Game.HELP) {
			var v3 = tf[0].y + 17;
			tf[0].posChanged = true;
			tf[0].y = v3;
			if(Game.EXTENDED) {
				var v4 = tf[0].x + 45;
				tf[0].posChanged = true;
				tf[0].x = v4;
			} else {
				var v5 = tf[0].x + 92;
				tf[0].posChanged = true;
				tf[0].x = v5;
			}
			tf[0].set_textColor(6718069);
		}
		tf[0].alpha = 0.6;
		this.addInteractive(tf[0],{ over : (function(tf) {
			return function() {
				if(!_gthis.fl_lockControls && tf[0].text != _gthis.pending) {
					tf[0].alpha = 0.7;
				}
			};
		})(tf), out : (function(tf) {
			return function() {
				if(tf[0].text != _gthis.pending) {
					tf[0].alpha = 0.48;
				}
			};
		})(tf), click : (function(a) {
			return function() {
				if(!_gthis.fl_lockControls) {
					_gthis.setPending(a[0]);
				}
			};
		})(a)});
		++x;
		if(x >= 3) {
			x = 0;
			++y;
		}
		this.actions.add(tf[0]);
	}
	this.setPending();
	this.initHotSpots();
	this.updateInventory();
	Assets.SOUNDS.ambiant().play(true);
	this.root.alpha = 0;
	var _tween = this.tw.create_(function() {
		return _gthis.root.alpha;
	},function(_setV) {
		_gthis.root.alpha = _setV;
	},null,1,null,2000);
	this.distort.intensity = 0.5;
	var _tween = this.tw.create_(function() {
		return _gthis.distort.intensity;
	},function(_setV) {
		_gthis.distort.intensity = _setV;
	},null,0,dn_TType.TEaseOut,5000);
	var _this = this.player.spr;
	if(_this._animManager == null) {
		_this._animManager = new dn_heaps_slib_AnimManager(_this);
		if(_this.onAnimManAlloc != null) {
			_this.onAnimManAlloc(_this._animManager);
		}
	}
	_this._animManager.play("wakeWait").loop();
	this.player.moveTo(10,4);
	this.player.update(this.utmod * this.getComputedTimeMultiplier());
	this.pop("Day 4380");
	this.pop("!...12 years today.");
	this.pop("And still many to go in this cell.");
	this.pop("My cozy little world.");
	this.afterPop = function() {
		_gthis.fl_pause = true;
		var _this = _gthis.player.spr;
		if(_this._animManager == null) {
			_this._animManager = new dn_heaps_slib_AnimManager(_this);
			if(_this.onAnimManAlloc != null) {
				_this.onAnimManAlloc(_this._animManager);
			}
		}
		_this._animManager.play("wakeUp",1);
		var _tween = _gthis.tw.create_(function() {
			return _gthis.player.yr;
		},function(_setV) {
			_gthis.player.yr = _setV;
		},null,1,null,300);
		var a = _tween;
		a.onUpdate = function() {
			_gthis.player.update(_gthis.utmod * _gthis.getComputedTimeMultiplier());
		};
		a.onEnd = function() {
			_gthis.resumeGame();
			Assets.SOUNDS.footstep1(1);
			_gthis.player.moveTo(10,5);
			_gthis.player.yr = 0;
			_gthis.player.update(_gthis.utmod * _gthis.getComputedTimeMultiplier());
		};
	};
	dn_Process.resizeAll();
};
$hxClasses["Game"] = Game;
Game.__name__ = "Game";
Game.__super__ = dn_Process;
Game.prototype = $extend(dn_Process.prototype,{
	onResize: function() {
		dn_Process.prototype.onResize.call(this);
		var _this = this.root;
		var x = dn_Process.CUSTOM_STAGE_WIDTH > 0 ? dn_Process.CUSTOM_STAGE_WIDTH : hxd_Window.getInstance().get_width();
		_this.posChanged = true;
		_this.x = x * 0.5 - Const.WID * 0.5 * Const.SCALE | 0;
		var _this = this.root;
		var v = Const.SCALE;
		_this.posChanged = true;
		_this.scaleX = v;
		_this.posChanged = true;
		_this.scaleY = v;
		this.snapshotTex.resize(dn_Process.CUSTOM_STAGE_WIDTH > 0 ? dn_Process.CUSTOM_STAGE_WIDTH : hxd_Window.getInstance().get_width(),dn_Process.CUSTOM_STAGE_HEIGHT > 0 ? dn_Process.CUSTOM_STAGE_HEIGHT : hxd_Window.getInstance().get_height());
	}
	,onDispose: function() {
		dn_Process.prototype.onDispose.call(this);
		Boot.ME.s2d.removeEventListener($bind(this,this.onEvent));
	}
	,onEvent: function(ev) {
		switch(ev.kind._hx_index) {
		case 0:
			this.onMouseDown(ev);
			break;
		case 1:
			this.onMouseUp(ev);
			break;
		case 2:
			break;
		case 3:
			break;
		case 4:
			break;
		case 5:
			break;
		case 6:
			break;
		case 7:
			break;
		case 8:
			break;
		case 9:
			break;
		case 10:
			break;
		case 11:
			break;
		case 12:
			break;
		}
	}
	,onMouseDown: function(ev) {
		if(this.skipClick || this.fl_ending) {
			return;
		}
		if(this.fl_pause) {
			this.resumeGame();
			this.closePop();
			return;
		}
		if(this.fl_lockControls) {
			return;
		}
		this.onArrive = null;
		var m = this.getMouse();
		this.movePlayer(m.cx,m.cy);
	}
	,onMouseUp: function(ev) {
		if(this.fl_pause) {
			return;
		}
	}
	,addInteractive: function(o,events) {
		var _gthis = this;
		var b = o.getBounds(this.wrapper);
		var i = new h2d_Interactive(b.xMax - b.xMin,b.yMax - b.yMin,this.wrapper);
		var x = b.xMin;
		var y = b.yMin;
		i.posChanged = true;
		i.x = x;
		i.posChanged = true;
		i.y = y;
		this.uiInteractives.push(i);
		if(events.click != null) {
			i.onClick = function(_) {
				events.click();
			};
		}
		if(events.over != null) {
			i.onOver = function(_) {
				events.over();
			};
		}
		if(events.out != null) {
			i.onOut = function(_) {
				events.out();
			};
		}
		var p = this.createChildProcess();
		p.onUpdateCb = function() {
			if(o.parent == null) {
				p.destroyed = true;
				if(i != null && i.parent != null) {
					i.parent.removeChild(i);
				}
				HxOverrides.remove(_gthis.uiInteractives,i);
				return;
			}
			o.getBounds(_gthis.wrapper,b);
			var x = b.xMin;
			var y = b.yMin;
			i.posChanged = true;
			i.x = x;
			i.posChanged = true;
			i.y = y;
			i.width = b.xMax - b.xMin;
			i.height = b.yMax - b.yMin;
		};
	}
	,makeText: function(str,multiline) {
		if(multiline == null) {
			multiline = false;
		}
		var tf = new h2d_Text(Assets.font);
		tf.set_text(str);
		tf.set_filter(new dn_heaps_filter_PixelOutline());
		if(multiline) {
			tf.set_maxWidth(Const.GAMEZONE_WID - 15);
		}
		return tf;
	}
	,resumeGame: function() {
		this.fl_pause = false;
		this.lockControls(false);
		if(this.curName != null) {
			this.curName.set_visible(true);
		}
	}
	,lockControls: function(l) {
		this.fl_lockControls = l;
		this.actionsWrapper.alpha = l ? 0.3 : 1;
		this.applyInteractiveVisibility();
		this.hideName();
		this.updateInventory();
	}
	,applyInteractiveVisibility: function() {
		var _g = 0;
		var _g1 = this.hotSpots;
		while(_g < _g1.length) {
			var hs = _g1[_g];
			++_g;
			hs.i.set_visible(!this.fl_lockControls);
		}
		var _g = 0;
		var _g1 = this.uiInteractives;
		while(_g < _g1.length) {
			var i = _g1[_g];
			++_g;
			i.set_visible(!this.fl_lockControls);
		}
	}
	,setPending: function(a) {
		var _g_head = this.actions.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var tf = val;
			tf.set_filter(null);
			tf.alpha = 0.48;
		}
		if(a == Game.HELP) {
			this.getTip();
			return;
		}
		if(a == Game.ABOUT) {
			Assets.SOUNDS.select(1);
			this.pop("@This game was made by Sebastien \"deepnight\" Benard in 48h for the Ludum Dare 23 game jam (theme: \"Tiny World\").");
			this.pop("@The first version being in Flash, it was ported to WebGL and DirectX on December 2020.");
			this.pop("@Visit DEEPNIGHT.NET for more games :)");
			return;
		}
		if(a != this.pending) {
			Assets.SOUNDS.select(1);
		}
		if(a == null) {
			a = Game.LOOK;
		}
		this.pending = a;
		var _g1_head = this.actions.h;
		while(_g1_head != null) {
			var val = _g1_head.item;
			_g1_head = _g1_head.next;
			var tf = val;
			if(tf.text == a) {
				tf.alpha = 1;
				tf.set_filter(new dn_heaps_filter_PixelOutline(4213603));
			}
		}
	}
	,movePlayer: function(cx,cy) {
		var pt = this.getClosest(cx,cy);
		if(pt == null || pt.x == this.player.cx && pt.y == this.player.cy) {
			return false;
		}
		this.playerPath = this.getPath(this.player.cx,this.player.cy,pt.x,pt.y);
		this.playerTarget = { cx : cx, cy : cy};
		return this.playerPath.length > 0;
	}
	,setTrigger: function(k,n) {
		if(n == null) {
			n = 1;
		}
		this.triggers.h[k] = n;
		this.refreshWorld();
		if(k == "kitchenLeftOpen" || k == "kitchenRightOpen") {
			Assets.SOUNDS.door(1);
		}
	}
	,getTrigger: function(k) {
		if(Object.prototype.hasOwnProperty.call(this.triggers.h,k)) {
			return this.triggers.h[k];
		} else {
			return 0;
		}
	}
	,hasTrigger: function(k) {
		return this.getTrigger(k) != 0;
	}
	,hasTriggerSet: function(k) {
		if(this.getTrigger(k) != 0) {
			return true;
		} else {
			this.setTrigger(k);
			return false;
		}
	}
	,hasItem: function(k) {
		var _g_head = this.inventory.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var i = val;
			if(i == k) {
				return true;
			}
		}
		return false;
	}
	,removeItem: function(k) {
		this.inventory.remove(k);
		this.updateInventory();
	}
	,addItem: function(k) {
		Assets.SOUNDS.pick(1);
		this.inventory.add(k);
		this.refreshWorld();
		if(this.hasItem("picPart1") && this.hasItem("picPart2") && this.hasItem("picPart3") && !this.hasTrigger("gotPicture")) {
			this.removeItem("picPart1");
			this.removeItem("picPart2");
			this.removeItem("picPart3");
			this.addItem("picture");
			this.setTrigger("gotPicture");
			Assets.SOUNDS.success(1);
			this.pop("!You assembled the 3 parts and now have restored the PICTURE.");
		}
		this.updateInventory();
	}
	,updateInventory: function() {
		var _gthis = this;
		var old = this.invCont != null ? this.invCont.alpha : 0;
		if(this.invCont != null) {
			var _this = this.invCont;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
		}
		this.invCont = new h2d_Flow();
		this.invCont.set_layout(h2d_FlowLayout.Vertical);
		var _this = this.invCont;
		_this.posChanged = true;
		_this.x = 2;
		var _this = this.invCont;
		_this.posChanged = true;
		_this.y = 132;
		this.invCont.set_minWidth(Const.GAMEZONE_WID);
		this.invCont.set_minHeight(4);
		this.invCont.set_horizontalAlign(h2d_FlowAlign.Middle);
		this.invCont.set_verticalSpacing(1);
		this.invCont.alpha = old;
		this.wrapper.add(this.invCont,1);
		var a = this.inventory.length == 0 ? 0 : 1;
		var _tween = this.tw.create_(function() {
			return _gthis.invCont.alpha;
		},function(_setV) {
			_gthis.invCont.alpha = _setV;
		},null,a,null,null);
		var _tween = this.tw.create_(function() {
			return _gthis.invSep1.alpha;
		},function(_setV) {
			_gthis.invSep1.alpha = _setV;
		},null,a,null,null);
		var _tween = this.tw.create_(function() {
			return _gthis.invSep2.alpha;
		},function(_setV) {
			_gthis.invSep2.alpha = _setV;
		},null,a,null,null);
		var n = 1;
		var _g_head = this.inventory.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var i = val;
			var name = Game.INAMES.h[i];
			var tf = this.makeText(name != null ? name : "!!" + i + "!!");
			tf.set_textColor(9797201);
			this.invCont.addChild(tf);
			this.addInteractive(tf,{ click : function() {
				_gthis.pop("@You don't need to select items in your inventory to use them. Just choose the USE action above.");
			}});
			++n;
		}
		var _this = this.invSep1;
		_this.posChanged = true;
		_this.x = this.invCont.x - 8;
		var _this = this.invSep1;
		_this.posChanged = true;
		_this.y = this.invCont.y;
		var _this = this.invSep2;
		_this.posChanged = true;
		_this.x = this.invCont.x - 8;
		var _this = this.invSep2;
		var v = this.invCont.y + this.invCont.get_outerHeight();
		_this.posChanged = true;
		_this.y = v;
	}
	,getMouse: function() {
		var x = (Boot.ME.s2d.get_mouseX() - this.root.x) / Const.SCALE - this.wrapper.x | 0;
		var y = Boot.ME.s2d.get_mouseY() / Const.SCALE - this.wrapper.y | 0;
		var cx = x / Const.GRID | 0;
		var cy = y / Const.GRID | 0;
		return { x : x, y : y, cx : cx, cy : cy};
	}
	,runPending: function(hs) {
		var _gthis = this;
		if(this.fl_pause || this.fl_lockControls || this.pending == null) {
			return;
		}
		var a = this.pending;
		if(!Object.prototype.hasOwnProperty.call(hs.act.h,a)) {
			a = "all";
		}
		if(Object.prototype.hasOwnProperty.call(hs.act.h,a)) {
			var resolve = function() {
				var r = hs.act.h[a];
				var _g = Type.typeof(r);
				switch(_g._hx_index) {
				case 5:
					r();
					break;
				case 6:
					if(_g.c == String) {
						_gthis.pop(r);
					} else {
						throw haxe_Exception.thrown("Unknown action type: " + Std.string(Type.typeof(r)));
					}
					break;
				default:
					throw haxe_Exception.thrown("Unknown action type: " + Std.string(Type.typeof(r)));
				}
			};
			this.skipClick = true;
			var m = this.getMouse();
			if(this.movePlayer(m.cx,m.cy)) {
				this.onArrive = resolve;
			} else {
				resolve();
			}
		} else {
			switch(this.pending) {
			case Game.CLOSE:
				this.pop("What?");
				break;
			case Game.LOOK:
				this.pop("Not much to say.");
				break;
			case Game.OPEN:
				this.pop("This can't be opened.");
				break;
			case Game.PICK:
				this.pop("I don't think I need that.");
				break;
			case Game.REMEMBER:
				this.pop("I... I don't remember anything about that...");
				break;
			case Game.USE:
				this.pop("I have no use for that.");
				break;
			}
		}
	}
	,getClosest: function(cx,cy) {
		var _gthis = this;
		var _this = this.world;
		if(!(cx < 0 || cx >= _this.wid || cy < 0 || cy >= _this.hei ? true : _this.cmap[cx][cy])) {
			return { x : cx, y : cy};
		}
		var all = dn_Bresenham.getDisc(cx,cy,3);
		var dh = new dn_DecisionHelper(all);
		var idx = 0;
		var v = $getIterator(dh.values);
		while(v.hasNext()) {
			var v1 = v.next();
			var tmp;
			if(!(dh.scores.h.hasOwnProperty(idx) && dh.scores.h[idx] == -1e+20)) {
				var _this = _gthis.world;
				var x = v1.x;
				var y = v1.y;
				tmp = x < 0 || x >= _this.wid || y < 0 || y >= _this.hei ? true : _this.cmap[x][y];
			} else {
				tmp = false;
			}
			if(tmp) {
				dh.scores.h[idx] = -1e+20;
			}
			++idx;
		}
		var idx = 0;
		var v = $getIterator(dh.values);
		while(v.hasNext()) {
			var v1 = v.next();
			if(!(dh.scores.h.hasOwnProperty(idx) && dh.scores.h[idx] == -1e+20)) {
				if(!dh.scores.h.hasOwnProperty(idx)) {
					dh.scores.h[idx] = 0;
				}
				dh.scores.h[idx] += v1.x == cx && v1.y - cy <= 2 ? 1 : 0;
			}
			++idx;
		}
		var idx = 0;
		var v = $getIterator(dh.values);
		while(v.hasNext()) {
			var v1 = v.next();
			if(!(dh.scores.h.hasOwnProperty(idx) && dh.scores.h[idx] == -1e+20)) {
				if(!dh.scores.h.hasOwnProperty(idx)) {
					dh.scores.h[idx] = 0;
				}
				var x = v1.x - cx;
				dh.scores.h[idx] += (x < 0 ? -x : x) <= 1 && v1.y == cy ? 1 : 0;
			}
			++idx;
		}
		var idx = 0;
		var v = $getIterator(dh.values);
		while(v.hasNext()) {
			var v1 = v.next();
			if(!(dh.scores.h.hasOwnProperty(idx) && dh.scores.h[idx] == -1e+20)) {
				if(!dh.scores.h.hasOwnProperty(idx)) {
					dh.scores.h[idx] = 0;
				}
				var bx = v1.x;
				var by = v1.y;
				dh.scores.h[idx] += -Math.sqrt((cx - bx) * (cx - bx) + (cy - by) * (cy - by));
			}
			++idx;
		}
		var idx = 0;
		var v = $getIterator(dh.values);
		while(v.hasNext()) {
			var v1 = v.next();
			if(!(dh.scores.h.hasOwnProperty(idx) && dh.scores.h[idx] == -1e+20)) {
				if(!dh.scores.h.hasOwnProperty(idx)) {
					dh.scores.h[idx] = 0;
				}
				var ax = v1.x;
				var ay = v1.y;
				var bx = _gthis.player.cx;
				var by = _gthis.player.cy;
				dh.scores.h[idx] += -Math.sqrt((ax - bx) * (ax - bx) + (ay - by) * (ay - by)) * 0.1;
			}
			++idx;
		}
		return dh.getBest();
	}
	,getPath: function(x,y,tx,ty) {
		var tmp;
		var _this = this.world;
		if(!(x < 0 || x >= _this.wid || y < 0 || y >= _this.hei ? true : _this.cmap[x][y])) {
			var _this = this.world;
			tmp = tx < 0 || tx >= _this.wid || ty < 0 || ty >= _this.hei ? true : _this.cmap[tx][ty];
		} else {
			tmp = true;
		}
		if(tmp) {
			return [];
		} else {
			return this.pathFinder.getPath(x,y,tx,ty);
		}
	}
	,initHotSpots: function() {
		var _gthis = this;
		var _g = 0;
		var _g1 = this.hotSpots;
		while(_g < _g1.length) {
			var hs = _g1[_g];
			++_g;
			var _this = hs.i;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
			if(hs.spr != null) {
				var _this1 = hs.spr;
				if(_this1 != null && _this1.parent != null) {
					_this1.parent.removeChild(_this1);
				}
			}
		}
		this.hotSpots = [];
		if(this.room != "hell") {
			this.addSpot(16,27,26,7,"A rusty pipe");
			this.setAction(Game.LOOK,"It brings me my daily water ration.");
			this.setAction(Game.REMEMBER,"For as long I remember, water has always seeped out of this pipe.");
			this.setAction(Game.USE,"It's useless, I can't fix it.");
			this.addSpot(9,39,7,17,"Iron door");
			this.setAction(Game.LOOK,"12 years already... Once a day, they serve my food in a metal tray.");
			this.setAction(Game.OPEN,"Guess what? It's locked.");
			this.setAction(Game.CLOSE,"This door seems to be intended to remain closed for the rest of eternity.");
			this.setAction(Game.PICK,"What?");
			this.setAction(Game.REMEMBER,"This door was locked 12 years ago. Only once. Never opened since then. I can't even remember the color of the corridor walls behind.");
			this.addSpot(73,26,21,14,"My bed");
			this.setAction(Game.LOOK,"It is almost as hard as the concrete ground.");
			this.setAction(Game.USE,"No, I just woke up. ");
			if(this.room == "cell") {
				this.setAction(Game.REMEMBER,"4380 nights spent in this bed.");
			} else {
				this.setAction(Game.REMEMBER,function() {
					_gthis.changeRoom("cell");
				});
			}
		}
		if(this.room == "cell") {
			this.addSpot(49,25,14,14,"Steel table");
			this.setAction(Game.LOOK,"Despite its aspect, this table isn't very stable.|But as everything down here, with time, you get used to it.");
			this.setAction(Game.REMEMBER,"They gave me this table 2 or 3 years ago.|Before that, I used to lay on the floor or on my bed.");
			this.addSpot(51,28,6,4,"A pen");
			this.setAction(Game.LOOK,"A simple black pen.");
			this.setAction(Game.REMEMBER,"I didn't use it often...|Actually, I only wrote a letter or something...|Can't remember, but it was kind of... IMPORTANT.");
			this.setAction(Game.PICK,"I don't think I will need it.");
			this.setAction(Game.USE,"I don't have anything to write on.");
			if(!this.hasItem("picPart1") && !this.hasTrigger("gotPicture")) {
				this.addSpot(57,24,6,7,"A ripped pîcture");
				var smooth = null;
				var p = null;
				var s = new dn_heaps_slib_HSprite(Assets.tiles,"picPart1",0);
				if(p != null) {
					p.addChild(s);
				}
				var xRatio = 0.;
				var yRatio = 0.;
				if(yRatio == null) {
					yRatio = 0.5;
				}
				if(xRatio == null) {
					xRatio = 0.5;
				}
				var _this = s.pivot;
				_this.centerFactorX = xRatio;
				_this.centerFactorY = yRatio;
				_this.usingFactor = true;
				_this.isUndefined = false;
				if(smooth != null) {
					s.smooth = smooth;
				}
				this.setSprite(s);
				this.setAction(Game.LOOK,"An old picture, totally torn...");
				this.setAction(Game.REMEMBER,"I don't remember anything about this picture... I should look for the other parts.");
				this.setAction(Game.PICK,function() {
					_gthis.pop("You pick it up. The picture is incomplete (probably 3 parts).");
					_gthis.addItem("picPart1");
				});
			}
			if(!this.hasTrigger("framed")) {
				this.addSpot(52,22,5,6,"Empty frame");
				if(this.hasTrigger("gotPicture")) {
					this.setAction(Game.USE,function() {
						_gthis.pop("You put the picture back in its frame. It fits perfectly.");
						_gthis.setTrigger("framed");
						Assets.SOUNDS.success(1);
						_gthis.removeItem("picture");
					});
				} else {
					this.setAction(Game.USE,"I don't have anything to put inside.");
				}
				this.setAction(Game.LOOK,"This frame is empty.|!Hmm... Where is the picture?");
				this.setAction(Game.REMEMBER,"I can't remember if I removed the frame content myself...");
				this.setAction(Game.OPEN,"Nothing inside.");
			} else {
				this.addSpot(52,22,5,6,"A very old picture");
				var smooth = null;
				var p = null;
				var s = new dn_heaps_slib_HSprite(Assets.tiles,"framed",0);
				if(p != null) {
					p.addChild(s);
				}
				var xRatio = 0.;
				var yRatio = 0.;
				if(yRatio == null) {
					yRatio = 0.5;
				}
				if(xRatio == null) {
					xRatio = 0.5;
				}
				var _this = s.pivot;
				_this.centerFactorX = xRatio;
				_this.centerFactorY = yRatio;
				_this.usingFactor = true;
				_this.isUndefined = false;
				if(smooth != null) {
					s.smooth = smooth;
				}
				this.setSprite(s);
				this.setAction(Game.LOOK,"The picture is very old and damaged. The character on the picture is barely recognizable.|A woman?|@You can use REMEMBER to recall important details about things around you.");
				this.setAction(Game.PICK,"No, this picture is in its place.");
				this.setAction(Game.REMEMBER,function() {
					if(!_gthis.hasTriggerSet("firstMemory")) {
						_gthis.pop("The picture is very old and damaged. The character on the picture is barely recognizable. A woman?|...|!Lydia?");
						var _g = $bind(_gthis,_gthis.changeRoom);
						var k = "kitchen";
						var tmp = function() {
							_g(k);
						};
						_gthis.afterPop = tmp;
					} else {
						_gthis.changeRoom("kitchen");
					}
				});
			}
			this.addSpot(20,32,20,19,"Stagnant water");
			this.setAction(Game.LOOK,"The water slowly seeps through cracks into my world.");
			this.setAction(Game.CLOSE,"I can't do anything to stop it.");
			this.setAction(Game.PICK,"I will have plenty of water here soon enough.");
			this.addSpot(70,51,16,14,"Ray of light");
			this.setAction(Game.LOOK,"A cold light falls upon my little world.");
			this.setAction(Game.REMEMBER,"I won't feel anymore the sea breeze in my hairs.");
			this.setAction(Game.PICK,"What?");
			if(!this.hasTrigger("calendar")) {
				this.addSpot(40,20,8,9,"An old calendar");
				var smooth = null;
				var p = null;
				var s = new dn_heaps_slib_HSprite(Assets.tiles,"calendar",0);
				if(p != null) {
					p.addChild(s);
				}
				var xRatio = 0.;
				var yRatio = 0.;
				if(yRatio == null) {
					yRatio = 0.5;
				}
				if(xRatio == null) {
					xRatio = 0.5;
				}
				var _this = s.pivot;
				_this.centerFactorX = xRatio;
				_this.centerFactorY = yRatio;
				_this.usingFactor = true;
				_this.isUndefined = false;
				if(smooth != null) {
					s.smooth = smooth;
				}
				this.setSprite(s);
				this.setAction(Game.LOOK,"This calendar is from other times... Even the year print has almost completely disappeared.|!...Hey, is there some kind of hole behind it?");
				this.setAction(Game.REMEMBER,"I think SOMEONE bought me this calendar when I was sent in here.");
				var f = function() {
					_gthis.setTrigger("calendar");
					Assets.SOUNDS.smallHit(1);
					_gthis.pop("As you pull the calendar, you reveal a hole hidden behind it...");
				};
				this.setAction(Game.USE,f);
				this.setAction(Game.OPEN,f);
			} else {
				this.addSpot(37,20,8,9,"Hidden hole");
				if(!this.hasItem("picPart2") && !this.hasTrigger("gotPicture")) {
					this.setAction(Game.LOOK,function() {
						_gthis.pop("You found the fragment of a ripped picture.");
						_gthis.addItem("picPart2");
					});
				} else {
					this.setAction(Game.LOOK,"This holes is empty.");
				}
				this.setAction(Game.CLOSE,"The calendar won't stay.");
				this.setAction(Game.REMEMBER,"Did I make this hole? I can't remember.");
			}
			this.addSpot(59,61,21,13,"Unused bed base");
			this.setAction(Game.LOOK,"It was never used. No one never got transfered in this cell, except me.");
			this.setAction(Game.USE,"From time to time, I switch my beds. Just for a pleasant change.");
			this.setAction(Game.REMEMBER,"I think it was already here when I was brought here.");
			if(!this.hasItem("picPart3") && !this.hasTrigger("gotPicture")) {
				this.addSpot(88,25,5,6,"Some sort of paper");
				var smooth = null;
				var p = null;
				var s = new dn_heaps_slib_HSprite(Assets.tiles,"picPart3",0);
				if(p != null) {
					p.addChild(s);
				}
				var xRatio = 0.;
				var yRatio = 0.;
				if(yRatio == null) {
					yRatio = 0.5;
				}
				if(xRatio == null) {
					xRatio = 0.5;
				}
				var _this = s.pivot;
				_this.centerFactorX = xRatio;
				_this.centerFactorY = yRatio;
				_this.usingFactor = true;
				_this.isUndefined = false;
				if(smooth != null) {
					s.smooth = smooth;
				}
				this.setSprite(s);
				this.setAction(Game.LOOK,"The fragment of a ripped picture is hidden under the bolster.");
				this.setAction(Game.REMEMBER,"How did it get there?");
				this.setAction(Game.PICK,function() {
					_gthis.pop("It's a fragment of a ripped picture.");
					_gthis.addItem("picPart3");
				});
			}
			this.addSpot(56,39,7,9,"Chair");
			this.setAction(Game.LOOK,"Rusted.");
			this.setAction(Game.USE,"There is nothing to wait.");
			this.addSpot(14,64,8,12,"Sink");
			if(this.hasTrigger("sinkOpen")) {
				var smooth = null;
				var p = null;
				var s = new dn_heaps_slib_HSprite(Assets.tiles,"flow",0);
				if(p != null) {
					p.addChild(s);
				}
				var xRatio = 0.;
				var yRatio = 0.;
				if(yRatio == null) {
					yRatio = 0.5;
				}
				if(xRatio == null) {
					xRatio = 0.5;
				}
				var _this = s.pivot;
				_this.centerFactorX = xRatio;
				_this.centerFactorY = yRatio;
				_this.usingFactor = true;
				_this.isUndefined = false;
				if(smooth != null) {
					s.smooth = smooth;
				}
				var s1 = s;
				this.setSprite(s1);
				s1.posChanged = true;
				s1.x += 1;
				s1.posChanged = true;
				s1.y += 3;
				if(s1._animManager == null) {
					s1._animManager = new dn_heaps_slib_AnimManager(s1);
					if(s1.onAnimManAlloc != null) {
						s1.onAnimManAlloc(s1._animManager);
					}
				}
				s1._animManager.play("flow").loop();
			}
			if(!this.hasTrigger("sinkClean")) {
				this.setAction(Game.PICK,"I need a tool or something.");
				this.setAction(Game.LOOK,"A basic sink with an old faucet.|!Something is blocking the pipe.");
				this.setAction(Game.REMEMBER,"I remember something important felt in the pipe.|!...Wasn't it a KEY?");
				this.setAction(Game.OPEN,"!No, something is stuck inside the pipe.");
			} else {
				if(!this.hasTrigger("sinkOpen")) {
					this.setAction(Game.LOOK,"I try to keep it as clean as possible.");
				} else {
					this.setAction(Game.LOOK,"The water is not exactly clear.");
				}
				this.setAction(Game.OPEN,function() {
					_gthis.setTrigger("sinkOpen");
					Assets.SOUNDS.robinet(1);
				});
				this.setAction(Game.CLOSE,function() {
					_gthis.setTrigger("sinkOpen",0);
					Assets.SOUNDS.robinet(1);
				});
			}
			if(!this.hasTrigger("sinkOpen")) {
				if(!this.hasTrigger("sinkClean")) {
					this.setAction(Game.USE,"!Something is stuck in the pipe: I need a tool or something.");
				} else {
					this.setAction(Game.USE,"I need to open the water first.");
				}
			}
			if(this.hasTrigger("sinkClean") && this.hasTrigger("sinkOpen")) {
				if(this.hasItem("cupKey") && !this.hasTrigger("washedKey")) {
					this.setAction(Game.USE,function() {
						_gthis.pop("You wash the key, fussy ol'man.");
						_gthis.setTrigger("washedKey");
					});
				} else {
					this.setAction(Game.USE,"The water feels refreshing.");
				}
			} else if(this.hasItem("knife") && !this.hasTrigger("sinkClean")) {
				this.setAction(Game.USE,function() {
					_gthis.pop("Using the knife, you manage to remove the thing blocking the sink.");
					_gthis.pop("You take out lots of dirt. Trapped inside, you find a KEY.");
					_gthis.setTrigger("sinkClean");
					Assets.SOUNDS.success(1);
					_gthis.addItem("cupKey");
				});
			}
			this.addSpot(89,41,6,6,"Small wooden case");
			if(this.hasTrigger("ringBack")) {
				var smooth = null;
				var p = null;
				var s = new dn_heaps_slib_HSprite(Assets.tiles,"ringBack",0);
				if(p != null) {
					p.addChild(s);
				}
				var xRatio = 0.;
				var yRatio = 0.;
				if(yRatio == null) {
					yRatio = 0.5;
				}
				if(xRatio == null) {
					xRatio = 0.5;
				}
				var _this = s.pivot;
				_this.centerFactorX = xRatio;
				_this.centerFactorY = yRatio;
				_this.usingFactor = true;
				_this.isUndefined = false;
				if(smooth != null) {
					s.smooth = smooth;
				}
				var s1 = this.setSprite(s);
				s1.posChanged = true;
				s1.x += 1;
				s1.posChanged = true;
				s1.y += 1;
				var _g = $bind(this,this.changeRoom);
				var k = "park";
				this.setAction(Game.REMEMBER,function() {
					_g(k);
				});
			} else {
				this.setAction(Game.REMEMBER,"I'm pretty sure it was not normally empty.|There is a thin slot in a soft cushion inside of the box.|!But what should go in there?");
			}
			if(!this.hasTrigger("ringBack")) {
				this.setAction(Game.LOOK,"It looks like some kind of jewel case. It is empty.");
			} else {
				this.setAction(Game.LOOK,"Lydia's ring is back in its box. Why did I hide it?");
			}
			this.setAction(Game.PICK,"I prefer to let it here.");
			if(this.hasItem("ring")) {
				this.setAction(Game.USE,function() {
					_gthis.pop("You put Lydia's ring back in its case.");
					Assets.SOUNDS.success(1);
					_gthis.removeItem("ring");
					_gthis.setTrigger("ringBack");
				});
			}
		}
		if(this.room == "kitchen") {
			this.addSpot(49,20,5,6,"Old picture of a woman");
			this.setAction(Game.LOOK,"A young and beautiful smiles at you, radiant with joy.");
			this.setAction(Game.PICK,"No, this picture is in its place.");
			this.setAction(Game.REMEMBER,function() {
				_gthis.pop("Lydia...|As beautiful as in my memories.");
				if(Game.EXTENDED) {
					var _g = $bind(_gthis,_gthis.changeRoom);
					var k = "cell";
					var tmp = function() {
						_g(k);
					};
					_gthis.afterPop = tmp;
				}
			});
			this.addSpot(42,29,8,6,"Sideboard left door");
			if(this.hasTrigger("kitchenLeftOpen")) {
				var smooth = null;
				var p = null;
				var s = new dn_heaps_slib_HSprite(Assets.tiles,"kitchenDoor",0);
				if(p != null) {
					p.addChild(s);
				}
				var xRatio = 0.;
				var yRatio = 0.;
				if(yRatio == null) {
					yRatio = 0.5;
				}
				if(xRatio == null) {
					xRatio = 0.5;
				}
				var _this = s.pivot;
				_this.centerFactorX = xRatio;
				_this.centerFactorY = yRatio;
				_this.usingFactor = true;
				_this.isUndefined = false;
				if(smooth != null) {
					s.smooth = smooth;
				}
				this.setSprite(s);
				this.setAction(Game.LOOK,"All kind of silverware, plates and things like that.");
				this.setAction(Game.REMEMBER,"I used to be the chef of the house...");
			}
			this.setAction(Game.OPEN,function() {
				_gthis.setTrigger("kitchenLeftOpen",1);
			});
			this.setAction(Game.CLOSE,function() {
				_gthis.setTrigger("kitchenLeftOpen",0);
			});
			this.addSpot(70,51,12,13,"Warm ray of light");
			this.setAction(Game.LOOK,"The warm feeling if pleasant and reassuring.");
			this.setAction(Game.REMEMBER,"The kitchen used to be a room bathed in light.|I guess it's summer outside.");
			this.setAction(Game.PICK,"What?");
			this.addSpot(51,29,8,6,"Sideboard right door");
			if(this.hasTrigger("kitchenRightOpen")) {
				var smooth = null;
				var p = null;
				var s = new dn_heaps_slib_HSprite(Assets.tiles,"kitchenDoor",0);
				if(p != null) {
					p.addChild(s);
				}
				var xRatio = 0.;
				var yRatio = 0.;
				if(yRatio == null) {
					yRatio = 0.5;
				}
				if(xRatio == null) {
					xRatio = 0.5;
				}
				var _this = s.pivot;
				_this.centerFactorX = xRatio;
				_this.centerFactorY = yRatio;
				_this.usingFactor = true;
				_this.isUndefined = false;
				if(smooth != null) {
					s.smooth = smooth;
				}
				this.setSprite(s);
				if(!this.hasTrigger("foundChest")) {
					this.setAction(Game.LOOK,function() {
						_gthis.pop("Cups, thousands of spoons and a tea set.|!You also found a STEEL CHEST inside the sideboard.");
						_gthis.afterPop = function() {
							_gthis.setTrigger("foundChest");
							Assets.SOUNDS.hit(1);
						};
					});
				} else {
					this.setAction(Game.LOOK,"Cups, thousands of spoons and a tea set.");
				}
				this.setAction(Game.REMEMBER,"Lydia was really fond of tea...");
			}
			this.setAction(Game.OPEN,function() {
				_gthis.setTrigger("kitchenRightOpen",1);
			});
			this.setAction(Game.CLOSE,function() {
				_gthis.setTrigger("kitchenRightOpen",0);
			});
			this.addSpot(42,47,6,13,"My chair");
			this.setAction(Game.LOOK,"My good old chair.");
			this.setAction(Game.REMEMBER,"Years ago, I used to sit here, and wait for...|Well. something... I don'k know.|!But nothing ever happened.");
			this.setAction(Game.USE,"Nah, I've spent too much time on this chair, at home...");
			this.addSpot(25,45,16,22,"Kitchen table");
			this.setAction(Game.LOOK,"My sturdy kitchen table.|It will last longer than me.");
			this.setAction(Game.REMEMBER,"Years ago, I used to sit here, and wait for...|Well. something... I don'k know.|!But nothing ever happened.");
			this.addSpot(18,24,8,14,"Lydia's chair");
			this.setAction(Game.LOOK,"Nice chair");
			this.setAction(Game.REMEMBER,"After Lydia's death, this chair stood in the corner of my kitchen.");
			if(!this.hasTrigger("rememberTable")) {
				this.addSpot(31,48,10,13,"Tablecloth");
				var frame = 0;
				var smooth = null;
				var p = null;
				if(frame == null) {
					frame = 0;
				}
				var s = new dn_heaps_slib_HSprite(Assets.tiles,"kitchenTable",frame);
				if(p != null) {
					p.addChild(s);
				}
				var xRatio = 0.;
				var yRatio = 0.;
				if(yRatio == null) {
					yRatio = 0.5;
				}
				if(xRatio == null) {
					xRatio = 0.5;
				}
				var _this = s.pivot;
				_this.centerFactorX = xRatio;
				_this.centerFactorY = yRatio;
				_this.usingFactor = true;
				_this.isUndefined = false;
				if(smooth != null) {
					s.smooth = smooth;
				}
				this.setSprite(s);
				this.setAction(Game.LOOK,"Very old. And completely stained.|!As you touch the surface, you feel something underneath...");
				this.setAction(Game.REMEMBER,"It's so old that I think Lydia even bought it before we met.|!I remember she had the habit to hide... SOMETHING underneath...");
				var f = function() {
					_gthis.pop("You remove the tablecloth...");
					_gthis.afterPop = function() {
						Assets.SOUNDS.smallHit(1);
						_gthis.pop("...revealing a small key.");
						_gthis.setTrigger("rememberTable");
					};
				};
				this.setAction(Game.USE,f);
				if(Game.EXTENDED) {
					this.setAction(Game.PICK,f);
					this.setAction(Game.OPEN,f);
				}
			} else if(!this.hasTrigger("foundKey")) {
				this.addSpot(34,47,6,6,"Small key");
				var frame = 1;
				var smooth = null;
				var p = null;
				if(frame == null) {
					frame = 0;
				}
				var s = new dn_heaps_slib_HSprite(Assets.tiles,"kitchenTable",frame);
				if(p != null) {
					p.addChild(s);
				}
				var xRatio = 0.;
				var yRatio = 0.;
				if(yRatio == null) {
					yRatio = 0.5;
				}
				if(xRatio == null) {
					xRatio = 0.5;
				}
				var _this = s.pivot;
				_this.centerFactorX = xRatio;
				_this.centerFactorY = yRatio;
				_this.usingFactor = true;
				_this.isUndefined = false;
				if(smooth != null) {
					s.smooth = smooth;
				}
				this.setSprite(s);
				this.setAction(Game.LOOK,"A small ornamented key is laying on the table. Probably made of copper.");
				this.setAction(Game.REMEMBER,"I used to play for long hours with this key.|What was it used for?");
				this.setAction(Game.PICK,function() {
					_gthis.pop("You pick the ornamented key.");
					_gthis.setTrigger("foundKey");
					_gthis.addItem("chestKey");
				});
			}
			if(this.hasTrigger("foundChest")) {
				this.addSpot(40,34,13,11,"A steel chest");
				var _this = Assets.tiles;
				var frame = this.hasTrigger("openChest") ? 1 : 0;
				var smooth = null;
				var p = null;
				if(frame == null) {
					frame = 0;
				}
				var s = new dn_heaps_slib_HSprite(_this,"kitchenChest",frame);
				if(p != null) {
					p.addChild(s);
				}
				var xRatio = 0.;
				var yRatio = 0.;
				if(yRatio == null) {
					yRatio = 0.5;
				}
				if(xRatio == null) {
					xRatio = 0.5;
				}
				var _this = s.pivot;
				_this.centerFactorX = xRatio;
				_this.centerFactorY = yRatio;
				_this.usingFactor = true;
				_this.isUndefined = false;
				if(smooth != null) {
					s.smooth = smooth;
				}
				this.setSprite(s);
				if(!this.hasTrigger("openChest")) {
					this.setAction(Game.LOOK,"It seems sturdy. And it's locked.");
				} else {
					if(this.hasTrigger("foundRing")) {
						this.setAction(Game.LOOK,"Completely empty.");
					} else {
						this.setAction(Game.LOOK,function() {
							_gthis.pop("There is a single GOLD RING in it.|It's really beautiful.|There is \"L\" engraved in it.|You pick it up.");
							_gthis.addItem("ring");
							_gthis.setTrigger("foundRing");
						});
					}
					this.setAction(Game.CLOSE,function() {
						_gthis.setTrigger("openChest",0);
						Assets.SOUNDS.hit(1);
					});
				}
				this.setAction(Game.REMEMBER,"I put something important in it...|And I wanted it to stay away from me.");
				if(this.hasTrigger("unlockedChest")) {
					this.setAction(Game.OPEN,function() {
						Assets.SOUNDS.smallHit(1);
						_gthis.setTrigger("openChest");
					});
				} else if(!this.hasItem("chestKey")) {
					this.setAction(Game.OPEN,"It's locked.");
				} else {
					this.setAction(Game.OPEN,function() {
						_gthis.pop("You use the copper key...|It clicks and opens.");
						Assets.SOUNDS.smallHit(1);
						_gthis.removeItem("chestKey");
						_gthis.setTrigger("openChest");
						_gthis.setTrigger("unlockedChest");
					});
				}
			}
			this.addSpot(23,54,10,8,"Food tray");
			this.setAction(Game.LOOK,"Probably as old as me...|And as empty as me.");
			this.setAction(Game.REMEMBER,"Once a day, they serve my meal in it.");
			this.addSpot(33,56,3,5,"Fork");
			this.setAction(Game.LOOK,"It only has one prong left.");
			this.addSpot(31,50,4,4,"Spoon");
			this.setAction(Game.LOOK,"Surprisingly, it's in a good state.");
			if(!this.hasItem("knife")) {
				this.addSpot(25,48,6,6,"Knife");
				var smooth = null;
				var p = null;
				var s = new dn_heaps_slib_HSprite(Assets.tiles,"kitchenKnife",0);
				if(p != null) {
					p.addChild(s);
				}
				var xRatio = 0.;
				var yRatio = 0.;
				if(yRatio == null) {
					yRatio = 0.5;
				}
				if(xRatio == null) {
					xRatio = 0.5;
				}
				var _this = s.pivot;
				_this.centerFactorX = xRatio;
				_this.centerFactorY = yRatio;
				_this.usingFactor = true;
				_this.isUndefined = false;
				if(smooth != null) {
					s.smooth = smooth;
				}
				this.setSprite(s);
				this.setAction(Game.LOOK,"A basic steel knife. The edge became (or got) blunt.|Might be useful.");
				this.setAction(Game.USE,"This won't cut anything... But it might become handy.");
				this.setAction(Game.PICK,function() {
					_gthis.pop("You pick it up.");
					_gthis.addItem("knife");
				});
			}
			this.addSpot(86,53,12,25,"Cupboard");
			if(this.hasTrigger("openCup")) {
				var smooth = null;
				var p = null;
				var s = new dn_heaps_slib_HSprite(Assets.tiles,"cupDoors",0);
				if(p != null) {
					p.addChild(s);
				}
				var xRatio = 0.;
				var yRatio = 0.;
				if(yRatio == null) {
					yRatio = 0.5;
				}
				if(xRatio == null) {
					xRatio = 0.5;
				}
				var _this = s.pivot;
				_this.centerFactorX = xRatio;
				_this.centerFactorY = yRatio;
				_this.usingFactor = true;
				_this.isUndefined = false;
				if(smooth != null) {
					s.smooth = smooth;
				}
				var fh = this.setSprite(s);
				fh.posChanged = true;
				fh.x -= 4;
				if(!this.hasItem("broom")) {
					this.setAction(Game.LOOK,function() {
						_gthis.pop("The cupboard contains various chemicals and upkeep products.");
						_gthis.pop("You find a medium sized broom in a corner, you take it.");
						_gthis.addItem("broom");
					});
				} else {
					this.setAction(Game.LOOK,"The cupboard contains various chemicals and upkeep products.");
				}
			} else {
				this.setAction(Game.LOOK,"A large wooden cupboard with two doors.");
			}
			this.setAction(Game.REMEMBER,"It contains everything usefull to keep a kitchen tidy.|Lydia knew more about this stuff than me.");
			if(!this.hasTrigger("unlockedCup") && !this.hasItem("cupKey")) {
				if(this.hasItem("chestKey")) {
					this.setAction(Game.OPEN,"!My key is too small for this lock.");
				} else {
					this.setAction(Game.OPEN,"!It's locked.");
				}
			} else if(!this.hasTrigger("unlockedCup")) {
				this.setAction(Game.OPEN,function() {
					_gthis.setTrigger("openCup");
					Assets.SOUNDS.door(1);
					_gthis.setTrigger("unlockedCup");
					_gthis.removeItem("cupKey");
					_gthis.pop("The key fits perfectly and the cupboard opens creaking.");
				});
			} else {
				this.setAction(Game.OPEN,function() {
					_gthis.setTrigger("openCup");
					Assets.SOUNDS.door(1);
				});
				this.setAction(Game.CLOSE,function() {
					_gthis.setTrigger("openCup",0);
					Assets.SOUNDS.door(1);
				});
			}
		}
		if(this.room == "park") {
			this.addSpot(2,8,41,26,"Leaves");
			this.setAction(Game.LOOK,"A peaceful leafy tree...");
			this.setAction(Game.REMEMBER,"I wish I could hear the gentle sound of the wind passing through the leaves...|!But there is no wind here.");
			this.addSpot(50,23,23,14,"Wooden bench");
			this.setAction(Game.LOOK,"Even if it seems as old as the trees, this bench looks welcoming.");
			this.setAction(Game.REMEMBER,"Isn't that...|..the bench where I met Lydia?");
			this.setAction(Game.USE,"!I.. don't feel comfortable with sitting on it.|I can't do it.");
			this.addSpot(71,50,14,14,"Pale ray of light");
			this.setAction(Game.LOOK,"It feels surprisingly cold.");
			this.setAction(Game.REMEMBER,"!This light is not exactly pleasant.|I guess it's winter outside.");
			this.addSpot(16,32,8,25,"Tree trunk");
			this.setAction(Game.LOOK,"Things are engraved in it.|\"Forever\"|\"L & D\"|\"With love\"|...");
			this.setAction(Game.REMEMBER,"I think I've written most of these words.");
			this.setAction(Game.USE,"I could shake the branches, but the trunk won't move.");
			if(this.hasTrigger("letterPop") && !this.hasItem("finalLetter")) {
				this.addSpot(69,41,7,7,"A letter");
				var smooth = null;
				var p = null;
				var s = new dn_heaps_slib_HSprite(Assets.tiles,"finalLetter",0);
				if(p != null) {
					p.addChild(s);
				}
				var xRatio = 0.;
				var yRatio = 0.;
				if(yRatio == null) {
					yRatio = 0.5;
				}
				if(xRatio == null) {
					xRatio = 0.5;
				}
				var _this = s.pivot;
				_this.centerFactorX = xRatio;
				_this.centerFactorY = yRatio;
				_this.usingFactor = true;
				_this.isUndefined = false;
				if(smooth != null) {
					s.smooth = smooth;
				}
				this.setSprite(s);
				this.setAction(Game.LOOK,"A letter.|The writing seems to be... mine.");
				this.setAction(Game.REMEMBER,"Did I write this letter ?");
				var f = function() {
					_gthis.addItem("finalLetter");
					_gthis.heroFade.set_visible(true);
					_gthis.heroFade.alpha = 0;
					var _tween = _gthis.tw.create_(function() {
						return _gthis.heroFade.alpha;
					},function(_setV) {
						_gthis.heroFade.alpha = _setV;
					},null,0.5,dn_TType.TEaseIn,1500);
					_gthis.pop("You take the letter and start to read it.");
					var _this = _gthis.player.spr;
					if(_this._animManager == null) {
						_this._animManager = new dn_heaps_slib_AnimManager(_this);
						if(_this.onAnimManAlloc != null) {
							_this.onAnimManAlloc(_this._animManager);
						}
					}
					_this._animManager.stopWithStateAnims();
					var _this = _gthis.player.spr;
					if(_this._animManager == null) {
						_this._animManager = new dn_heaps_slib_AnimManager(_this);
						if(_this.onAnimManAlloc != null) {
							_this.onAnimManAlloc(_this._animManager);
						}
					}
					_this._animManager.play("read").loop();
					_gthis.pop("@Dear myself,");
					_gthis.afterPop = function() {
						_gthis.changeRoom("cell");
					};
				};
				this.setAction(Game.PICK,f);
				this.setAction(Game.USE,f);
				this.setAction(Game.OPEN,f);
			}
			if(!this.hasTrigger("phoneDropped")) {
				this.addSpot(18,25,7,6,"???");
				var smooth = null;
				var p = null;
				var s = new dn_heaps_slib_HSprite(Assets.tiles,"phone",0);
				if(p != null) {
					p.addChild(s);
				}
				var xRatio = 0.;
				var yRatio = 0.;
				if(yRatio == null) {
					yRatio = 0.5;
				}
				if(xRatio == null) {
					xRatio = 0.5;
				}
				var _this = s.pivot;
				_this.centerFactorX = xRatio;
				_this.centerFactorY = yRatio;
				_this.usingFactor = true;
				_this.isUndefined = false;
				if(smooth != null) {
					s.smooth = smooth;
				}
				this.setSprite(s);
				this.setAction(Game.LOOK,"There is SOMETHING in the leaves.");
				this.setAction(Game.REMEMBER,"!I can't see what it is from here.");
				if(!this.hasItem("broom")) {
					this.setAction("all","It's out of my reach.");
				} else {
					var f = function() {
						_gthis.setTrigger("phoneDropped");
						Assets.SOUNDS.hit(1);
						_gthis.pop("Using your BROOM, you reach the object and push it to the ground.");
					};
					this.setAction(Game.USE,f);
					this.setAction(Game.PICK,f);
				}
			} else {
				this.addSpot(20,49,6,6,"Cellphone");
				var smooth = null;
				var p = null;
				var s = new dn_heaps_slib_HSprite(Assets.tiles,"phone",0);
				if(p != null) {
					p.addChild(s);
				}
				var xRatio = 0.;
				var yRatio = 0.;
				if(yRatio == null) {
					yRatio = 0.5;
				}
				if(xRatio == null) {
					xRatio = 0.5;
				}
				var _this = s.pivot;
				_this.centerFactorX = xRatio;
				_this.centerFactorY = yRatio;
				_this.usingFactor = true;
				_this.isUndefined = false;
				if(smooth != null) {
					s.smooth = smooth;
				}
				this.setSprite(s);
				this.setAction(Game.LOOK,"It's a cellphone, a quite common model.");
				this.setAction(Game.REMEMBER,"It's mine.");
				this.setAction(Game.PICK,"!No.|For some reason... I don't want to keep it...");
				this.setAction(Game.OPEN,"No, I'm not much into technical things.");
				if(!this.hasTrigger("phoneCalled")) {
					this.setAction(Game.USE,function() {
						_gthis.pop("As you press the WAKE button on the cellphone, a voice comes from it.");
						_gthis.pop("It seems that someone is on the line...");
						_gthis.pop("@Mr Belmont? .. Daniel Belmont?");
						_gthis.pop("@Dr Prowell speaking...");
						_gthis.pop("@...Is your wife Mme Lydia Belmont?...");
						_gthis.pop("!I'm really sorry sir... but she...");
						_gthis.pop("The cellphone abruptly cease to function.");
						_gthis.setTrigger("phoneCalled");
						var _g = $bind(_gthis,_gthis.changeRoom);
						var k = "hell";
						var tmp = function() {
							_g(k);
						};
						_gthis.afterPop = tmp;
					});
				} else {
					this.setAction(Game.USE,"!It seems broken or something.");
				}
			}
		}
	}
	,addSpot: function(x,y,w,h,name) {
		var _gthis = this;
		var i = new h2d_Interactive(w,h);
		this.wrapper.add(i,99);
		i.posChanged = true;
		i.x = x;
		i.posChanged = true;
		i.y = y;
		var hs = { i : i, spr : null, name : name, act : new haxe_ds_StringMap()};
		this.hotSpots.push(hs);
		this.lastSpot = hs;
		i.onClick = function(_) {
			_gthis.runPending(hs);
		};
		i.onOver = function(_) {
			i.alpha = 1;
			_gthis.showName(i,name);
		};
		i.onOut = function(_) {
			i.alpha = 0.6;
			_gthis.hideName();
		};
		i.alpha = 0.6;
		return hs;
	}
	,getTip: function() {
		Assets.SOUNDS.help(1);
		if(!this.hasTriggerSet("usedTip")) {
			this.pop("@This action will provide some useful tips if you get stuck in the game.");
		}
		if(!this.hasTrigger("framed") && !this.hasItem("picture")) {
			this.pop("You should first concentrate on finding the 3 photo fragments.");
		} else if(Game.EXTENDED && !this.hasTrigger("framed") && this.hasItem("picture")) {
			this.pop("Put the photograph back in its frame.|!To do this, select USE, then click on the EMPTY FRAME (you never need to click on the inventory).");
		} else if(!this.hasTrigger("goKitchen")) {
			this.pop("You can use REMEMBER on things to dive in past memories, or get important story details.");
		} else if(!this.hasTrigger("rememberTable")) {
			this.pop("You should check the table in the kitchen...");
		} else if(!this.hasTrigger("foundRing")) {
			this.pop("You must find something PRECIOUS hidden in the kitchen.");
		} else if(Game.EXTENDED && !this.hasTrigger("teleportedBackCell")) {
			this.pop("To come back to your cell, you can use REMEMBER on your bed or on the photograph.");
		} else if(Game.EXTENDED && !this.hasTrigger("sinkClean") && !this.hasItem("cupKey") && !this.hasItem("knife")) {
			this.pop("You forgot something else on the kitchen table.");
		} else if(!this.hasTrigger("sinkClean") && !this.hasItem("cupKey")) {
			this.pop("You should pay attention to the sink in your cell.");
		} else if(!this.hasItem("broom")) {
			this.pop("You need to use your KEY somewhere.");
		} else if(Game.EXTENDED && !this.hasTrigger("goPark")) {
			this.pop("You need to use the RING somewhere. I remember there was a small wooden case near my bed...");
		} else if(!this.hasTrigger("phoneDropped")) {
			this.pop("You should take advantage of the length of the BROOM in the park...");
		} else if(Game.EXTENDED && !this.hasTrigger("phoneCalled")) {
			this.pop("Now you reached the thing in the leaves, you should USE it.");
		} else if(Game.EXTENDED && !this.hasItem("finalLetter")) {
			this.pop("I saw a letter in the park. It wasn't there at the beginning, was it?");
		} else {
			this.pop("!I can't help you right now, sorry. It's up to you!");
		}
	}
	,changeRoom: function(k) {
		var _gthis = this;
		var from = this.room;
		var d = 4000;
		this.hideName();
		this.root.drawTo(this.snapshotTex);
		var snapshot = new h2d_Bitmap();
		this.root.add(snapshot,99);
		snapshot.posChanged = true;
		snapshot.x = -this.root.x / Const.SCALE;
		snapshot.set_tile(h2d_Tile.fromTexture(this.snapshotTex));
		var v = 1 / Const.SCALE;
		snapshot.posChanged = true;
		snapshot.scaleX = v;
		snapshot.posChanged = true;
		snapshot.scaleY = v;
		var _tween = this.tw.create_(function() {
			return snapshot.alpha;
		},function(_setV) {
			snapshot.alpha = _setV;
		},null,0,dn_TType.TEaseIn,d * 0.8);
		this.delayer.addMs(null,function() {
			if(snapshot != null && snapshot.parent != null) {
				snapshot.parent.removeChild(snapshot);
			}
		},d);
		var onTeleport = null;
		this.room = k;
		switch(k) {
		case "cell":
			this.setTrigger("teleportedBackCell");
			this.player.moveTo(10,5);
			if(this.hasItem("finalLetter") && !this.hasTriggerSet("finalMonologue")) {
				onTeleport = function() {
					_gthis.pop("@I write this letter while I'm still conscious and sane.");
					_gthis.pop("@Lydia used to say that, getting older, I was becoming more and more scatterbrain.");
					_gthis.pop("!She was damn right.");
					_gthis.pop("@My memories are fading away. And with them, my guilt for the things that led me into this cell.");
					_gthis.pop("!But I will also forget Lydia.");
					_gthis.pop("@My tender and beloved Lydia... This can't possibly happen. I must cherish her memory.");
					_gthis.pop("@I must remember the pain. Cry for her... Again and again...");
					_gthis.pop("@That's why I set up all of this paper chase for you. For me.");
					_gthis.pop("@I'm losing my mind. I'm seeing things, places.");
					_gthis.pop("@That's not the first time you discover this letter. And it won't be the last one.");
					_gthis.pop("@We must remember Lydia.");
					_gthis.pop("@Set everything up for us,  when you will forget again.");
					_gthis.pop("@Make sure that Lydia will always live in our tiny world.");
					_gthis.pop("@- Daniel.");
					_gthis.afterPop = function() {
						_gthis.lockControls(true);
						_gthis.fl_pause = true;
						_gthis.fl_ending = true;
						_gthis.actionsWrapper.set_visible(false);
						_gthis.invCont.set_visible(false);
						var _tween = _gthis.tw.create_(function() {
							return _gthis.heroFade.alpha;
						},function(_setV) {
							_gthis.heroFade.alpha = _setV;
						},null,1,dn_TType.TEase,5000);
						var _this = _gthis.player.spr;
						if(_this._animManager == null) {
							_this._animManager = new dn_heaps_slib_AnimManager(_this);
							if(_this.onAnimManAlloc != null) {
								_this.onAnimManAlloc(_this._animManager);
							}
						}
						var _this1 = _this._animManager.play("cry",1);
						var plays = 9999;
						if(plays == null) {
							plays = 1;
						}
						_this1.play("afterCry",plays,true);
						_gthis.delayer.addS(null,function() {
							_gthis.tw.terminate_(function() {
								return _gthis.heroFade.alpha;
							},function(_setV) {
								_gthis.heroFade.alpha = _setV;
							},false);
							var _tween = _gthis.tw.create_(function() {
								return _gthis.heroFade.alpha;
							},function(_setV) {
								_gthis.heroFade.alpha = _setV;
							},null,0.7,dn_TType.TEaseOut,500);
							_gthis.delayer.addS(null,function() {
								var _tween = _gthis.tw.create_(function() {
									return _gthis.root.alpha;
								},function(_setV) {
									_gthis.root.alpha = _setV;
								},null,0,dn_TType.TEaseIn,1000);
								_tween.onEnd = $bind(_gthis,_gthis.credits);
							},2);
						},7);
					};
				};
			}
			break;
		case "hell":
			this.player.moveTo(10,6);
			break;
		case "kitchen":
			this.player.moveTo(5,5);
			if(!this.hasTriggerSet("goKitchen")) {
				onTeleport = function() {
					_gthis.pop("My kitchen. Exactly like I left it.");
				};
			}
			break;
		case "park":
			if(from != "hell") {
				this.player.moveTo(10,5);
			} else {
				this.player.moveTo(this.player.cx,5);
			}
			if(!this.hasTriggerSet("goPark")) {
				onTeleport = function() {
					_gthis.pop("...|!The Arthur park.");
				};
			}
			break;
		}
		Assets.SOUNDS.teleport(1);
		this.initWorld();
		this.player.world = this.world;
		this.playerPath = [];
		this.playerTarget = null;
		this.onArrive = null;
		this.lockControls(true);
		var _tween = this.tw.create_(function() {
			return _gthis.distort.intensity;
		},function(_setV) {
			_gthis.distort.intensity = _setV;
		},null,1,dn_TType.TEaseIn,d * 0.6);
		_tween.onEnd = function() {
			var _tween = _gthis.tw.create_(function() {
				return _gthis.distort.intensity;
			},function(_setV) {
				_gthis.distort.intensity = _setV;
			},null,0.1,dn_TType.TEaseOut,d * 0.4);
			_tween.onEnd = function() {
				var _tween = _gthis.tw.create_(function() {
					return _gthis.distort.intensity;
				},function(_setV) {
					_gthis.distort.intensity = _setV;
				},null,0,dn_TType.TEaseIn,6000);
				_gthis.lockControls(false);
				if(onTeleport != null) {
					onTeleport();
				}
			};
		};
	}
	,credits: function() {
		this.invCont.set_visible(this.actionsWrapper.set_visible(this.miscWrapper.set_visible(false)));
		this.root.alpha = 1;
		this.uiInteractives = [];
		this.wrapper.removeChildren();
		var list = ["\"Memento XII\"","A 48h Ludum Dare game","by Sebastien Benard","","Thank you for playing!","Please visit DEEPNIGHT.NET","",":)"];
		var n = 0;
		var _g = 0;
		while(_g < list.length) {
			var t = list[_g];
			++_g;
			var tf = [this.makeText(t)];
			this.root.addChild(tf[0]);
			tf[0].posChanged = true;
			tf[0].x = 20;
			tf[0].posChanged = true;
			tf[0].y = 20 + 11 * n;
			tf[0].alpha = 0;
			var _tween = this.tw.create_((function(tf) {
				return function() {
					return tf[0].alpha;
				};
			})(tf),(function(tf) {
				return function(_setV) {
					tf[0].alpha = _setV;
				};
			})(tf),null,n == 0 ? 1 : 0.5,dn_TType.TEaseIn,1000);
			_tween.delayMs(1500 * n);
			++n;
		}
	}
	,setSprite: function(s) {
		this.lastSpot.spr = s;
		this.wrapper.add(s,2);
		s.posChanged = true;
		s.x = this.lastSpot.i.x;
		s.posChanged = true;
		s.y = this.lastSpot.i.y;
		return s;
	}
	,setAction: function(a,effect) {
		this.lastSpot.act.h[a] = effect;
	}
	,initWorld: function() {
		var _gthis = this;
		this.world = new World();
		var _this = this.world;
		var _g = 2;
		var _g1 = 12;
		while(_g < _g1) {
			var x2 = _g++;
			var _g2 = 4;
			var _g3 = 10;
			while(_g2 < _g3) {
				var y2 = _g2++;
				_this.cmap[x2][y2] = false;
			}
		}
		var frame = 0;
		switch(this.room) {
		case "cell":
			frame = 0;
			var _this = this.world;
			var w = 2;
			var h = 1;
			if(h == null) {
				h = 1;
			}
			if(w == null) {
				w = 1;
			}
			var _g = 6;
			var _g1 = 6 + w;
			while(_g < _g1) {
				var x2 = _g++;
				var _g2 = 4;
				var _g3 = 4 + h;
				while(_g2 < _g3) {
					var y2 = _g2++;
					_this.cmap[x2][y2] = true;
				}
			}
			var _this = this.world;
			var _g = 7;
			var _g1 = 8;
			while(_g < _g1) {
				var x2 = _g++;
				var _g2 = 5;
				var _g3 = 6;
				while(_g2 < _g3) {
					var y2 = _g2++;
					_this.cmap[x2][y2] = true;
				}
			}
			var _this = this.world;
			var w = 1;
			var h = 2;
			if(h == null) {
				h = 1;
			}
			if(w == null) {
				w = 1;
			}
			var _g = 11;
			var _g1 = 11 + w;
			while(_g < _g1) {
				var x2 = _g++;
				var _g2 = 5;
				var _g3 = 5 + h;
				while(_g2 < _g3) {
					var y2 = _g2++;
					_this.cmap[x2][y2] = true;
				}
			}
			var _this = this.world;
			var w = 3;
			var h = 1;
			if(h == null) {
				h = 1;
			}
			if(w == null) {
				w = 1;
			}
			var _g = 9;
			var _g1 = 9 + w;
			while(_g < _g1) {
				var x2 = _g++;
				var _g2 = 4;
				var _g3 = 4 + h;
				while(_g2 < _g3) {
					var y2 = _g2++;
					_this.cmap[x2][y2] = true;
				}
			}
			var _this = this.world;
			var w = 1;
			var h = 3;
			if(h == null) {
				h = 1;
			}
			if(w == null) {
				w = 1;
			}
			var _g = 2;
			var _g1 = 2 + w;
			while(_g < _g1) {
				var x2 = _g++;
				var _g2 = 7;
				var _g3 = 7 + h;
				while(_g2 < _g3) {
					var y2 = _g2++;
					_this.cmap[x2][y2] = true;
				}
			}
			var _this = this.world;
			var w = 3;
			var h = 2;
			if(h == null) {
				h = 1;
			}
			if(w == null) {
				w = 1;
			}
			var _g = 7;
			var _g1 = 7 + w;
			while(_g < _g1) {
				var x2 = _g++;
				var _g2 = 8;
				var _g3 = 8 + h;
				while(_g2 < _g3) {
					var y2 = _g2++;
					_this.cmap[x2][y2] = true;
				}
			}
			break;
		case "hell":
			frame = 3;
			var _this = this.world;
			var w = 3;
			var h = 1;
			if(h == null) {
				h = 1;
			}
			if(w == null) {
				w = 1;
			}
			var _g = 9;
			var _g1 = 9 + w;
			while(_g < _g1) {
				var x2 = _g++;
				var _g2 = 4;
				var _g3 = 4 + h;
				while(_g2 < _g3) {
					var y2 = _g2++;
					_this.cmap[x2][y2] = true;
				}
			}
			break;
		case "kitchen":
			frame = 1;
			var _this = this.world;
			var _g = 2;
			var _g1 = 3;
			while(_g < _g1) {
				var x2 = _g++;
				var _g2 = 4;
				var _g3 = 5;
				while(_g2 < _g3) {
					var y2 = _g2++;
					_this.cmap[x2][y2] = true;
				}
			}
			var _this = this.world;
			var w = 3;
			var h = 1;
			if(h == null) {
				h = 1;
			}
			if(w == null) {
				w = 1;
			}
			var _g = 5;
			var _g1 = 5 + w;
			while(_g < _g1) {
				var x2 = _g++;
				var _g2 = 4;
				var _g3 = 4 + h;
				while(_g2 < _g3) {
					var y2 = _g2++;
					_this.cmap[x2][y2] = true;
				}
			}
			var _this = this.world;
			var w = 3;
			var h = 1;
			if(h == null) {
				h = 1;
			}
			if(w == null) {
				w = 1;
			}
			var _g = 9;
			var _g1 = 9 + w;
			while(_g < _g1) {
				var x2 = _g++;
				var _g2 = 4;
				var _g3 = 4 + h;
				while(_g2 < _g3) {
					var y2 = _g2++;
					_this.cmap[x2][y2] = true;
				}
			}
			var _this = this.world;
			var w = 2;
			var h = 2;
			if(h == null) {
				h = 1;
			}
			if(w == null) {
				w = 1;
			}
			var _g = 3;
			var _g1 = 3 + w;
			while(_g < _g1) {
				var x2 = _g++;
				var _g2 = 6;
				var _g3 = 6 + h;
				while(_g2 < _g3) {
					var y2 = _g2++;
					_this.cmap[x2][y2] = true;
				}
			}
			var _this = this.world;
			var _g = 5;
			var _g1 = 6;
			while(_g < _g1) {
				var x2 = _g++;
				var _g2 = 6;
				var _g3 = 7;
				while(_g2 < _g3) {
					var y2 = _g2++;
					_this.cmap[x2][y2] = true;
				}
			}
			var _this = this.world;
			var w = 1;
			var h = 3;
			if(h == null) {
				h = 1;
			}
			if(w == null) {
				w = 1;
			}
			var _g = 11;
			var _g1 = 11 + w;
			while(_g < _g1) {
				var x2 = _g++;
				var _g2 = 7;
				var _g3 = 7 + h;
				while(_g2 < _g3) {
					var y2 = _g2++;
					_this.cmap[x2][y2] = true;
				}
			}
			break;
		case "park":
			frame = 2;
			var _this = this.world;
			var w = 3;
			var h = 1;
			if(h == null) {
				h = 1;
			}
			if(w == null) {
				w = 1;
			}
			var _g = 9;
			var _g1 = 9 + w;
			while(_g < _g1) {
				var x2 = _g++;
				var _g2 = 4;
				var _g3 = 4 + h;
				while(_g2 < _g3) {
					var y2 = _g2++;
					_this.cmap[x2][y2] = true;
				}
			}
			var _this = this.world;
			var w = 2;
			var h = 1;
			if(h == null) {
				h = 1;
			}
			if(w == null) {
				w = 1;
			}
			var _g = 2;
			var _g1 = 2 + w;
			while(_g < _g1) {
				var x2 = _g++;
				var _g2 = 4;
				var _g3 = 4 + h;
				while(_g2 < _g3) {
					var y2 = _g2++;
					_this.cmap[x2][y2] = true;
				}
			}
			var _this = this.world;
			var w = 1;
			var h = 2;
			if(h == null) {
				h = 1;
			}
			if(w == null) {
				w = 1;
			}
			var _g = 2;
			var _g1 = 2 + w;
			while(_g < _g1) {
				var x2 = _g++;
				var _g2 = 5;
				var _g3 = 5 + h;
				while(_g2 < _g3) {
					var y2 = _g2++;
					_this.cmap[x2][y2] = true;
				}
			}
			var _this = this.world;
			var _g = 2;
			var _g1 = 3;
			while(_g < _g1) {
				var x2 = _g++;
				var _g2 = 7;
				var _g3 = 8;
				while(_g2 < _g3) {
					var y2 = _g2++;
					_this.cmap[x2][y2] = true;
				}
			}
			break;
		}
		if(this.roomBg != null) {
			var _this = this.roomBg;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
		}
		var frame1 = frame;
		var smooth = null;
		var p = null;
		if(frame1 == null) {
			frame1 = 0;
		}
		var s = new dn_heaps_slib_HSprite(Assets.tiles,"cell",frame1);
		if(p != null) {
			p.addChild(s);
		}
		var xRatio = 0.;
		var yRatio = 0.;
		if(yRatio == null) {
			yRatio = 0.5;
		}
		if(xRatio == null) {
			xRatio = 0.5;
		}
		var _this = s.pivot;
		_this.centerFactorX = xRatio;
		_this.centerFactorY = yRatio;
		_this.usingFactor = true;
		_this.isUndefined = false;
		if(smooth != null) {
			s.smooth = smooth;
		}
		this.roomBg = s;
		if(this.room == "cell") {
			var smooth = null;
			var p = null;
			var s = new dn_heaps_slib_HSprite(Assets.tiles,"reflections",0);
			if(p != null) {
				p.addChild(s);
			}
			var xRatio = 0.;
			var yRatio = 0.;
			if(yRatio == null) {
				yRatio = 0.5;
			}
			if(xRatio == null) {
				xRatio = 0.5;
			}
			var _this = s.pivot;
			_this.centerFactorX = xRatio;
			_this.centerFactorY = yRatio;
			_this.usingFactor = true;
			_this.isUndefined = false;
			if(smooth != null) {
				s.smooth = smooth;
			}
			var r = s;
			this.roomBg.addChild(r);
			r.alpha = 0;
			r.posChanged = true;
			r.x = 24;
			r.posChanged = true;
			r.y = 32;
			var loop = null;
			loop = function() {
				var _tween = _gthis.tw.create_(function() {
					return r.alpha;
				},function(_setV) {
					r.alpha = _setV;
				},null,1,dn_TType.TLinear,1000);
				_tween.onEnd = function() {
					var _tween = _gthis.tw.create_(function() {
						return r.alpha;
					},function(_setV) {
						r.alpha = _setV;
					},null,0,dn_TType.TLinear,1000);
					_tween.onEnd = loop;
				};
			};
			loop();
		}
		this.wrapper.add(this.roomBg,1);
		var _g = 0;
		var _g1 = this.world.wid;
		while(_g < _g1) {
			var x = _g++;
			var _g2 = 0;
			var _g3 = this.world.hei;
			while(_g2 < _g3) {
				var y = _g2++;
			}
		}
		this.refreshWorld();
		this.pathFinder.init(this.world.wid,this.world.hei,($_=this.world,$bind($_,$_.collide)));
	}
	,refreshWorld: function() {
		this.initHotSpots();
		this.applyInteractiveVisibility();
	}
	,hideName: function() {
		if(this.curName != null) {
			this.curName.parent.removeChild(this.curName);
		}
		this.curName = null;
	}
	,showName: function(i,str) {
		this.hideName();
		var tf = this.makeText(str);
		this.wrapper.add(tf,10);
		tf.set_textColor(12106441);
		var v = i.x + i.width * 0.5 - tf.get_textWidth() * 0.5 | 0;
		tf.posChanged = true;
		tf.x = v;
		var v = i.y - tf.get_textHeight();
		tf.posChanged = true;
		tf.y = v;
		tf.alpha = 0;
		var _tween = this.tw.create_(function() {
			return tf.alpha;
		},function(_setV) {
			tf.alpha = _setV;
		},null,1,dn_TType.TEaseOut,400);
		this.curName = tf;
		this.curName.set_visible(!this.fl_pause && !this.fl_lockControls);
	}
	,closePop: function(nextQueue) {
		if(nextQueue == null) {
			nextQueue = true;
		}
		if(this.popUp != null) {
			this.popUp.parent.removeChild(this.popUp);
			this.popUp = null;
		}
		if(nextQueue && this.popQueue.length == 0 && this.afterPop != null) {
			var cb = this.afterPop;
			this.afterPop = null;
			cb();
		} else if(nextQueue && this.popQueue.length > 0) {
			this.pop(this.popQueue.pop());
		}
	}
	,pop: function(str) {
		if(this.popUp != null) {
			this.popQueue.add(str);
			return;
		}
		if(str.indexOf("|") > 0) {
			var parts = str.split("|");
			str = parts[0];
			var _g = 1;
			var _g1 = parts.length;
			while(_g < _g1) {
				var i = _g++;
				this.popQueue.add(parts[i]);
			}
		}
		var col = 5200072;
		var tcol = 16777215;
		if(str.charAt(0) == "!") {
			col = 10357772;
			str = HxOverrides.substr(str,1,null);
		}
		if(str.charAt(0) == "@") {
			col = 4939606;
			tcol = 10992305;
			str = HxOverrides.substr(str,1,null);
		}
		this.skipClick = true;
		this.lockControls(true);
		if(this.curName != null) {
			this.curName.set_visible(false);
		}
		this.closePop(false);
		var f = new h2d_Flow();
		this.wrapper.add(f,10);
		var tf = this.makeText(str,true);
		tf.set_filter(new h2d_filter_DropShadow(1,1.5707963267948966,0,0.4,null,null,null,true));
		tf.set_textColor(tcol);
		tf.posChanged = true;
		tf.x += 10;
		tf.posChanged = true;
		tf.y += 10;
		f.addChild(tf);
		f.set_padding(4);
		f.set_paddingTop(f.paddingTop - 1);
		var bg = new h2d_Bitmap(h2d_Tile.fromColor(col,f.get_outerWidth(),f.get_outerHeight()));
		f.addChildAt(bg,0);
		f.getProperties(bg).set_isAbsolute(true);
		bg.set_filter(new h2d_filter_Group([new dn_heaps_filter_PixelOutline(16777215),new dn_heaps_filter_PixelOutline(0)]));
		var v = -50 + Std.random(100) + 32;
		f.posChanged = true;
		f.x = v;
		var x = f.x;
		var max = Const.WID - this.wrapper.x - f.get_outerWidth() - 5;
		f.posChanged = true;
		f.x = x < 5 ? 5 : x > max ? max : x;
		var v = this.player.cy >= 6 ? Std.random(30) + 20 : Std.random(30) + Const.GRID * 6;
		f.posChanged = true;
		f.y = v;
		if(f.y < 5) {
			f.posChanged = true;
			f.y = 5;
		}
		if(f.y + f.get_outerHeight() + 5 >= (dn_Process.CUSTOM_STAGE_HEIGHT > 0 ? dn_Process.CUSTOM_STAGE_HEIGHT : hxd_Window.getInstance().get_height())) {
			var v = (dn_Process.CUSTOM_STAGE_HEIGHT > 0 ? dn_Process.CUSTOM_STAGE_HEIGHT : hxd_Window.getInstance().get_height()) - f.get_outerHeight() - 5;
			f.posChanged = true;
			f.y = v;
		}
		this.fl_pause = true;
		this.popUp = f;
	}
	,preUpdate: function() {
		dn_Process.prototype.preUpdate.call(this);
		this.skipClick = false;
	}
	,update: function() {
		dn_Process.prototype.update.call(this);
		if(hxd_Key.isPressed(68) && hxd_Key.isDown(17) && hxd_Key.isDown(16)) {
			this.interactiveDebug = !this.interactiveDebug;
			var _g = 0;
			var _g1 = this.uiInteractives;
			while(_g < _g1.length) {
				var i = _g1[_g];
				++_g;
				i.backgroundColor = this.interactiveDebug ? 1727987967 : null;
			}
			var _g = 0;
			var _g1 = this.hotSpots;
			while(_g < _g1.length) {
				var h = _g1[_g];
				++_g;
				h.i.backgroundColor = this.interactiveDebug ? 1727987967 : null;
			}
		}
		if(!this.fl_pause && !this.fl_ending) {
			var s = 0.047;
			if(this.playerPath.length > 0) {
				var tx = (this.playerPath[0].cx + 0.5) * Const.GRID;
				var ty = (this.playerPath[0].cy + 0.5) * Const.GRID;
				var _this = this.player;
				var _this1 = this.player;
				var a = Math.atan2(ty - ((_this.cy + _this.yr) * Const.GRID | 0),tx - ((_this1.cx + _this1.xr) * Const.GRID | 0));
				this.player.dx += Math.cos(a) * s * (this.utmod * this.getComputedTimeMultiplier());
				this.player.dy += Math.sin(a) * s * (this.utmod * this.getComputedTimeMultiplier());
				var _this = this.player;
				var ax = (_this.cx + _this.xr) * Const.GRID | 0;
				var _this = this.player;
				var ay = (_this.cy + _this.yr) * Const.GRID | 0;
				if(Math.sqrt((ax - tx) * (ax - tx) + (ay - ty) * (ay - ty)) <= 3) {
					this.playerPath.shift();
				}
				if(this.playerPath.length == 0 && this.onArrive != null) {
					this.onArrive();
					this.onArrive = null;
					if(this.playerTarget != null) {
						this.player.lookAt(this.playerTarget.cx,this.playerTarget.cy);
					}
					this.playerTarget = null;
				}
			}
			var _this = this.player;
			var tmp;
			var x = _this.dx;
			if(!((x < 0 ? -x : x) > 0.01)) {
				var x = _this.dy;
				tmp = (x < 0 ? -x : x) > 0.01;
			} else {
				tmp = true;
			}
			if(!tmp && this.playerPath.length == 0) {
				var tmp;
				var _this = this.player.spr;
				if(_this._animManager == null) {
					_this._animManager = new dn_heaps_slib_AnimManager(_this);
					if(_this.onAnimManAlloc != null) {
						_this.onAnimManAlloc(_this._animManager);
					}
				}
				var _this1 = _this._animManager;
				if(!(!_this1.destroyed && _this1.stack.length > 0 && _this1.stack[0].group == "walkUp")) {
					var _this = this.player.spr;
					if(_this._animManager == null) {
						_this._animManager = new dn_heaps_slib_AnimManager(_this);
						if(_this.onAnimManAlloc != null) {
							_this.onAnimManAlloc(_this._animManager);
						}
					}
					var _this1 = _this._animManager;
					tmp = !_this1.destroyed && _this1.stack.length > 0 && _this1.stack[0].group == "walkDown";
				} else {
					tmp = true;
				}
				if(tmp) {
					this.footStep = 0;
				}
			} else {
				this.footStep -= this.utmod * this.getComputedTimeMultiplier() * this.walkAnimSpd;
				if(this.footStep <= 0) {
					if(Std.random(3) == 0) {
						Assets.SOUNDS.footstep1(1);
					} else {
						Assets.SOUNDS.footstep2(1);
					}
					this.footStep = 6;
				}
			}
			var idx = 0;
			var a = Game.LOOK;
			if(hxd_Key.isPressed(HxOverrides.cca(a,0)) || hxd_Key.isPressed(49 + idx++)) {
				this.setPending(a);
			}
			var a = Game.REMEMBER;
			if(hxd_Key.isPressed(HxOverrides.cca(a,0)) || hxd_Key.isPressed(49 + idx++)) {
				this.setPending(a);
			}
			var a = Game.USE;
			if(hxd_Key.isPressed(HxOverrides.cca(a,0)) || hxd_Key.isPressed(49 + idx++)) {
				this.setPending(a);
			}
			var a = Game.PICK;
			if(hxd_Key.isPressed(HxOverrides.cca(a,0)) || hxd_Key.isPressed(49 + idx++)) {
				this.setPending(a);
			}
			var a = Game.OPEN;
			if(hxd_Key.isPressed(HxOverrides.cca(a,0)) || hxd_Key.isPressed(49 + idx++)) {
				this.setPending(a);
			}
			var a = Game.CLOSE;
			if(hxd_Key.isPressed(HxOverrides.cca(a,0)) || hxd_Key.isPressed(49 + idx++)) {
				this.setPending(a);
			}
			var a = Game.HELP;
			if(hxd_Key.isPressed(HxOverrides.cca(a,0)) || hxd_Key.isPressed(49 + idx++)) {
				this.setPending(a);
			}
			if(hxd_Key.isPressed(82) && hxd_Key.isDown(16)) {
				Main.ME.startGame();
				return;
			}
			if(this.room == "hell" && this.player.cx <= 6) {
				this.pop("!Lydia!!!");
				this.setTrigger("letterPop");
				var _g = $bind(this,this.changeRoom);
				var k = "park";
				this.afterPop = function() {
					_g(k);
				};
			}
			this.player.update(this.utmod * this.getComputedTimeMultiplier());
		}
		var _this = this.heroFade;
		_this.posChanged = true;
		_this.x = this.player.spr.x;
		var _this = this.heroFade;
		_this.posChanged = true;
		_this.y = this.player.spr.y - 4;
	}
	,__class__: Game
});
var HxOverrides = function() { };
$hxClasses["HxOverrides"] = HxOverrides;
HxOverrides.__name__ = "HxOverrides";
HxOverrides.strDate = function(s) {
	switch(s.length) {
	case 8:
		var k = s.split(":");
		var d = new Date();
		d["setTime"](0);
		d["setUTCHours"](k[0]);
		d["setUTCMinutes"](k[1]);
		d["setUTCSeconds"](k[2]);
		return d;
	case 10:
		var k = s.split("-");
		return new Date(k[0],k[1] - 1,k[2],0,0,0);
	case 19:
		var k = s.split(" ");
		var y = k[0].split("-");
		var t = k[1].split(":");
		return new Date(y[0],y[1] - 1,y[2],t[0],t[1],t[2]);
	default:
		throw haxe_Exception.thrown("Invalid date format : " + s);
	}
};
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.now = function() {
	return Date.now();
};
var Lambda = function() { };
$hxClasses["Lambda"] = Lambda;
Lambda.__name__ = "Lambda";
Lambda.array = function(it) {
	var a = [];
	var i = $getIterator(it);
	while(i.hasNext()) {
		var i1 = i.next();
		a.push(i1);
	}
	return a;
};
var Main = function(s) {
	dn_Process.call(this);
	Main.ME = this;
	this.createRoot(s);
	h3d_Engine.CURRENT.backgroundColor = -16777216 | Const.BG_COLOR;
	hxd_Res.set_loader(new hxd_res_Loader(new hxd_fs_EmbedFileSystem(haxe_Unserializer.run("oy3:sfxoy13:footstep1.wavty8:pick.wavty11:success.wavty11:ambiant.oggty12:teleport.oggty8:door.wavty10:select.wavty9:close.wavty8:help.wavty12:smallHit.wavty11:robinet.wavty13:footstep2.wavty7:hit.wavtgy9:tiles.pngty5:fontsoy9:04b03.fntty13:alterebro.fntty10:04B_03.TTFty13:alterebro.pngty20:alterebroOutline.pngty20:alterebroOutline.fntty9:04b03.pngtgg"))));
	hxd_snd_Manager.get();
	Assets.init();
	this.controller = new dn_legacy_Controller(s);
	this.ca = this.controller.createAccess("main");
	this.overlay = new dn_heaps_filter_OverlayTexture(dn_heaps_filter_OverlayTextureStyle.Classic,Const.SCALE);
	this.overlay.get_shader().alpha__ = 0.3;
	Boot.ME.s2d.set_filter(this.overlay);
	hxd_Timer.wantedFPS = 30;
	hxd_Timer.skip();
	this.delayer.addF(null,$bind(this,this.startGame),1);
	dn_Process.resizeAll();
};
$hxClasses["Main"] = Main;
Main.__name__ = "Main";
Main.__super__ = dn_Process;
Main.prototype = $extend(dn_Process.prototype,{
	onResize: function() {
		dn_Process.prototype.onResize.call(this);
		var x = dn_heaps_Scaler.bestFit_f(Const.WID,Const.HEI,null,null);
		var tmp;
		if(x >= 0) {
			tmp = x | 0;
		} else {
			var i = x | 0;
			tmp = x == i ? i : i - 1;
		}
		Const.SCALE = tmp;
		var _this = this.overlay;
		var v = Const.SCALE;
		if(_this.size != v) {
			_this.invalidated = true;
		}
		_this.size = v;
	}
	,startGame: function() {
		if(Game.ME != null) {
			Game.ME.destroyed = true;
			this.delayer.addF(null,function() {
				new Game();
			},1);
		} else {
			new Game();
		}
	}
	,update: function() {
		var tmp = this.utmod;
		var tmp1 = this.getComputedTimeMultiplier();
		Assets.tiles.tmod = tmp * tmp1;
		dn_Process.prototype.update.call(this);
	}
	,__class__: Main
});
Math.__name__ = "Math";
var Reflect = function() { };
$hxClasses["Reflect"] = Reflect;
Reflect.__name__ = "Reflect";
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( _g ) {
		return null;
	}
};
Reflect.isFunction = function(f) {
	if(typeof(f) == "function") {
		return !(f.__name__ || f.__ename__);
	} else {
		return false;
	}
};
Reflect.compare = function(a,b) {
	if(a == b) {
		return 0;
	} else if(a > b) {
		return 1;
	} else {
		return -1;
	}
};
Reflect.compareMethods = function(f1,f2) {
	if(f1 == f2) {
		return true;
	}
	if(!Reflect.isFunction(f1) || !Reflect.isFunction(f2)) {
		return false;
	}
	if(f1.scope == f2.scope && f1.method == f2.method) {
		return f1.method != null;
	} else {
		return false;
	}
};
Reflect.isEnumValue = function(v) {
	if(v != null) {
		return v.__enum__ != null;
	} else {
		return false;
	}
};
var Std = function() { };
$hxClasses["Std"] = Std;
Std.__name__ = "Std";
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	if(x != null) {
		var _g = 0;
		var _g1 = x.length;
		while(_g < _g1) {
			var i = _g++;
			var c = x.charCodeAt(i);
			if(c <= 8 || c >= 14 && c != 32 && c != 45) {
				var nc = x.charCodeAt(i + 1);
				var v = parseInt(x,nc == 120 || nc == 88 ? 16 : 10);
				if(isNaN(v)) {
					return null;
				} else {
					return v;
				}
			}
		}
	}
	return null;
};
Std.random = function(x) {
	if(x <= 0) {
		return 0;
	} else {
		return Math.floor(Math.random() * x);
	}
};
var StringBuf = function() {
	this.b = "";
};
$hxClasses["StringBuf"] = StringBuf;
StringBuf.__name__ = "StringBuf";
StringBuf.prototype = {
	__class__: StringBuf
};
var StringTools = function() { };
$hxClasses["StringTools"] = StringTools;
StringTools.__name__ = "StringTools";
StringTools.htmlEscape = function(s,quotes) {
	var buf_b = "";
	var _g_offset = 0;
	var _g_s = s;
	while(_g_offset < _g_s.length) {
		var s = _g_s;
		var index = _g_offset++;
		var c = s.charCodeAt(index);
		if(c >= 55296 && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
		}
		var c1 = c;
		if(c1 >= 65536) {
			++_g_offset;
		}
		var code = c1;
		switch(code) {
		case 34:
			if(quotes) {
				buf_b += "&quot;";
			} else {
				buf_b += String.fromCodePoint(code);
			}
			break;
		case 38:
			buf_b += "&amp;";
			break;
		case 39:
			if(quotes) {
				buf_b += "&#039;";
			} else {
				buf_b += String.fromCodePoint(code);
			}
			break;
		case 60:
			buf_b += "&lt;";
			break;
		case 62:
			buf_b += "&gt;";
			break;
		default:
			buf_b += String.fromCodePoint(code);
		}
	}
	return buf_b;
};
StringTools.startsWith = function(s,start) {
	if(s.length >= start.length) {
		return s.lastIndexOf(start,0) == 0;
	} else {
		return false;
	}
};
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
StringTools.replace = function(s,sub,by) {
	return s.split(sub).join(by);
};
StringTools.hex = function(n,digits) {
	var s = "";
	var hexChars = "0123456789ABCDEF";
	while(true) {
		s = hexChars.charAt(n & 15) + s;
		n >>>= 4;
		if(!(n > 0)) {
			break;
		}
	}
	if(digits != null) {
		while(s.length < digits) s = "0" + s;
	}
	return s;
};
var ValueType = $hxEnums["ValueType"] = { __ename__:true,__constructs__:null
	,TNull: {_hx_name:"TNull",_hx_index:0,__enum__:"ValueType",toString:$estr}
	,TInt: {_hx_name:"TInt",_hx_index:1,__enum__:"ValueType",toString:$estr}
	,TFloat: {_hx_name:"TFloat",_hx_index:2,__enum__:"ValueType",toString:$estr}
	,TBool: {_hx_name:"TBool",_hx_index:3,__enum__:"ValueType",toString:$estr}
	,TObject: {_hx_name:"TObject",_hx_index:4,__enum__:"ValueType",toString:$estr}
	,TFunction: {_hx_name:"TFunction",_hx_index:5,__enum__:"ValueType",toString:$estr}
	,TClass: ($_=function(c) { return {_hx_index:6,c:c,__enum__:"ValueType",toString:$estr}; },$_._hx_name="TClass",$_.__params__ = ["c"],$_)
	,TEnum: ($_=function(e) { return {_hx_index:7,e:e,__enum__:"ValueType",toString:$estr}; },$_._hx_name="TEnum",$_.__params__ = ["e"],$_)
	,TUnknown: {_hx_name:"TUnknown",_hx_index:8,__enum__:"ValueType",toString:$estr}
};
ValueType.__constructs__ = [ValueType.TNull,ValueType.TInt,ValueType.TFloat,ValueType.TBool,ValueType.TObject,ValueType.TFunction,ValueType.TClass,ValueType.TEnum,ValueType.TUnknown];
ValueType.__empty_constructs__ = [ValueType.TNull,ValueType.TInt,ValueType.TFloat,ValueType.TBool,ValueType.TObject,ValueType.TFunction,ValueType.TUnknown];
var Type = function() { };
$hxClasses["Type"] = Type;
Type.__name__ = "Type";
Type.createInstance = function(cl,args) {
	var ctor = Function.prototype.bind.apply(cl,[null].concat(args));
	return new (ctor);
};
Type.createEnum = function(e,constr,params) {
	var f = Reflect.field(e,constr);
	if(f == null) {
		throw haxe_Exception.thrown("No such constructor " + constr);
	}
	if(Reflect.isFunction(f)) {
		if(params == null) {
			throw haxe_Exception.thrown("Constructor " + constr + " need parameters");
		}
		return f.apply(e,params);
	}
	if(params != null && params.length != 0) {
		throw haxe_Exception.thrown("Constructor " + constr + " does not need parameters");
	}
	return f;
};
Type.createEnumIndex = function(e,index,params) {
	var c;
	var _g = e.__constructs__[index];
	if(_g == null) {
		c = null;
	} else {
		var ctor = _g;
		c = ctor._hx_name;
	}
	if(c == null) {
		throw haxe_Exception.thrown(index + " is not a valid enum constructor index");
	}
	return Type.createEnum(e,c,params);
};
Type.typeof = function(v) {
	switch(typeof(v)) {
	case "boolean":
		return ValueType.TBool;
	case "function":
		if(v.__name__ || v.__ename__) {
			return ValueType.TObject;
		}
		return ValueType.TFunction;
	case "number":
		if(Math.ceil(v) == v % 2147483648.0) {
			return ValueType.TInt;
		}
		return ValueType.TFloat;
	case "object":
		if(v == null) {
			return ValueType.TNull;
		}
		var e = v.__enum__;
		if(e != null) {
			return ValueType.TEnum($hxEnums[e]);
		}
		var c = js_Boot.getClass(v);
		if(c != null) {
			return ValueType.TClass(c);
		}
		return ValueType.TObject;
	case "string":
		return ValueType.TClass(String);
	case "undefined":
		return ValueType.TNull;
	default:
		return ValueType.TUnknown;
	}
};
Type.enumEq = function(a,b) {
	if(a == b) {
		return true;
	}
	try {
		var e = a.__enum__;
		if(e == null || e != b.__enum__) {
			return false;
		}
		if(a._hx_index != b._hx_index) {
			return false;
		}
		var enm = $hxEnums[e];
		var params = enm.__constructs__[a._hx_index].__params__;
		var _g = 0;
		while(_g < params.length) {
			var f = params[_g];
			++_g;
			if(!Type.enumEq(a[f],b[f])) {
				return false;
			}
		}
	} catch( _g ) {
		return false;
	}
	return true;
};
Type.enumParameters = function(e) {
	var enm = $hxEnums[e.__enum__];
	var params = enm.__constructs__[e._hx_index].__params__;
	if(params != null) {
		var _g = [];
		var _g1 = 0;
		while(_g1 < params.length) {
			var p = params[_g1];
			++_g1;
			_g.push(e[p]);
		}
		return _g;
	} else {
		return [];
	}
};
var UInt = {};
UInt.gt = function(a,b) {
	var aNeg = a < 0;
	var bNeg = b < 0;
	if(aNeg != bNeg) {
		return aNeg;
	} else {
		return a > b;
	}
};
UInt.gte = function(a,b) {
	var aNeg = a < 0;
	var bNeg = b < 0;
	if(aNeg != bNeg) {
		return aNeg;
	} else {
		return a >= b;
	}
};
UInt.toFloat = function(this1) {
	var int = this1;
	if(int < 0) {
		return 4294967296.0 + int;
	} else {
		return int + 0.0;
	}
};
var World = function() {
	this.wid = 13;
	this.hei = 11;
	this.cmap = [];
	var _g = 0;
	var _g1 = this.wid;
	while(_g < _g1) {
		var x = _g++;
		this.cmap[x] = [];
		var _g2 = 0;
		var _g3 = this.hei;
		while(_g2 < _g3) {
			var y = _g2++;
			this.cmap[x][y] = true;
		}
	}
};
$hxClasses["World"] = World;
World.__name__ = "World";
World.prototype = {
	collide: function(x,y) {
		if(x < 0 || x >= this.wid || y < 0 || y >= this.hei) {
			return true;
		} else {
			return this.cmap[x][y];
		}
	}
	,__class__: World
};
var XmlType = {};
XmlType.toString = function(this1) {
	switch(this1) {
	case 0:
		return "Element";
	case 1:
		return "PCData";
	case 2:
		return "CData";
	case 3:
		return "Comment";
	case 4:
		return "DocType";
	case 5:
		return "ProcessingInstruction";
	case 6:
		return "Document";
	}
};
var Xml = function(nodeType) {
	this.nodeType = nodeType;
	this.children = [];
	this.attributeMap = new haxe_ds_StringMap();
};
$hxClasses["Xml"] = Xml;
Xml.__name__ = "Xml";
Xml.parse = function(str) {
	return haxe_xml_Parser.parse(str);
};
Xml.createElement = function(name) {
	var xml = new Xml(Xml.Element);
	if(xml.nodeType != Xml.Element) {
		throw haxe_Exception.thrown("Bad node type, expected Element but found " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
	}
	xml.nodeName = name;
	return xml;
};
Xml.createPCData = function(data) {
	var xml = new Xml(Xml.PCData);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createCData = function(data) {
	var xml = new Xml(Xml.CData);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createComment = function(data) {
	var xml = new Xml(Xml.Comment);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createDocType = function(data) {
	var xml = new Xml(Xml.DocType);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createProcessingInstruction = function(data) {
	var xml = new Xml(Xml.ProcessingInstruction);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createDocument = function() {
	return new Xml(Xml.Document);
};
Xml.prototype = {
	get: function(att) {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return this.attributeMap.h[att];
	}
	,set: function(att,value) {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		this.attributeMap.h[att] = value;
	}
	,exists: function(att) {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return Object.prototype.hasOwnProperty.call(this.attributeMap.h,att);
	}
	,attributes: function() {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return new haxe_ds__$StringMap_StringMapKeyIterator(this.attributeMap.h);
	}
	,iterator: function() {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return new haxe_iterators_ArrayIterator(this.children);
	}
	,elements: function() {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = this.children;
		while(_g1 < _g2.length) {
			var child = _g2[_g1];
			++_g1;
			if(child.nodeType == Xml.Element) {
				_g.push(child);
			}
		}
		var ret = _g;
		return new haxe_iterators_ArrayIterator(ret);
	}
	,elementsNamed: function(name) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = this.children;
		while(_g1 < _g2.length) {
			var child = _g2[_g1];
			++_g1;
			var tmp;
			if(child.nodeType == Xml.Element) {
				if(child.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (child.nodeType == null ? "null" : XmlType.toString(child.nodeType)));
				}
				tmp = child.nodeName == name;
			} else {
				tmp = false;
			}
			if(tmp) {
				_g.push(child);
			}
		}
		var ret = _g;
		return new haxe_iterators_ArrayIterator(ret);
	}
	,firstElement: function() {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			if(child.nodeType == Xml.Element) {
				return child;
			}
		}
		return null;
	}
	,addChild: function(x) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		if(x.parent != null) {
			x.parent.removeChild(x);
		}
		this.children.push(x);
		x.parent = this;
	}
	,removeChild: function(x) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		if(HxOverrides.remove(this.children,x)) {
			x.parent = null;
			return true;
		}
		return false;
	}
	,toString: function() {
		return haxe_xml_Printer.print(this);
	}
	,__class__: Xml
};
var dn_Bresenham = function() { };
$hxClasses["dn.Bresenham"] = dn_Bresenham;
dn_Bresenham.__name__ = "dn.Bresenham";
dn_Bresenham.getDisc = function(x0,y0,radius) {
	var pts = [];
	dn_Bresenham.iterateDisc(x0,y0,radius,function(x,y) {
		pts.push({ x : x, y : y});
	});
	return pts;
};
dn_Bresenham.iterateDisc = function(x0,y0,radius,cb) {
	var x = radius;
	var y = 0;
	var radiusError = 1 - x;
	while(x >= y) {
		var fy = y + y0;
		var _g = -x + x0;
		var _g1 = x + x0 + 1;
		while(_g < _g1) {
			var x1 = _g++;
			cb(x1,fy);
		}
		if((radius <= 1 || x != y && y != 0) && radiusError >= 0) {
			var fy1 = x + y0;
			var _g2 = -y + x0;
			var _g3 = y + x0 + 1;
			while(_g2 < _g3) {
				var x2 = _g2++;
				cb(x2,fy1);
			}
		}
		if(y != 0) {
			var fy2 = -y + y0;
			var _g4 = -x + x0;
			var _g5 = x + x0 + 1;
			while(_g4 < _g5) {
				var x3 = _g4++;
				cb(x3,fy2);
			}
		}
		if((radius <= 1 || x != y && y != 0) && radiusError >= 0) {
			var fy3 = -x + y0;
			var _g6 = -y + x0;
			var _g7 = y + x0 + 1;
			while(_g6 < _g7) {
				var x4 = _g6++;
				cb(x4,fy3);
			}
		}
		++y;
		if(radiusError < 0) {
			radiusError += 2 * y + 1;
		} else {
			--x;
			radiusError += 2 * (y - x + 1);
		}
	}
};
var dn_Cooldown = function(fps,maxSize) {
	if(dn_Cooldown.INDEXES == null) {
		if(haxe_rtti_Meta.getType(dn_Cooldown).indexes != null) {
			var _g = [];
			var _g1 = 0;
			var _g2 = haxe_rtti_Meta.getType(dn_Cooldown).indexes;
			while(_g1 < _g2.length) {
				var str = _g2[_g1];
				++_g1;
				_g.push(Std.string(str));
			}
			dn_Cooldown.INDEXES = _g;
		}
	}
	this.baseFps = fps;
	this.changeMaxSizeAndReset(maxSize == null ? dn_Cooldown.DEFAULT_COUNT_LIMIT : maxSize);
};
$hxClasses["dn.Cooldown"] = dn_Cooldown;
dn_Cooldown.__name__ = "dn.Cooldown";
dn_Cooldown.prototype = {
	changeMaxSizeAndReset: function(newMaxSize) {
		this.cds = new dn_struct_RecyclablePool(newMaxSize,function() {
			return new dn__$Cooldown_CdInst();
		});
		this.cds.nalloc = 0;
		this.fastCheck = new haxe_ds_IntMap();
	}
	,dispose: function() {
		this.cds.dispose(null);
		this.cds = null;
		this.fastCheck = null;
	}
	,toString: function() {
		return "Cooldowns(" + this.cds.nalloc + "/" + this.cds.size + ")";
	}
	,update: function(tmod) {
		var i = 0;
		var cd;
		var cb = null;
		while(i < this.cds.nalloc) {
			var _this = this.cds;
			cd = i < 0 || i >= _this.nalloc ? null : _this.pool[i];
			cd.frames -= tmod;
			if(cd.frames <= 0) {
				cb = cd.onCompleteOnce;
				var _this1 = this.cds;
				this.fastCheck.remove((i < 0 || i >= _this1.nalloc ? null : _this1.pool[i]).k);
				var _this2 = this.cds;
				if(i >= 0 && i < _this2.nalloc) {
					if(_this2.nalloc > 1) {
						var tmp = _this2.pool[i];
						_this2.pool[i] = _this2.pool[_this2.nalloc - 1];
						_this2.pool[_this2.nalloc - 1] = tmp;
						_this2.nalloc--;
					} else {
						_this2.nalloc = 0;
					}
				}
				if(cb != null) {
					cb();
				}
			} else {
				++i;
			}
		}
	}
	,__class__: dn_Cooldown
};
var dn__$Cooldown_CdInst = function() {
};
$hxClasses["dn._Cooldown.CdInst"] = dn__$Cooldown_CdInst;
dn__$Cooldown_CdInst.__name__ = "dn._Cooldown.CdInst";
dn__$Cooldown_CdInst.prototype = {
	recycle: function() {
		this.onCompleteOnce = null;
	}
	,toString: function() {
		var x = (this.initial == 0 ? 0 : 1 - (this.initial == 0 ? 0 : this.frames / this.initial)) * 100;
		return dn_Cooldown.INDEXES[this.k >>> 22] + "|" + (this.k & 4194303) + (": " + this.frames + "/" + this.initial + " (" + ((x > 0 ? x + .5 : x < 0 ? x - .5 : 0) | 0) + "%)");
	}
	,__class__: dn__$Cooldown_CdInst
};
var dn_DecisionHelper = function(a) {
	this.values = a;
	this.scores = new haxe_ds_IntMap();
};
$hxClasses["dn.DecisionHelper"] = dn_DecisionHelper;
dn_DecisionHelper.__name__ = "dn.DecisionHelper";
dn_DecisionHelper.prototype = {
	getBest: function() {
		var bestIdx = -1;
		var best = null;
		var idx = 0;
		var v = $getIterator(this.values);
		while(v.hasNext()) {
			var v1 = v.next();
			var tmp;
			if(!(this.scores.h.hasOwnProperty(idx) && this.scores.h[idx] == -1e+20)) {
				if(bestIdx >= 0) {
					if(!this.scores.h.hasOwnProperty(idx)) {
						this.scores.h[idx] = 0;
					}
					var tmp1 = this.scores.h[idx];
					if(!this.scores.h.hasOwnProperty(bestIdx)) {
						this.scores.h[bestIdx] = 0;
					}
					tmp = tmp1 > this.scores.h[bestIdx];
				} else {
					tmp = true;
				}
			} else {
				tmp = false;
			}
			if(tmp) {
				best = v1;
				bestIdx = idx;
			}
			++idx;
		}
		return best;
	}
	,__class__: dn_DecisionHelper
};
var dn__$Delayer_Task = function(id,t,cb) {
	this.t = t;
	this.cb = cb;
	this.id = id;
};
$hxClasses["dn._Delayer.Task"] = dn__$Delayer_Task;
dn__$Delayer_Task.__name__ = "dn._Delayer.Task";
dn__$Delayer_Task.prototype = {
	__class__: dn__$Delayer_Task
};
var dn_Delayer = function(fps) {
	this.fps = fps;
	this.delays = [];
};
$hxClasses["dn.Delayer"] = dn_Delayer;
dn_Delayer.__name__ = "dn.Delayer";
dn_Delayer.prototype = {
	destroy: function() {
		this.delays = null;
	}
	,cmp: function(a,b) {
		if(a.t < b.t) {
			return -1;
		} else if(a.t > b.t) {
			return 1;
		} else {
			return 0;
		}
	}
	,addMs: function(id,cb,ms) {
		this.delays.push(new dn__$Delayer_Task(id,ms / 1000 * this.fps,cb));
		haxe_ds_ArraySort.sort(this.delays,$bind(this,this.cmp));
	}
	,addS: function(id,cb,sec) {
		this.delays.push(new dn__$Delayer_Task(id,sec * this.fps,cb));
		haxe_ds_ArraySort.sort(this.delays,$bind(this,this.cmp));
	}
	,addF: function(id,cb,frames) {
		this.delays.push(new dn__$Delayer_Task(id,frames,cb));
		haxe_ds_ArraySort.sort(this.delays,$bind(this,this.cmp));
	}
	,update: function(dt) {
		var i = 0;
		while(i < this.delays.length) {
			this.delays[i].t -= dt;
			if(this.delays[i].t <= 0) {
				this.delays[i].cb();
				if(this.delays == null || this.delays[i] == null) {
					break;
				}
				this.delays[i].cb = null;
				this.delays.shift();
			} else {
				++i;
			}
		}
	}
	,__class__: dn_Delayer
};
var dn_Lib = function() { };
$hxClasses["dn.Lib"] = dn_Lib;
dn_Lib.__name__ = "dn.Lib";
dn_Lib.println = function(v) {
	console.log(Std.string(v));
};
var dn_TType = $hxEnums["dn.TType"] = { __ename__:true,__constructs__:null
	,TLinear: {_hx_name:"TLinear",_hx_index:0,__enum__:"dn.TType",toString:$estr}
	,TLoop: {_hx_name:"TLoop",_hx_index:1,__enum__:"dn.TType",toString:$estr}
	,TLoopEaseIn: {_hx_name:"TLoopEaseIn",_hx_index:2,__enum__:"dn.TType",toString:$estr}
	,TLoopEaseOut: {_hx_name:"TLoopEaseOut",_hx_index:3,__enum__:"dn.TType",toString:$estr}
	,TEase: {_hx_name:"TEase",_hx_index:4,__enum__:"dn.TType",toString:$estr}
	,TEaseIn: {_hx_name:"TEaseIn",_hx_index:5,__enum__:"dn.TType",toString:$estr}
	,TEaseOut: {_hx_name:"TEaseOut",_hx_index:6,__enum__:"dn.TType",toString:$estr}
	,TBurn: {_hx_name:"TBurn",_hx_index:7,__enum__:"dn.TType",toString:$estr}
	,TBurnIn: {_hx_name:"TBurnIn",_hx_index:8,__enum__:"dn.TType",toString:$estr}
	,TBurnOut: {_hx_name:"TBurnOut",_hx_index:9,__enum__:"dn.TType",toString:$estr}
	,TZigZag: {_hx_name:"TZigZag",_hx_index:10,__enum__:"dn.TType",toString:$estr}
	,TRand: {_hx_name:"TRand",_hx_index:11,__enum__:"dn.TType",toString:$estr}
	,TShake: {_hx_name:"TShake",_hx_index:12,__enum__:"dn.TType",toString:$estr}
	,TShakeBoth: {_hx_name:"TShakeBoth",_hx_index:13,__enum__:"dn.TType",toString:$estr}
	,TJump: {_hx_name:"TJump",_hx_index:14,__enum__:"dn.TType",toString:$estr}
	,TElasticEnd: {_hx_name:"TElasticEnd",_hx_index:15,__enum__:"dn.TType",toString:$estr}
	,TBackOut: {_hx_name:"TBackOut",_hx_index:16,__enum__:"dn.TType",toString:$estr}
};
dn_TType.__constructs__ = [dn_TType.TLinear,dn_TType.TLoop,dn_TType.TLoopEaseIn,dn_TType.TLoopEaseOut,dn_TType.TEase,dn_TType.TEaseIn,dn_TType.TEaseOut,dn_TType.TBurn,dn_TType.TBurnIn,dn_TType.TBurnOut,dn_TType.TZigZag,dn_TType.TRand,dn_TType.TShake,dn_TType.TShakeBoth,dn_TType.TJump,dn_TType.TElasticEnd,dn_TType.TBackOut];
dn_TType.__empty_constructs__ = [dn_TType.TLinear,dn_TType.TLoop,dn_TType.TLoopEaseIn,dn_TType.TLoopEaseOut,dn_TType.TEase,dn_TType.TEaseIn,dn_TType.TEaseOut,dn_TType.TBurn,dn_TType.TBurnIn,dn_TType.TBurnOut,dn_TType.TZigZag,dn_TType.TRand,dn_TType.TShake,dn_TType.TShakeBoth,dn_TType.TJump,dn_TType.TElasticEnd,dn_TType.TBackOut];
var dn_Tween = function(tw) {
	this.tw = tw;
	this.paused = false;
	this.done = false;
	this.n = this.ln = 0;
	this.delay = 0;
	this.speed = 1;
	this.set_type(dn_TType.TEase);
	this.plays = 1;
	this.pixelSnap = false;
};
$hxClasses["dn.Tween"] = dn_Tween;
dn_Tween.__name__ = "dn.Tween";
dn_Tween.prototype = {
	set_type: function(t) {
		var _gthis = this;
		this.type = t;
		var tmp;
		switch(this.type._hx_index) {
		case 0:
			tmp = function(step) {
				return step;
			};
			break;
		case 1:
			tmp = function(step) {
				var n = 1 - step;
				var n1 = 1 - step;
				return n * n * n * 0 + 3 * step * (n1 * n1) * 1.33 + 3 * (step * step) * (1 - step) * 1.33 + step * step * step * 0;
			};
			break;
		case 2:
			tmp = function(step) {
				var n = 1 - step;
				var n1 = 1 - step;
				return n * n * n * 0 + 3 * step * (n1 * n1) * 0 + 3 * (step * step) * (1 - step) * 2.25 + step * step * step * 0;
			};
			break;
		case 3:
			tmp = function(step) {
				var n = 1 - step;
				var n1 = 1 - step;
				return n * n * n * 0 + 3 * step * (n1 * n1) * 2.25 + 3 * (step * step) * (1 - step) * 0 + step * step * step * 0;
			};
			break;
		case 4:
			tmp = function(step) {
				var n = 1 - step;
				var n1 = 1 - step;
				return n * n * n * 0 + 3 * step * (n1 * n1) * 0 + 3 * (step * step) * (1 - step) + step * step * step;
			};
			break;
		case 5:
			tmp = function(step) {
				var n = 1 - step;
				var n1 = 1 - step;
				return n * n * n * 0 + 3 * step * (n1 * n1) * 0 + 3 * (step * step) * (1 - step) * 0.5 + step * step * step;
			};
			break;
		case 6:
			tmp = function(step) {
				var n = 1 - step;
				var n1 = 1 - step;
				return n * n * n * 0 + 3 * step * (n1 * n1) * 0.5 + 3 * (step * step) * (1 - step) + step * step * step;
			};
			break;
		case 7:
			tmp = function(step) {
				var n = 1 - step;
				var n1 = 1 - step;
				return n * n * n * 0 + 3 * step * (n1 * n1) + 3 * (step * step) * (1 - step) * 0 + step * step * step;
			};
			break;
		case 8:
			tmp = function(step) {
				var n = 1 - step;
				var n1 = 1 - step;
				return n * n * n * 0 + 3 * step * (n1 * n1) + 3 * (step * step) * (1 - step) + step * step * step;
			};
			break;
		case 9:
			tmp = function(step) {
				var n = 1 - step;
				var n1 = 1 - step;
				return n * n * n * 0 + 3 * step * (n1 * n1) * 0 + 3 * (step * step) * (1 - step) * 0 + step * step * step;
			};
			break;
		case 10:
			tmp = function(step) {
				var n = 1 - step;
				var n1 = 1 - step;
				return n * n * n * 0 + 3 * step * (n1 * n1) * 2.5 + 3 * (step * step) * (1 - step) * -1.5 + step * step * step;
			};
			break;
		case 11:
			tmp = function(step) {
				return step;
			};
			break;
		case 12:
			tmp = function(step) {
				var n = 1 - step;
				var n1 = 1 - step;
				return n * n * n * 0.5 + 3 * step * (n1 * n1) * 1.22 + 3 * (step * step) * (1 - step) * 1.25 + step * step * step * 0;
			};
			break;
		case 13:
			tmp = function(step) {
				var n = 1 - step;
				var n1 = 1 - step;
				return n * n * n * 0.5 + 3 * step * (n1 * n1) * 1.22 + 3 * (step * step) * (1 - step) * 1.25 + step * step * step * 0;
			};
			break;
		case 14:
			tmp = function(step) {
				var n = 1 - step;
				var n1 = 1 - step;
				return n * n * n * 0 + 3 * step * (n1 * n1) * 2 + 3 * (step * step) * (1 - step) * 2.79 + step * step * step;
			};
			break;
		case 15:
			tmp = function(step) {
				var n = 1 - step;
				var n1 = 1 - step;
				return n * n * n * 0 + 3 * step * (n1 * n1) * 0.7 + 3 * (step * step) * (1 - step) * 1.5 + step * step * step;
			};
			break;
		case 16:
			tmp = function(step) {
				var s = 1.70158;
				step = step / 1 - 1;
				return step * step * ((s + 1) * step + s) + 1;
			};
			break;
		}
		this.interpolate = tmp;
		return this.type;
	}
	,onUpdate: function() {
	}
	,onUpdateT: function(t) {
	}
	,onEnd: function() {
	}
	,onStart: function() {
	}
	,chainedEvent: function() {
	}
	,interpolate: function(v) {
		return v;
	}
	,delayMs: function(d) {
		var x = d * this.tw.baseFps / 1000;
		this.delay = (x > 0 ? x + .5 : x < 0 ? x - .5 : 0) | 0;
	}
	,endWithoutCallbacks: function() {
		this.done = true;
	}
	,complete: function(fl_allowLoop) {
		if(fl_allowLoop == null) {
			fl_allowLoop = false;
		}
		var v = this.from + (this.to - this.from) * this.interpolate(1);
		if(this.pixelSnap) {
			v = (v > 0 ? v + .5 : v < 0 ? v - .5 : 0) | 0;
		}
		this.setter(v);
		this.onUpdate();
		this.onUpdateT(1);
		this.onEnd();
		this.chainedEvent();
		if(fl_allowLoop && (this.plays == -1 || this.plays > 1)) {
			if(this.plays != -1) {
				this.plays--;
			}
			this.n = this.ln = 0;
		} else {
			this.done = true;
		}
	}
	,internalUpdate: function(dt) {
		if(this.done) {
			return true;
		}
		if(this.paused) {
			return false;
		}
		if(this.delay > 0) {
			this.delay -= dt;
			return false;
		}
		if(this.onStart != null) {
			var cb = $bind(this,this.onStart);
			this.onStart = null;
			cb();
		}
		var dist = this.to - this.from;
		if(this.type == dn_TType.TRand) {
			this.ln += Std.random(100) < 33 ? this.speed * dt : 0;
		} else {
			this.ln += this.speed * dt;
		}
		this.n = this.interpolate(this.ln);
		if(this.ln < 1) {
			var val;
			if(this.type != dn_TType.TShake && this.type != dn_TType.TShakeBoth) {
				val = this.from + this.n * dist;
			} else if(this.type == dn_TType.TShake) {
				var val1 = this.from;
				var val2 = Math.random();
				var x = this.n * dist;
				val = val1 + val2 * (x < 0 ? -x : x) * (dist > 0 ? 1 : -1);
			} else {
				val = this.from + Math.random() * this.n * dist * (Std.random(2) * 2 - 1);
			}
			if(this.pixelSnap) {
				val = (val > 0 ? val + .5 : val < 0 ? val - .5 : 0) | 0;
			}
			this.setter(val);
			this.onUpdate();
			this.onUpdateT(this.ln);
		} else {
			this.complete(true);
		}
		return this.done;
	}
	,__class__: dn_Tween
};
var dn_Tweenie = function(fps) {
	this.baseFps = fps;
	this.allTweens = new dn_struct_FixedArray(null,512);
};
$hxClasses["dn.Tweenie"] = dn_Tweenie;
dn_Tweenie.__name__ = "dn.Tweenie";
dn_Tweenie.prototype = {
	terminate_: function(getter,setter,withCallbacks) {
		if(this.allTweens == null) {
			return;
		}
		var v = getter();
		var _g_arr = this.allTweens;
		var _g_i = 0;
		while(_g_i < _g_arr.nalloc) {
			var t = _g_arr.values[_g_i++];
			if(t.done) {
				continue;
			}
			var old = t.getter();
			t.setter(old + 1);
			if(getter() != v) {
				t.setter(old);
				if(withCallbacks) {
					t.ln = 1;
					t.complete(false);
				} else {
					t.endWithoutCallbacks();
				}
			} else {
				t.setter(old);
			}
		}
	}
	,create_: function(getter,setter,from,to,tp,duration_ms,allowDuplicates) {
		if(allowDuplicates == null) {
			allowDuplicates = false;
		}
		if(duration_ms == null) {
			duration_ms = dn_Tweenie.DEFAULT_DURATION;
		}
		if(!allowDuplicates) {
			this.terminate_(getter,setter,false);
		}
		var t = new dn_Tween(this);
		t.getter = getter;
		t.setter = setter;
		t.from = from == null ? getter() : from;
		t.speed = 1 / (duration_ms * this.baseFps / 1000);
		t.to = to;
		if(tp != null) {
			t.set_type(tp);
		}
		if(from != null) {
			setter(from);
		}
		var _this = this.allTweens;
		if(_this.nalloc >= _this.values.length) {
			throw haxe_Exception.thrown("FixedArray limit reached (" + _this.values.length + ")");
		}
		_this.values[_this.nalloc] = t;
		_this.nalloc++;
		return t;
	}
	,destroy: function() {
		this.allTweens = null;
	}
	,update: function(dt) {
		if(dt == null) {
			dt = 1.0;
		}
		var i = 0;
		while(i < this.allTweens.nalloc) {
			var _this = this.allTweens;
			var t = i < 0 || i >= _this.nalloc ? null : _this.values[i];
			if(t.internalUpdate(dt)) {
				this.allTweens.remove(t);
			} else {
				++i;
			}
		}
	}
	,__class__: dn_Tweenie
};
var dn_data_GetText = function() { };
$hxClasses["dn.data.GetText"] = dn_data_GetText;
dn_data_GetText.__name__ = "dn.data.GetText";
var dn_data_PoEntry = function(rawId,ctx) {
	this.msgid = rawId;
	this.contextDisamb = ctx;
	if(dn_data_GetText.TRANSLATOR_NOTE_REG.match(this.msgid)) {
		this.msgid = this.msgid.replace(dn_data_GetText.TRANSLATOR_NOTE_REG.r,"$3");
		this.translatorNote = dn_data_GetText.TRANSLATOR_NOTE_REG.matched(2);
	}
	if(dn_data_GetText.CONTEXT_DISAMB_REG.match(this.msgid)) {
		this.msgid = this.msgid.replace(dn_data_GetText.CONTEXT_DISAMB_REG.r,"$3");
		this.contextDisamb = dn_data_GetText.CONTEXT_DISAMB_REG.matched(2);
	}
	if(dn_data_GetText.COMMENT_REG.match(this.msgid)) {
		this.msgid = this.msgid.replace(dn_data_GetText.COMMENT_REG.r,"$3");
		this.comment = dn_data_GetText.COMMENT_REG.matched(2);
	}
	if(dn_data_GetText.VERBOSE) {
		dn_Lib.println("    - New entry: " + this.msgid);
	}
};
$hxClasses["dn.data.PoEntry"] = dn_data_PoEntry;
dn_data_PoEntry.__name__ = "dn.data.PoEntry";
dn_data_PoEntry.prototype = {
	toString: function() {
		return this.msgid + (this.contextDisamb == null ? "" : dn_data_GetText.CONTEXT_DISAMB_SEP + this.contextDisamb);
	}
	,__class__: dn_data_PoEntry
};
var dn_heaps_Scaler = function() { };
$hxClasses["dn.heaps.Scaler"] = dn_heaps_Scaler;
dn_heaps_Scaler.__name__ = "dn.heaps.Scaler";
dn_heaps_Scaler.getViewportWidth = function() {
	return hxd_Window.getInstance().get_width();
};
dn_heaps_Scaler.getViewportHeight = function() {
	return hxd_Window.getInstance().get_height();
};
dn_heaps_Scaler.bestFit_f = function(widPx,heiPx,contextWid,contextHei) {
	var sx = (contextWid == null ? dn_heaps_Scaler.getViewportWidth() : contextWid) / widPx;
	var sy = (contextHei == null ? dn_heaps_Scaler.getViewportHeight() : contextHei) / (heiPx == null ? widPx : heiPx);
	var y = sx < sy ? sx : sy;
	if(1 > y) {
		return 1;
	} else {
		return y;
	}
};
var dn_heaps__$Sfx_GlobalGroup = function(id) {
	this.id = id;
	this.volume = 1;
	this.soundGroup = new hxd_snd_SoundGroup("global" + id);
};
$hxClasses["dn.heaps._Sfx.GlobalGroup"] = dn_heaps__$Sfx_GlobalGroup;
dn_heaps__$Sfx_GlobalGroup.__name__ = "dn.heaps._Sfx.GlobalGroup";
dn_heaps__$Sfx_GlobalGroup.prototype = {
	__class__: dn_heaps__$Sfx_GlobalGroup
};
var dn_heaps_filter_OverlayTextureStyle = $hxEnums["dn.heaps.filter.OverlayTextureStyle"] = { __ename__:true,__constructs__:null
	,Classic: {_hx_name:"Classic",_hx_index:0,__enum__:"dn.heaps.filter.OverlayTextureStyle",toString:$estr}
	,Soft: {_hx_name:"Soft",_hx_index:1,__enum__:"dn.heaps.filter.OverlayTextureStyle",toString:$estr}
	,Top: {_hx_name:"Top",_hx_index:2,__enum__:"dn.heaps.filter.OverlayTextureStyle",toString:$estr}
	,Deep: {_hx_name:"Deep",_hx_index:3,__enum__:"dn.heaps.filter.OverlayTextureStyle",toString:$estr}
	,ScanlineLight: {_hx_name:"ScanlineLight",_hx_index:4,__enum__:"dn.heaps.filter.OverlayTextureStyle",toString:$estr}
	,ScanlineDark: {_hx_name:"ScanlineDark",_hx_index:5,__enum__:"dn.heaps.filter.OverlayTextureStyle",toString:$estr}
};
dn_heaps_filter_OverlayTextureStyle.__constructs__ = [dn_heaps_filter_OverlayTextureStyle.Classic,dn_heaps_filter_OverlayTextureStyle.Soft,dn_heaps_filter_OverlayTextureStyle.Top,dn_heaps_filter_OverlayTextureStyle.Deep,dn_heaps_filter_OverlayTextureStyle.ScanlineLight,dn_heaps_filter_OverlayTextureStyle.ScanlineDark];
dn_heaps_filter_OverlayTextureStyle.__empty_constructs__ = [dn_heaps_filter_OverlayTextureStyle.Classic,dn_heaps_filter_OverlayTextureStyle.Soft,dn_heaps_filter_OverlayTextureStyle.Top,dn_heaps_filter_OverlayTextureStyle.Deep,dn_heaps_filter_OverlayTextureStyle.ScanlineLight,dn_heaps_filter_OverlayTextureStyle.ScanlineDark];
var dn_heaps_filter_OverlayTexture = function(style,sizePx) {
	if(sizePx == null) {
		sizePx = 2;
	}
	if(style == null) {
		style = dn_heaps_filter_OverlayTextureStyle.Classic;
	}
	this.invalidated = true;
	this.autoUpdateSize = null;
	h2d_filter_Shader.call(this,new dn_heaps_filter__$OverlayTexture_OverlayBlendShader());
	this.get_shader().alpha__ = 1;
	if(this.textureStyle != style) {
		this.invalidated = true;
	}
	this.textureStyle = style;
	if(this.size != sizePx) {
		this.invalidated = true;
	}
	this.size = sizePx;
};
$hxClasses["dn.heaps.filter.OverlayTexture"] = dn_heaps_filter_OverlayTexture;
dn_heaps_filter_OverlayTexture.__name__ = "dn.heaps.filter.OverlayTexture";
dn_heaps_filter_OverlayTexture.__super__ = h2d_filter_Shader;
dn_heaps_filter_OverlayTexture.prototype = $extend(h2d_filter_Shader.prototype,{
	sync: function(ctx,s) {
		h2d_filter_Shader.prototype.sync.call(this,ctx,s);
		if(!((s) instanceof h2d_Scene)) {
			throw haxe_Exception.thrown("OverlayTextureFilter should only be attached to a 2D Scene");
		}
		if(this.invalidated) {
			this.invalidated = false;
			this.renderTexture(ctx.scene.width,ctx.scene.height);
		}
		if(this.autoUpdateSize != null && this.size != this.autoUpdateSize()) {
			var v = this.autoUpdateSize();
			if(this.size != v) {
				this.invalidated = true;
			}
			this.size = v;
		}
	}
	,renderTexture: function(screenWid,screenHei) {
		if(this.overlayTex != null) {
			this.overlayTex.dispose();
		}
		var bd = new hxd_BitmapData(this.size,this.size);
		bd.clear(-8355712);
		switch(this.textureStyle._hx_index) {
		case 0:
			var _g = 0;
			var _g1 = this.size - 1;
			while(_g < _g1) {
				var x = _g++;
				bd.setPixel(x,0,-1);
				bd.setPixel(x + 1,this.size - 1,-16777216);
			}
			var _g = 0;
			var _g1 = this.size - 1;
			while(_g < _g1) {
				var y = _g++;
				bd.setPixel(0,y,-1);
				bd.setPixel(this.size - 1,y + 1,-13421773);
			}
			break;
		case 1:
			var _g = 0;
			var _g1 = this.size - 1;
			while(_g < _g1) {
				var x = _g++;
				bd.setPixel(x,0,-1);
				bd.setPixel(x + 1,this.size - 1,-10066330);
			}
			var _g = 0;
			var _g1 = this.size - 1;
			while(_g < _g1) {
				var y = _g++;
				bd.setPixel(0,y,-1);
				bd.setPixel(this.size - 1,y + 1,-10066330);
			}
			break;
		case 2:
			var _g = 0;
			var _g1 = this.size - 1;
			while(_g < _g1) {
				var x = _g++;
				bd.setPixel(x,0,-1);
				bd.setPixel(x,this.size - 1,-16777216);
			}
			break;
		case 3:
			var _g = 0;
			var _g1 = this.size - 1;
			while(_g < _g1) {
				var x = _g++;
				bd.setPixel(x,0,-1);
				bd.setPixel(x + 1,this.size - 1,-16777216);
			}
			var _g = 0;
			var _g1 = this.size - 1;
			while(_g < _g1) {
				var y = _g++;
				bd.setPixel(0,y,-1);
				bd.setPixel(this.size - 1,y + 1,-13421773);
			}
			var _g = 1;
			var _g1 = this.size - 1 - 1;
			while(_g < _g1) {
				var x = _g++;
				bd.setPixel(x,1,-1);
				bd.setPixel(x + 1,this.size - 1 - 1,-16777216);
			}
			var _g = 1;
			var _g1 = this.size - 1 - 1;
			while(_g < _g1) {
				var y = _g++;
				bd.setPixel(1,y,-1);
				bd.setPixel(this.size - 1 - 1,y + 1,-13421773);
			}
			break;
		case 4:
			var _g = 0;
			var _g1 = this.size;
			while(_g < _g1) {
				var x = _g++;
				bd.setPixel(x,0,-1);
			}
			break;
		case 5:
			var _g = 0;
			var _g1 = this.size;
			while(_g < _g1) {
				var x = _g++;
				bd.setPixel(x,0,-16777216);
			}
			break;
		}
		this.overlayTex = h3d_mat_Texture.fromBitmap(bd);
		this.overlayTex.set_filter(h3d_mat_Filter.Nearest);
		this.overlayTex.set_wrap(h3d_mat_Wrap.Repeat);
		this.get_shader().overlay__ = this.overlayTex;
		this.get_shader().uvScale__ = new h3d_Vector(screenWid / this.overlayTex.width,screenHei / this.overlayTex.width);
	}
	,__class__: dn_heaps_filter_OverlayTexture
});
var dn_heaps_filter__$OverlayTexture_OverlayBlendShader = function() {
	this.uvScale__ = new h3d_Vector();
	this.alpha__ = 0;
	h3d_shader_ScreenShader.call(this);
};
$hxClasses["dn.heaps.filter._OverlayTexture.OverlayBlendShader"] = dn_heaps_filter__$OverlayTexture_OverlayBlendShader;
dn_heaps_filter__$OverlayTexture_OverlayBlendShader.__name__ = "dn.heaps.filter._OverlayTexture.OverlayBlendShader";
dn_heaps_filter__$OverlayTexture_OverlayBlendShader.__super__ = h3d_shader_ScreenShader;
dn_heaps_filter__$OverlayTexture_OverlayBlendShader.prototype = $extend(h3d_shader_ScreenShader.prototype,{
	get_texture: function() {
		return this.texture__;
	}
	,set_texture: function(_v) {
		return this.texture__ = _v;
	}
	,get_overlay: function() {
		return this.overlay__;
	}
	,set_overlay: function(_v) {
		return this.overlay__ = _v;
	}
	,get_alpha: function() {
		return this.alpha__;
	}
	,set_alpha: function(_v) {
		return this.alpha__ = _v;
	}
	,get_uvScale: function() {
		return this.uvScale__;
	}
	,set_uvScale: function(_v) {
		return this.uvScale__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.texture__;
		case 2:
			return this.overlay__;
		case 3:
			return this.alpha__;
		case 4:
			return this.uvScale__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 3:
			return this.alpha__;
		default:
		}
		return 0.;
	}
	,__class__: dn_heaps_filter__$OverlayTexture_OverlayBlendShader
});
var dn_heaps_filter_PixelOutline = function(color,a,knockOut) {
	if(knockOut == null) {
		knockOut = false;
	}
	if(a == null) {
		a = 1.0;
	}
	if(color == null) {
		color = 0;
	}
	this.extendBounds = true;
	h2d_filter_Shader.call(this,new dn_heaps_filter__$PixelOutline_InternalShader());
	this.color = color;
	var c = this.color;
	var s = 0.00392156862745098;
	this.get_shader().outlineColor__ = new h3d_Vector((c >> 16 & 255) * s,(c >> 8 & 255) * s,(c & 255) * s,(c >>> 24) * s);
	this.get_shader().outlineColor__.w = this.alpha;
	this.alpha = a;
	this.get_shader().outlineColor__.w = a;
	this.smooth = false;
	this.left = true;
	this.get_shader().leftMul__ = 1;
	this.right = true;
	this.get_shader().rightMul__ = 1;
	this.top = true;
	this.get_shader().topMul__ = 1;
	this.bottom = true;
	this.get_shader().bottomMul__ = 1;
	this.knockOut = knockOut;
	this.get_shader().knockOutThreshold__ = this.knockOut ? 0 : 1;
};
$hxClasses["dn.heaps.filter.PixelOutline"] = dn_heaps_filter_PixelOutline;
dn_heaps_filter_PixelOutline.__name__ = "dn.heaps.filter.PixelOutline";
dn_heaps_filter_PixelOutline.__super__ = h2d_filter_Shader;
dn_heaps_filter_PixelOutline.prototype = $extend(h2d_filter_Shader.prototype,{
	sync: function(ctx,s) {
		h2d_filter_Shader.prototype.sync.call(this,ctx,s);
		this.boundsExtend = this.extendBounds ? 1 : 0;
	}
	,draw: function(ctx,t) {
		var _this = this.get_shader().texelSize__;
		var x = 1 / t.width;
		var y = 1 / t.height;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = 0.;
		_this.w = 1.;
		return h2d_filter_Shader.prototype.draw.call(this,ctx,t);
	}
	,__class__: dn_heaps_filter_PixelOutline
});
var dn_heaps_filter__$PixelOutline_InternalShader = function() {
	this.bottomMul__ = 0;
	this.topMul__ = 0;
	this.rightMul__ = 0;
	this.leftMul__ = 0;
	this.knockOutThreshold__ = 0;
	this.outlineColor__ = new h3d_Vector();
	this.texelSize__ = new h3d_Vector();
	h3d_shader_ScreenShader.call(this);
};
$hxClasses["dn.heaps.filter._PixelOutline.InternalShader"] = dn_heaps_filter__$PixelOutline_InternalShader;
dn_heaps_filter__$PixelOutline_InternalShader.__name__ = "dn.heaps.filter._PixelOutline.InternalShader";
dn_heaps_filter__$PixelOutline_InternalShader.__super__ = h3d_shader_ScreenShader;
dn_heaps_filter__$PixelOutline_InternalShader.prototype = $extend(h3d_shader_ScreenShader.prototype,{
	get_texture: function() {
		return this.texture__;
	}
	,set_texture: function(_v) {
		return this.texture__ = _v;
	}
	,get_texelSize: function() {
		return this.texelSize__;
	}
	,set_texelSize: function(_v) {
		return this.texelSize__ = _v;
	}
	,get_outlineColor: function() {
		return this.outlineColor__;
	}
	,set_outlineColor: function(_v) {
		return this.outlineColor__ = _v;
	}
	,get_knockOutThreshold: function() {
		return this.knockOutThreshold__;
	}
	,set_knockOutThreshold: function(_v) {
		return this.knockOutThreshold__ = _v;
	}
	,get_leftMul: function() {
		return this.leftMul__;
	}
	,set_leftMul: function(_v) {
		return this.leftMul__ = _v;
	}
	,get_rightMul: function() {
		return this.rightMul__;
	}
	,set_rightMul: function(_v) {
		return this.rightMul__ = _v;
	}
	,get_topMul: function() {
		return this.topMul__;
	}
	,set_topMul: function(_v) {
		return this.topMul__ = _v;
	}
	,get_bottomMul: function() {
		return this.bottomMul__;
	}
	,set_bottomMul: function(_v) {
		return this.bottomMul__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.texture__;
		case 2:
			return this.texelSize__;
		case 3:
			return this.outlineColor__;
		case 4:
			return this.knockOutThreshold__;
		case 5:
			return this.leftMul__;
		case 6:
			return this.rightMul__;
		case 7:
			return this.topMul__;
		case 8:
			return this.bottomMul__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 4:
			return this.knockOutThreshold__;
		case 5:
			return this.leftMul__;
		case 6:
			return this.rightMul__;
		case 7:
			return this.topMul__;
		case 8:
			return this.bottomMul__;
		default:
		}
		return 0.;
	}
	,__class__: dn_heaps_filter__$PixelOutline_InternalShader
});
var dn_heaps_slib__$AnimManager_AnimInstance = function(s,g) {
	this.reverse = false;
	this.speed = 1.0;
	this.stopOnLastFrame = false;
	this.killAfterPlay = false;
	this.isStateAnim = false;
	this.paused = false;
	this.playDuration = -1.;
	this.plays = 1;
	this.curFrameCpt = 0.0;
	this.animCursor = 0;
	this.frames = [];
	this.spr = s;
	this.group = g;
	var _this = this.spr.lib;
	var k = this.group;
	if(!(k != null && Object.prototype.hasOwnProperty.call(_this.groups.h,k) && _this.groups.h[k].frames.length > 0)) {
		throw haxe_Exception.thrown("unknown group " + this.group);
	}
	var _this = this.spr.lib;
	var k = this.group;
	this.frames = (k == null ? _this.currentGroup : _this.groups.h[k]).anim;
};
$hxClasses["dn.heaps.slib._AnimManager.AnimInstance"] = dn_heaps_slib__$AnimManager_AnimInstance;
dn_heaps_slib__$AnimManager_AnimInstance.__name__ = "dn.heaps.slib._AnimManager.AnimInstance";
dn_heaps_slib__$AnimManager_AnimInstance.prototype = {
	onEnd: function() {
	}
	,onEachLoop: function() {
	}
	,__class__: dn_heaps_slib__$AnimManager_AnimInstance
};
var dn_heaps_slib__$AnimManager_StateAnim = function(g,cb) {
	this.group = g;
	this.priority = 0;
	this.cond = cb;
	this.spd = 1.0;
};
$hxClasses["dn.heaps.slib._AnimManager.StateAnim"] = dn_heaps_slib__$AnimManager_StateAnim;
dn_heaps_slib__$AnimManager_StateAnim.__name__ = "dn.heaps.slib._AnimManager.StateAnim";
dn_heaps_slib__$AnimManager_StateAnim.prototype = {
	__class__: dn_heaps_slib__$AnimManager_StateAnim
};
var dn_heaps_slib__$AnimManager_Transition = function(f,t,a,cb) {
	this.from = f;
	this.to = t;
	this.anim = a;
	this.cond = cb;
	this.spd = 1.0;
	this.reverse = false;
};
$hxClasses["dn.heaps.slib._AnimManager.Transition"] = dn_heaps_slib__$AnimManager_Transition;
dn_heaps_slib__$AnimManager_Transition.__name__ = "dn.heaps.slib._AnimManager.Transition";
dn_heaps_slib__$AnimManager_Transition.prototype = {
	__class__: dn_heaps_slib__$AnimManager_Transition
};
var dn_heaps_slib_AnimManager = function(spr) {
	this.suspendF = 0.;
	this.destroyed = false;
	this.needUpdates = false;
	this.genSpeed = 1.0;
	this.stateAnimsActive = true;
	this.transitions = [];
	this.stateAnims = [];
	this.stack = [];
	this.spr = spr;
};
$hxClasses["dn.heaps.slib.AnimManager"] = dn_heaps_slib_AnimManager;
dn_heaps_slib_AnimManager.__name__ = "dn.heaps.slib.AnimManager";
dn_heaps_slib_AnimManager.prototype = {
	destroy: function() {
		this.destroyed = true;
		this.stopWithoutStateAnims();
		this.needUpdates = false;
		this.stateAnims = null;
		this.stack = null;
		this.spr = null;
	}
	,play: function(group,plays,queueAnim) {
		if(queueAnim == null) {
			queueAnim = false;
		}
		if(plays == null) {
			plays = 1;
		}
		var _this = this.spr.lib;
		var g = group == null ? _this.currentGroup : _this.groups.h[group];
		if(g == null) {
			return this;
		}
		if(g.anim == null || g.anim.length == 0) {
			return this;
		}
		if(!queueAnim && (!this.destroyed && this.stack.length > 0)) {
			this.stack = [];
		}
		var a = new dn_heaps_slib__$AnimManager_AnimInstance(this.spr,group);
		this.stack.push(a);
		a.plays = plays;
		this.needUpdates = true;
		if(!queueAnim) {
			var t = this.getTransition(this.spr.groupName,this.stack[0].group);
			if(t != null && t.anim != this.spr.groupName) {
				var _this = this.spr.lib;
				var k = t.anim;
				if(k != null && Object.prototype.hasOwnProperty.call(_this.groups.h,k) && _this.groups.h[k].frames.length > 0) {
					var a = new dn_heaps_slib__$AnimManager_AnimInstance(this.spr,t.anim);
					this.stack.splice(0,0,a);
					a.speed = t.spd;
					a.reverse = t.reverse;
				}
			}
			var _this = this.stack[0];
			var f = _this.frames[_this.reverse ? _this.frames.length - 1 - _this.animCursor : _this.animCursor];
			if(_this.spr.get_anim().onEnterFrame != null && _this.lastFrame != f) {
				_this.spr.get_anim().onEnterFrame(f);
			}
			if(_this.spr.groupName != _this.group) {
				_this.spr.set(null,_this.group,f);
			} else if(_this.spr.frame != f) {
				_this.spr.setFrame(f);
			}
			_this.lastFrame = f;
		}
		return this;
	}
	,loop: function() {
		if(!this.destroyed && this.stack.length > 0) {
			this.stack[this.stack.length - 1].plays = 999999;
		}
		return this;
	}
	,stopWithStateAnims: function() {
		this.stateAnimsActive = true;
		this.stack = [];
		this.applyStateAnims();
	}
	,stopWithoutStateAnims: function(k,frame) {
		this.stateAnimsActive = false;
		this.stack = [];
		if(k != null) {
			this.spr.set(null,k,frame != null ? frame : 0);
		} else if(frame != null) {
			this.spr.setFrame(frame);
		}
	}
	,unsuspend: function() {
		this.suspendF = 0;
	}
	,getTransition: function(from,to) {
		var _g = 0;
		var _g1 = this.transitions;
		while(_g < _g1.length) {
			var t = _g1[_g];
			++_g;
			if((t.from == dn_heaps_slib_AnimManager.ANYTHING || t.from == from) && (t.to == dn_heaps_slib_AnimManager.ANYTHING || t.to == to) && t.cond()) {
				return t;
			}
		}
		return null;
	}
	,registerStateAnim: function(group,priority,spd,condition) {
		if(spd == null) {
			spd = 1.0;
		}
		if(condition == null) {
			condition = function() {
				return true;
			};
		}
		this.removeStateAnim(group,priority);
		var s = new dn_heaps_slib__$AnimManager_StateAnim(group,condition);
		s.priority = priority;
		s.spd = spd;
		this.stateAnims.push(s);
		this.stateAnims.sort(function(a,b) {
			return -Reflect.compare(a.priority,b.priority);
		});
		this.applyStateAnims();
	}
	,removeStateAnim: function(group,priority) {
		var i = 0;
		while(i < this.stateAnims.length) if(this.stateAnims[i].group == group && this.stateAnims[i].priority == priority) {
			this.stateAnims.splice(i,1);
		} else {
			++i;
		}
	}
	,applyStateAnims: function() {
		if(!this.stateAnimsActive) {
			return;
		}
		if(!this.destroyed && this.stack.length > 0 && !this.stack[0].isStateAnim) {
			return;
		}
		var _g = 0;
		var _g1 = this.stateAnims;
		while(_g < _g1.length) {
			var sa = _g1[_g];
			++_g;
			if(sa.cond()) {
				if(!this.destroyed && this.stack.length > 0 && this.stack[0].group == sa.group) {
					break;
				}
				var _this = this.play(sa.group).loop();
				if(!_this.destroyed && _this.stack.length > 0) {
					_this.stack[_this.stack.length - 1].speed = sa.spd;
				}
				if(!this.destroyed && this.stack.length > 0) {
					this.stack[this.stack.length - 1].isStateAnim = true;
				}
				break;
			}
		}
	}
	,_update: function(dt) {
		if(dn_heaps_slib_SpriteLib.DISABLE_ANIM_UPDATES) {
			return;
		}
		if(this.suspendF > 0) {
			this.suspendF -= dt;
			if(this.suspendF <= 0) {
				this.unsuspend();
			}
			return;
		}
		this.applyStateAnims();
		var a = this.stack[0];
		if(a != null && !a.paused) {
			a.curFrameCpt += dt * this.genSpeed * a.speed;
			if(a.playDuration > 0) {
				a.playDuration -= dt;
				if(a.playDuration <= 0) {
					a.plays = 0;
					a.animCursor = a.frames.length;
					a.curFrameCpt = 1;
				}
			}
			while(a.curFrameCpt > 1) {
				a.curFrameCpt--;
				a.animCursor++;
				if(a.animCursor < a.frames.length) {
					var f = a.frames[a.reverse ? a.frames.length - 1 - a.animCursor : a.animCursor];
					if(a.spr.get_anim().onEnterFrame != null && a.lastFrame != f) {
						a.spr.get_anim().onEnterFrame(f);
					}
					if(a.spr.groupName != a.group) {
						a.spr.set(null,a.group,f);
					} else if(a.spr.frame != f) {
						a.spr.setFrame(f);
					}
					a.lastFrame = f;
					continue;
				}
				a.animCursor = 0;
				a.plays--;
				if(a.plays > 0 || a.playDuration > 0) {
					a.onEachLoop();
					a = this.stack[0];
					var f1 = a.frames[a.reverse ? a.frames.length - 1 - a.animCursor : a.animCursor];
					if(a.spr.get_anim().onEnterFrame != null && a.lastFrame != f1) {
						a.spr.get_anim().onEnterFrame(f1);
					}
					if(a.spr.groupName != a.group) {
						a.spr.set(null,a.group,f1);
					} else if(a.spr.frame != f1) {
						a.spr.setFrame(f1);
					}
					a.lastFrame = f1;
					continue;
				}
				if(a.stopOnLastFrame) {
					this.stopWithoutStateAnims();
				}
				a.onEnd();
				if(a.killAfterPlay) {
					this.spr.remove();
					break;
				}
				if(!this.destroyed && this.stack.length > 0) {
					this.stack.shift();
					if(this.stack.length == 0) {
						this.stopWithStateAnims();
					} else {
						var t = this.getTransition(this.spr.groupName,this.stack[0].group);
						if(t != null && t.anim != this.spr.groupName) {
							var _this = this.spr.lib;
							var k = t.anim;
							if(k != null && Object.prototype.hasOwnProperty.call(_this.groups.h,k) && _this.groups.h[k].frames.length > 0) {
								var a1 = new dn_heaps_slib__$AnimManager_AnimInstance(this.spr,t.anim);
								this.stack.splice(0,0,a1);
								a1.speed = t.spd;
								a1.reverse = t.reverse;
							}
						}
						var _this1 = this.stack[0];
						var f2 = _this1.frames[_this1.reverse ? _this1.frames.length - 1 - _this1.animCursor : _this1.animCursor];
						if(_this1.spr.get_anim().onEnterFrame != null && _this1.lastFrame != f2) {
							_this1.spr.get_anim().onEnterFrame(f2);
						}
						if(_this1.spr.groupName != _this1.group) {
							_this1.spr.set(null,_this1.group,f2);
						} else if(_this1.spr.frame != f2) {
							_this1.spr.setFrame(f2);
						}
						_this1.lastFrame = f2;
					}
					a = this.stack[0];
				}
				if(!(!this.destroyed && this.stack.length > 0)) {
					break;
				}
			}
		}
		if(this.overlap != null && !this.spr.destroyed) {
			this.overlap.curFrameCpt += dt * this.genSpeed * this.overlap.speed;
			while(this.overlap.curFrameCpt > 1) {
				this.overlap.curFrameCpt--;
				this.overlap.animCursor++;
				var _this = this.overlap;
				if(_this.animCursor >= _this.frames.length) {
					this.overlap = null;
					if(this.stack[0] != null) {
						var _this1 = this.stack[0];
						var f = _this1.frames[_this1.reverse ? _this1.frames.length - 1 - _this1.animCursor : _this1.animCursor];
						if(_this1.spr.get_anim().onEnterFrame != null && _this1.lastFrame != f) {
							_this1.spr.get_anim().onEnterFrame(f);
						}
						if(_this1.spr.groupName != _this1.group) {
							_this1.spr.set(null,_this1.group,f);
						} else if(_this1.spr.frame != f) {
							_this1.spr.setFrame(f);
						}
						_this1.lastFrame = f;
					}
					break;
				}
			}
			if(this.overlap != null) {
				var _this = this.overlap;
				var f = _this.frames[_this.reverse ? _this.frames.length - 1 - _this.animCursor : _this.animCursor];
				if(_this.spr.get_anim().onEnterFrame != null && _this.lastFrame != f) {
					_this.spr.get_anim().onEnterFrame(f);
				}
				if(_this.spr.groupName != _this.group) {
					_this.spr.set(null,_this.group,f);
				} else if(_this.spr.frame != f) {
					_this.spr.setFrame(f);
				}
				_this.lastFrame = f;
			}
		}
		if(!this.destroyed && !(!this.destroyed && this.stack.length > 0) && this.overlap == null) {
			this.needUpdates = false;
		}
	}
	,__class__: dn_heaps_slib_AnimManager
};
var h2d_col_Point = function(x,y) {
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.x = x;
	this.y = y;
};
$hxClasses["h2d.col.Point"] = h2d_col_Point;
h2d_col_Point.__name__ = "h2d.col.Point";
h2d_col_Point.prototype = {
	__class__: h2d_col_Point
};
var h2d_Object = function(parent) {
	this.blendMode = h2d_BlendMode.Alpha;
	this.alpha = 1.;
	this.visible = true;
	this.rotation = 0;
	this.scaleY = 1;
	this.scaleX = 1;
	this.y = 0;
	this.x = 0;
	this.matA = 1;
	this.matB = 0;
	this.matC = 0;
	this.matD = 1;
	this.absX = 0;
	this.absY = 0;
	this.posChanged = parent != null;
	this.children = [];
	if(parent != null) {
		parent.addChild(this);
	}
};
$hxClasses["h2d.Object"] = h2d_Object;
h2d_Object.__name__ = "h2d.Object";
h2d_Object.prototype = {
	getBounds: function(relativeTo,out) {
		if(out == null) {
			out = new h2d_col_Bounds();
		} else {
			out.xMin = 1e20;
			out.yMin = 1e20;
			out.xMax = -1e20;
			out.yMax = -1e20;
		}
		if(relativeTo != null) {
			relativeTo.syncPos();
		}
		if(relativeTo != this) {
			this.syncPos();
		}
		this.getBoundsRec(relativeTo,out,false);
		if(out.xMax <= out.xMin || out.yMax <= out.yMin) {
			this.addBounds(relativeTo,out,-1,-1,2,2);
			out.xMax = out.xMin = (out.xMax + out.xMin) * 0.5;
			out.yMax = out.yMin = (out.yMax + out.yMin) * 0.5;
		}
		return out;
	}
	,getAbsPos: function() {
		this.syncPos();
		var m = new h2d_col_Matrix();
		m.a = this.matA;
		m.b = this.matB;
		m.c = this.matC;
		m.d = this.matD;
		m.x = this.absX;
		m.y = this.absY;
		return m;
	}
	,set_filter: function(f) {
		if(this.filter != null && this.allocated) {
			this.filter.unbind(this);
		}
		this.filter = f;
		if(f != null && this.allocated) {
			f.bind(this);
		}
		return f;
	}
	,getBoundsRec: function(relativeTo,out,forSize) {
		if(this.posChanged) {
			this.calcAbsPos();
			var _g = 0;
			var _g1 = this.children;
			while(_g < _g1.length) {
				var c = _g1[_g];
				++_g;
				c.posChanged = true;
			}
			this.posChanged = false;
		}
		var n = this.children.length;
		if(n == 0) {
			out.xMin = 1e20;
			out.yMin = 1e20;
			out.xMax = -1e20;
			out.yMax = -1e20;
			return;
		}
		if(n == 1) {
			var c = this.children[0];
			if(c.visible) {
				c.getBoundsRec(relativeTo,out,forSize);
			} else {
				out.xMin = 1e20;
				out.yMin = 1e20;
				out.xMax = -1e20;
				out.yMax = -1e20;
			}
			return;
		}
		var xmin = Infinity;
		var ymin = Infinity;
		var xmax = -Infinity;
		var ymax = -Infinity;
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			if(!c.visible) {
				continue;
			}
			c.getBoundsRec(relativeTo,out,forSize);
			if(out.xMin < xmin) {
				xmin = out.xMin;
			}
			if(out.yMin < ymin) {
				ymin = out.yMin;
			}
			if(out.xMax > xmax) {
				xmax = out.xMax;
			}
			if(out.yMax > ymax) {
				ymax = out.yMax;
			}
		}
		out.xMin = xmin;
		out.yMin = ymin;
		out.xMax = xmax;
		out.yMax = ymax;
	}
	,addBounds: function(relativeTo,out,dx,dy,width,height) {
		if(width <= 0 || height <= 0) {
			return;
		}
		if(relativeTo == null) {
			var x;
			var y;
			var x = dx * this.matA + dy * this.matC + this.absX;
			var y = dx * this.matB + dy * this.matD + this.absY;
			if(x < out.xMin) {
				out.xMin = x;
			}
			if(x > out.xMax) {
				out.xMax = x;
			}
			if(y < out.yMin) {
				out.yMin = y;
			}
			if(y > out.yMax) {
				out.yMax = y;
			}
			var x = (dx + width) * this.matA + dy * this.matC + this.absX;
			var y = (dx + width) * this.matB + dy * this.matD + this.absY;
			if(x < out.xMin) {
				out.xMin = x;
			}
			if(x > out.xMax) {
				out.xMax = x;
			}
			if(y < out.yMin) {
				out.yMin = y;
			}
			if(y > out.yMax) {
				out.yMax = y;
			}
			var x = dx * this.matA + (dy + height) * this.matC + this.absX;
			var y = dx * this.matB + (dy + height) * this.matD + this.absY;
			if(x < out.xMin) {
				out.xMin = x;
			}
			if(x > out.xMax) {
				out.xMax = x;
			}
			if(y < out.yMin) {
				out.yMin = y;
			}
			if(y > out.yMax) {
				out.yMax = y;
			}
			var x = (dx + width) * this.matA + (dy + height) * this.matC + this.absX;
			var y = (dx + width) * this.matB + (dy + height) * this.matD + this.absY;
			if(x < out.xMin) {
				out.xMin = x;
			}
			if(x > out.xMax) {
				out.xMax = x;
			}
			if(y < out.yMin) {
				out.yMin = y;
			}
			if(y > out.yMax) {
				out.yMax = y;
			}
			return;
		}
		if(relativeTo == this) {
			if(out.xMin > dx) {
				out.xMin = dx;
			}
			if(out.yMin > dy) {
				out.yMin = dy;
			}
			if(out.xMax < dx + width) {
				out.xMax = dx + width;
			}
			if(out.yMax < dy + height) {
				out.yMax = dy + height;
			}
			return;
		}
		var r = relativeTo.matA * relativeTo.matD - relativeTo.matB * relativeTo.matC;
		if(r == 0) {
			return;
		}
		var det = 1 / r;
		var rA = relativeTo.matD * det;
		var rB = -relativeTo.matB * det;
		var rC = -relativeTo.matC * det;
		var rD = relativeTo.matA * det;
		var rX = this.absX - relativeTo.absX;
		var rY = this.absY - relativeTo.absY;
		var x = dx * this.matA + dy * this.matC + rX;
		var y = dx * this.matB + dy * this.matD + rY;
		var x1 = x * rA + y * rC;
		var y1 = x * rB + y * rD;
		if(x1 < out.xMin) {
			out.xMin = x1;
		}
		if(x1 > out.xMax) {
			out.xMax = x1;
		}
		if(y1 < out.yMin) {
			out.yMin = y1;
		}
		if(y1 > out.yMax) {
			out.yMax = y1;
		}
		x = (dx + width) * this.matA + dy * this.matC + rX;
		y = (dx + width) * this.matB + dy * this.matD + rY;
		var x1 = x * rA + y * rC;
		var y1 = x * rB + y * rD;
		if(x1 < out.xMin) {
			out.xMin = x1;
		}
		if(x1 > out.xMax) {
			out.xMax = x1;
		}
		if(y1 < out.yMin) {
			out.yMin = y1;
		}
		if(y1 > out.yMax) {
			out.yMax = y1;
		}
		x = dx * this.matA + (dy + height) * this.matC + rX;
		y = dx * this.matB + (dy + height) * this.matD + rY;
		var x1 = x * rA + y * rC;
		var y1 = x * rB + y * rD;
		if(x1 < out.xMin) {
			out.xMin = x1;
		}
		if(x1 > out.xMax) {
			out.xMax = x1;
		}
		if(y1 < out.yMin) {
			out.yMin = y1;
		}
		if(y1 > out.yMax) {
			out.yMax = y1;
		}
		x = (dx + width) * this.matA + (dy + height) * this.matC + rX;
		y = (dx + width) * this.matB + (dy + height) * this.matD + rY;
		var x1 = x * rA + y * rC;
		var y1 = x * rB + y * rD;
		if(x1 < out.xMin) {
			out.xMin = x1;
		}
		if(x1 > out.xMax) {
			out.xMax = x1;
		}
		if(y1 < out.yMin) {
			out.yMin = y1;
		}
		if(y1 > out.yMax) {
			out.yMax = y1;
		}
	}
	,localToGlobal: function(pt) {
		this.syncPos();
		if(pt == null) {
			pt = new h2d_col_Point();
		}
		var px = pt.x * this.matA + pt.y * this.matC + this.absX;
		var py = pt.x * this.matB + pt.y * this.matD + this.absY;
		pt.x = px;
		pt.y = py;
		return pt;
	}
	,getScene: function() {
		var p = this;
		while(p.parent != null) p = p.parent;
		if(((p) instanceof h2d_Scene)) {
			return p;
		} else {
			return null;
		}
	}
	,set_visible: function(b) {
		if(this.visible == b) {
			return b;
		}
		this.visible = b;
		if(this.parentContainer != null) {
			this.parentContainer.contentChanged(this);
		}
		return b;
	}
	,addChild: function(s) {
		this.addChildAt(s,this.children.length);
	}
	,addChildAt: function(s,pos) {
		if(pos < 0) {
			pos = 0;
		}
		if(pos > this.children.length) {
			pos = this.children.length;
		}
		var p = this;
		while(p != null) {
			if(p == s) {
				throw haxe_Exception.thrown("Recursive addChild");
			}
			p = p.parent;
		}
		if(s.parent != null) {
			var old = s.allocated;
			s.allocated = false;
			s.parent.removeChild(s);
			s.allocated = old;
		}
		this.children.splice(pos,0,s);
		if(!this.allocated && s.allocated) {
			s.onRemove();
		}
		s.parent = this;
		s.parentContainer = this.parentContainer;
		s.posChanged = true;
		if(this.allocated) {
			if(!s.allocated) {
				s.onAdd();
			} else {
				s.onHierarchyMoved(true);
			}
		}
		if(this.parentContainer != null) {
			this.parentContainer.contentChanged(this);
		}
	}
	,onHierarchyMoved: function(parentChanged) {
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			c.onHierarchyMoved(parentChanged);
		}
	}
	,onAdd: function() {
		this.allocated = true;
		if(this.filter != null) {
			this.filter.bind(this);
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			c.onAdd();
		}
	}
	,onRemove: function() {
		this.allocated = false;
		if(this.filter != null) {
			this.filter.unbind(this);
		}
		var i = this.children.length - 1;
		while(i >= 0) {
			var c = this.children[i--];
			if(c != null) {
				c.onRemove();
			}
		}
	}
	,removeChild: function(s) {
		if(HxOverrides.remove(this.children,s)) {
			if(s.allocated) {
				s.onRemove();
			}
			s.parent = null;
			if(s.parentContainer != null) {
				s.setParentContainer(null);
			}
			s.posChanged = true;
			if(this.parentContainer != null) {
				this.parentContainer.contentChanged(this);
			}
		}
	}
	,setParentContainer: function(c) {
		this.parentContainer = c;
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			s.setParentContainer(c);
		}
	}
	,removeChildren: function() {
		while(this.children.length > 0) this.removeChild(this.getChildAt(0));
	}
	,remove: function() {
		if(this.parent != null) {
			this.parent.removeChild(this);
		}
	}
	,drawTo: function(t) {
		var s = this.getScene();
		var needDispose = s == null;
		if(s == null) {
			s = new h2d_Scene();
		}
		s.drawImplTo(this,[t]);
		if(needDispose) {
			s.dispose();
			this.onRemove();
		}
	}
	,draw: function(ctx) {
	}
	,sync: function(ctx) {
		var changed = this.posChanged;
		if(changed) {
			this.calcAbsPos();
			this.posChanged = false;
		}
		this.lastFrame = ctx.frame;
		var p = 0;
		var len = this.children.length;
		while(p < len) {
			var c = this.children[p];
			if(c == null) {
				break;
			}
			if(c.lastFrame != ctx.frame) {
				if(changed) {
					c.posChanged = true;
				}
				c.sync(ctx);
			}
			if(this.children[p] != c) {
				p = 0;
				len = this.children.length;
			} else {
				++p;
			}
		}
	}
	,syncPos: function() {
		if(this.parent != null) {
			this.parent.syncPos();
		}
		if(this.posChanged) {
			this.calcAbsPos();
			var _g = 0;
			var _g1 = this.children;
			while(_g < _g1.length) {
				var c = _g1[_g];
				++_g;
				c.posChanged = true;
			}
			this.posChanged = false;
		}
	}
	,calcAbsPos: function() {
		if(this.parent == null) {
			var cr;
			var sr;
			if(this.rotation == 0) {
				cr = 1.;
				sr = 0.;
				this.matA = this.scaleX;
				this.matB = 0;
				this.matC = 0;
				this.matD = this.scaleY;
			} else {
				cr = Math.cos(this.rotation);
				sr = Math.sin(this.rotation);
				this.matA = this.scaleX * cr;
				this.matB = this.scaleX * sr;
				this.matC = this.scaleY * -sr;
				this.matD = this.scaleY * cr;
			}
			this.absX = this.x;
			this.absY = this.y;
		} else {
			if(this.rotation == 0) {
				this.matA = this.scaleX * this.parent.matA;
				this.matB = this.scaleX * this.parent.matB;
				this.matC = this.scaleY * this.parent.matC;
				this.matD = this.scaleY * this.parent.matD;
			} else {
				var cr = Math.cos(this.rotation);
				var sr = Math.sin(this.rotation);
				var tmpA = this.scaleX * cr;
				var tmpB = this.scaleX * sr;
				var tmpC = this.scaleY * -sr;
				var tmpD = this.scaleY * cr;
				this.matA = tmpA * this.parent.matA + tmpB * this.parent.matC;
				this.matB = tmpA * this.parent.matB + tmpB * this.parent.matD;
				this.matC = tmpC * this.parent.matA + tmpD * this.parent.matC;
				this.matD = tmpC * this.parent.matB + tmpD * this.parent.matD;
			}
			this.absX = this.x * this.parent.matA + this.y * this.parent.matC + this.parent.absX;
			this.absY = this.x * this.parent.matB + this.y * this.parent.matD + this.parent.absY;
		}
	}
	,emitTile: function(ctx,tile) {
		if(h2d_Object.nullDrawable == null) {
			h2d_Object.nullDrawable = new h2d_Drawable(null);
		}
		h2d_Object.nullDrawable.absX = this.absX;
		h2d_Object.nullDrawable.absY = this.absY;
		h2d_Object.nullDrawable.matA = this.matA;
		h2d_Object.nullDrawable.matB = this.matB;
		h2d_Object.nullDrawable.matC = this.matC;
		h2d_Object.nullDrawable.matD = this.matD;
		ctx.drawTile(h2d_Object.nullDrawable,tile);
	}
	,clipBounds: function(ctx,bounds,scaleX,scaleY) {
		if(scaleY == null) {
			scaleY = 1.;
		}
		if(scaleX == null) {
			scaleX = 1.;
		}
		var view = ctx.tmpBounds;
		var matA;
		var matB;
		var matC;
		var matD;
		var absX;
		var absY;
		if(ctx.inFilter != null) {
			var f1 = ctx.baseShader.filterMatrixA__;
			var f2 = ctx.baseShader.filterMatrixB__;
			var tmpA = this.matA * f1.x + this.matB * f1.y;
			var tmpB = this.matA * f2.x + this.matB * f2.y;
			var tmpC = this.matC * f1.x + this.matD * f1.y;
			var tmpD = this.matC * f2.x + this.matD * f2.y;
			var tmpX = this.absX * f1.x + this.absY * f1.y + f1.z;
			var tmpY = this.absX * f2.x + this.absY * f2.y + f2.z;
			matA = (tmpA * ctx.viewA + tmpB * ctx.viewC) / scaleX;
			matB = (tmpA * ctx.viewB + tmpB * ctx.viewD) / scaleY;
			matC = (tmpC * ctx.viewA + tmpD * ctx.viewC) / scaleX;
			matD = (tmpC * ctx.viewB + tmpD * ctx.viewD) / scaleY;
			absX = tmpX * ctx.viewA + tmpY * ctx.viewC + ctx.viewX;
			absY = tmpX * ctx.viewB + tmpY * ctx.viewD + ctx.viewY;
		} else {
			matA = (this.matA * ctx.viewA + this.matB * ctx.viewC) / scaleX;
			matB = (this.matA * ctx.viewB + this.matB * ctx.viewD) / scaleY;
			matC = (this.matC * ctx.viewA + this.matD * ctx.viewC) / scaleX;
			matD = (this.matC * ctx.viewB + this.matD * ctx.viewD) / scaleY;
			absX = this.absX * ctx.viewA + this.absY * ctx.viewC + ctx.viewX;
			absY = this.absX * ctx.viewB + this.absY * ctx.viewD + ctx.viewY;
		}
		view.xMin = 1e20;
		view.yMin = 1e20;
		view.xMax = -1e20;
		view.yMax = -1e20;
		var x = bounds.xMin;
		var y = bounds.yMin;
		var x1 = x * matA + y * matC + absX;
		var y1 = x * matB + y * matD + absY;
		if(x1 < view.xMin) {
			view.xMin = x1;
		}
		if(x1 > view.xMax) {
			view.xMax = x1;
		}
		if(y1 < view.yMin) {
			view.yMin = y1;
		}
		if(y1 > view.yMax) {
			view.yMax = y1;
		}
		var x = bounds.xMax;
		var y = bounds.yMin;
		var x1 = x * matA + y * matC + absX;
		var y1 = x * matB + y * matD + absY;
		if(x1 < view.xMin) {
			view.xMin = x1;
		}
		if(x1 > view.xMax) {
			view.xMax = x1;
		}
		if(y1 < view.yMin) {
			view.yMin = y1;
		}
		if(y1 > view.yMax) {
			view.yMax = y1;
		}
		var x = bounds.xMin;
		var y = bounds.yMax;
		var x1 = x * matA + y * matC + absX;
		var y1 = x * matB + y * matD + absY;
		if(x1 < view.xMin) {
			view.xMin = x1;
		}
		if(x1 > view.xMax) {
			view.xMax = x1;
		}
		if(y1 < view.yMin) {
			view.yMin = y1;
		}
		if(y1 > view.yMax) {
			view.yMax = y1;
		}
		var x = bounds.xMax;
		var y = bounds.yMax;
		var x1 = x * matA + y * matC + absX;
		var y1 = x * matB + y * matD + absY;
		if(x1 < view.xMin) {
			view.xMin = x1;
		}
		if(x1 > view.xMax) {
			view.xMax = x1;
		}
		if(y1 < view.yMin) {
			view.yMin = y1;
		}
		if(y1 > view.yMax) {
			view.yMax = y1;
		}
		if(view.xMin < -1) {
			view.xMin = -1;
		}
		if(view.yMin < -1) {
			view.yMin = -1;
		}
		if(view.xMax > 1) {
			view.xMax = 1;
		}
		if(view.yMax > 1) {
			view.yMax = 1;
		}
		var invDet = 1 / (matA * matD - matB * matC);
		var sxMin = view.xMin;
		var syMin = view.yMin;
		var sxMax = view.xMax;
		var syMax = view.yMax;
		view.xMin = 1e20;
		view.yMin = 1e20;
		view.xMax = -1e20;
		view.yMax = -1e20;
		var x = sxMin;
		var y = syMin;
		x -= absX;
		y -= absY;
		var x1 = (x * matD - y * matC) * invDet;
		var y1 = (-x * matB + y * matA) * invDet;
		if(x1 < view.xMin) {
			view.xMin = x1;
		}
		if(x1 > view.xMax) {
			view.xMax = x1;
		}
		if(y1 < view.yMin) {
			view.yMin = y1;
		}
		if(y1 > view.yMax) {
			view.yMax = y1;
		}
		var x = sxMax;
		var y = syMin;
		x -= absX;
		y -= absY;
		var x1 = (x * matD - y * matC) * invDet;
		var y1 = (-x * matB + y * matA) * invDet;
		if(x1 < view.xMin) {
			view.xMin = x1;
		}
		if(x1 > view.xMax) {
			view.xMax = x1;
		}
		if(y1 < view.yMin) {
			view.yMin = y1;
		}
		if(y1 > view.yMax) {
			view.yMax = y1;
		}
		var x = sxMin;
		var y = syMax;
		x -= absX;
		y -= absY;
		var x1 = (x * matD - y * matC) * invDet;
		var y1 = (-x * matB + y * matA) * invDet;
		if(x1 < view.xMin) {
			view.xMin = x1;
		}
		if(x1 > view.xMax) {
			view.xMax = x1;
		}
		if(y1 < view.yMin) {
			view.yMin = y1;
		}
		if(y1 > view.yMax) {
			view.yMax = y1;
		}
		var x = sxMax;
		var y = syMax;
		x -= absX;
		y -= absY;
		var x1 = (x * matD - y * matC) * invDet;
		var y1 = (-x * matB + y * matA) * invDet;
		if(x1 < view.xMin) {
			view.xMin = x1;
		}
		if(x1 > view.xMax) {
			view.xMax = x1;
		}
		if(y1 < view.yMin) {
			view.yMin = y1;
		}
		if(y1 > view.yMax) {
			view.yMax = y1;
		}
		var a = bounds.xMin;
		var b = view.xMin;
		bounds.xMin = a < b ? b : a;
		var a = bounds.yMin;
		var b = view.yMin;
		bounds.yMin = a < b ? b : a;
		var a = bounds.xMax;
		var b = view.xMax;
		bounds.xMax = a > b ? b : a;
		var a = bounds.yMax;
		var b = view.yMax;
		bounds.yMax = a > b ? b : a;
	}
	,drawFilters: function(ctx) {
		if(!ctx.pushFilter(this)) {
			return;
		}
		var bounds = ctx.tmpBounds;
		var total = new h2d_col_Bounds();
		this.filter.sync(ctx,this);
		var scaleX;
		var scaleY;
		if(this.filter.useScreenResolution) {
			var s = ctx.scene;
			scaleX = s.viewportScaleX * this.filter.resolutionScale;
			scaleY = s.viewportScaleY * this.filter.resolutionScale;
		} else {
			scaleX = this.filter.resolutionScale;
			scaleY = this.filter.resolutionScale;
		}
		if(this.filter.autoBounds) {
			var maxExtent = this.filter.boundsExtend;
			if(maxExtent >= 0) {
				this.getBounds(this,bounds);
				bounds.xMin = bounds.xMin * scaleX - maxExtent;
				bounds.yMin = bounds.yMin * scaleY - maxExtent;
				bounds.xMax = bounds.xMax * scaleX + maxExtent;
				bounds.yMax = bounds.yMax * scaleY + maxExtent;
				if(bounds.xMin < total.xMin) {
					total.xMin = bounds.xMin;
				}
				if(bounds.xMax > total.xMax) {
					total.xMax = bounds.xMax;
				}
				if(bounds.yMin < total.yMin) {
					total.yMin = bounds.yMin;
				}
				if(bounds.yMax > total.yMax) {
					total.yMax = bounds.yMax;
				}
			}
		} else {
			var scale = h2d_Object.tmpPoint;
			var x = scaleX;
			var y = scaleY;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			scale.x = x;
			scale.y = y;
			this.filter.getBounds(this,bounds,scale);
			if(bounds.xMin < total.xMin) {
				total.xMin = bounds.xMin;
			}
			if(bounds.xMax > total.xMax) {
				total.xMax = bounds.xMax;
			}
			if(bounds.yMin < total.yMin) {
				total.yMin = bounds.yMin;
			}
			if(bounds.yMax > total.yMax) {
				total.yMax = bounds.yMax;
			}
			scaleX = scale.x;
			scaleY = scale.y;
		}
		ctx.setFilterScale(scaleX,scaleY);
		this.clipBounds(ctx,total,scaleX,scaleY);
		var xMin = Math.floor(total.xMin + 1e-10);
		var yMin = Math.floor(total.yMin + 1e-10);
		var width = Math.ceil(total.xMax - xMin - 1e-10);
		var height = Math.ceil(total.yMax - yMin - 1e-10);
		if(width <= 0 || height <= 0 || total.xMax < total.xMin) {
			ctx.popFilter();
			return;
		}
		var t = ctx.textures.allocTarget("filterTemp",width,height,false);
		ctx.pushTarget(t,xMin,yMin,width,height);
		ctx.engine.clear(0);
		var oldAlpha = ctx.globalAlpha;
		var shader = ctx.baseShader;
		var _this = shader.filterMatrixA__;
		var x = _this.x;
		var y = _this.y;
		var z = _this.z;
		var w = _this.w;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var oldA_x = x;
		var oldA_y = y;
		var oldA_z = z;
		var oldA_w = w;
		var _this = shader.filterMatrixB__;
		var x = _this.x;
		var y = _this.y;
		var z = _this.z;
		var w = _this.w;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var oldB_x = x;
		var oldB_y = y;
		var oldB_z = z;
		var oldB_w = w;
		var invDet = 1 / (this.matA * this.matD - this.matB * this.matC);
		var invA = this.matD * invDet * scaleX;
		var invB = -this.matB * invDet * scaleY;
		var invC = -this.matC * invDet * scaleX;
		var invD = this.matA * invDet * scaleY;
		var invX = -(this.absX * invA + this.absY * invC);
		var invY = -(this.absX * invB + this.absY * invD);
		var _this = shader.filterMatrixA__;
		var x = invA;
		var y = invC;
		var z = invX;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		_this.w = 1.;
		var _this = shader.filterMatrixB__;
		var x = invB;
		var y = invD;
		var z = invY;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		_this.w = 1.;
		ctx.globalAlpha = 1;
		this.drawContent(ctx);
		var finalTile = h2d_Tile.fromTexture(t);
		finalTile.dx = xMin / scaleX;
		finalTile.dy = yMin / scaleY;
		var prev = finalTile;
		finalTile = this.filter.draw(ctx,finalTile);
		if(finalTile != null) {
			if(finalTile != prev) {
				finalTile.dx = (finalTile.dx + xMin) / scaleX;
				finalTile.dy = (finalTile.dy + yMin) / scaleY;
			}
			finalTile.width /= scaleX;
			finalTile.height /= scaleY;
		}
		var _this = shader.filterMatrixA__;
		_this.x = oldA_x;
		_this.y = oldA_y;
		_this.z = oldA_z;
		_this.w = oldA_w;
		var _this = shader.filterMatrixB__;
		_this.x = oldB_x;
		_this.y = oldB_y;
		_this.z = oldB_z;
		_this.w = oldB_w;
		ctx.popTarget();
		ctx.popFilter();
		ctx.globalAlpha = oldAlpha;
		if(finalTile == null) {
			return;
		}
		this.drawFiltered(ctx,finalTile);
	}
	,drawFiltered: function(ctx,tile) {
		var oldAlpha = ctx.globalAlpha;
		ctx.currentBlend = null;
		ctx.inFilterBlend = this.blendMode;
		ctx.globalAlpha *= this.alpha;
		this.emitTile(ctx,tile);
		ctx.globalAlpha = oldAlpha;
		ctx.inFilterBlend = null;
		ctx.currentBlend = null;
	}
	,drawRec: function(ctx) {
		if(!this.visible) {
			return;
		}
		if(this.posChanged) {
			this.calcAbsPos();
			var _g = 0;
			var _g1 = this.children;
			while(_g < _g1.length) {
				var c = _g1[_g];
				++_g;
				c.posChanged = true;
			}
			this.posChanged = false;
		}
		if(this.filter != null && this.filter.get_enable()) {
			this.drawFilters(ctx);
		} else {
			var old = ctx.globalAlpha;
			ctx.globalAlpha *= this.alpha;
			this.drawContent(ctx);
			ctx.globalAlpha = old;
		}
	}
	,drawContent: function(ctx) {
		if(ctx.front2back) {
			var i = this.children.length;
			while(i-- > 0) this.children[i].drawRec(ctx);
			this.draw(ctx);
		} else {
			this.draw(ctx);
			var _g = 0;
			var _g1 = this.children;
			while(_g < _g1.length) {
				var c = _g1[_g];
				++_g;
				c.drawRec(ctx);
			}
		}
	}
	,getChildAt: function(n) {
		return this.children[n];
	}
	,getChildIndex: function(o) {
		var _g = 0;
		var _g1 = this.children.length;
		while(_g < _g1) {
			var i = _g++;
			if(this.children[i] == o) {
				return i;
			}
		}
		return -1;
	}
	,contentChanged: function(s) {
	}
	,constraintSize: function(maxWidth,maxHeight) {
	}
	,__class__: h2d_Object
};
var h2d_Drawable = function(parent) {
	h2d_Object.call(this,parent);
	this.color = new h3d_Vector(1,1,1,1);
};
$hxClasses["h2d.Drawable"] = h2d_Drawable;
h2d_Drawable.__name__ = "h2d.Drawable";
h2d_Drawable.__super__ = h2d_Object;
h2d_Drawable.prototype = $extend(h2d_Object.prototype,{
	drawFiltered: function(ctx,tile) {
		var old = this.shaders;
		this.shaders = null;
		h2d_Object.prototype.drawFiltered.call(this,ctx,tile);
		this.shaders = old;
	}
	,addShader: function(s) {
		if(s == null) {
			throw haxe_Exception.thrown("Can't add null shader");
		}
		this.shaders = hxsl_ShaderList.addSort(s,this.shaders);
		return s;
	}
	,removeShader: function(s) {
		var prev = null;
		var cur = this.shaders;
		while(cur != null) {
			if(cur.s == s) {
				if(prev == null) {
					this.shaders = cur.next;
				} else {
					prev.next = cur.next;
				}
				return true;
			}
			prev = cur;
			cur = cur.next;
		}
		return false;
	}
	,emitTile: function(ctx,tile) {
		if(tile == null) {
			tile = new h2d_Tile(null,0,0,5,5);
		}
		if(!ctx.drawTile(this,tile)) {
			return;
		}
	}
	,__class__: h2d_Drawable
});
var dn_heaps_slib_SpriteInterface = function() { };
$hxClasses["dn.heaps.slib.SpriteInterface"] = dn_heaps_slib_SpriteInterface;
dn_heaps_slib_SpriteInterface.__name__ = "dn.heaps.slib.SpriteInterface";
dn_heaps_slib_SpriteInterface.__isInterface__ = true;
dn_heaps_slib_SpriteInterface.prototype = {
	__class__: dn_heaps_slib_SpriteInterface
};
var dn_heaps_slib_HSprite = function(l,g,f,parent) {
	if(f == null) {
		f = 0;
	}
	h2d_Drawable.call(this,parent);
	this.destroyed = false;
	this.pivot = new dn_heaps_slib_SpritePivot();
	this.lastPage = -1;
	if(l != null) {
		var frame = f;
		if(frame == null) {
			frame = 0;
		}
		if(l != null) {
			if(l.pages == null || l.pages.length == 0) {
				throw haxe_Exception.thrown("sprite sheet has no backing texture, please generate one");
			}
			if(g == null) {
				this.groupName = null;
				this.group = null;
				this.frameData = null;
			}
			if(this.allocated && this.lib != null) {
				HxOverrides.remove(this.lib.children,this);
			}
			this.lib = l;
			if(this.allocated) {
				this.lib.children.push(this);
			}
			if(this.pivot.isUndefined) {
				var xRatio = this.lib.defaultCenterX;
				var yRatio = this.lib.defaultCenterY;
				if(yRatio == null) {
					yRatio = 0.5;
				}
				if(xRatio == null) {
					xRatio = 0.5;
				}
				var _this = this.pivot;
				_this.centerFactorX = xRatio;
				_this.centerFactorY = yRatio;
				_this.usingFactor = true;
				_this.isUndefined = false;
			}
		}
		if(g != null && g != this.groupName) {
			this.groupName = g;
		}
		if(!this.destroyed && this.lib != null && this.groupName != null) {
			var _this = this.lib;
			var k = this.groupName;
			this.group = k == null ? _this.currentGroup : _this.groups.h[k];
			var _this = this.lib;
			var k = this.groupName;
			var frame1 = frame;
			if(frame1 == null) {
				frame1 = 0;
			}
			var g = k == null ? _this.currentGroup : _this.groups.h[k];
			this.frameData = g == null ? null : g.frames[frame1];
			if(this.frameData == null) {
				throw haxe_Exception.thrown("Unknown frame: " + this.groupName + "(" + frame + ")");
			}
			if(this.rawTile == null) {
				this.rawTile = this.lib.pages[this.frameData.page].clone();
			} else {
				this.rawTile.setTexture(this.lib.pages[this.frameData.page].innerTex);
			}
			this.lastPage = this.frameData.page;
			this.setFrame(frame);
		} else {
			this.setEmptyTexture();
		}
	} else {
		this.setEmptyTexture();
	}
};
$hxClasses["dn.heaps.slib.HSprite"] = dn_heaps_slib_HSprite;
dn_heaps_slib_HSprite.__name__ = "dn.heaps.slib.HSprite";
dn_heaps_slib_HSprite.__interfaces__ = [dn_heaps_slib_SpriteInterface];
dn_heaps_slib_HSprite.__super__ = h2d_Drawable;
dn_heaps_slib_HSprite.prototype = $extend(h2d_Drawable.prototype,{
	toString: function() {
		return "HSprite_" + this.groupName + "[" + this.frame + "]";
	}
	,get_anim: function() {
		if(this._animManager == null) {
			this._animManager = new dn_heaps_slib_AnimManager(this);
			if(this.onAnimManAlloc != null) {
				this.onAnimManAlloc(this._animManager);
			}
		}
		return this._animManager;
	}
	,setEmptyTexture: function() {
		this.rawTile = h2d_Tile.fromColor(0,4,4,0);
	}
	,set: function(l,g,frame,stopAllAnims) {
		if(stopAllAnims == null) {
			stopAllAnims = false;
		}
		if(frame == null) {
			frame = 0;
		}
		if(l != null) {
			if(l.pages == null || l.pages.length == 0) {
				throw haxe_Exception.thrown("sprite sheet has no backing texture, please generate one");
			}
			if(g == null) {
				this.groupName = null;
				this.group = null;
				this.frameData = null;
			}
			if(this.allocated && this.lib != null) {
				HxOverrides.remove(this.lib.children,this);
			}
			this.lib = l;
			if(this.allocated) {
				this.lib.children.push(this);
			}
			if(this.pivot.isUndefined) {
				var xRatio = this.lib.defaultCenterX;
				var yRatio = this.lib.defaultCenterY;
				if(yRatio == null) {
					yRatio = 0.5;
				}
				if(xRatio == null) {
					xRatio = 0.5;
				}
				var _this = this.pivot;
				_this.centerFactorX = xRatio;
				_this.centerFactorY = yRatio;
				_this.usingFactor = true;
				_this.isUndefined = false;
			}
		}
		if(g != null && g != this.groupName) {
			this.groupName = g;
		}
		if(!this.destroyed && this.lib != null && this.groupName != null) {
			if(stopAllAnims && this._animManager != null) {
				if(this._animManager == null) {
					this._animManager = new dn_heaps_slib_AnimManager(this);
					if(this.onAnimManAlloc != null) {
						this.onAnimManAlloc(this._animManager);
					}
				}
				this._animManager.stopWithoutStateAnims();
			}
			var _this = this.lib;
			var k = this.groupName;
			this.group = k == null ? _this.currentGroup : _this.groups.h[k];
			var _this = this.lib;
			var k = this.groupName;
			var frame1 = frame;
			if(frame1 == null) {
				frame1 = 0;
			}
			var g = k == null ? _this.currentGroup : _this.groups.h[k];
			this.frameData = g == null ? null : g.frames[frame1];
			if(this.frameData == null) {
				throw haxe_Exception.thrown("Unknown frame: " + this.groupName + "(" + frame + ")");
			}
			if(this.rawTile == null) {
				this.rawTile = this.lib.pages[this.frameData.page].clone();
			} else {
				this.rawTile.setTexture(this.lib.pages[this.frameData.page].innerTex);
			}
			this.lastPage = this.frameData.page;
			this.setFrame(frame);
		} else {
			this.setEmptyTexture();
		}
	}
	,setFrame: function(f) {
		this.frame = f;
		if(!this.destroyed && this.lib != null && this.groupName != null) {
			var prev = this.frameData;
			var _this = this.lib;
			var k = this.groupName;
			var frame = this.frame;
			if(frame == null) {
				frame = 0;
			}
			var g = k == null ? _this.currentGroup : _this.groups.h[k];
			this.frameData = g == null ? null : g.frames[frame];
			if(this.frameData == null) {
				throw haxe_Exception.thrown("Unknown frame: " + this.groupName + "(" + this.frame + ")");
			}
			if(this.lastFrame != this.frameData.page) {
				this.rawTile.setTexture(this.lib.pages[this.frameData.page].innerTex);
				this.lastPage = this.frameData.page;
			}
			if(this.onFrameChange != null) {
				this.onFrameChange();
			}
		}
	}
	,onAdd: function() {
		h2d_Drawable.prototype.onAdd.call(this);
		this.destroyed = false;
		if(this.lib != null) {
			this.lib.children.push(this);
		}
	}
	,onRemove: function() {
		h2d_Drawable.prototype.onRemove.call(this);
		this.destroyed = true;
		if(this.lib != null) {
			HxOverrides.remove(this.lib.children,this);
		}
		if(this._animManager != null) {
			this._animManager.destroy();
			this._animManager = null;
		}
	}
	,getBoundsRec: function(relativeTo,out,forSize) {
		h2d_Drawable.prototype.getBoundsRec.call(this,relativeTo,out,forSize);
		var tmp;
		if(this.customTile != null) {
			var _this = this.pivot;
			if(!_this.isUndefined && !_this.usingFactor) {
				this.customTile.dx = -(this.pivot.coordX | 0);
				this.customTile.dy = -(this.pivot.coordY | 0);
			} else {
				var _this = this.pivot;
				if(!_this.isUndefined && _this.usingFactor) {
					this.customTile.dx = -(this.customTile.width * this.pivot.centerFactorX | 0);
					this.customTile.dy = -(this.customTile.height * this.pivot.centerFactorY | 0);
				}
			}
			tmp = this.customTile;
		} else if(!this.destroyed && this.lib != null && this.groupName != null) {
			var fd = this.frameData;
			this.rawTile.setPosition(fd.x,fd.y);
			this.rawTile.setSize(fd.wid,fd.hei);
			var _this = this.pivot;
			if(!_this.isUndefined && !_this.usingFactor) {
				this.rawTile.dx = -(this.pivot.coordX + fd.realX | 0);
				this.rawTile.dy = -(this.pivot.coordY + fd.realY | 0);
			} else {
				var _this = this.pivot;
				if(!_this.isUndefined && _this.usingFactor) {
					this.rawTile.dx = -(fd.realWid * this.pivot.centerFactorX + fd.realX | 0);
					this.rawTile.dy = -(fd.realHei * this.pivot.centerFactorY + fd.realY | 0);
				}
			}
			tmp = this.rawTile;
		} else {
			var _this = this.pivot;
			if(!_this.isUndefined && !_this.usingFactor) {
				this.rawTile.dx = -(this.pivot.coordX | 0);
				this.rawTile.dy = -(this.pivot.coordY | 0);
			} else {
				var _this = this.pivot;
				if(!_this.isUndefined && _this.usingFactor) {
					this.rawTile.dx = -(this.rawTile.width * this.pivot.centerFactorX | 0);
					this.rawTile.dy = -(this.rawTile.height * this.pivot.centerFactorY | 0);
				}
			}
			tmp = this.rawTile;
		}
		var tmp1 = tmp.dx;
		var tmp;
		if(this.customTile != null) {
			var _this = this.pivot;
			if(!_this.isUndefined && !_this.usingFactor) {
				this.customTile.dx = -(this.pivot.coordX | 0);
				this.customTile.dy = -(this.pivot.coordY | 0);
			} else {
				var _this = this.pivot;
				if(!_this.isUndefined && _this.usingFactor) {
					this.customTile.dx = -(this.customTile.width * this.pivot.centerFactorX | 0);
					this.customTile.dy = -(this.customTile.height * this.pivot.centerFactorY | 0);
				}
			}
			tmp = this.customTile;
		} else if(!this.destroyed && this.lib != null && this.groupName != null) {
			var fd = this.frameData;
			this.rawTile.setPosition(fd.x,fd.y);
			this.rawTile.setSize(fd.wid,fd.hei);
			var _this = this.pivot;
			if(!_this.isUndefined && !_this.usingFactor) {
				this.rawTile.dx = -(this.pivot.coordX + fd.realX | 0);
				this.rawTile.dy = -(this.pivot.coordY + fd.realY | 0);
			} else {
				var _this = this.pivot;
				if(!_this.isUndefined && _this.usingFactor) {
					this.rawTile.dx = -(fd.realWid * this.pivot.centerFactorX + fd.realX | 0);
					this.rawTile.dy = -(fd.realHei * this.pivot.centerFactorY + fd.realY | 0);
				}
			}
			tmp = this.rawTile;
		} else {
			var _this = this.pivot;
			if(!_this.isUndefined && !_this.usingFactor) {
				this.rawTile.dx = -(this.pivot.coordX | 0);
				this.rawTile.dy = -(this.pivot.coordY | 0);
			} else {
				var _this = this.pivot;
				if(!_this.isUndefined && _this.usingFactor) {
					this.rawTile.dx = -(this.rawTile.width * this.pivot.centerFactorX | 0);
					this.rawTile.dy = -(this.rawTile.height * this.pivot.centerFactorY | 0);
				}
			}
			tmp = this.rawTile;
		}
		var tmp2 = tmp.dy;
		var tmp;
		if(this.customTile != null) {
			var _this = this.pivot;
			if(!_this.isUndefined && !_this.usingFactor) {
				this.customTile.dx = -(this.pivot.coordX | 0);
				this.customTile.dy = -(this.pivot.coordY | 0);
			} else {
				var _this = this.pivot;
				if(!_this.isUndefined && _this.usingFactor) {
					this.customTile.dx = -(this.customTile.width * this.pivot.centerFactorX | 0);
					this.customTile.dy = -(this.customTile.height * this.pivot.centerFactorY | 0);
				}
			}
			tmp = this.customTile;
		} else if(!this.destroyed && this.lib != null && this.groupName != null) {
			var fd = this.frameData;
			this.rawTile.setPosition(fd.x,fd.y);
			this.rawTile.setSize(fd.wid,fd.hei);
			var _this = this.pivot;
			if(!_this.isUndefined && !_this.usingFactor) {
				this.rawTile.dx = -(this.pivot.coordX + fd.realX | 0);
				this.rawTile.dy = -(this.pivot.coordY + fd.realY | 0);
			} else {
				var _this = this.pivot;
				if(!_this.isUndefined && _this.usingFactor) {
					this.rawTile.dx = -(fd.realWid * this.pivot.centerFactorX + fd.realX | 0);
					this.rawTile.dy = -(fd.realHei * this.pivot.centerFactorY + fd.realY | 0);
				}
			}
			tmp = this.rawTile;
		} else {
			var _this = this.pivot;
			if(!_this.isUndefined && !_this.usingFactor) {
				this.rawTile.dx = -(this.pivot.coordX | 0);
				this.rawTile.dy = -(this.pivot.coordY | 0);
			} else {
				var _this = this.pivot;
				if(!_this.isUndefined && _this.usingFactor) {
					this.rawTile.dx = -(this.rawTile.width * this.pivot.centerFactorX | 0);
					this.rawTile.dy = -(this.rawTile.height * this.pivot.centerFactorY | 0);
				}
			}
			tmp = this.rawTile;
		}
		var tmp3 = tmp.width;
		var tmp;
		if(this.customTile != null) {
			var _this = this.pivot;
			if(!_this.isUndefined && !_this.usingFactor) {
				this.customTile.dx = -(this.pivot.coordX | 0);
				this.customTile.dy = -(this.pivot.coordY | 0);
			} else {
				var _this = this.pivot;
				if(!_this.isUndefined && _this.usingFactor) {
					this.customTile.dx = -(this.customTile.width * this.pivot.centerFactorX | 0);
					this.customTile.dy = -(this.customTile.height * this.pivot.centerFactorY | 0);
				}
			}
			tmp = this.customTile;
		} else if(!this.destroyed && this.lib != null && this.groupName != null) {
			var fd = this.frameData;
			this.rawTile.setPosition(fd.x,fd.y);
			this.rawTile.setSize(fd.wid,fd.hei);
			var _this = this.pivot;
			if(!_this.isUndefined && !_this.usingFactor) {
				this.rawTile.dx = -(this.pivot.coordX + fd.realX | 0);
				this.rawTile.dy = -(this.pivot.coordY + fd.realY | 0);
			} else {
				var _this = this.pivot;
				if(!_this.isUndefined && _this.usingFactor) {
					this.rawTile.dx = -(fd.realWid * this.pivot.centerFactorX + fd.realX | 0);
					this.rawTile.dy = -(fd.realHei * this.pivot.centerFactorY + fd.realY | 0);
				}
			}
			tmp = this.rawTile;
		} else {
			var _this = this.pivot;
			if(!_this.isUndefined && !_this.usingFactor) {
				this.rawTile.dx = -(this.pivot.coordX | 0);
				this.rawTile.dy = -(this.pivot.coordY | 0);
			} else {
				var _this = this.pivot;
				if(!_this.isUndefined && _this.usingFactor) {
					this.rawTile.dx = -(this.rawTile.width * this.pivot.centerFactorX | 0);
					this.rawTile.dy = -(this.rawTile.height * this.pivot.centerFactorY | 0);
				}
			}
			tmp = this.rawTile;
		}
		this.addBounds(relativeTo,out,tmp1,tmp2,tmp3,tmp.height);
	}
	,draw: function(ctx) {
		var tmp;
		if(this.customTile != null) {
			var _this = this.pivot;
			if(!_this.isUndefined && !_this.usingFactor) {
				this.customTile.dx = -(this.pivot.coordX | 0);
				this.customTile.dy = -(this.pivot.coordY | 0);
			} else {
				var _this = this.pivot;
				if(!_this.isUndefined && _this.usingFactor) {
					this.customTile.dx = -(this.customTile.width * this.pivot.centerFactorX | 0);
					this.customTile.dy = -(this.customTile.height * this.pivot.centerFactorY | 0);
				}
			}
			tmp = this.customTile;
		} else if(!this.destroyed && this.lib != null && this.groupName != null) {
			var fd = this.frameData;
			this.rawTile.setPosition(fd.x,fd.y);
			this.rawTile.setSize(fd.wid,fd.hei);
			var _this = this.pivot;
			if(!_this.isUndefined && !_this.usingFactor) {
				this.rawTile.dx = -(this.pivot.coordX + fd.realX | 0);
				this.rawTile.dy = -(this.pivot.coordY + fd.realY | 0);
			} else {
				var _this = this.pivot;
				if(!_this.isUndefined && _this.usingFactor) {
					this.rawTile.dx = -(fd.realWid * this.pivot.centerFactorX + fd.realX | 0);
					this.rawTile.dy = -(fd.realHei * this.pivot.centerFactorY + fd.realY | 0);
				}
			}
			tmp = this.rawTile;
		} else {
			var _this = this.pivot;
			if(!_this.isUndefined && !_this.usingFactor) {
				this.rawTile.dx = -(this.pivot.coordX | 0);
				this.rawTile.dy = -(this.pivot.coordY | 0);
			} else {
				var _this = this.pivot;
				if(!_this.isUndefined && _this.usingFactor) {
					this.rawTile.dx = -(this.rawTile.width * this.pivot.centerFactorX | 0);
					this.rawTile.dy = -(this.rawTile.height * this.pivot.centerFactorY | 0);
				}
			}
			tmp = this.rawTile;
		}
		this.emitTile(ctx,tmp);
	}
	,sync: function(ctx) {
		h2d_Drawable.prototype.sync.call(this,ctx);
		if(this._animManager != null) {
			if(this._animManager == null) {
				this._animManager = new dn_heaps_slib_AnimManager(this);
				if(this.onAnimManAlloc != null) {
					this.onAnimManAlloc(this._animManager);
				}
			}
			var _this = this._animManager;
			if(_this.needUpdates) {
				_this._update(this.lib != null ? this.lib.tmod : 1);
			}
		}
	}
	,__class__: dn_heaps_slib_HSprite
});
var dn_heaps_slib_FrameData = function(page,x,y,wid,hei,realX,realY,realWid,realHei,tile) {
	this.page = page;
	this.x = x;
	this.y = y;
	this.wid = wid;
	this.hei = hei;
	this.realX = realX;
	this.realY = realY;
	this.realWid = realWid;
	this.realHei = realHei;
	this.tile = tile;
};
$hxClasses["dn.heaps.slib.FrameData"] = dn_heaps_slib_FrameData;
dn_heaps_slib_FrameData.__name__ = "dn.heaps.slib.FrameData";
dn_heaps_slib_FrameData.prototype = {
	toString: function() {
		return "P." + this.page + " " + this.x + "," + this.y + " " + this.wid + " x " + this.hei + " (real: " + this.realX + "," + this.realY + " " + this.realWid + " x " + this.realHei + ")";
	}
	,__class__: dn_heaps_slib_FrameData
};
var dn_heaps_slib_LibGroup = function(id,maxWid,maxHei,frames,anim) {
	this.id = id;
	this.maxWid = maxWid;
	this.maxHei = maxHei;
	this.frames = frames;
	this.anim = anim;
};
$hxClasses["dn.heaps.slib.LibGroup"] = dn_heaps_slib_LibGroup;
dn_heaps_slib_LibGroup.__name__ = "dn.heaps.slib.LibGroup";
dn_heaps_slib_LibGroup.prototype = {
	__class__: dn_heaps_slib_LibGroup
};
var dn_heaps_slib_SLBError = $hxEnums["dn.heaps.slib.SLBError"] = { __ename__:true,__constructs__:null
	,NoGroupSelected: {_hx_name:"NoGroupSelected",_hx_index:0,__enum__:"dn.heaps.slib.SLBError",toString:$estr}
	,GroupAlreadyExists: ($_=function(g) { return {_hx_index:1,g:g,__enum__:"dn.heaps.slib.SLBError",toString:$estr}; },$_._hx_name="GroupAlreadyExists",$_.__params__ = ["g"],$_)
	,InvalidFrameDuration: ($_=function(s) { return {_hx_index:2,s:s,__enum__:"dn.heaps.slib.SLBError",toString:$estr}; },$_._hx_name="InvalidFrameDuration",$_.__params__ = ["s"],$_)
	,EndFrameLower: ($_=function(s) { return {_hx_index:3,s:s,__enum__:"dn.heaps.slib.SLBError",toString:$estr}; },$_._hx_name="EndFrameLower",$_.__params__ = ["s"],$_)
	,InvalidFrames: ($_=function(s) { return {_hx_index:4,s:s,__enum__:"dn.heaps.slib.SLBError",toString:$estr}; },$_._hx_name="InvalidFrames",$_.__params__ = ["s"],$_)
	,NoCurrentGroup: {_hx_name:"NoCurrentGroup",_hx_index:5,__enum__:"dn.heaps.slib.SLBError",toString:$estr}
	,AnimFrameExceeds: ($_=function(id,anim,frame) { return {_hx_index:6,id:id,anim:anim,frame:frame,__enum__:"dn.heaps.slib.SLBError",toString:$estr}; },$_._hx_name="AnimFrameExceeds",$_.__params__ = ["id","anim","frame"],$_)
	,AssetImportFailed: ($_=function(e) { return {_hx_index:7,e:e,__enum__:"dn.heaps.slib.SLBError",toString:$estr}; },$_._hx_name="AssetImportFailed",$_.__params__ = ["e"],$_)
	,NotSameSLBFromBatch: {_hx_name:"NotSameSLBFromBatch",_hx_index:8,__enum__:"dn.heaps.slib.SLBError",toString:$estr}
};
dn_heaps_slib_SLBError.__constructs__ = [dn_heaps_slib_SLBError.NoGroupSelected,dn_heaps_slib_SLBError.GroupAlreadyExists,dn_heaps_slib_SLBError.InvalidFrameDuration,dn_heaps_slib_SLBError.EndFrameLower,dn_heaps_slib_SLBError.InvalidFrames,dn_heaps_slib_SLBError.NoCurrentGroup,dn_heaps_slib_SLBError.AnimFrameExceeds,dn_heaps_slib_SLBError.AssetImportFailed,dn_heaps_slib_SLBError.NotSameSLBFromBatch];
dn_heaps_slib_SLBError.__empty_constructs__ = [dn_heaps_slib_SLBError.NoGroupSelected,dn_heaps_slib_SLBError.NoCurrentGroup,dn_heaps_slib_SLBError.NotSameSLBFromBatch];
var dn_heaps_slib_SpriteLib = function(pages,normalPages) {
	this.tmod = 1.0;
	this.groups = new haxe_ds_StringMap();
	this.defaultCenterX = 0;
	this.defaultCenterY = 0;
	this.gridX = this.gridY = 16;
	this.children = [];
	this.pages = pages;
	this.normalPages = normalPages;
};
$hxClasses["dn.heaps.slib.SpriteLib"] = dn_heaps_slib_SpriteLib;
dn_heaps_slib_SpriteLib.__name__ = "dn.heaps.slib.SpriteLib";
dn_heaps_slib_SpriteLib.prototype = {
	createGroup: function(k) {
		if(Object.prototype.hasOwnProperty.call(this.groups.h,k)) {
			throw haxe_Exception.thrown(dn_heaps_slib_SLBError.GroupAlreadyExists(k));
		}
		var this1 = this.groups;
		var value = new dn_heaps_slib_LibGroup(k,0,0,[],[]);
		this1.h[k] = value;
		this.currentGroup = k == null ? this.currentGroup : this.groups.h[k];
		var k = null;
		if(k == null) {
			return this.currentGroup;
		} else {
			return this.groups.h[k];
		}
	}
	,slice: function(groupName,page,x,y,wid,hei,repeatX,repeatY) {
		if(repeatY == null) {
			repeatY = 1;
		}
		if(repeatX == null) {
			repeatX = 1;
		}
		var g = this.createGroup(groupName);
		this.currentGroup = groupName == null ? this.currentGroup : this.groups.h[groupName];
		var k = null;
		var tmp = k == null;
		var x1 = g.maxWid;
		g.maxWid = x1 > wid ? x1 : wid;
		var x1 = g.maxHei;
		g.maxHei = x1 > hei ? x1 : hei;
		var _g = 0;
		var _g1 = repeatY;
		while(_g < _g1) {
			var iy = _g++;
			var _g2 = 0;
			var _g3 = repeatX;
			while(_g2 < _g3) {
				var ix = _g2++;
				g.frames.push(new dn_heaps_slib_FrameData(page,x + ix * wid,y + iy * hei,wid,hei,0,0,wid,hei,null));
			}
		}
	}
	,sliceGrid: function(groupName,page,gx,gy,repeatX,repeatY) {
		if(repeatY == null) {
			repeatY = 1;
		}
		if(repeatX == null) {
			repeatX = 1;
		}
		var g = this.createGroup(groupName);
		this.currentGroup = groupName == null ? this.currentGroup : this.groups.h[groupName];
		var k = null;
		var tmp = k == null;
		var x = g.maxWid;
		var y = this.gridX;
		g.maxWid = x > y ? x : y;
		var x = g.maxHei;
		var y = this.gridY;
		g.maxHei = x > y ? x : y;
		var _g = 0;
		var _g1 = repeatY;
		while(_g < _g1) {
			var iy = _g++;
			var _g2 = 0;
			var _g3 = repeatX;
			while(_g2 < _g3) {
				var ix = _g2++;
				g.frames.push(new dn_heaps_slib_FrameData(page,this.gridX * (gx + ix),this.gridY * (gy + iy),this.gridX,this.gridY,0,0,this.gridX,this.gridY,null));
			}
		}
	}
	,sliceAnimGrid: function(groupName,page,frameDuration,gx,gy,repeatX,repeatY) {
		if(repeatY == null) {
			repeatY = 1;
		}
		if(repeatX == null) {
			repeatX = 1;
		}
		this.sliceGrid(groupName,page,gx,gy,repeatX,repeatY);
		var frames = [];
		var _g = 0;
		var _g1 = repeatX * repeatY;
		while(_g < _g1) {
			var f = _g++;
			var _g2 = 0;
			var _g3 = frameDuration;
			while(_g2 < _g3) {
				var i = _g2++;
				frames.push(f);
			}
		}
		this.__defineAnim(groupName,frames);
	}
	,toString: function() {
		var l = [];
		var h = this.groups.h;
		var k_h = h;
		var k_keys = Object.keys(h);
		var k_length = k_keys.length;
		var k_current = 0;
		while(k_current < k_length) {
			var k = k_keys[k_current++];
			var g = k == null ? this.currentGroup : this.groups.h[k];
			l.push(k + " (" + g.maxWid + "x" + g.maxHei + ")" + (g.frames.length > 1 ? " " + g.frames.length + "f" : "") + (g.anim.length > 1 ? " animated(" + g.anim.length + "f)" : ""));
		}
		l.sort(function(a,b) {
			return Reflect.compare(a,b);
		});
		return "| " + l.join("\n| ");
	}
	,__defineAnim: function(group,anim) {
		if(this.currentGroup == null && group == null) {
			throw haxe_Exception.thrown(dn_heaps_slib_SLBError.NoCurrentGroup);
		}
		if(group != null) {
			this.currentGroup = group == null ? this.currentGroup : this.groups.h[group];
			var k = null;
			var tmp = k == null;
		}
		var _g = 0;
		while(_g < anim.length) {
			var f = anim[_g];
			++_g;
			if(f >= this.currentGroup.frames.length) {
				throw haxe_Exception.thrown(dn_heaps_slib_SLBError.AnimFrameExceeds(this.currentGroup.id,"[" + anim.join(",") + "] " + this.currentGroup.frames.length,f));
			}
		}
		this.currentGroup.anim = anim;
	}
	,__class__: dn_heaps_slib_SpriteLib
};
var dn_heaps_slib_SpritePivot = function() {
	this.isUndefined = true;
};
$hxClasses["dn.heaps.slib.SpritePivot"] = dn_heaps_slib_SpritePivot;
dn_heaps_slib_SpritePivot.__name__ = "dn.heaps.slib.SpritePivot";
dn_heaps_slib_SpritePivot.prototype = {
	__class__: dn_heaps_slib_SpritePivot
};
var dn_legacy_Mode = $hxEnums["dn.legacy.Mode"] = { __ename__:true,__constructs__:null
	,Keyboard: {_hx_name:"Keyboard",_hx_index:0,__enum__:"dn.legacy.Mode",toString:$estr}
	,Pad: {_hx_name:"Pad",_hx_index:1,__enum__:"dn.legacy.Mode",toString:$estr}
};
dn_legacy_Mode.__constructs__ = [dn_legacy_Mode.Keyboard,dn_legacy_Mode.Pad];
dn_legacy_Mode.__empty_constructs__ = [dn_legacy_Mode.Keyboard,dn_legacy_Mode.Pad];
var dn_legacy_Controller = function(s2d) {
	this.hasAnyPress = false;
	this.longPressLock = new haxe_ds_IntMap();
	var this1 = new Array(28);
	this.framePresses = this1;
	var this1 = new Array(28);
	this.pressTimers = this1;
	this.fourth = new haxe_ds_IntMap();
	this.third = new haxe_ds_IntMap();
	this.secondary = new haxe_ds_IntMap();
	this.primary = new haxe_ds_IntMap();
	this.allowAutoSwitch = true;
	this.suspendTimer = 0.;
	this.exclusiveId = null;
	this.mode = dn_legacy_Mode.Keyboard;
	var _gthis = this;
	dn_legacy_Controller.ALL.push(this);
	this.gc = new dn_legacy_GamePad(0.4);
	s2d.addEventListener(function(e) {
		if(_gthis.allowAutoSwitch && (e.kind == hxd_EventKind.EMove || e.kind == hxd_EventKind.EKeyDown) && _gthis.mode != dn_legacy_Mode.Keyboard) {
			_gthis.mode = dn_legacy_Mode.Keyboard;
		}
	});
	var _g = 0;
	var _g1 = this.pressTimers.length;
	while(_g < _g1) {
		var idx = _g++;
		this.pressTimers[idx] = -1;
	}
	var _g = 0;
	var _g1 = this.framePresses.length;
	while(_g < _g1) {
		var idx = _g++;
		this.framePresses[idx] = -1;
	}
};
$hxClasses["dn.legacy.Controller"] = dn_legacy_Controller;
dn_legacy_Controller.__name__ = "dn.legacy.Controller";
dn_legacy_Controller.beforeUpdate = function() {
	dn_legacy_GamePad.update();
	var _g = 0;
	var _g1 = dn_legacy_Controller.ALL;
	while(_g < _g1.length) {
		var c = _g1[_g];
		++_g;
		if(c.gc != null) {
			var tmp;
			if(c.allowAutoSwitch && c.mode != dn_legacy_Mode.Pad) {
				var tmp1;
				var tmp2;
				var tmp3;
				var tmp4;
				var tmp5;
				var tmp6;
				var _this = c.gc;
				if(!(_this.device != null && _this.toggles[0] > 0)) {
					var _this1 = c.gc;
					tmp6 = _this1.device != null && _this1.toggles[1] > 0;
				} else {
					tmp6 = true;
				}
				if(!tmp6) {
					var _this2 = c.gc;
					tmp5 = _this2.device != null && _this2.toggles[2] > 0;
				} else {
					tmp5 = true;
				}
				if(!tmp5) {
					var _this3 = c.gc;
					tmp4 = _this3.device != null && _this3.toggles[3] > 0;
				} else {
					tmp4 = true;
				}
				if(!tmp4) {
					var _this4 = c.gc;
					var x;
					if(_this4.device != null) {
						var idx = dn_legacy_GamePad.MAPPING[18];
						var overrideDeadZone = -1.;
						if(overrideDeadZone == null) {
							overrideDeadZone = -1.;
						}
						var v = idx > -1 && idx < _this4.device.values.length ? _this4.device.values[idx] : 0;
						var dz = overrideDeadZone < 0. ? _this4.deadZone : overrideDeadZone;
						x = v > -dz && v < dz ? 0. : v;
					} else {
						x = 0.;
					}
					tmp3 = (x < 0 ? -x : x) >= 0.75;
				} else {
					tmp3 = true;
				}
				if(!tmp3) {
					var _this5 = c.gc;
					var x1;
					if(_this5.device != null) {
						var idx1 = dn_legacy_GamePad.MAPPING[21];
						var overrideDeadZone1 = -1.;
						if(overrideDeadZone1 == null) {
							overrideDeadZone1 = -1.;
						}
						var v1 = idx1 > -1 && idx1 < _this5.device.values.length ? _this5.device.values[idx1] : 0;
						var dz1 = overrideDeadZone1 < 0. ? _this5.deadZone : overrideDeadZone1;
						x1 = v1 > -dz1 && v1 < dz1 ? 0. : v1;
					} else {
						x1 = 0.;
					}
					tmp2 = (x1 < 0 ? -x1 : x1) >= 0.75;
				} else {
					tmp2 = true;
				}
				if(!tmp2) {
					var _this6 = c.gc;
					var x2;
					if(_this6.device != null) {
						var idx2 = dn_legacy_GamePad.MAPPING[24];
						var overrideDeadZone2 = -1.;
						if(overrideDeadZone2 == null) {
							overrideDeadZone2 = -1.;
						}
						var v2 = idx2 > -1 && idx2 < _this6.device.values.length ? _this6.device.values[idx2] : 0;
						var dz2 = overrideDeadZone2 < 0. ? _this6.deadZone : overrideDeadZone2;
						x2 = v2 > -dz2 && v2 < dz2 ? 0. : v2;
					} else {
						x2 = 0.;
					}
					tmp1 = (x2 < 0 ? -x2 : x2) >= 0.75;
				} else {
					tmp1 = true;
				}
				if(!tmp1) {
					var _this7 = c.gc;
					var x3;
					if(_this7.device != null) {
						var idx3 = dn_legacy_GamePad.MAPPING[27];
						var overrideDeadZone3 = -1.;
						if(overrideDeadZone3 == null) {
							overrideDeadZone3 = -1.;
						}
						var v3 = idx3 > -1 && idx3 < _this7.device.values.length ? _this7.device.values[idx3] : 0;
						var dz3 = overrideDeadZone3 < 0. ? _this7.deadZone : overrideDeadZone3;
						x3 = v3 > -dz3 && v3 < dz3 ? 0. : v3;
					} else {
						x3 = 0.;
					}
					tmp = (x3 < 0 ? -x3 : x3) >= 0.75;
				} else {
					tmp = true;
				}
			} else {
				tmp = false;
			}
			if(tmp) {
				c.mode = dn_legacy_Mode.Pad;
			}
			if(c.hasAnyPress) {
				c.hasAnyPress = false;
				var _g2 = 0;
				var _g3 = c.framePresses.length;
				while(_g2 < _g3) {
					var idx4 = _g2++;
					c.framePresses[idx4] = -1;
				}
			}
			c.updateLongPress(0);
			c.updateLongPress(1);
			c.updateLongPress(2);
			c.updateLongPress(3);
			c.updateLongPress(5);
			c.updateLongPress(13);
		}
	}
};
dn_legacy_Controller.prototype = {
	createAccess: function(id,exclusive) {
		if(exclusive == null) {
			exclusive = false;
		}
		return new dn_legacy_ControllerAccess(this,id,exclusive);
	}
	,updateLongPress: function(k) {
		var idx = k;
		var _this = this.gc;
		if(_this.device != null && _this.toggles[k] > 0 || hxd_Key.isDown(this.primary.h[k]) || hxd_Key.isDown(this.secondary.h[k]) || hxd_Key.isDown(this.third.h[k]) || hxd_Key.isDown(this.fourth.h[k])) {
			if(this.pressTimers[idx] == -1) {
				this.pressTimers[idx] = HxOverrides.now() / 1000;
			}
			if(HxOverrides.now() / 1000 - this.pressTimers[idx] >= dn_legacy_Controller.LONG_PRESS) {
				if(!this.longPressLock.h.hasOwnProperty(idx)) {
					this.framePresses[idx] = 2;
					this.hasAnyPress = true;
					this.longPressLock.h[idx] = true;
				}
			}
		} else {
			if(this.longPressLock.h.hasOwnProperty(idx)) {
				this.longPressLock.remove(idx);
			}
			if(this.pressTimers[idx] != -1) {
				if(this.framePresses[idx] < 0) {
					if(HxOverrides.now() / 1000 - this.pressTimers[idx] <= dn_legacy_Controller.SHORT_PRESS) {
						this.hasAnyPress = true;
						this.framePresses[idx] = 1;
					}
				}
				this.pressTimers[idx] = -1;
			}
		}
	}
	,__class__: dn_legacy_Controller
};
var dn_legacy_ControllerAccess = function(parent,id,exclusive) {
	if(exclusive == null) {
		exclusive = false;
	}
	this.parent = parent;
	this.id = id + dn_legacy_Controller.UNIQ_ID++;
	var sec = 0.1;
	if(sec == null) {
		sec = 0.07;
	}
	parent.suspendTimer = HxOverrides.now() / 1000 + sec;
	if(exclusive) {
		this.parent.exclusiveId = this.id;
	}
};
$hxClasses["dn.legacy.ControllerAccess"] = dn_legacy_ControllerAccess;
dn_legacy_ControllerAccess.__name__ = "dn.legacy.ControllerAccess";
dn_legacy_ControllerAccess.prototype = {
	__class__: dn_legacy_ControllerAccess
};
var hxd_Pad = function() {
	this.rawRYAxis = 0.;
	this.rawRXAxis = 0.;
	this.rawYAxis = 0.;
	this.rawXAxis = 0.;
	this.prevButtons = [];
	this.values = [];
	this.buttons = [];
	this.config = hxd_Pad.DEFAULT_CONFIG;
	this.index = -1;
	this.connected = true;
};
$hxClasses["hxd.Pad"] = hxd_Pad;
hxd_Pad.__name__ = "hxd.Pad";
hxd_Pad.pickConfig = function(name) {
	switch(name) {
	case "054c-05c4-Wireless Controller":case "054c-09cc-Wireless Controller":
		return hxd_Pad.CONFIG_JS_DS4_FF;
	case "Wireless Controller (STANDARD GAMEPAD Vendor: 054c Product: 05c4)":case "Wireless Controller (STANDARD GAMEPAD Vendor: 054c Product: 09cc)":
		return hxd_Pad.CONFIG_JS_DS4;
	default:
		return hxd_Pad.CONFIG_JS_STD;
	}
};
hxd_Pad.wait = function(onPad) {
	if(!js_Browser.get_supported()) {
		return;
	}
	hxd_Pad.waitPad = onPad;
	if(!hxd_Pad.initDone) {
		hxd_Pad.initDone = true;
		window.addEventListener("gamepadconnected",function(p) {
			var pad = new hxd_Pad();
			pad.d = p.gamepad;
			pad.config = hxd_Pad.pickConfig(pad.d.id);
			pad.index = pad.d.index;
			hxd_Pad.pads.h[pad.d.index] = pad;
			hxd_Pad.waitPad(pad);
		});
		window.addEventListener("gamepaddisconnected",function(p) {
			var pad = hxd_Pad.pads.h[p.gamepad.index];
			if(pad == null) {
				return;
			}
			hxd_Pad.pads.remove(p.gamepad.index);
			pad.connected = false;
			pad.onDisconnect();
		});
		haxe_MainLoop.add(hxd_Pad.syncPads);
	}
};
hxd_Pad.syncPads = function() {
	var freshPads = [];
	try {
		freshPads = $global.navigator.getGamepads();
	} catch( _g ) {
	}
	if(freshPads.length > 0) {
		var _g = 0;
		var _g1 = freshPads.length;
		while(_g < _g1) {
			var i = _g++;
			if(hxd_Pad.pads.h[i] != null) {
				hxd_Pad.pads.h[i].d = freshPads[i];
			}
		}
	}
	var p = hxd_Pad.pads.iterator();
	while(p.hasNext()) {
		var p1 = p.next();
		var _g = 0;
		var _g1 = p1.d.buttons.length;
		while(_g < _g1) {
			var i = _g++;
			p1.prevButtons[i] = p1.buttons[i];
			p1.buttons[i] = p1.d.buttons[i].pressed;
			p1.values[i] = p1.d.buttons[i].value;
		}
		var _g2 = 0;
		var _g3 = p1.d.axes.length >> 1;
		while(_g2 < _g3) {
			var i1 = _g2++;
			var x = p1.d.axes[i1 << 1];
			var y = p1.d.axes[(i1 << 1) + 1];
			p1.values[(i1 << 1) + p1.d.buttons.length] = x;
			p1.values[(i1 << 1) + p1.d.buttons.length + 1] = -y;
			if(i1 == 0) {
				p1.rawXAxis = x;
				p1.rawYAxis = y;
			} else if(i1 == 1) {
				p1.rawRXAxis = x;
				p1.rawRYAxis = y;
			}
		}
	}
};
hxd_Pad.prototype = {
	onDisconnect: function() {
	}
	,__class__: hxd_Pad
};
var dn_legacy_GamePad = function(deadZone,onEnable) {
	this.axisAsButtonDeadZone = 0.70;
	this.deadZone = 0.18;
	dn_legacy_GamePad.ALL.push(this);
	this.toggles = [];
	if(deadZone != null) {
		this.deadZone = deadZone;
	}
	if(onEnable != null) {
		this.onEnable = onEnable;
	}
	if(dn_legacy_GamePad.AVAILABLE_DEVICES == null) {
		dn_legacy_GamePad.AVAILABLE_DEVICES = [];
		hxd_Pad.wait(dn_legacy_GamePad.onDevice);
	} else if(dn_legacy_GamePad.AVAILABLE_DEVICES.length > 0) {
		this.enableDevice(dn_legacy_GamePad.AVAILABLE_DEVICES[0]);
	}
	this.lastActivity = HxOverrides.now() / 1000;
};
$hxClasses["dn.legacy.GamePad"] = dn_legacy_GamePad;
dn_legacy_GamePad.__name__ = "dn.legacy.GamePad";
dn_legacy_GamePad.onDevice = function(p) {
	var _g = 0;
	var _g1 = dn_legacy_GamePad.ALL;
	while(_g < _g1.length) {
		var i = _g1[_g];
		++_g;
		if(i.device == null) {
			i.enableDevice(p);
			return;
		}
	}
	dn_legacy_GamePad.AVAILABLE_DEVICES.push(p);
	p.onDisconnect = function() {
		HxOverrides.remove(dn_legacy_GamePad.AVAILABLE_DEVICES,p);
	};
};
dn_legacy_GamePad.update = function() {
	var _g = 0;
	var _g1 = dn_legacy_GamePad.ALL;
	while(_g < _g1.length) {
		var e = _g1[_g];
		++_g;
		var hasToggle = false;
		if(e.device != null) {
			var _g2 = 0;
			while(_g2 < 28) {
				var i = _g2++;
				var this1 = i;
				var k = this1;
				var tmp;
				switch(k) {
				case 18:case 21:case 24:case 27:
					var simplified = true;
					var overrideDeadZone = e.axisAsButtonDeadZone;
					if(overrideDeadZone == null) {
						overrideDeadZone = -1.;
					}
					if(simplified == null) {
						simplified = false;
					}
					var tmp1;
					if(e.device != null) {
						var idx = dn_legacy_GamePad.MAPPING[k];
						var overrideDeadZone1 = overrideDeadZone;
						if(overrideDeadZone1 == null) {
							overrideDeadZone1 = -1.;
						}
						var v = idx > -1 && idx < e.device.values.length ? e.device.values[idx] : 0;
						var dz = overrideDeadZone1 < 0. ? e.deadZone : overrideDeadZone1;
						tmp1 = simplified ? v < -dz ? -1. : v > dz ? 1. : 0. : v > -dz && v < dz ? 0. : v;
					} else {
						tmp1 = 0.;
					}
					tmp = tmp1 > 0;
					break;
				case 17:case 20:case 23:case 26:
					var simplified1 = true;
					var overrideDeadZone2 = e.axisAsButtonDeadZone;
					if(overrideDeadZone2 == null) {
						overrideDeadZone2 = -1.;
					}
					if(simplified1 == null) {
						simplified1 = false;
					}
					var tmp2;
					if(e.device != null) {
						var idx1 = dn_legacy_GamePad.MAPPING[k];
						var overrideDeadZone3 = overrideDeadZone2;
						if(overrideDeadZone3 == null) {
							overrideDeadZone3 = -1.;
						}
						var v1 = idx1 > -1 && idx1 < e.device.values.length ? e.device.values[idx1] : 0;
						var dz1 = overrideDeadZone3 < 0. ? e.deadZone : overrideDeadZone3;
						tmp2 = simplified1 ? v1 < -dz1 ? -1. : v1 > dz1 ? 1. : 0. : v1 > -dz1 && v1 < dz1 ? 0. : v1;
					} else {
						tmp2 = 0.;
					}
					tmp = tmp2 < 0;
					break;
				default:
					var simplified2 = true;
					if(simplified2 == null) {
						simplified2 = false;
					}
					var tmp3;
					if(e.device != null) {
						var idx2 = dn_legacy_GamePad.MAPPING[k];
						var overrideDeadZone4 = -1.;
						if(overrideDeadZone4 == null) {
							overrideDeadZone4 = -1.;
						}
						var v2 = idx2 > -1 && idx2 < e.device.values.length ? e.device.values[idx2] : 0;
						var dz2 = overrideDeadZone4 < 0. ? e.deadZone : overrideDeadZone4;
						tmp3 = simplified2 ? v2 < -dz2 ? -1. : v2 > dz2 ? 1. : 0. : v2 > -dz2 && v2 < dz2 ? 0. : v2;
					} else {
						tmp3 = 0.;
					}
					tmp = tmp3 != 0;
				}
				if(tmp) {
					hasToggle = true;
					if(e.toggles[i] >= 1) {
						e.toggles[i] = 2;
					} else {
						e.toggles[i] = 1;
					}
				} else {
					e.toggles[i] = 0;
				}
			}
		}
		if(hasToggle) {
			e.lastActivity = HxOverrides.now() / 1000;
		}
	}
};
dn_legacy_GamePad.prototype = {
	onEnable: function(pad) {
	}
	,onDisable: function(pad) {
	}
	,enableDevice: function(p) {
		var _gthis = this;
		if(this.device == null) {
			HxOverrides.remove(dn_legacy_GamePad.AVAILABLE_DEVICES,p);
			p.onDisconnect = function() {
				_gthis.disable();
			};
			this.device = p;
			this.onEnable(this);
		}
	}
	,disable: function() {
		if(this.device != null) {
			this.device = null;
			this.onDisable(this);
		}
	}
	,__class__: dn_legacy_GamePad
};
var dn_pathfinder_AStar = function(nodeToPoint) {
	this.hei = -1;
	this.wid = -1;
	this.nodes = [];
	this.nodeToPoint = nodeToPoint;
};
$hxClasses["dn.pathfinder.AStar"] = dn_pathfinder_AStar;
dn_pathfinder_AStar.__name__ = "dn.pathfinder.AStar";
dn_pathfinder_AStar.prototype = {
	init: function(w,h,hasCollision) {
		this.wid = w;
		this.hei = h;
		this.hasCollision = hasCollision;
		this.nodes = [];
		var _g = 0;
		var _g1 = this.hei;
		while(_g < _g1) {
			var cy = _g++;
			var _g2 = 0;
			var _g3 = this.wid;
			while(_g2 < _g3) {
				var cx = _g2++;
				if(hasCollision(cx - 1,cy - 1) && !hasCollision(cx,cy - 1) && !hasCollision(cx - 1,cy) || hasCollision(cx + 1,cy - 1) && !hasCollision(cx,cy - 1) && !hasCollision(cx + 1,cy) || hasCollision(cx + 1,cy + 1) && !hasCollision(cx,cy + 1) && !hasCollision(cx + 1,cy) || hasCollision(cx - 1,cy + 1) && !hasCollision(cx,cy + 1) && !hasCollision(cx - 1,cy)) {
					this.nodes.push(new dn_pathfinder__$AStar_PathNode(this,cx,cy));
				}
			}
		}
		var _g = 0;
		var _g1 = this.nodes;
		while(_g < _g1.length) {
			var n = _g1[_g];
			++_g;
			var _g2 = 0;
			var _g3 = this.nodes;
			while(_g2 < _g3.length) {
				var n2 = _g3[_g2];
				++_g2;
				var tmp;
				if(n != n2) {
					var _gthis = this;
					var x0 = n.cx;
					var y0 = n.cy;
					var x1 = n2.cx;
					var y1 = n2.cy;
					if(_gthis.hasCollision(x0,y0) || _gthis.hasCollision(x1,y1)) {
						tmp = false;
					} else {
						var x = y1 - y0;
						var x2 = x1 - x0;
						var swapXY = (x < 0 ? -x : x) > (x2 < 0 ? -x2 : x2);
						var tmp1;
						if(swapXY) {
							tmp1 = x0;
							x0 = y0;
							y0 = tmp1;
							tmp1 = x1;
							x1 = y1;
							y1 = tmp1;
						}
						if(x0 > x1) {
							tmp1 = x0;
							x0 = x1;
							x1 = tmp1;
							tmp1 = y0;
							y0 = y1;
							y1 = tmp1;
						}
						var deltax = x1 - x0;
						var x3 = y1 - y0;
						var deltay = Math.floor(x3 < 0 ? -x3 : x3);
						var error = Math.floor(deltax / 2);
						var y = y0;
						var ystep = y0 < y1 ? 1 : -1;
						var valid = true;
						var _g4 = x0;
						var _g5 = x1 + 1;
						while(_g4 < _g5) {
							var x4 = _g4++;
							if(swapXY && _gthis.hasCollision(y,x4) || !swapXY && _gthis.hasCollision(x4,y)) {
								valid = false;
								break;
							}
							error -= deltay;
							if(error < 0) {
								y += ystep;
								error += deltax;
							}
						}
						tmp = valid;
					}
				} else {
					tmp = false;
				}
				if(tmp) {
					n.link(n2);
				}
			}
		}
	}
	,hasCollision: function(cx,cy) {
		return false;
	}
	,getNodeAt: function(cx,cy) {
		var _g = 0;
		var _g1 = this.nodes;
		while(_g < _g1.length) {
			var n = _g1[_g];
			++_g;
			if(n.cx == cx && n.cy == cy) {
				return n;
			}
		}
		return null;
	}
	,getPath: function(fx,fy,tx,ty) {
		var _gthis = this;
		if(this.wid < 0) {
			throw haxe_Exception.thrown("AStar.init() should be called first.");
		}
		var _gthis1 = this;
		var x0 = fx;
		var y0 = fy;
		var x1 = tx;
		var y1 = ty;
		var tmp;
		if(_gthis1.hasCollision(x0,y0) || _gthis1.hasCollision(x1,y1)) {
			tmp = false;
		} else {
			var x = y1 - y0;
			var x2 = x1 - x0;
			var swapXY = (x < 0 ? -x : x) > (x2 < 0 ? -x2 : x2);
			var tmp1;
			if(swapXY) {
				tmp1 = x0;
				x0 = y0;
				y0 = tmp1;
				tmp1 = x1;
				x1 = y1;
				y1 = tmp1;
			}
			if(x0 > x1) {
				tmp1 = x0;
				x0 = x1;
				x1 = tmp1;
				tmp1 = y0;
				y0 = y1;
				y1 = tmp1;
			}
			var deltax = x1 - x0;
			var x = y1 - y0;
			var deltay = Math.floor(x < 0 ? -x : x);
			var error = Math.floor(deltax / 2);
			var y = y0;
			var ystep = y0 < y1 ? 1 : -1;
			var valid = true;
			var _g = x0;
			var _g1 = x1 + 1;
			while(_g < _g1) {
				var x = _g++;
				if(swapXY && _gthis1.hasCollision(y,x) || !swapXY && _gthis1.hasCollision(x,y)) {
					valid = false;
					break;
				}
				error -= deltay;
				if(error < 0) {
					y += ystep;
					error += deltax;
				}
			}
			tmp = valid;
		}
		if(tmp) {
			return [this.nodeToPoint(tx,ty)];
		}
		var _g = 0;
		var _g1 = this.nodes;
		while(_g < _g1.length) {
			var n = _g1[_g];
			++_g;
			n.initBeforeAStar();
		}
		var addeds = 0;
		var start = this.getNodeAt(fx,fy);
		if(start == null) {
			++addeds;
			start = new dn_pathfinder__$AStar_PathNode(this,fx,fy);
			var _g = 0;
			var _g1 = this.nodes;
			while(_g < _g1.length) {
				var n = _g1[_g];
				++_g;
				var _gthis1 = this;
				var x0 = start.cx;
				var y0 = start.cy;
				var x1 = n.cx;
				var y1 = n.cy;
				var tmp;
				if(_gthis1.hasCollision(x0,y0) || _gthis1.hasCollision(x1,y1)) {
					tmp = false;
				} else {
					var x = y1 - y0;
					var x2 = x1 - x0;
					var swapXY = (x < 0 ? -x : x) > (x2 < 0 ? -x2 : x2);
					var tmp1;
					if(swapXY) {
						tmp1 = x0;
						x0 = y0;
						y0 = tmp1;
						tmp1 = x1;
						x1 = y1;
						y1 = tmp1;
					}
					if(x0 > x1) {
						tmp1 = x0;
						x0 = x1;
						x1 = tmp1;
						tmp1 = y0;
						y0 = y1;
						y1 = tmp1;
					}
					var deltax = x1 - x0;
					var x3 = y1 - y0;
					var deltay = Math.floor(x3 < 0 ? -x3 : x3);
					var error = Math.floor(deltax / 2);
					var y = y0;
					var ystep = y0 < y1 ? 1 : -1;
					var valid = true;
					var _g2 = x0;
					var _g3 = x1 + 1;
					while(_g2 < _g3) {
						var x4 = _g2++;
						if(swapXY && _gthis1.hasCollision(y,x4) || !swapXY && _gthis1.hasCollision(x4,y)) {
							valid = false;
							break;
						}
						error -= deltay;
						if(error < 0) {
							y += ystep;
							error += deltax;
						}
					}
					tmp = valid;
				}
				if(tmp) {
					start.link(n,true);
				}
			}
			this.nodes.push(start);
		}
		var end = this.getNodeAt(tx,ty);
		if(end == null) {
			++addeds;
			end = new dn_pathfinder__$AStar_PathNode(this,tx,ty);
			var _g = 0;
			var _g1 = this.nodes;
			while(_g < _g1.length) {
				var n = _g1[_g];
				++_g;
				var _gthis1 = this;
				var x0 = end.cx;
				var y0 = end.cy;
				var x1 = n.cx;
				var y1 = n.cy;
				var tmp;
				if(_gthis1.hasCollision(x0,y0) || _gthis1.hasCollision(x1,y1)) {
					tmp = false;
				} else {
					var x = y1 - y0;
					var x2 = x1 - x0;
					var swapXY = (x < 0 ? -x : x) > (x2 < 0 ? -x2 : x2);
					var tmp1;
					if(swapXY) {
						tmp1 = x0;
						x0 = y0;
						y0 = tmp1;
						tmp1 = x1;
						x1 = y1;
						y1 = tmp1;
					}
					if(x0 > x1) {
						tmp1 = x0;
						x0 = x1;
						x1 = tmp1;
						tmp1 = y0;
						y0 = y1;
						y1 = tmp1;
					}
					var deltax = x1 - x0;
					var x3 = y1 - y0;
					var deltay = Math.floor(x3 < 0 ? -x3 : x3);
					var error = Math.floor(deltax / 2);
					var y = y0;
					var ystep = y0 < y1 ? 1 : -1;
					var valid = true;
					var _g2 = x0;
					var _g3 = x1 + 1;
					while(_g2 < _g3) {
						var x4 = _g2++;
						if(swapXY && _gthis1.hasCollision(y,x4) || !swapXY && _gthis1.hasCollision(x4,y)) {
							valid = false;
							break;
						}
						error -= deltay;
						if(error < 0) {
							y += ystep;
							error += deltax;
						}
					}
					tmp = valid;
				}
				if(tmp) {
					end.link(n,true);
				}
			}
			this.nodes.push(end);
		}
		var _this = this.astar(start,end);
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			var n = _this[i];
			result[i] = _gthis.nodeToPoint(n.cx,n.cy);
		}
		var path = result;
		var _g = 0;
		var _g1 = addeds;
		while(_g < _g1) {
			var i = _g++;
			this.nodes.pop();
		}
		return path;
	}
	,astar: function(start,end) {
		var opens = [start];
		var openMarks = new haxe_ds_IntMap();
		openMarks.h[start.id] = true;
		var closedMarks_h = { };
		while(opens.length > 0) {
			var best = -1;
			var _g = 0;
			var _g1 = opens.length;
			while(_g < _g1) {
				var i = _g++;
				var tmp;
				if(best >= 0) {
					var _this = opens[i];
					var tx = end.cx;
					var ty = end.cy;
					var ax = _this.cx;
					var ay = _this.cy;
					var _this1 = opens[best];
					var tx1 = end.cx;
					var ty1 = end.cy;
					var ax1 = _this1.cx;
					var ay1 = _this1.cy;
					tmp = _this.homeDist + ((ax - tx) * (ax - tx) + (ay - ty) * (ay - ty)) < _this1.homeDist + ((ax1 - tx1) * (ax1 - tx1) + (ay1 - ty1) * (ay1 - ty1));
				} else {
					tmp = true;
				}
				if(tmp) {
					best = i;
				}
			}
			var cur = opens[best];
			if(cur == end) {
				var path = [cur];
				var n = this.getDeepestParentOnSight(cur);
				while(n != null) {
					path.push(n);
					n = this.getDeepestParentOnSight(n);
				}
				path.reverse();
				return path;
			}
			closedMarks_h[cur.id] = true;
			opens.splice(best,1);
			openMarks.remove(cur.id);
			var i1 = 0;
			var _g2 = 0;
			var _g3 = cur.nexts;
			while(_g2 < _g3.length) {
				var n1 = _g3[_g2];
				++_g2;
				if(closedMarks_h.hasOwnProperty(n1.id)) {
					continue;
				}
				var tx2 = n1.cx;
				var ty2 = n1.cy;
				var ax2 = cur.cx;
				var ay2 = cur.cy;
				var homeDist = cur.homeDist + ((ax2 - tx2) * (ax2 - tx2) + (ay2 - ty2) * (ay2 - ty2));
				var isBetter = false;
				if(!openMarks.h.hasOwnProperty(n1.id)) {
					isBetter = true;
					opens.push(n1);
					openMarks.h[n1.id] = true;
				} else if(homeDist < n1.homeDist) {
					isBetter = true;
				}
				if(isBetter) {
					n1.parent = cur;
					n1.homeDist = homeDist;
					++i1;
				}
			}
		}
		return [];
	}
	,getDeepestParentOnSight: function(cur) {
		var n = cur.parent;
		var lastSight = n;
		while(n != null) {
			var _gthis = this;
			var x0 = cur.cx;
			var y0 = cur.cy;
			var x1 = n.cx;
			var y1 = n.cy;
			var tmp;
			if(_gthis.hasCollision(x0,y0) || _gthis.hasCollision(x1,y1)) {
				tmp = false;
			} else {
				var x = y1 - y0;
				var x2 = x1 - x0;
				var swapXY = (x < 0 ? -x : x) > (x2 < 0 ? -x2 : x2);
				var tmp1;
				if(swapXY) {
					tmp1 = x0;
					x0 = y0;
					y0 = tmp1;
					tmp1 = x1;
					x1 = y1;
					y1 = tmp1;
				}
				if(x0 > x1) {
					tmp1 = x0;
					x0 = x1;
					x1 = tmp1;
					tmp1 = y0;
					y0 = y1;
					y1 = tmp1;
				}
				var deltax = x1 - x0;
				var x3 = y1 - y0;
				var deltay = Math.floor(x3 < 0 ? -x3 : x3);
				var error = Math.floor(deltax / 2);
				var y = y0;
				var ystep = y0 < y1 ? 1 : -1;
				var valid = true;
				var _g = x0;
				var _g1 = x1 + 1;
				while(_g < _g1) {
					var x4 = _g++;
					if(swapXY && _gthis.hasCollision(y,x4) || !swapXY && _gthis.hasCollision(x4,y)) {
						valid = false;
						break;
					}
					error -= deltay;
					if(error < 0) {
						y += ystep;
						error += deltax;
					}
				}
				tmp = valid;
			}
			if(tmp) {
				lastSight = n;
			} else {
				return lastSight;
			}
			n = n.parent;
		}
		return null;
	}
	,__class__: dn_pathfinder_AStar
};
var dn_pathfinder__$AStar_PathNode = function(as,x,y) {
	this.homeDist = 0.;
	this.originalNexts = [];
	this.nexts = [];
	this.cx = x;
	this.cy = y;
	this.id = this.cx + this.cy * as.wid;
};
$hxClasses["dn.pathfinder._AStar.PathNode"] = dn_pathfinder__$AStar_PathNode;
dn_pathfinder__$AStar_PathNode.__name__ = "dn.pathfinder._AStar.PathNode";
dn_pathfinder__$AStar_PathNode.prototype = {
	initBeforeAStar: function() {
		this.homeDist = 0;
		this.parent = null;
		this.nexts = this.originalNexts.slice();
	}
	,link: function(n,tmpLink) {
		if(tmpLink == null) {
			tmpLink = false;
		}
		if(tmpLink) {
			this.nexts.push(n);
			n.nexts.push(this);
		} else {
			this.originalNexts.push(n);
			n.originalNexts.push(this);
		}
	}
	,__class__: dn_pathfinder__$AStar_PathNode
};
var dn_struct__$FixedArray_FixedArrayIterator = function(arr) {
	this.arr = arr;
	this.i = 0;
};
$hxClasses["dn.struct._FixedArray.FixedArrayIterator"] = dn_struct__$FixedArray_FixedArrayIterator;
dn_struct__$FixedArray_FixedArrayIterator.__name__ = "dn.struct._FixedArray.FixedArrayIterator";
dn_struct__$FixedArray_FixedArrayIterator.prototype = {
	hasNext: function() {
		return this.i < this.arr.nalloc;
	}
	,next: function() {
		return this.arr.values[this.i++];
	}
	,__class__: dn_struct__$FixedArray_FixedArrayIterator
};
var dn_struct_RecyclablePool = function(size,valueConstructor) {
	this.nalloc = 0;
	this.size = size;
	var this1 = new Array(size);
	this.pool = this1;
	var _g = 0;
	var _g1 = this.pool.length;
	while(_g < _g1) {
		var i = _g++;
		this.pool[i] = valueConstructor();
	}
};
$hxClasses["dn.struct.RecyclablePool"] = dn_struct_RecyclablePool;
dn_struct_RecyclablePool.__name__ = "dn.struct.RecyclablePool";
dn_struct_RecyclablePool.prototype = {
	toString: function() {
		return "RecyclablePool(" + this.nalloc + "/" + this.size + ")";
	}
	,dispose: function(elementDisposer) {
		if(elementDisposer != null) {
			var _g = 0;
			var _g1 = this.pool;
			while(_g < _g1.length) {
				var e = _g1[_g];
				++_g;
				elementDisposer(e);
			}
		}
		this.nalloc = 0;
		this.pool = null;
	}
	,__class__: dn_struct_RecyclablePool
};
var dn_struct__$RecyclablePool_TestObject = function(id) {
	this.id = id;
};
$hxClasses["dn.struct._RecyclablePool.TestObject"] = dn_struct__$RecyclablePool_TestObject;
dn_struct__$RecyclablePool_TestObject.__name__ = "dn.struct._RecyclablePool.TestObject";
dn_struct__$RecyclablePool_TestObject.prototype = {
	toString: function() {
		return "#" + this.id + "=" + Std.string(this.value);
	}
	,recycle: function() {
		this.value = Std.random(999999);
	}
	,__class__: dn_struct__$RecyclablePool_TestObject
};
var format_gif_Block = $hxEnums["format.gif.Block"] = { __ename__:true,__constructs__:null
	,BFrame: ($_=function(frame) { return {_hx_index:0,frame:frame,__enum__:"format.gif.Block",toString:$estr}; },$_._hx_name="BFrame",$_.__params__ = ["frame"],$_)
	,BExtension: ($_=function(extension) { return {_hx_index:1,extension:extension,__enum__:"format.gif.Block",toString:$estr}; },$_._hx_name="BExtension",$_.__params__ = ["extension"],$_)
	,BEOF: {_hx_name:"BEOF",_hx_index:2,__enum__:"format.gif.Block",toString:$estr}
};
format_gif_Block.__constructs__ = [format_gif_Block.BFrame,format_gif_Block.BExtension,format_gif_Block.BEOF];
format_gif_Block.__empty_constructs__ = [format_gif_Block.BEOF];
var format_gif_Extension = $hxEnums["format.gif.Extension"] = { __ename__:true,__constructs__:null
	,EGraphicControl: ($_=function(gce) { return {_hx_index:0,gce:gce,__enum__:"format.gif.Extension",toString:$estr}; },$_._hx_name="EGraphicControl",$_.__params__ = ["gce"],$_)
	,EComment: ($_=function(text) { return {_hx_index:1,text:text,__enum__:"format.gif.Extension",toString:$estr}; },$_._hx_name="EComment",$_.__params__ = ["text"],$_)
	,EText: ($_=function(pte) { return {_hx_index:2,pte:pte,__enum__:"format.gif.Extension",toString:$estr}; },$_._hx_name="EText",$_.__params__ = ["pte"],$_)
	,EApplicationExtension: ($_=function(ext) { return {_hx_index:3,ext:ext,__enum__:"format.gif.Extension",toString:$estr}; },$_._hx_name="EApplicationExtension",$_.__params__ = ["ext"],$_)
	,EUnknown: ($_=function(id,data) { return {_hx_index:4,id:id,data:data,__enum__:"format.gif.Extension",toString:$estr}; },$_._hx_name="EUnknown",$_.__params__ = ["id","data"],$_)
};
format_gif_Extension.__constructs__ = [format_gif_Extension.EGraphicControl,format_gif_Extension.EComment,format_gif_Extension.EText,format_gif_Extension.EApplicationExtension,format_gif_Extension.EUnknown];
format_gif_Extension.__empty_constructs__ = [];
var format_gif_ApplicationExtension = $hxEnums["format.gif.ApplicationExtension"] = { __ename__:true,__constructs__:null
	,AENetscapeLooping: ($_=function(loops) { return {_hx_index:0,loops:loops,__enum__:"format.gif.ApplicationExtension",toString:$estr}; },$_._hx_name="AENetscapeLooping",$_.__params__ = ["loops"],$_)
	,AEUnknown: ($_=function(name,version,data) { return {_hx_index:1,name:name,version:version,data:data,__enum__:"format.gif.ApplicationExtension",toString:$estr}; },$_._hx_name="AEUnknown",$_.__params__ = ["name","version","data"],$_)
};
format_gif_ApplicationExtension.__constructs__ = [format_gif_ApplicationExtension.AENetscapeLooping,format_gif_ApplicationExtension.AEUnknown];
format_gif_ApplicationExtension.__empty_constructs__ = [];
var format_gif_Version = $hxEnums["format.gif.Version"] = { __ename__:true,__constructs__:null
	,GIF87a: {_hx_name:"GIF87a",_hx_index:0,__enum__:"format.gif.Version",toString:$estr}
	,GIF89a: {_hx_name:"GIF89a",_hx_index:1,__enum__:"format.gif.Version",toString:$estr}
	,Unknown: ($_=function(version) { return {_hx_index:2,version:version,__enum__:"format.gif.Version",toString:$estr}; },$_._hx_name="Unknown",$_.__params__ = ["version"],$_)
};
format_gif_Version.__constructs__ = [format_gif_Version.GIF87a,format_gif_Version.GIF89a,format_gif_Version.Unknown];
format_gif_Version.__empty_constructs__ = [format_gif_Version.GIF87a,format_gif_Version.GIF89a];
var format_gif_DisposalMethod = $hxEnums["format.gif.DisposalMethod"] = { __ename__:true,__constructs__:null
	,UNSPECIFIED: {_hx_name:"UNSPECIFIED",_hx_index:0,__enum__:"format.gif.DisposalMethod",toString:$estr}
	,NO_ACTION: {_hx_name:"NO_ACTION",_hx_index:1,__enum__:"format.gif.DisposalMethod",toString:$estr}
	,FILL_BACKGROUND: {_hx_name:"FILL_BACKGROUND",_hx_index:2,__enum__:"format.gif.DisposalMethod",toString:$estr}
	,RENDER_PREVIOUS: {_hx_name:"RENDER_PREVIOUS",_hx_index:3,__enum__:"format.gif.DisposalMethod",toString:$estr}
	,UNDEFINED: ($_=function(index) { return {_hx_index:4,index:index,__enum__:"format.gif.DisposalMethod",toString:$estr}; },$_._hx_name="UNDEFINED",$_.__params__ = ["index"],$_)
};
format_gif_DisposalMethod.__constructs__ = [format_gif_DisposalMethod.UNSPECIFIED,format_gif_DisposalMethod.NO_ACTION,format_gif_DisposalMethod.FILL_BACKGROUND,format_gif_DisposalMethod.RENDER_PREVIOUS,format_gif_DisposalMethod.UNDEFINED];
format_gif_DisposalMethod.__empty_constructs__ = [format_gif_DisposalMethod.UNSPECIFIED,format_gif_DisposalMethod.NO_ACTION,format_gif_DisposalMethod.FILL_BACKGROUND,format_gif_DisposalMethod.RENDER_PREVIOUS];
var format_gif_Reader = function(i) {
	this.i = i;
	i.set_bigEndian(false);
};
$hxClasses["format.gif.Reader"] = format_gif_Reader;
format_gif_Reader.__name__ = "format.gif.Reader";
format_gif_Reader.prototype = {
	read: function() {
		var b = 71;
		if(this.i.readByte() != b) {
			throw haxe_Exception.thrown("Invalid header");
		}
		var b = 73;
		if(this.i.readByte() != b) {
			throw haxe_Exception.thrown("Invalid header");
		}
		var b = 70;
		if(this.i.readByte() != b) {
			throw haxe_Exception.thrown("Invalid header");
		}
		var gifVer = this.i.readString(3);
		var version = format_gif_Version.GIF89a;
		switch(gifVer) {
		case "87a":
			version = format_gif_Version.GIF87a;
			break;
		case "89a":
			version = format_gif_Version.GIF89a;
			break;
		default:
			version = format_gif_Version.Unknown(gifVer);
		}
		var width = this.i.readUInt16();
		var height = this.i.readUInt16();
		var packedField = this.i.readByte();
		var bgIndex = this.i.readByte();
		var pixelAspectRatio = this.i.readByte();
		if(pixelAspectRatio != 0) {
			pixelAspectRatio = (pixelAspectRatio + 15) / 64;
		} else {
			pixelAspectRatio = 1;
		}
		var lsd = { width : width, height : height, hasGlobalColorTable : (packedField & 128) == 128, colorResolution : (packedField & 112) >>> 4, sorted : (packedField & 8) == 8, globalColorTableSize : 2 << (packedField & 7), backgroundColorIndex : bgIndex, pixelAspectRatio : pixelAspectRatio};
		var gct = null;
		if(lsd.hasGlobalColorTable) {
			gct = this.readColorTable(lsd.globalColorTableSize);
		}
		var blocks = new haxe_ds_List();
		while(true) {
			var b = this.readBlock();
			blocks.add(b);
			if(b == format_gif_Block.BEOF) {
				break;
			}
		}
		return { version : version, logicalScreenDescriptor : lsd, globalColorTable : gct, blocks : blocks};
	}
	,readBlock: function() {
		var blockID = this.i.readByte();
		switch(blockID) {
		case 33:
			return this.readExtension();
		case 44:
			return this.readImage();
		case 59:
			return format_gif_Block.BEOF;
		}
		return format_gif_Block.BEOF;
	}
	,readImage: function() {
		var x = this.i.readUInt16();
		var y = this.i.readUInt16();
		var width = this.i.readUInt16();
		var height = this.i.readUInt16();
		var packed = this.i.readByte();
		var localColorTable = (packed & 128) == 128;
		var interlaced = (packed & 64) == 64;
		var sorted = (packed & 32) == 32;
		var localColorTableSize = 2 << (packed & 7);
		var lct = null;
		if(localColorTable) {
			lct = this.readColorTable(localColorTableSize);
		}
		return format_gif_Block.BFrame({ x : x, y : y, width : width, height : height, localColorTable : localColorTable, interlaced : interlaced, sorted : sorted, localColorTableSize : localColorTableSize, pixels : this.readPixels(width,height,interlaced), colorTable : lct});
	}
	,readPixels: function(width,height,interlaced) {
		var input = this.i;
		var pixelsCount = width * height;
		var pixels = new haxe_io_Bytes(new ArrayBuffer(pixelsCount));
		var minCodeSize = input.readByte();
		var blockSize = input.readByte() - 1;
		var bits = input.readByte();
		var bitsCount = 8;
		var clearCode = 1 << minCodeSize;
		var eoiCode = clearCode + 1;
		var codeSize = minCodeSize + 1;
		var codeSizeLimit = 1 << codeSize;
		var codeMask = codeSizeLimit - 1;
		var baseDict = [];
		var _g = 0;
		var _g1 = clearCode;
		while(_g < _g1) {
			var i = _g++;
			baseDict[i] = [i];
		}
		var dict = [];
		var dictLen = clearCode + 2;
		var newRecord;
		var i = 0;
		var code = 0;
		var last;
		while(i < pixelsCount) {
			last = code;
			while(bitsCount < codeSize) {
				if(blockSize == 0) {
					break;
				}
				bits |= input.readByte() << bitsCount;
				bitsCount += 8;
				--blockSize;
				if(blockSize == 0) {
					blockSize = input.readByte();
				}
			}
			code = bits & codeMask;
			bits >>= codeSize;
			bitsCount -= codeSize;
			if(code == clearCode) {
				dict = baseDict.slice();
				dictLen = clearCode + 2;
				codeSize = minCodeSize + 1;
				codeSizeLimit = 1 << codeSize;
				codeMask = codeSizeLimit - 1;
				continue;
			}
			if(code == eoiCode) {
				break;
			}
			if(code < dictLen) {
				if(last != clearCode) {
					newRecord = dict[last].slice();
					newRecord.push(dict[code][0]);
					dict[dictLen++] = newRecord;
				}
			} else {
				if(code != dictLen) {
					throw haxe_Exception.thrown("Invalid LZW code. Excepted: " + dictLen + ", got: " + code);
				}
				newRecord = dict[last].slice();
				newRecord.push(newRecord[0]);
				dict[dictLen++] = newRecord;
			}
			newRecord = dict[code];
			var _g = 0;
			while(_g < newRecord.length) {
				var item = newRecord[_g];
				++_g;
				pixels.b[i++] = item;
			}
			if(dictLen == codeSizeLimit && codeSize < 12) {
				++codeSize;
				codeSizeLimit = 1 << codeSize;
				codeMask = codeSizeLimit - 1;
			}
		}
		while(blockSize > 0) {
			input.readByte();
			--blockSize;
			if(blockSize == 0) {
				blockSize = input.readByte();
			}
		}
		while(i < pixelsCount) pixels.b[i++] = 0;
		if(interlaced) {
			var buffer = new haxe_io_Bytes(new ArrayBuffer(pixelsCount));
			var offset = this.deinterlace(pixels,buffer,8,0,0,width,height);
			offset = this.deinterlace(pixels,buffer,8,4,offset,width,height);
			offset = this.deinterlace(pixels,buffer,4,2,offset,width,height);
			this.deinterlace(pixels,buffer,2,1,offset,width,height);
			pixels = buffer;
		}
		return pixels;
	}
	,deinterlace: function(input,output,step,y,offset,width,height) {
		while(y < height) {
			output.blit(y * width,input,offset,width);
			offset += width;
			y += step;
		}
		return offset;
	}
	,readExtension: function() {
		var subId = this.i.readByte();
		switch(subId) {
		case 1:
			if(this.i.readByte() != 12) {
				throw haxe_Exception.thrown("Incorrect size of Plain Text Extension introducer block.");
			}
			var tmp = this.i.readUInt16();
			var tmp1 = this.i.readUInt16();
			var tmp2 = this.i.readUInt16();
			var tmp3 = this.i.readUInt16();
			var tmp4 = this.i.readByte();
			var tmp5 = this.i.readByte();
			var tmp6 = this.i.readByte();
			var tmp7 = this.i.readByte();
			var buffer = new haxe_io_BytesOutput();
			var bytes = new haxe_io_Bytes(new ArrayBuffer(255));
			var len = this.i.readByte();
			while(len != 0) {
				this.i.readBytes(bytes,0,len);
				buffer.writeBytes(bytes,0,len);
				len = this.i.readByte();
			}
			buffer.flush();
			bytes = buffer.getBytes();
			buffer.close();
			return format_gif_Block.BExtension(format_gif_Extension.EText({ textGridX : tmp, textGridY : tmp1, textGridWidth : tmp2, textGridHeight : tmp3, charCellWidth : tmp4, charCellHeight : tmp5, textForegroundColorIndex : tmp6, textBackgroundColorIndex : tmp7, text : bytes.toString()}));
		case 249:
			if(this.i.readByte() != 4) {
				throw haxe_Exception.thrown("Incorrect Graphic Control Extension block size!");
			}
			var packed = this.i.readByte();
			var disposalMethod;
			switch((packed & 28) >> 2) {
			case 0:
				disposalMethod = format_gif_DisposalMethod.UNSPECIFIED;
				break;
			case 1:
				disposalMethod = format_gif_DisposalMethod.NO_ACTION;
				break;
			case 2:
				disposalMethod = format_gif_DisposalMethod.FILL_BACKGROUND;
				break;
			case 3:
				disposalMethod = format_gif_DisposalMethod.RENDER_PREVIOUS;
				break;
			default:
				disposalMethod = format_gif_DisposalMethod.UNDEFINED((packed & 28) >> 2);
			}
			var b = format_gif_Block.BExtension(format_gif_Extension.EGraphicControl({ disposalMethod : disposalMethod, userInput : (packed & 2) == 2, hasTransparentColor : (packed & 1) == 1, delay : this.i.readUInt16(), transparentIndex : this.i.readByte()}));
			this.i.readByte();
			return b;
		case 254:
			var buffer = new haxe_io_BytesOutput();
			var bytes = new haxe_io_Bytes(new ArrayBuffer(255));
			var len = this.i.readByte();
			while(len != 0) {
				this.i.readBytes(bytes,0,len);
				buffer.writeBytes(bytes,0,len);
				len = this.i.readByte();
			}
			buffer.flush();
			bytes = buffer.getBytes();
			buffer.close();
			return format_gif_Block.BExtension(format_gif_Extension.EComment(bytes.toString()));
		case 255:
			return this.readApplicationExtension();
		default:
			var buffer = new haxe_io_BytesOutput();
			var bytes = new haxe_io_Bytes(new ArrayBuffer(255));
			var len = this.i.readByte();
			while(len != 0) {
				this.i.readBytes(bytes,0,len);
				buffer.writeBytes(bytes,0,len);
				len = this.i.readByte();
			}
			buffer.flush();
			bytes = buffer.getBytes();
			buffer.close();
			return format_gif_Block.BExtension(format_gif_Extension.EUnknown(subId,bytes));
		}
	}
	,readApplicationExtension: function() {
		if(this.i.readByte() != 11) {
			throw haxe_Exception.thrown("Incorrect size of Application Extension introducer block.");
		}
		var name = this.i.readString(8);
		var version = this.i.readString(3);
		var buffer = new haxe_io_BytesOutput();
		var bytes = new haxe_io_Bytes(new ArrayBuffer(255));
		var len = this.i.readByte();
		while(len != 0) {
			this.i.readBytes(bytes,0,len);
			buffer.writeBytes(bytes,0,len);
			len = this.i.readByte();
		}
		buffer.flush();
		bytes = buffer.getBytes();
		buffer.close();
		var data = bytes;
		if(name == "NETSCAPE" && version == "2.0" && data.b[0] == 1) {
			return format_gif_Block.BExtension(format_gif_Extension.EApplicationExtension(format_gif_ApplicationExtension.AENetscapeLooping(data.b[1] | data.b[2] << 8)));
		}
		return format_gif_Block.BExtension(format_gif_Extension.EApplicationExtension(format_gif_ApplicationExtension.AEUnknown(name,version,data)));
	}
	,readColorTable: function(size) {
		size *= 3;
		var output = new haxe_io_Bytes(new ArrayBuffer(size));
		var c = 0;
		while(c < size) {
			var v = this.i.readByte();
			output.b[c] = v;
			var v1 = this.i.readByte();
			output.b[c + 1] = v1;
			var v2 = this.i.readByte();
			output.b[c + 2] = v2;
			c += 3;
		}
		return output;
	}
	,__class__: format_gif_Reader
};
var format_gif_Tools = function() { };
$hxClasses["format.gif.Tools"] = format_gif_Tools;
format_gif_Tools.__name__ = "format.gif.Tools";
format_gif_Tools.extractFullBGRA = function(data,frameIndex) {
	var gce = null;
	var frameCaret = 0;
	var bytes = new haxe_io_Bytes(new ArrayBuffer(data.logicalScreenDescriptor.width * data.logicalScreenDescriptor.height * 4));
	var _g_head = data.blocks.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var block = val;
		switch(block._hx_index) {
		case 0:
			var frame = block.frame;
			var ct = frame.localColorTable ? frame.colorTable : data.globalColorTable;
			if(ct == null) {
				throw haxe_Exception.thrown("Frame does not have a color table!");
			}
			var transparentIndex = gce != null && gce.hasTransparentColor ? gce.transparentIndex * 3 : -1;
			var pixels = frame.pixels;
			var x = 0;
			var writeCaret = (frame.y * data.logicalScreenDescriptor.width + frame.x) * 4;
			var lineSkip = (data.logicalScreenDescriptor.width - frame.width) * 4 + 4;
			var disposalMethod = frameCaret != frameIndex && gce != null ? gce.disposalMethod : format_gif_DisposalMethod.NO_ACTION;
			switch(disposalMethod._hx_index) {
			case 2:
				var _g = 0;
				var _g1 = pixels.length;
				while(_g < _g1) {
					var i = _g++;
					bytes.b[writeCaret] = 0;
					bytes.b[writeCaret + 1] = 0;
					bytes.b[writeCaret + 2] = 0;
					bytes.b[writeCaret + 3] = 0;
					if(++x == frame.width) {
						x = 0;
						writeCaret += lineSkip;
					} else {
						writeCaret += 4;
					}
				}
				break;
			case 3:
				break;
			default:
				var _g2 = 0;
				var _g3 = pixels.length;
				while(_g2 < _g3) {
					var i1 = _g2++;
					var index = pixels.b[i1] * 3;
					if(transparentIndex != index) {
						bytes.b[writeCaret] = ct.b[index + 2];
						bytes.b[writeCaret + 1] = ct.b[index + 1];
						bytes.b[writeCaret + 2] = ct.b[index];
						bytes.b[writeCaret + 3] = 255;
					}
					if(++x == frame.width) {
						x = 0;
						writeCaret += lineSkip;
					} else {
						writeCaret += 4;
					}
				}
			}
			if(frameCaret == frameIndex) {
				return bytes;
			}
			++frameCaret;
			gce = null;
			break;
		case 1:
			var ext = block.extension;
			if(ext._hx_index == 0) {
				var g = ext.gce;
				gce = g;
			}
			break;
		default:
		}
	}
	return bytes;
};
format_gif_Tools.extractFullRGBA = function(data,frameIndex) {
	var gce = null;
	var frameCaret = 0;
	var bytes = new haxe_io_Bytes(new ArrayBuffer(data.logicalScreenDescriptor.width * data.logicalScreenDescriptor.height * 4));
	var _g_head = data.blocks.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var block = val;
		switch(block._hx_index) {
		case 0:
			var frame = block.frame;
			var ct = frame.localColorTable ? frame.colorTable : data.globalColorTable;
			if(ct == null) {
				throw haxe_Exception.thrown("Frame does not have a color table!");
			}
			var transparentIndex = gce != null && gce.hasTransparentColor ? gce.transparentIndex * 3 : -1;
			var pixels = frame.pixels;
			var x = 0;
			var writeCaret = (frame.y * data.logicalScreenDescriptor.width + frame.x) * 4;
			var lineSkip = (data.logicalScreenDescriptor.width - frame.width) * 4 + 4;
			var disposalMethod = frameCaret != frameIndex && gce != null ? gce.disposalMethod : format_gif_DisposalMethod.NO_ACTION;
			switch(disposalMethod._hx_index) {
			case 2:
				var _g = 0;
				var _g1 = pixels.length;
				while(_g < _g1) {
					var i = _g++;
					bytes.b[writeCaret] = 0;
					bytes.b[writeCaret + 1] = 0;
					bytes.b[writeCaret + 2] = 0;
					bytes.b[writeCaret + 3] = 0;
					if(++x == frame.width) {
						x = 0;
						writeCaret += lineSkip;
					} else {
						writeCaret += 4;
					}
				}
				break;
			case 3:
				break;
			default:
				var _g2 = 0;
				var _g3 = pixels.length;
				while(_g2 < _g3) {
					var i1 = _g2++;
					var index = pixels.b[i1] * 3;
					if(transparentIndex != index) {
						bytes.b[writeCaret] = ct.b[index];
						bytes.b[writeCaret + 1] = ct.b[index + 1];
						bytes.b[writeCaret + 2] = ct.b[index + 2];
						bytes.b[writeCaret + 3] = 255;
					}
					if(++x == frame.width) {
						x = 0;
						writeCaret += lineSkip;
					} else {
						writeCaret += 4;
					}
				}
			}
			if(frameCaret == frameIndex) {
				return bytes;
			}
			++frameCaret;
			gce = null;
			break;
		case 1:
			var ext = block.extension;
			if(ext._hx_index == 0) {
				var g = ext.gce;
				gce = g;
			}
			break;
		default:
		}
	}
	return bytes;
};
var format_mp3_SamplingRate = $hxEnums["format.mp3.SamplingRate"] = { __ename__:true,__constructs__:null
	,SR_8000: {_hx_name:"SR_8000",_hx_index:0,__enum__:"format.mp3.SamplingRate",toString:$estr}
	,SR_11025: {_hx_name:"SR_11025",_hx_index:1,__enum__:"format.mp3.SamplingRate",toString:$estr}
	,SR_12000: {_hx_name:"SR_12000",_hx_index:2,__enum__:"format.mp3.SamplingRate",toString:$estr}
	,SR_22050: {_hx_name:"SR_22050",_hx_index:3,__enum__:"format.mp3.SamplingRate",toString:$estr}
	,SR_24000: {_hx_name:"SR_24000",_hx_index:4,__enum__:"format.mp3.SamplingRate",toString:$estr}
	,SR_32000: {_hx_name:"SR_32000",_hx_index:5,__enum__:"format.mp3.SamplingRate",toString:$estr}
	,SR_44100: {_hx_name:"SR_44100",_hx_index:6,__enum__:"format.mp3.SamplingRate",toString:$estr}
	,SR_48000: {_hx_name:"SR_48000",_hx_index:7,__enum__:"format.mp3.SamplingRate",toString:$estr}
	,SR_Bad: {_hx_name:"SR_Bad",_hx_index:8,__enum__:"format.mp3.SamplingRate",toString:$estr}
};
format_mp3_SamplingRate.__constructs__ = [format_mp3_SamplingRate.SR_8000,format_mp3_SamplingRate.SR_11025,format_mp3_SamplingRate.SR_12000,format_mp3_SamplingRate.SR_22050,format_mp3_SamplingRate.SR_24000,format_mp3_SamplingRate.SR_32000,format_mp3_SamplingRate.SR_44100,format_mp3_SamplingRate.SR_48000,format_mp3_SamplingRate.SR_Bad];
format_mp3_SamplingRate.__empty_constructs__ = [format_mp3_SamplingRate.SR_8000,format_mp3_SamplingRate.SR_11025,format_mp3_SamplingRate.SR_12000,format_mp3_SamplingRate.SR_22050,format_mp3_SamplingRate.SR_24000,format_mp3_SamplingRate.SR_32000,format_mp3_SamplingRate.SR_44100,format_mp3_SamplingRate.SR_48000,format_mp3_SamplingRate.SR_Bad];
var format_mp3_Bitrate = $hxEnums["format.mp3.Bitrate"] = { __ename__:true,__constructs__:null
	,BR_8: {_hx_name:"BR_8",_hx_index:0,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_16: {_hx_name:"BR_16",_hx_index:1,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_24: {_hx_name:"BR_24",_hx_index:2,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_32: {_hx_name:"BR_32",_hx_index:3,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_40: {_hx_name:"BR_40",_hx_index:4,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_48: {_hx_name:"BR_48",_hx_index:5,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_56: {_hx_name:"BR_56",_hx_index:6,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_64: {_hx_name:"BR_64",_hx_index:7,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_80: {_hx_name:"BR_80",_hx_index:8,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_96: {_hx_name:"BR_96",_hx_index:9,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_112: {_hx_name:"BR_112",_hx_index:10,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_128: {_hx_name:"BR_128",_hx_index:11,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_144: {_hx_name:"BR_144",_hx_index:12,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_160: {_hx_name:"BR_160",_hx_index:13,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_176: {_hx_name:"BR_176",_hx_index:14,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_192: {_hx_name:"BR_192",_hx_index:15,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_224: {_hx_name:"BR_224",_hx_index:16,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_256: {_hx_name:"BR_256",_hx_index:17,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_288: {_hx_name:"BR_288",_hx_index:18,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_320: {_hx_name:"BR_320",_hx_index:19,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_352: {_hx_name:"BR_352",_hx_index:20,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_384: {_hx_name:"BR_384",_hx_index:21,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_416: {_hx_name:"BR_416",_hx_index:22,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_448: {_hx_name:"BR_448",_hx_index:23,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_Free: {_hx_name:"BR_Free",_hx_index:24,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_Bad: {_hx_name:"BR_Bad",_hx_index:25,__enum__:"format.mp3.Bitrate",toString:$estr}
};
format_mp3_Bitrate.__constructs__ = [format_mp3_Bitrate.BR_8,format_mp3_Bitrate.BR_16,format_mp3_Bitrate.BR_24,format_mp3_Bitrate.BR_32,format_mp3_Bitrate.BR_40,format_mp3_Bitrate.BR_48,format_mp3_Bitrate.BR_56,format_mp3_Bitrate.BR_64,format_mp3_Bitrate.BR_80,format_mp3_Bitrate.BR_96,format_mp3_Bitrate.BR_112,format_mp3_Bitrate.BR_128,format_mp3_Bitrate.BR_144,format_mp3_Bitrate.BR_160,format_mp3_Bitrate.BR_176,format_mp3_Bitrate.BR_192,format_mp3_Bitrate.BR_224,format_mp3_Bitrate.BR_256,format_mp3_Bitrate.BR_288,format_mp3_Bitrate.BR_320,format_mp3_Bitrate.BR_352,format_mp3_Bitrate.BR_384,format_mp3_Bitrate.BR_416,format_mp3_Bitrate.BR_448,format_mp3_Bitrate.BR_Free,format_mp3_Bitrate.BR_Bad];
format_mp3_Bitrate.__empty_constructs__ = [format_mp3_Bitrate.BR_8,format_mp3_Bitrate.BR_16,format_mp3_Bitrate.BR_24,format_mp3_Bitrate.BR_32,format_mp3_Bitrate.BR_40,format_mp3_Bitrate.BR_48,format_mp3_Bitrate.BR_56,format_mp3_Bitrate.BR_64,format_mp3_Bitrate.BR_80,format_mp3_Bitrate.BR_96,format_mp3_Bitrate.BR_112,format_mp3_Bitrate.BR_128,format_mp3_Bitrate.BR_144,format_mp3_Bitrate.BR_160,format_mp3_Bitrate.BR_176,format_mp3_Bitrate.BR_192,format_mp3_Bitrate.BR_224,format_mp3_Bitrate.BR_256,format_mp3_Bitrate.BR_288,format_mp3_Bitrate.BR_320,format_mp3_Bitrate.BR_352,format_mp3_Bitrate.BR_384,format_mp3_Bitrate.BR_416,format_mp3_Bitrate.BR_448,format_mp3_Bitrate.BR_Free,format_mp3_Bitrate.BR_Bad];
var format_mp3_MPEG = function() { };
$hxClasses["format.mp3.MPEG"] = format_mp3_MPEG;
format_mp3_MPEG.__name__ = "format.mp3.MPEG";
format_mp3_MPEG.enum2Num = function(m) {
	switch(m._hx_index) {
	case 0:
		return 3;
	case 1:
		return 2;
	case 2:
		return 0;
	case 3:
		return format_mp3_MPEG.Reserved;
	}
};
format_mp3_MPEG.num2Enum = function(m) {
	switch(m) {
	case 0:
		return format_mp3_MPEGVersion.MPEG_V25;
	case 2:
		return format_mp3_MPEGVersion.MPEG_V2;
	case 3:
		return format_mp3_MPEGVersion.MPEG_V1;
	default:
		return format_mp3_MPEGVersion.MPEG_Reserved;
	}
};
format_mp3_MPEG.srEnum2Num = function(sr) {
	switch(sr._hx_index) {
	case 0:
		return 8000;
	case 1:
		return 11025;
	case 2:
		return 12000;
	case 3:
		return 22050;
	case 4:
		return 24000;
	case 5:
		return 32000;
	case 6:
		return 44100;
	case 7:
		return 48000;
	case 8:
		return -1;
	}
};
format_mp3_MPEG.bitrateEnum2Num = function(br) {
	switch(br._hx_index) {
	case 0:
		return 8;
	case 1:
		return 16;
	case 2:
		return 24;
	case 3:
		return 32;
	case 4:
		return 40;
	case 5:
		return 48;
	case 6:
		return 56;
	case 7:
		return 64;
	case 8:
		return 80;
	case 9:
		return 96;
	case 10:
		return 112;
	case 11:
		return 128;
	case 12:
		return 144;
	case 13:
		return 160;
	case 14:
		return 176;
	case 15:
		return 192;
	case 16:
		return 224;
	case 17:
		return 256;
	case 18:
		return 288;
	case 19:
		return 320;
	case 20:
		return 352;
	case 21:
		return 384;
	case 22:
		return 416;
	case 23:
		return 448;
	case 24:
		return 0;
	case 25:
		return -1;
	}
};
var format_mp3_CLayer = function() { };
$hxClasses["format.mp3.CLayer"] = format_mp3_CLayer;
format_mp3_CLayer.__name__ = "format.mp3.CLayer";
format_mp3_CLayer.num2Enum = function(l) {
	switch(l) {
	case 1:
		return format_mp3_Layer.Layer3;
	case 2:
		return format_mp3_Layer.Layer2;
	case 3:
		return format_mp3_Layer.Layer1;
	default:
		return format_mp3_Layer.LayerReserved;
	}
};
var format_mp3_CChannelMode = function() { };
$hxClasses["format.mp3.CChannelMode"] = format_mp3_CChannelMode;
format_mp3_CChannelMode.__name__ = "format.mp3.CChannelMode";
format_mp3_CChannelMode.num2Enum = function(c) {
	switch(c) {
	case 0:
		return format_mp3_ChannelMode.Stereo;
	case 1:
		return format_mp3_ChannelMode.JointStereo;
	case 2:
		return format_mp3_ChannelMode.DualChannel;
	case 3:
		return format_mp3_ChannelMode.Mono;
	default:
		throw haxe_Exception.thrown("assert");
	}
};
var format_mp3_CEmphasis = function() { };
$hxClasses["format.mp3.CEmphasis"] = format_mp3_CEmphasis;
format_mp3_CEmphasis.__name__ = "format.mp3.CEmphasis";
format_mp3_CEmphasis.num2Enum = function(c) {
	switch(c) {
	case 0:
		return format_mp3_Emphasis.NoEmphasis;
	case 1:
		return format_mp3_Emphasis.Ms50_15;
	case 2:
		return format_mp3_Emphasis.InvalidEmphasis;
	case 3:
		return format_mp3_Emphasis.CCIT_J17;
	default:
		throw haxe_Exception.thrown("assert");
	}
};
var format_mp3_MPEGVersion = $hxEnums["format.mp3.MPEGVersion"] = { __ename__:true,__constructs__:null
	,MPEG_V1: {_hx_name:"MPEG_V1",_hx_index:0,__enum__:"format.mp3.MPEGVersion",toString:$estr}
	,MPEG_V2: {_hx_name:"MPEG_V2",_hx_index:1,__enum__:"format.mp3.MPEGVersion",toString:$estr}
	,MPEG_V25: {_hx_name:"MPEG_V25",_hx_index:2,__enum__:"format.mp3.MPEGVersion",toString:$estr}
	,MPEG_Reserved: {_hx_name:"MPEG_Reserved",_hx_index:3,__enum__:"format.mp3.MPEGVersion",toString:$estr}
};
format_mp3_MPEGVersion.__constructs__ = [format_mp3_MPEGVersion.MPEG_V1,format_mp3_MPEGVersion.MPEG_V2,format_mp3_MPEGVersion.MPEG_V25,format_mp3_MPEGVersion.MPEG_Reserved];
format_mp3_MPEGVersion.__empty_constructs__ = [format_mp3_MPEGVersion.MPEG_V1,format_mp3_MPEGVersion.MPEG_V2,format_mp3_MPEGVersion.MPEG_V25,format_mp3_MPEGVersion.MPEG_Reserved];
var format_mp3_Layer = $hxEnums["format.mp3.Layer"] = { __ename__:true,__constructs__:null
	,LayerReserved: {_hx_name:"LayerReserved",_hx_index:0,__enum__:"format.mp3.Layer",toString:$estr}
	,Layer3: {_hx_name:"Layer3",_hx_index:1,__enum__:"format.mp3.Layer",toString:$estr}
	,Layer2: {_hx_name:"Layer2",_hx_index:2,__enum__:"format.mp3.Layer",toString:$estr}
	,Layer1: {_hx_name:"Layer1",_hx_index:3,__enum__:"format.mp3.Layer",toString:$estr}
};
format_mp3_Layer.__constructs__ = [format_mp3_Layer.LayerReserved,format_mp3_Layer.Layer3,format_mp3_Layer.Layer2,format_mp3_Layer.Layer1];
format_mp3_Layer.__empty_constructs__ = [format_mp3_Layer.LayerReserved,format_mp3_Layer.Layer3,format_mp3_Layer.Layer2,format_mp3_Layer.Layer1];
var format_mp3_ChannelMode = $hxEnums["format.mp3.ChannelMode"] = { __ename__:true,__constructs__:null
	,Stereo: {_hx_name:"Stereo",_hx_index:0,__enum__:"format.mp3.ChannelMode",toString:$estr}
	,JointStereo: {_hx_name:"JointStereo",_hx_index:1,__enum__:"format.mp3.ChannelMode",toString:$estr}
	,DualChannel: {_hx_name:"DualChannel",_hx_index:2,__enum__:"format.mp3.ChannelMode",toString:$estr}
	,Mono: {_hx_name:"Mono",_hx_index:3,__enum__:"format.mp3.ChannelMode",toString:$estr}
};
format_mp3_ChannelMode.__constructs__ = [format_mp3_ChannelMode.Stereo,format_mp3_ChannelMode.JointStereo,format_mp3_ChannelMode.DualChannel,format_mp3_ChannelMode.Mono];
format_mp3_ChannelMode.__empty_constructs__ = [format_mp3_ChannelMode.Stereo,format_mp3_ChannelMode.JointStereo,format_mp3_ChannelMode.DualChannel,format_mp3_ChannelMode.Mono];
var format_mp3_Emphasis = $hxEnums["format.mp3.Emphasis"] = { __ename__:true,__constructs__:null
	,NoEmphasis: {_hx_name:"NoEmphasis",_hx_index:0,__enum__:"format.mp3.Emphasis",toString:$estr}
	,Ms50_15: {_hx_name:"Ms50_15",_hx_index:1,__enum__:"format.mp3.Emphasis",toString:$estr}
	,CCIT_J17: {_hx_name:"CCIT_J17",_hx_index:2,__enum__:"format.mp3.Emphasis",toString:$estr}
	,InvalidEmphasis: {_hx_name:"InvalidEmphasis",_hx_index:3,__enum__:"format.mp3.Emphasis",toString:$estr}
};
format_mp3_Emphasis.__constructs__ = [format_mp3_Emphasis.NoEmphasis,format_mp3_Emphasis.Ms50_15,format_mp3_Emphasis.CCIT_J17,format_mp3_Emphasis.InvalidEmphasis];
format_mp3_Emphasis.__empty_constructs__ = [format_mp3_Emphasis.NoEmphasis,format_mp3_Emphasis.Ms50_15,format_mp3_Emphasis.CCIT_J17,format_mp3_Emphasis.InvalidEmphasis];
var format_mp3_FrameType = $hxEnums["format.mp3.FrameType"] = { __ename__:true,__constructs__:null
	,FT_MP3: {_hx_name:"FT_MP3",_hx_index:0,__enum__:"format.mp3.FrameType",toString:$estr}
	,FT_NONE: {_hx_name:"FT_NONE",_hx_index:1,__enum__:"format.mp3.FrameType",toString:$estr}
};
format_mp3_FrameType.__constructs__ = [format_mp3_FrameType.FT_MP3,format_mp3_FrameType.FT_NONE];
format_mp3_FrameType.__empty_constructs__ = [format_mp3_FrameType.FT_MP3,format_mp3_FrameType.FT_NONE];
var format_mp3_Reader = function(i) {
	this.i = i;
	i.set_bigEndian(true);
	this.bits = new format_tools_BitsInput(i);
	this.samples = 0;
	this.sampleSize = 0;
	this.any_read = false;
};
$hxClasses["format.mp3.Reader"] = format_mp3_Reader;
format_mp3_Reader.__name__ = "format.mp3.Reader";
format_mp3_Reader.prototype = {
	skipID3v2: function() {
		this.id3v2_version = this.i.readUInt16();
		this.id3v2_flags = this.i.readByte();
		var size = this.i.readByte() & 127;
		size = size << 7 | this.i.readByte() & 127;
		size = size << 7 | this.i.readByte() & 127;
		size = size << 7 | this.i.readByte() & 127;
		this.id3v2_data = this.i.read(size);
	}
	,seekFrame: function() {
		var found = false;
		try {
			var b;
			while(true) {
				b = this.i.readByte();
				if(!this.any_read) {
					this.any_read = true;
					if(b == 73) {
						b = this.i.readByte();
						if(b == 68) {
							b = this.i.readByte();
							if(b == 51) {
								this.skipID3v2();
							}
						}
					}
				}
				if(b == 255) {
					this.bits.nbits = 0;
					b = this.bits.readBits(3);
					if(b == 7) {
						return format_mp3_FrameType.FT_MP3;
					}
				}
			}
		} catch( _g ) {
			if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
				return format_mp3_FrameType.FT_NONE;
			} else {
				throw _g;
			}
		}
	}
	,readFrames: function() {
		var frames = [];
		var ft;
		while(true) {
			ft = this.seekFrame();
			if(!(ft != format_mp3_FrameType.FT_NONE)) {
				break;
			}
			switch(ft._hx_index) {
			case 0:
				var f = this.readFrame();
				if(f != null) {
					frames.push(f);
				}
				break;
			case 1:
				break;
			}
		}
		return frames;
	}
	,readFrameHeader: function() {
		var version = this.bits.readBits(2);
		var layer = this.bits.readBits(2);
		var hasCrc = !this.bits.readBit();
		if(version == format_mp3_MPEG.Reserved || layer == format_mp3_CLayer.LReserved) {
			return null;
		}
		var bitrateIdx = this.bits.readBits(4);
		var bitrate = format_mp3_Tools.getBitrate(version,layer,bitrateIdx);
		var samplingRateIdx = this.bits.readBits(2);
		var samplingRate = format_mp3_Tools.getSamplingRate(version,samplingRateIdx);
		var isPadded = this.bits.readBit();
		var privateBit = this.bits.readBit();
		if(bitrate == format_mp3_Bitrate.BR_Bad || bitrate == format_mp3_Bitrate.BR_Free || samplingRate == format_mp3_SamplingRate.SR_Bad) {
			return null;
		}
		var channelMode = this.bits.readBits(2);
		var isIntensityStereo = this.bits.readBit();
		var isMSStereo = this.bits.readBit();
		var isCopyrighted = this.bits.readBit();
		var isOriginal = this.bits.readBit();
		var emphasis = this.bits.readBits(2);
		var crc16 = 0;
		if(hasCrc) {
			crc16 = this.i.readUInt16();
		}
		return { version : format_mp3_MPEG.num2Enum(version), layer : format_mp3_CLayer.num2Enum(layer), hasCrc : hasCrc, crc16 : crc16, bitrate : bitrate, samplingRate : samplingRate, isPadded : isPadded, privateBit : privateBit, channelMode : format_mp3_CChannelMode.num2Enum(channelMode), isIntensityStereo : isIntensityStereo, isMSStereo : isMSStereo, isCopyrighted : isCopyrighted, isOriginal : isOriginal, emphasis : format_mp3_CEmphasis.num2Enum(emphasis)};
	}
	,readFrame: function() {
		var header = this.readFrameHeader();
		if(header == null || format_mp3_Tools.isInvalidFrameHeader(header)) {
			return null;
		}
		try {
			var data = this.i.read(format_mp3_Tools.getSampleDataSizeHdr(header));
			this.samples += format_mp3_Tools.getSampleCountHdr(header);
			this.sampleSize += data.length;
			return { header : header, data : data};
		} catch( _g ) {
			if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
				return null;
			} else {
				throw _g;
			}
		}
	}
	,read: function() {
		var fs = this.readFrames();
		return { frames : fs, sampleCount : this.samples, sampleSize : this.sampleSize, id3v2 : this.id3v2_data == null ? null : { versionBytes : this.id3v2_version, flagByte : this.id3v2_flags, data : this.id3v2_data}};
	}
	,__class__: format_mp3_Reader
};
var format_mp3_Tools = function() { };
$hxClasses["format.mp3.Tools"] = format_mp3_Tools;
format_mp3_Tools.__name__ = "format.mp3.Tools";
format_mp3_Tools.getBitrate = function(mpegVersion,layerIdx,bitrateIdx) {
	if(mpegVersion == format_mp3_MPEG.Reserved || layerIdx == format_mp3_CLayer.LReserved) {
		return format_mp3_Bitrate.BR_Bad;
	}
	return (mpegVersion == 3 ? format_mp3_MPEG.V1_Bitrates : format_mp3_MPEG.V2_Bitrates)[layerIdx][bitrateIdx];
};
format_mp3_Tools.getSamplingRate = function(mpegVersion,samplingRateIdx) {
	return format_mp3_MPEG.SamplingRates[mpegVersion][samplingRateIdx];
};
format_mp3_Tools.isInvalidFrameHeader = function(hdr) {
	if(!(hdr.version == format_mp3_MPEGVersion.MPEG_Reserved || hdr.layer == format_mp3_Layer.LayerReserved || hdr.bitrate == format_mp3_Bitrate.BR_Bad || hdr.bitrate == format_mp3_Bitrate.BR_Free)) {
		return hdr.samplingRate == format_mp3_SamplingRate.SR_Bad;
	} else {
		return true;
	}
};
format_mp3_Tools.getSampleDataSize = function(mpegVersion,bitrate,samplingRate,isPadded,hasCrc) {
	return ((mpegVersion == 3 ? 144 : 72) * bitrate * 1000 / samplingRate | 0) + (isPadded ? 1 : 0) - (hasCrc ? 2 : 0) - 4;
};
format_mp3_Tools.getSampleDataSizeHdr = function(hdr) {
	return format_mp3_Tools.getSampleDataSize(format_mp3_MPEG.enum2Num(hdr.version),format_mp3_MPEG.bitrateEnum2Num(hdr.bitrate),format_mp3_MPEG.srEnum2Num(hdr.samplingRate),hdr.isPadded,hdr.hasCrc);
};
format_mp3_Tools.getSampleCount = function(mpegVersion) {
	if(mpegVersion == 3) {
		return 1152;
	} else {
		return 576;
	}
};
format_mp3_Tools.getSampleCountHdr = function(hdr) {
	return format_mp3_Tools.getSampleCount(format_mp3_MPEG.enum2Num(hdr.version));
};
var format_png_Color = $hxEnums["format.png.Color"] = { __ename__:true,__constructs__:null
	,ColGrey: ($_=function(alpha) { return {_hx_index:0,alpha:alpha,__enum__:"format.png.Color",toString:$estr}; },$_._hx_name="ColGrey",$_.__params__ = ["alpha"],$_)
	,ColTrue: ($_=function(alpha) { return {_hx_index:1,alpha:alpha,__enum__:"format.png.Color",toString:$estr}; },$_._hx_name="ColTrue",$_.__params__ = ["alpha"],$_)
	,ColIndexed: {_hx_name:"ColIndexed",_hx_index:2,__enum__:"format.png.Color",toString:$estr}
};
format_png_Color.__constructs__ = [format_png_Color.ColGrey,format_png_Color.ColTrue,format_png_Color.ColIndexed];
format_png_Color.__empty_constructs__ = [format_png_Color.ColIndexed];
var format_png_Chunk = $hxEnums["format.png.Chunk"] = { __ename__:true,__constructs__:null
	,CEnd: {_hx_name:"CEnd",_hx_index:0,__enum__:"format.png.Chunk",toString:$estr}
	,CHeader: ($_=function(h) { return {_hx_index:1,h:h,__enum__:"format.png.Chunk",toString:$estr}; },$_._hx_name="CHeader",$_.__params__ = ["h"],$_)
	,CData: ($_=function(b) { return {_hx_index:2,b:b,__enum__:"format.png.Chunk",toString:$estr}; },$_._hx_name="CData",$_.__params__ = ["b"],$_)
	,CPalette: ($_=function(b) { return {_hx_index:3,b:b,__enum__:"format.png.Chunk",toString:$estr}; },$_._hx_name="CPalette",$_.__params__ = ["b"],$_)
	,CUnknown: ($_=function(id,data) { return {_hx_index:4,id:id,data:data,__enum__:"format.png.Chunk",toString:$estr}; },$_._hx_name="CUnknown",$_.__params__ = ["id","data"],$_)
};
format_png_Chunk.__constructs__ = [format_png_Chunk.CEnd,format_png_Chunk.CHeader,format_png_Chunk.CData,format_png_Chunk.CPalette,format_png_Chunk.CUnknown];
format_png_Chunk.__empty_constructs__ = [format_png_Chunk.CEnd];
var format_png_Reader = function(i) {
	this.i = i;
	i.set_bigEndian(true);
	this.checkCRC = true;
};
$hxClasses["format.png.Reader"] = format_png_Reader;
format_png_Reader.__name__ = "format.png.Reader";
format_png_Reader.prototype = {
	read: function() {
		var b = 137;
		if(this.i.readByte() != b) {
			throw haxe_Exception.thrown("Invalid header");
		}
		var b = 80;
		if(this.i.readByte() != b) {
			throw haxe_Exception.thrown("Invalid header");
		}
		var b = 78;
		if(this.i.readByte() != b) {
			throw haxe_Exception.thrown("Invalid header");
		}
		var b = 71;
		if(this.i.readByte() != b) {
			throw haxe_Exception.thrown("Invalid header");
		}
		var b = 13;
		if(this.i.readByte() != b) {
			throw haxe_Exception.thrown("Invalid header");
		}
		var b = 10;
		if(this.i.readByte() != b) {
			throw haxe_Exception.thrown("Invalid header");
		}
		var b = 26;
		if(this.i.readByte() != b) {
			throw haxe_Exception.thrown("Invalid header");
		}
		var b = 10;
		if(this.i.readByte() != b) {
			throw haxe_Exception.thrown("Invalid header");
		}
		var l = new haxe_ds_List();
		while(true) {
			var c = this.readChunk();
			l.add(c);
			if(c == format_png_Chunk.CEnd) {
				break;
			}
		}
		return l;
	}
	,readHeader: function(i) {
		i.set_bigEndian(true);
		var width = i.readInt32();
		var height = i.readInt32();
		var colbits = i.readByte();
		var color = i.readByte();
		var color1;
		switch(color) {
		case 0:
			color1 = format_png_Color.ColGrey(false);
			break;
		case 2:
			color1 = format_png_Color.ColTrue(false);
			break;
		case 3:
			color1 = format_png_Color.ColIndexed;
			break;
		case 4:
			color1 = format_png_Color.ColGrey(true);
			break;
		case 6:
			color1 = format_png_Color.ColTrue(true);
			break;
		default:
			throw haxe_Exception.thrown("Unknown color model " + color + ":" + colbits);
		}
		var compress = i.readByte();
		var filter = i.readByte();
		if(compress != 0 || filter != 0) {
			throw haxe_Exception.thrown("Invalid header");
		}
		var interlace = i.readByte();
		if(interlace != 0 && interlace != 1) {
			throw haxe_Exception.thrown("Invalid header");
		}
		return { width : width, height : height, colbits : colbits, color : color1, interlaced : interlace == 1};
	}
	,readChunk: function() {
		var dataLen = this.i.readInt32();
		var id = this.i.readString(4);
		var data = this.i.read(dataLen);
		var crc = this.i.readInt32();
		if(this.checkCRC) {
			var c_crc = -1;
			var tmp = (c_crc ^ HxOverrides.cca(id,0)) & 255;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			c_crc = c_crc >>> 8 ^ tmp;
			var tmp = (c_crc ^ HxOverrides.cca(id,1)) & 255;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			c_crc = c_crc >>> 8 ^ tmp;
			var tmp = (c_crc ^ HxOverrides.cca(id,2)) & 255;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			c_crc = c_crc >>> 8 ^ tmp;
			var tmp = (c_crc ^ HxOverrides.cca(id,3)) & 255;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			c_crc = c_crc >>> 8 ^ tmp;
			var b = data.b.bufferValue;
			var _g = 0;
			var _g1 = data.length;
			while(_g < _g1) {
				var i = _g++;
				var tmp = (c_crc ^ b.bytes[i]) & 255;
				tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
				tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
				tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
				tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
				tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
				tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
				tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
				tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
				c_crc = c_crc >>> 8 ^ tmp;
			}
			if((c_crc ^ -1) != crc) {
				throw haxe_Exception.thrown("CRC check failure");
			}
		}
		switch(id) {
		case "IDAT":
			return format_png_Chunk.CData(data);
		case "IEND":
			return format_png_Chunk.CEnd;
		case "IHDR":
			return format_png_Chunk.CHeader(this.readHeader(new haxe_io_BytesInput(data)));
		case "PLTE":
			return format_png_Chunk.CPalette(data);
		default:
			return format_png_Chunk.CUnknown(id,data);
		}
	}
	,__class__: format_png_Reader
};
var format_png_Tools = function() { };
$hxClasses["format.png.Tools"] = format_png_Tools;
format_png_Tools.__name__ = "format.png.Tools";
format_png_Tools.getHeader = function(d) {
	var _g_head = d.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var c = val;
		if(c._hx_index == 1) {
			var h = c.h;
			return h;
		}
	}
	throw haxe_Exception.thrown("Header not found");
};
format_png_Tools.getPalette = function(d) {
	var _g_head = d.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var c = val;
		if(c._hx_index == 3) {
			var b = c.b;
			return b;
		}
	}
	return null;
};
format_png_Tools.extract32 = function(d,bytes,flipY) {
	var h = format_png_Tools.getHeader(d);
	var bgra = bytes == null ? new haxe_io_Bytes(new ArrayBuffer(h.width * h.height * 4)) : bytes;
	var data = null;
	var fullData = null;
	var _g_head = d.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var c = val;
		if(c._hx_index == 2) {
			var b = c.b;
			if(fullData != null) {
				fullData.add(b);
			} else if(data == null) {
				data = b;
			} else {
				fullData = new haxe_io_BytesBuffer();
				fullData.add(data);
				fullData.add(b);
				data = null;
			}
		}
	}
	if(fullData != null) {
		data = fullData.getBytes();
	}
	if(data == null) {
		throw haxe_Exception.thrown("Data not found");
	}
	data = format_tools_Inflate.run(data);
	var r = 0;
	var w = 0;
	var lineDelta = 0;
	if(flipY) {
		lineDelta = -h.width * 8;
		w = (h.height - 1) * (h.width * 4);
	}
	var flipY1 = flipY ? -1 : 1;
	var _g = h.color;
	switch(_g._hx_index) {
	case 0:
		var alpha = _g.alpha;
		if(h.colbits != 8) {
			throw haxe_Exception.thrown("Unsupported color mode");
		}
		var width = h.width;
		var stride = (alpha ? 2 : 1) * width + 1;
		if(data.length < h.height * stride) {
			throw haxe_Exception.thrown("Not enough data");
		}
		var alphvaIdx = -1;
		if(!alpha) {
			var _g1_head = d.h;
			while(_g1_head != null) {
				var val = _g1_head.item;
				_g1_head = _g1_head.next;
				var t = val;
				if(t._hx_index == 4) {
					if(t.id == "tRNS") {
						var data1 = t.data;
						if(data1.length >= 2) {
							alphvaIdx = data1.b[1];
						}
						break;
					}
				}
			}
		}
		var _g1 = 0;
		var _g2 = h.height;
		while(_g1 < _g2) {
			var y = _g1++;
			var f = data.b[r++];
			switch(f) {
			case 0:
				if(alpha) {
					var _g3 = 0;
					var _g4 = width;
					while(_g3 < _g4) {
						var x = _g3++;
						var v = data.b[r++];
						bgra.b[w++] = v;
						bgra.b[w++] = v;
						bgra.b[w++] = v;
						bgra.b[w++] = data.b[r++];
					}
				} else {
					var _g5 = 0;
					var _g6 = width;
					while(_g5 < _g6) {
						var x1 = _g5++;
						var v1 = data.b[r++];
						bgra.b[w++] = v1;
						bgra.b[w++] = v1;
						bgra.b[w++] = v1;
						bgra.b[w++] = v1 == alphvaIdx ? 0 : 255;
					}
				}
				break;
			case 1:
				var cv = 0;
				var ca = 0;
				if(alpha) {
					var _g7 = 0;
					var _g8 = width;
					while(_g7 < _g8) {
						var x2 = _g7++;
						cv += data.b[r++];
						bgra.b[w++] = cv;
						bgra.b[w++] = cv;
						bgra.b[w++] = cv;
						ca += data.b[r++];
						bgra.b[w++] = ca;
					}
				} else {
					var _g9 = 0;
					var _g10 = width;
					while(_g9 < _g10) {
						var x3 = _g9++;
						cv += data.b[r++];
						bgra.b[w++] = cv;
						bgra.b[w++] = cv;
						bgra.b[w++] = cv;
						bgra.b[w++] = cv == alphvaIdx ? 0 : 255;
					}
				}
				break;
			case 2:
				var stride = y == 0 ? 0 : width * 4 * flipY1;
				if(alpha) {
					var _g11 = 0;
					var _g12 = width;
					while(_g11 < _g12) {
						var x4 = _g11++;
						var v2 = data.b[r++] + bgra.b[w - stride];
						bgra.b[w++] = v2;
						bgra.b[w++] = v2;
						bgra.b[w++] = v2;
						bgra.b[w++] = data.b[r++] + bgra.b[w - stride];
					}
				} else {
					var _g13 = 0;
					var _g14 = width;
					while(_g13 < _g14) {
						var x5 = _g13++;
						var v3 = data.b[r++] + bgra.b[w - stride];
						bgra.b[w++] = v3;
						bgra.b[w++] = v3;
						bgra.b[w++] = v3;
						bgra.b[w++] = v3 == alphvaIdx ? 0 : 255;
					}
				}
				break;
			case 3:
				var cv1 = 0;
				var ca1 = 0;
				var stride1 = y == 0 ? 0 : width * 4 * flipY1;
				if(alpha) {
					var _g15 = 0;
					var _g16 = width;
					while(_g15 < _g16) {
						var x6 = _g15++;
						cv1 = data.b[r++] + (cv1 + bgra.b[w - stride1] >> 1) & 255;
						bgra.b[w++] = cv1;
						bgra.b[w++] = cv1;
						bgra.b[w++] = cv1;
						ca1 = data.b[r++] + (ca1 + bgra.b[w - stride1] >> 1) & 255;
						bgra.b[w++] = ca1;
					}
				} else {
					var _g17 = 0;
					var _g18 = width;
					while(_g17 < _g18) {
						var x7 = _g17++;
						cv1 = data.b[r++] + (cv1 + bgra.b[w - stride1] >> 1) & 255;
						bgra.b[w++] = cv1;
						bgra.b[w++] = cv1;
						bgra.b[w++] = cv1;
						bgra.b[w++] = cv1 == alphvaIdx ? 0 : 255;
					}
				}
				break;
			case 4:
				var stride2 = width * 4 * flipY1;
				var cv2 = 0;
				var ca2 = 0;
				if(alpha) {
					var _g19 = 0;
					var _g20 = width;
					while(_g19 < _g20) {
						var x8 = _g19++;
						var b = y == 0 ? 0 : bgra.b[w - stride2];
						var c = x8 == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
						var k = cv2 + b - c;
						var pa = k - cv2;
						if(pa < 0) {
							pa = -pa;
						}
						var pb = k - b;
						if(pb < 0) {
							pb = -pb;
						}
						var pc = k - c;
						if(pc < 0) {
							pc = -pc;
						}
						var pos = r++;
						cv2 = (pa <= pb && pa <= pc ? cv2 : pb <= pc ? b : c) + data.b[pos] & 255;
						bgra.b[w++] = cv2;
						bgra.b[w++] = cv2;
						bgra.b[w++] = cv2;
						var b1 = y == 0 ? 0 : bgra.b[w - stride2];
						var c1 = x8 == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
						var k1 = ca2 + b1 - c1;
						var pa1 = k1 - ca2;
						if(pa1 < 0) {
							pa1 = -pa1;
						}
						var pb1 = k1 - b1;
						if(pb1 < 0) {
							pb1 = -pb1;
						}
						var pc1 = k1 - c1;
						if(pc1 < 0) {
							pc1 = -pc1;
						}
						var pos1 = r++;
						ca2 = (pa1 <= pb1 && pa1 <= pc1 ? ca2 : pb1 <= pc1 ? b1 : c1) + data.b[pos1] & 255;
						bgra.b[w++] = ca2;
					}
				} else {
					var _g21 = 0;
					var _g22 = width;
					while(_g21 < _g22) {
						var x9 = _g21++;
						var b2 = y == 0 ? 0 : bgra.b[w - stride2];
						var c2 = x9 == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
						var k2 = cv2 + b2 - c2;
						var pa2 = k2 - cv2;
						if(pa2 < 0) {
							pa2 = -pa2;
						}
						var pb2 = k2 - b2;
						if(pb2 < 0) {
							pb2 = -pb2;
						}
						var pc2 = k2 - c2;
						if(pc2 < 0) {
							pc2 = -pc2;
						}
						var pos2 = r++;
						cv2 = (pa2 <= pb2 && pa2 <= pc2 ? cv2 : pb2 <= pc2 ? b2 : c2) + data.b[pos2] & 255;
						bgra.b[w++] = cv2;
						bgra.b[w++] = cv2;
						bgra.b[w++] = cv2;
						bgra.b[w++] = cv2 == alphvaIdx ? 0 : 255;
					}
				}
				break;
			default:
				throw haxe_Exception.thrown("Invalid filter " + f);
			}
			w += lineDelta;
		}
		break;
	case 1:
		var alpha = _g.alpha;
		if(h.colbits != 8) {
			throw haxe_Exception.thrown("Unsupported color mode");
		}
		var width = h.width;
		var stride = (alpha ? 4 : 3) * width + 1;
		if(data.length < h.height * stride) {
			throw haxe_Exception.thrown("Not enough data");
		}
		var alphaRed = -1;
		var alphaGreen = -1;
		var alphaBlue = -1;
		if(!alpha) {
			var _g1_head = d.h;
			while(_g1_head != null) {
				var val = _g1_head.item;
				_g1_head = _g1_head.next;
				var t = val;
				if(t._hx_index == 4) {
					if(t.id == "tRNS") {
						var data1 = t.data;
						if(data1.length >= 6) {
							alphaRed = data1.b[1];
							alphaGreen = data1.b[3];
							alphaBlue = data1.b[5];
						}
						break;
					}
				}
			}
		}
		var cr = 0;
		var cg = 0;
		var cb = 0;
		var ca = 0;
		var _g = 0;
		var _g1 = h.height;
		while(_g < _g1) {
			var y = _g++;
			var f = data.b[r++];
			switch(f) {
			case 0:
				if(alpha) {
					var _g2 = 0;
					var _g3 = width;
					while(_g2 < _g3) {
						var x = _g2++;
						bgra.b[w++] = data.b[r + 2];
						bgra.b[w++] = data.b[r + 1];
						bgra.b[w++] = data.b[r];
						bgra.b[w++] = data.b[r + 3];
						r += 4;
					}
				} else {
					var _g4 = 0;
					var _g5 = width;
					while(_g4 < _g5) {
						var x1 = _g4++;
						cb = data.b[r + 2];
						bgra.b[w++] = cb;
						cg = data.b[r + 1];
						bgra.b[w++] = cg;
						cr = data.b[r];
						bgra.b[w++] = cr;
						bgra.b[w++] = cr == alphaRed && cg == alphaGreen && cb == alphaBlue ? 0 : 255;
						r += 3;
					}
				}
				break;
			case 1:
				ca = 0;
				cb = ca;
				cg = cb;
				cr = cg;
				if(alpha) {
					var _g6 = 0;
					var _g7 = width;
					while(_g6 < _g7) {
						var x2 = _g6++;
						cb += data.b[r + 2];
						bgra.b[w++] = cb;
						cg += data.b[r + 1];
						bgra.b[w++] = cg;
						cr += data.b[r];
						bgra.b[w++] = cr;
						ca += data.b[r + 3];
						bgra.b[w++] = ca;
						r += 4;
					}
				} else {
					var _g8 = 0;
					var _g9 = width;
					while(_g8 < _g9) {
						var x3 = _g8++;
						cb += data.b[r + 2];
						bgra.b[w++] = cb;
						cg += data.b[r + 1];
						bgra.b[w++] = cg;
						cr += data.b[r];
						bgra.b[w++] = cr;
						bgra.b[w++] = cr == alphaRed && cg == alphaGreen && cb == alphaBlue ? 0 : 255;
						r += 3;
					}
				}
				break;
			case 2:
				var stride = y == 0 ? 0 : width * 4 * flipY1;
				if(alpha) {
					var _g10 = 0;
					var _g11 = width;
					while(_g10 < _g11) {
						var x4 = _g10++;
						bgra.b[w] = data.b[r + 2] + bgra.b[w - stride];
						++w;
						bgra.b[w] = data.b[r + 1] + bgra.b[w - stride];
						++w;
						bgra.b[w] = data.b[r] + bgra.b[w - stride];
						++w;
						bgra.b[w] = data.b[r + 3] + bgra.b[w - stride];
						++w;
						r += 4;
					}
				} else {
					var _g12 = 0;
					var _g13 = width;
					while(_g12 < _g13) {
						var x5 = _g12++;
						cb = data.b[r + 2] + bgra.b[w - stride];
						bgra.b[w] = cb;
						++w;
						cg = data.b[r + 1] + bgra.b[w - stride];
						bgra.b[w] = cg;
						++w;
						cr = data.b[r] + bgra.b[w - stride];
						bgra.b[w] = cr;
						++w;
						bgra.b[w++] = cr == alphaRed && cg == alphaGreen && cb == alphaBlue ? 0 : 255;
						r += 3;
					}
				}
				break;
			case 3:
				ca = 0;
				cb = ca;
				cg = cb;
				cr = cg;
				var stride1 = y == 0 ? 0 : width * 4 * flipY1;
				if(alpha) {
					var _g14 = 0;
					var _g15 = width;
					while(_g14 < _g15) {
						var x6 = _g14++;
						cb = data.b[r + 2] + (cb + bgra.b[w - stride1] >> 1) & 255;
						bgra.b[w++] = cb;
						cg = data.b[r + 1] + (cg + bgra.b[w - stride1] >> 1) & 255;
						bgra.b[w++] = cg;
						cr = data.b[r] + (cr + bgra.b[w - stride1] >> 1) & 255;
						bgra.b[w++] = cr;
						ca = data.b[r + 3] + (ca + bgra.b[w - stride1] >> 1) & 255;
						bgra.b[w++] = ca;
						r += 4;
					}
				} else {
					var _g16 = 0;
					var _g17 = width;
					while(_g16 < _g17) {
						var x7 = _g16++;
						cb = data.b[r + 2] + (cb + bgra.b[w - stride1] >> 1) & 255;
						bgra.b[w++] = cb;
						cg = data.b[r + 1] + (cg + bgra.b[w - stride1] >> 1) & 255;
						bgra.b[w++] = cg;
						cr = data.b[r] + (cr + bgra.b[w - stride1] >> 1) & 255;
						bgra.b[w++] = cr;
						bgra.b[w++] = cr == alphaRed && cg == alphaGreen && cb == alphaBlue ? 0 : 255;
						r += 3;
					}
				}
				break;
			case 4:
				var stride2 = width * 4 * flipY1;
				ca = 0;
				cb = ca;
				cg = cb;
				cr = cg;
				if(alpha) {
					var _g18 = 0;
					var _g19 = width;
					while(_g18 < _g19) {
						var x8 = _g18++;
						var b = y == 0 ? 0 : bgra.b[w - stride2];
						var c = x8 == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
						var k = cb + b - c;
						var pa = k - cb;
						if(pa < 0) {
							pa = -pa;
						}
						var pb = k - b;
						if(pb < 0) {
							pb = -pb;
						}
						var pc = k - c;
						if(pc < 0) {
							pc = -pc;
						}
						cb = (pa <= pb && pa <= pc ? cb : pb <= pc ? b : c) + data.b[r + 2] & 255;
						bgra.b[w++] = cb;
						var b1 = y == 0 ? 0 : bgra.b[w - stride2];
						var c1 = x8 == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
						var k1 = cg + b1 - c1;
						var pa1 = k1 - cg;
						if(pa1 < 0) {
							pa1 = -pa1;
						}
						var pb1 = k1 - b1;
						if(pb1 < 0) {
							pb1 = -pb1;
						}
						var pc1 = k1 - c1;
						if(pc1 < 0) {
							pc1 = -pc1;
						}
						cg = (pa1 <= pb1 && pa1 <= pc1 ? cg : pb1 <= pc1 ? b1 : c1) + data.b[r + 1] & 255;
						bgra.b[w++] = cg;
						var b2 = y == 0 ? 0 : bgra.b[w - stride2];
						var c2 = x8 == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
						var k2 = cr + b2 - c2;
						var pa2 = k2 - cr;
						if(pa2 < 0) {
							pa2 = -pa2;
						}
						var pb2 = k2 - b2;
						if(pb2 < 0) {
							pb2 = -pb2;
						}
						var pc2 = k2 - c2;
						if(pc2 < 0) {
							pc2 = -pc2;
						}
						cr = (pa2 <= pb2 && pa2 <= pc2 ? cr : pb2 <= pc2 ? b2 : c2) + data.b[r] & 255;
						bgra.b[w++] = cr;
						var b3 = y == 0 ? 0 : bgra.b[w - stride2];
						var c3 = x8 == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
						var k3 = ca + b3 - c3;
						var pa3 = k3 - ca;
						if(pa3 < 0) {
							pa3 = -pa3;
						}
						var pb3 = k3 - b3;
						if(pb3 < 0) {
							pb3 = -pb3;
						}
						var pc3 = k3 - c3;
						if(pc3 < 0) {
							pc3 = -pc3;
						}
						ca = (pa3 <= pb3 && pa3 <= pc3 ? ca : pb3 <= pc3 ? b3 : c3) + data.b[r + 3] & 255;
						bgra.b[w++] = ca;
						r += 4;
					}
				} else {
					var _g20 = 0;
					var _g21 = width;
					while(_g20 < _g21) {
						var x9 = _g20++;
						var b4 = y == 0 ? 0 : bgra.b[w - stride2];
						var c4 = x9 == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
						var k4 = cb + b4 - c4;
						var pa4 = k4 - cb;
						if(pa4 < 0) {
							pa4 = -pa4;
						}
						var pb4 = k4 - b4;
						if(pb4 < 0) {
							pb4 = -pb4;
						}
						var pc4 = k4 - c4;
						if(pc4 < 0) {
							pc4 = -pc4;
						}
						cb = (pa4 <= pb4 && pa4 <= pc4 ? cb : pb4 <= pc4 ? b4 : c4) + data.b[r + 2] & 255;
						bgra.b[w++] = cb;
						var b5 = y == 0 ? 0 : bgra.b[w - stride2];
						var c5 = x9 == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
						var k5 = cg + b5 - c5;
						var pa5 = k5 - cg;
						if(pa5 < 0) {
							pa5 = -pa5;
						}
						var pb5 = k5 - b5;
						if(pb5 < 0) {
							pb5 = -pb5;
						}
						var pc5 = k5 - c5;
						if(pc5 < 0) {
							pc5 = -pc5;
						}
						cg = (pa5 <= pb5 && pa5 <= pc5 ? cg : pb5 <= pc5 ? b5 : c5) + data.b[r + 1] & 255;
						bgra.b[w++] = cg;
						var b6 = y == 0 ? 0 : bgra.b[w - stride2];
						var c6 = x9 == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
						var k6 = cr + b6 - c6;
						var pa6 = k6 - cr;
						if(pa6 < 0) {
							pa6 = -pa6;
						}
						var pb6 = k6 - b6;
						if(pb6 < 0) {
							pb6 = -pb6;
						}
						var pc6 = k6 - c6;
						if(pc6 < 0) {
							pc6 = -pc6;
						}
						cr = (pa6 <= pb6 && pa6 <= pc6 ? cr : pb6 <= pc6 ? b6 : c6) + data.b[r] & 255;
						bgra.b[w++] = cr;
						bgra.b[w++] = cr == alphaRed && cg == alphaGreen && cb == alphaBlue ? 0 : 255;
						r += 3;
					}
				}
				break;
			default:
				throw haxe_Exception.thrown("Invalid filter " + f);
			}
			w += lineDelta;
		}
		break;
	case 2:
		var pal = format_png_Tools.getPalette(d);
		if(pal == null) {
			throw haxe_Exception.thrown("PNG Palette is missing");
		}
		var alpha = null;
		var _g1_head = d.h;
		while(_g1_head != null) {
			var val = _g1_head.item;
			_g1_head = _g1_head.next;
			var t = val;
			if(t._hx_index == 4) {
				if(t.id == "tRNS") {
					var data1 = t.data;
					alpha = data1;
					break;
				}
			}
		}
		if(alpha != null && alpha.length < 1 << h.colbits) {
			var alpha2 = new haxe_io_Bytes(new ArrayBuffer(1 << h.colbits));
			alpha2.blit(0,alpha,0,alpha.length);
			alpha2.fill(alpha.length,alpha2.length - alpha.length,255);
			alpha = alpha2;
		}
		var width = h.width;
		var stride = Math.ceil(width * h.colbits / 8) + 1;
		if(data.length < h.height * stride) {
			throw haxe_Exception.thrown("Not enough data");
		}
		var tmp = h.width * h.colbits;
		var rline = tmp >> 3;
		var _g = 0;
		var _g1 = h.height;
		while(_g < _g1) {
			var y = _g++;
			var f = data.b[r++];
			if(f == 0) {
				r += rline;
				continue;
			}
			switch(f) {
			case 1:
				var c = 0;
				var _g2 = 0;
				var _g3 = width;
				while(_g2 < _g3) {
					var x = _g2++;
					var v = data.b[r];
					c += v;
					data.b[r++] = c & 255;
				}
				break;
			case 2:
				var stride = y == 0 ? 0 : rline + 1;
				var _g4 = 0;
				var _g5 = width;
				while(_g4 < _g5) {
					var x1 = _g4++;
					var v1 = data.b[r];
					data.b[r] = v1 + data.b[r - stride];
					++r;
				}
				break;
			case 3:
				var c1 = 0;
				var stride1 = y == 0 ? 0 : rline + 1;
				var _g6 = 0;
				var _g7 = width;
				while(_g6 < _g7) {
					var x2 = _g6++;
					var v2 = data.b[r];
					c1 = v2 + (c1 + data.b[r - stride1] >> 1) & 255;
					data.b[r++] = c1;
				}
				break;
			case 4:
				var stride2 = rline + 1;
				var c2 = 0;
				var _g8 = 0;
				var _g9 = width;
				while(_g8 < _g9) {
					var x3 = _g8++;
					var v3 = data.b[r];
					var numChannels = 1;
					if(numChannels == null) {
						numChannels = 4;
					}
					var b = y == 0 ? 0 : data.b[r - stride2];
					var c3 = x3 == 0 || y == 0 ? 0 : data.b[r - stride2 - numChannels];
					var k = c2 + b - c3;
					var pa = k - c2;
					if(pa < 0) {
						pa = -pa;
					}
					var pb = k - b;
					if(pb < 0) {
						pb = -pb;
					}
					var pc = k - c3;
					if(pc < 0) {
						pc = -pc;
					}
					c2 = (pa <= pb && pa <= pc ? c2 : pb <= pc ? b : c3) + v3 & 255;
					data.b[r++] = c2;
				}
				break;
			default:
				throw haxe_Exception.thrown("Invalid filter " + f);
			}
		}
		var r = 0;
		if(h.colbits == 8) {
			var _g = 0;
			var _g1 = h.height;
			while(_g < _g1) {
				var y = _g++;
				++r;
				var _g2 = 0;
				var _g3 = h.width;
				while(_g2 < _g3) {
					var x = _g2++;
					var c = data.b[r++];
					bgra.b[w++] = pal.b[c * 3 + 2];
					bgra.b[w++] = pal.b[c * 3 + 1];
					bgra.b[w++] = pal.b[c * 3];
					bgra.b[w++] = alpha != null ? alpha.b[c] : 255;
				}
				w += lineDelta;
			}
		} else if(h.colbits < 8) {
			var req = h.colbits;
			var mask = (1 << req) - 1;
			var _g = 0;
			var _g1 = h.height;
			while(_g < _g1) {
				var y = _g++;
				++r;
				var bits = 0;
				var nbits = 0;
				var _g2 = 0;
				var _g3 = h.width;
				while(_g2 < _g3) {
					var x = _g2++;
					if(nbits < req) {
						bits = bits << 8 | data.b[r++];
						nbits += 8;
					}
					var c = bits >>> nbits - req & mask;
					nbits -= req;
					bgra.b[w++] = pal.b[c * 3 + 2];
					bgra.b[w++] = pal.b[c * 3 + 1];
					bgra.b[w++] = pal.b[c * 3];
					bgra.b[w++] = alpha != null ? alpha.b[c] : 255;
				}
				w += lineDelta;
			}
		} else {
			throw haxe_Exception.thrown(h.colbits + " indexed bits per pixel not supported");
		}
		break;
	}
	return bgra;
};
var format_tga_ImageOrigin = $hxEnums["format.tga.ImageOrigin"] = { __ename__:true,__constructs__:null
	,BottomLeft: {_hx_name:"BottomLeft",_hx_index:0,__enum__:"format.tga.ImageOrigin",toString:$estr}
	,BottomRight: {_hx_name:"BottomRight",_hx_index:1,__enum__:"format.tga.ImageOrigin",toString:$estr}
	,TopLeft: {_hx_name:"TopLeft",_hx_index:2,__enum__:"format.tga.ImageOrigin",toString:$estr}
	,TopRight: {_hx_name:"TopRight",_hx_index:3,__enum__:"format.tga.ImageOrigin",toString:$estr}
};
format_tga_ImageOrigin.__constructs__ = [format_tga_ImageOrigin.BottomLeft,format_tga_ImageOrigin.BottomRight,format_tga_ImageOrigin.TopLeft,format_tga_ImageOrigin.TopRight];
format_tga_ImageOrigin.__empty_constructs__ = [format_tga_ImageOrigin.BottomLeft,format_tga_ImageOrigin.BottomRight,format_tga_ImageOrigin.TopLeft,format_tga_ImageOrigin.TopRight];
var format_tga_ImageType = $hxEnums["format.tga.ImageType"] = { __ename__:true,__constructs__:null
	,NoImage: {_hx_name:"NoImage",_hx_index:0,__enum__:"format.tga.ImageType",toString:$estr}
	,UncompressedColorMapped: {_hx_name:"UncompressedColorMapped",_hx_index:1,__enum__:"format.tga.ImageType",toString:$estr}
	,UncompressedTrueColor: {_hx_name:"UncompressedTrueColor",_hx_index:2,__enum__:"format.tga.ImageType",toString:$estr}
	,UncompressedBlackAndWhite: {_hx_name:"UncompressedBlackAndWhite",_hx_index:3,__enum__:"format.tga.ImageType",toString:$estr}
	,RunLengthColorMapped: {_hx_name:"RunLengthColorMapped",_hx_index:4,__enum__:"format.tga.ImageType",toString:$estr}
	,RunLengthTrueColor: {_hx_name:"RunLengthTrueColor",_hx_index:5,__enum__:"format.tga.ImageType",toString:$estr}
	,RunLengthBlackAndWhite: {_hx_name:"RunLengthBlackAndWhite",_hx_index:6,__enum__:"format.tga.ImageType",toString:$estr}
	,Unknown: ($_=function(type) { return {_hx_index:7,type:type,__enum__:"format.tga.ImageType",toString:$estr}; },$_._hx_name="Unknown",$_.__params__ = ["type"],$_)
};
format_tga_ImageType.__constructs__ = [format_tga_ImageType.NoImage,format_tga_ImageType.UncompressedColorMapped,format_tga_ImageType.UncompressedTrueColor,format_tga_ImageType.UncompressedBlackAndWhite,format_tga_ImageType.RunLengthColorMapped,format_tga_ImageType.RunLengthTrueColor,format_tga_ImageType.RunLengthBlackAndWhite,format_tga_ImageType.Unknown];
format_tga_ImageType.__empty_constructs__ = [format_tga_ImageType.NoImage,format_tga_ImageType.UncompressedColorMapped,format_tga_ImageType.UncompressedTrueColor,format_tga_ImageType.UncompressedBlackAndWhite,format_tga_ImageType.RunLengthColorMapped,format_tga_ImageType.RunLengthTrueColor,format_tga_ImageType.RunLengthBlackAndWhite];
var format_tga_Reader = function(i) {
	this.i = i;
	i.set_bigEndian(false);
};
$hxClasses["format.tga.Reader"] = format_tga_Reader;
format_tga_Reader.__name__ = "format.tga.Reader";
format_tga_Reader.prototype = {
	read: function() {
		var idLength = this.i.readByte();
		var header = this.readHeader();
		var id = idLength == 0 ? "" : this.i.readString(idLength);
		var colorMap = this.readColorMapData(header);
		return { header : header, imageId : id, colorMapData : colorMap, imageData : this.readImageData(header,colorMap), developerData : null};
	}
	,readHeader: function() {
		var colorMapType = this.i.readByte();
		var dataType;
		var dataId = this.i.readByte();
		switch(dataId) {
		case 0:
			dataType = format_tga_ImageType.NoImage;
			break;
		case 1:
			dataType = format_tga_ImageType.UncompressedColorMapped;
			break;
		case 2:
			dataType = format_tga_ImageType.UncompressedTrueColor;
			break;
		case 3:
			dataType = format_tga_ImageType.UncompressedBlackAndWhite;
			break;
		case 9:
			dataType = format_tga_ImageType.RunLengthColorMapped;
			break;
		case 10:
			dataType = format_tga_ImageType.RunLengthTrueColor;
			break;
		case 11:
			dataType = format_tga_ImageType.RunLengthBlackAndWhite;
			break;
		default:
			dataType = format_tga_ImageType.Unknown(dataId);
		}
		var colorMapOrigin = this.i.readInt16();
		var colorMapLength = this.i.readInt16();
		var colorMapDepth = this.i.readByte();
		var xOrigin = this.i.readInt16();
		var yOrigin = this.i.readInt16();
		var width = this.i.readInt16();
		var height = this.i.readInt16();
		var depth = this.i.readByte();
		var descriptor = this.i.readByte();
		var origin;
		switch(descriptor & 48) {
		case 16:
			origin = format_tga_ImageOrigin.BottomRight;
			break;
		case 32:
			origin = format_tga_ImageOrigin.TopLeft;
			break;
		case 48:
			origin = format_tga_ImageOrigin.TopRight;
			break;
		default:
			origin = format_tga_ImageOrigin.BottomLeft;
		}
		return { colorMapType : colorMapType, imageType : dataType, colorMapFirstIndex : colorMapOrigin, colorMapLength : colorMapLength, colorMapEntrySize : colorMapDepth, xOrigin : xOrigin, yOrigin : yOrigin, width : width, height : height, bitsPerPixel : depth, alphaChannelBits : descriptor & 15, imageOrigin : origin};
	}
	,readColorMapData: function(header) {
		if(header.colorMapType == 0) {
			return null;
		}
		return this.readPixels(header.colorMapEntrySize,header.colorMapLength,header.alphaChannelBits,false);
	}
	,readImageData: function(header,colorMap) {
		switch(header.imageType._hx_index) {
		case 0:
			return null;
		case 1:
			return this.readIndexes(header.bitsPerPixel,header.width * header.height,colorMap,header.colorMapFirstIndex,false);
		case 2:
			return this.readPixels(header.bitsPerPixel,header.width * header.height,header.alphaChannelBits,false);
		case 3:
			return this.readMono(header.bitsPerPixel,header.width * header.height,header.alphaChannelBits,false);
		case 4:
			return this.readIndexes(header.bitsPerPixel,header.width * header.height,colorMap,header.colorMapFirstIndex,true);
		case 5:
			return this.readPixels(header.bitsPerPixel,header.width * header.height,header.alphaChannelBits,true);
		case 6:
			return this.readMono(header.bitsPerPixel,header.width * header.height,header.alphaChannelBits,true);
		default:
			throw haxe_Exception.thrown("Unsupported image data type!");
		}
	}
	,readPixels: function(bitsPerPixel,amount,alphaChannelBits,rle) {
		var this1 = new Array(amount);
		var list = this1;
		var alpha = alphaChannelBits != 0;
		var bitFieldSize = bitsPerPixel / 3 | 0;
		if(bitFieldSize > 8) {
			bitFieldSize = 8;
		}
		var parsePixel;
		var readEntry;
		switch(bitsPerPixel) {
		case 8:
			readEntry = ($_=this.i,$bind($_,$_.readByte));
			parsePixel = $bind(this,this.parsePixel1);
			break;
		case 16:
			readEntry = ($_=this.i,$bind($_,$_.readUInt16));
			parsePixel = $bind(this,this.parsePixel2);
			break;
		case 24:
			readEntry = ($_=this.i,$bind($_,$_.readUInt24));
			parsePixel = $bind(this,this.parsePixel3);
			break;
		case 32:
			readEntry = ($_=this.i,$bind($_,$_.readInt32));
			parsePixel = $bind(this,this.parsePixel4);
			break;
		default:
			throw haxe_Exception.thrown("Unsupported bits per pixels amount!");
		}
		if(rle) {
			var rleChunk;
			var i = 0;
			while(i < amount) {
				rleChunk = this.i.readByte();
				if((rleChunk & 128) != 0) {
					rleChunk &= 127;
					var pixel = parsePixel(readEntry(),alpha);
					while(rleChunk >= 0) {
						list[i++] = pixel;
						--rleChunk;
					}
				} else {
					rleChunk &= 127;
					while(rleChunk >= 0) {
						list[i++] = parsePixel(readEntry(),alpha);
						--rleChunk;
					}
				}
			}
		} else {
			var _g = 0;
			var _g1 = amount;
			while(_g < _g1) {
				var i = _g++;
				list[i] = parsePixel(readEntry(),alpha);
			}
		}
		return list;
	}
	,readMono: function(bitsPerPixel,amount,alphaChannelBits,rle) {
		var this1 = new Array(amount);
		var list = this1;
		var alpha = alphaChannelBits != 0;
		var parsePixel;
		var readEntry;
		switch(bitsPerPixel) {
		case 8:
			readEntry = ($_=this.i,$bind($_,$_.readByte));
			parsePixel = $bind(this,this.parsePixel1);
			break;
		case 16:
			readEntry = ($_=this.i,$bind($_,$_.readUInt16));
			parsePixel = $bind(this,this.parsePixelGreyAlpha);
			break;
		default:
			throw haxe_Exception.thrown("Unsupported bits per pixels amount!");
		}
		if(rle) {
			var rleChunk;
			var i = 0;
			while(i < amount) {
				rleChunk = this.i.readByte();
				if((rleChunk & 128) != 0) {
					rleChunk &= 127;
					var pixel = parsePixel(readEntry(),alpha);
					while(rleChunk >= 0) {
						list[i++] = pixel;
						--rleChunk;
					}
				} else {
					rleChunk &= 127;
					while(rleChunk >= 0) {
						list[i++] = parsePixel(readEntry(),alpha);
						--rleChunk;
					}
				}
			}
		} else {
			var _g = 0;
			var _g1 = amount;
			while(_g < _g1) {
				var i = _g++;
				list[i] = parsePixel(readEntry(),alpha);
			}
		}
		return list;
	}
	,readIndexes: function(bitsPerPixel,amount,colorMap,offset,rle) {
		var this1 = new Array(amount);
		var list = this1;
		var readEntry;
		switch(bitsPerPixel) {
		case 8:
			readEntry = ($_=this.i,$bind($_,$_.readByte));
			break;
		case 16:
			readEntry = ($_=this.i,$bind($_,$_.readUInt16));
			break;
		case 24:
			readEntry = ($_=this.i,$bind($_,$_.readUInt24));
			break;
		case 32:
			readEntry = ($_=this.i,$bind($_,$_.readInt32));
			break;
		default:
			throw haxe_Exception.thrown("Unsupported bits per pixels amount!");
		}
		if(rle) {
			var i = 0;
			var rleChunk;
			while(i < amount) {
				rleChunk = this.i.readByte();
				if((rleChunk & 128) != 0) {
					rleChunk &= 127;
					var pixel = colorMap[offset + readEntry()];
					while(rleChunk >= 0) {
						list[i++] = pixel;
						--rleChunk;
					}
				} else {
					rleChunk &= 127;
					while(rleChunk >= 0) {
						list[i++] = colorMap[offset + readEntry()];
						--rleChunk;
					}
				}
			}
		} else {
			var _g = 0;
			var _g1 = amount;
			while(_g < _g1) {
				var i = _g++;
				list[i] = colorMap[offset + readEntry()];
			}
		}
		return list;
	}
	,parsePixel1: function(value,alpha) {
		return value << 16 | value << 8 | value;
	}
	,parsePixelGreyAlpha: function(value,alpha) {
		return (alpha ? (value & 65280) << 16 : 0) | this.parsePixel1(value & 255,false);
	}
	,parsePixel2: function(value,alpha) {
		return (alpha ? (value & 32768) == 1 ? -16777216 : 0 : 0) | (((value & 31744) >> 10) / 31 * 255 | 0) << 16 | (((value & 992) >> 5) / 31 * 255 | 0) << 8 | ((value & 31) / 31 * 255 | 0);
	}
	,parsePixel3: function(value,alpha) {
		return value;
	}
	,parsePixel4: function(value,alpha) {
		return value;
	}
	,__class__: format_tga_Reader
};
var format_tools_BitsInput = function(i) {
	this.i = i;
	this.nbits = 0;
	this.bits = 0;
};
$hxClasses["format.tools.BitsInput"] = format_tools_BitsInput;
format_tools_BitsInput.__name__ = "format.tools.BitsInput";
format_tools_BitsInput.prototype = {
	readBits: function(n) {
		if(this.nbits >= n) {
			var c = this.nbits - n;
			var k = this.bits >>> c & (1 << n) - 1;
			this.nbits = c;
			return k;
		}
		var k = this.i.readByte();
		if(this.nbits >= 24) {
			if(n > 31) {
				throw haxe_Exception.thrown("Bits error");
			}
			var c = 8 + this.nbits - n;
			var d = this.bits & (1 << this.nbits) - 1;
			d = d << 8 - c | k << c;
			this.bits = k;
			this.nbits = c;
			return d;
		}
		this.bits = this.bits << 8 | k;
		this.nbits += 8;
		return this.readBits(n);
	}
	,readBit: function() {
		if(this.nbits == 0) {
			this.bits = this.i.readByte();
			this.nbits = 8;
		}
		this.nbits--;
		return (this.bits >>> this.nbits & 1) == 1;
	}
	,__class__: format_tools_BitsInput
};
var format_tools_Inflate = function() { };
$hxClasses["format.tools.Inflate"] = format_tools_Inflate;
format_tools_Inflate.__name__ = "format.tools.Inflate";
format_tools_Inflate.run = function(bytes) {
	return haxe_zip_Uncompress.run(bytes);
};
var format_wav_WAVEFormat = $hxEnums["format.wav.WAVEFormat"] = { __ename__:true,__constructs__:null
	,WF_PCM: {_hx_name:"WF_PCM",_hx_index:0,__enum__:"format.wav.WAVEFormat",toString:$estr}
};
format_wav_WAVEFormat.__constructs__ = [format_wav_WAVEFormat.WF_PCM];
format_wav_WAVEFormat.__empty_constructs__ = [format_wav_WAVEFormat.WF_PCM];
var format_wav_Reader = function(i) {
	this.i = i;
	i.set_bigEndian(false);
};
$hxClasses["format.wav.Reader"] = format_wav_Reader;
format_wav_Reader.__name__ = "format.wav.Reader";
format_wav_Reader.prototype = {
	read: function() {
		if(this.i.readString(4) != "RIFF") {
			throw haxe_Exception.thrown("RIFF header expected");
		}
		var len = this.i.readInt32();
		if(this.i.readString(4) != "WAVE") {
			throw haxe_Exception.thrown("WAVE signature not found");
		}
		var fmt = this.i.readString(4);
		_hx_loop1: while(fmt != "fmt ") switch(fmt) {
		case "JUNK":
			var junkLen = this.i.readInt32();
			this.i.read(junkLen);
			fmt = this.i.readString(4);
			break;
		case "bext":
			var bextLen = this.i.readInt32();
			this.i.read(bextLen);
			fmt = this.i.readString(4);
			break;
		default:
			break _hx_loop1;
		}
		if(fmt != "fmt ") {
			throw haxe_Exception.thrown("unsupported wave chunk " + fmt);
		}
		var fmtlen = this.i.readInt32();
		var format;
		switch(this.i.readUInt16()) {
		case 1:case 3:
			format = format_wav_WAVEFormat.WF_PCM;
			break;
		default:
			throw haxe_Exception.thrown("only PCM (uncompressed) WAV files are supported");
		}
		var channels = this.i.readUInt16();
		var samplingRate = this.i.readInt32();
		var byteRate = this.i.readInt32();
		var blockAlign = this.i.readUInt16();
		var bitsPerSample = this.i.readUInt16();
		if(fmtlen > 16) {
			this.i.read(fmtlen - 16);
		}
		var nextChunk = this.i.readString(4);
		while(nextChunk != "data") {
			this.i.read(this.i.readInt32());
			nextChunk = this.i.readString(4);
		}
		if(nextChunk != "data") {
			throw haxe_Exception.thrown("expected data subchunk");
		}
		var datalen = this.i.readInt32();
		var data;
		try {
			data = this.i.read(datalen);
		} catch( _g ) {
			if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
				throw haxe_Exception.thrown("Invalid chunk data length");
			} else {
				throw _g;
			}
		}
		var cuePoints = [];
		try {
			while(true) {
				var nextChunk = this.i.readString(4);
				if(nextChunk == "cue ") {
					this.i.readInt32();
					var nbCuePoints = this.i.readInt32();
					var _g = 0;
					var _g1 = nbCuePoints;
					while(_g < _g1) {
						var _ = _g++;
						var cueId = this.i.readInt32();
						this.i.readInt32();
						this.i.readString(4);
						this.i.readInt32();
						this.i.readInt32();
						var cueSampleOffset = this.i.readInt32();
						cuePoints.push({ id : cueId, sampleOffset : cueSampleOffset});
					}
				} else {
					this.i.read(this.i.readInt32());
				}
			}
		} catch( _g ) {
			if(!((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
				throw _g;
			}
		}
		return { header : { format : format, channels : channels, samplingRate : samplingRate, byteRate : byteRate, blockAlign : blockAlign, bitsPerSample : bitsPerSample}, data : data, cuePoints : cuePoints};
	}
	,__class__: format_wav_Reader
};
var h2d_Bitmap = function(tile,parent) {
	h2d_Drawable.call(this,parent);
	this.set_tile(tile);
};
$hxClasses["h2d.Bitmap"] = h2d_Bitmap;
h2d_Bitmap.__name__ = "h2d.Bitmap";
h2d_Bitmap.__super__ = h2d_Drawable;
h2d_Bitmap.prototype = $extend(h2d_Drawable.prototype,{
	getBoundsRec: function(relativeTo,out,forSize) {
		h2d_Drawable.prototype.getBoundsRec.call(this,relativeTo,out,forSize);
		if(this.tile != null) {
			if(this.width == null && this.height == null) {
				this.addBounds(relativeTo,out,this.tile.dx,this.tile.dy,this.tile.width,this.tile.height);
			} else {
				this.addBounds(relativeTo,out,this.tile.dx,this.tile.dy,this.width != null ? this.width : this.tile.width * this.height / this.tile.height,this.height != null ? this.height : this.tile.height * this.width / this.tile.width);
			}
		}
	}
	,set_tile: function(t) {
		if(this.tile == t) {
			return t;
		}
		this.tile = t;
		if(this.parentContainer != null) {
			this.parentContainer.contentChanged(this);
		}
		return t;
	}
	,draw: function(ctx) {
		if(this.width == null && this.height == null) {
			this.emitTile(ctx,this.tile);
			return;
		}
		if(this.tile == null) {
			this.set_tile(h2d_Tile.fromColor(16711935));
		}
		var ow = this.tile.width;
		var oh = this.tile.height;
		this.tile.width = this.width != null ? this.width : ow * this.height / oh;
		this.tile.height = this.height != null ? this.height : oh * this.width / ow;
		this.emitTile(ctx,this.tile);
		this.tile.width = ow;
		this.tile.height = oh;
	}
	,__class__: h2d_Bitmap
});
var h2d_BlendMode = $hxEnums["h2d.BlendMode"] = { __ename__:true,__constructs__:null
	,None: {_hx_name:"None",_hx_index:0,__enum__:"h2d.BlendMode",toString:$estr}
	,Alpha: {_hx_name:"Alpha",_hx_index:1,__enum__:"h2d.BlendMode",toString:$estr}
	,Add: {_hx_name:"Add",_hx_index:2,__enum__:"h2d.BlendMode",toString:$estr}
	,AlphaAdd: {_hx_name:"AlphaAdd",_hx_index:3,__enum__:"h2d.BlendMode",toString:$estr}
	,SoftAdd: {_hx_name:"SoftAdd",_hx_index:4,__enum__:"h2d.BlendMode",toString:$estr}
	,Multiply: {_hx_name:"Multiply",_hx_index:5,__enum__:"h2d.BlendMode",toString:$estr}
	,AlphaMultiply: {_hx_name:"AlphaMultiply",_hx_index:6,__enum__:"h2d.BlendMode",toString:$estr}
	,Erase: {_hx_name:"Erase",_hx_index:7,__enum__:"h2d.BlendMode",toString:$estr}
	,Screen: {_hx_name:"Screen",_hx_index:8,__enum__:"h2d.BlendMode",toString:$estr}
	,Sub: {_hx_name:"Sub",_hx_index:9,__enum__:"h2d.BlendMode",toString:$estr}
	,Max: {_hx_name:"Max",_hx_index:10,__enum__:"h2d.BlendMode",toString:$estr}
	,Min: {_hx_name:"Min",_hx_index:11,__enum__:"h2d.BlendMode",toString:$estr}
};
h2d_BlendMode.__constructs__ = [h2d_BlendMode.None,h2d_BlendMode.Alpha,h2d_BlendMode.Add,h2d_BlendMode.AlphaAdd,h2d_BlendMode.SoftAdd,h2d_BlendMode.Multiply,h2d_BlendMode.AlphaMultiply,h2d_BlendMode.Erase,h2d_BlendMode.Screen,h2d_BlendMode.Sub,h2d_BlendMode.Max,h2d_BlendMode.Min];
h2d_BlendMode.__empty_constructs__ = [h2d_BlendMode.None,h2d_BlendMode.Alpha,h2d_BlendMode.Add,h2d_BlendMode.AlphaAdd,h2d_BlendMode.SoftAdd,h2d_BlendMode.Multiply,h2d_BlendMode.AlphaMultiply,h2d_BlendMode.Erase,h2d_BlendMode.Screen,h2d_BlendMode.Sub,h2d_BlendMode.Max,h2d_BlendMode.Min];
var h2d_Camera = function(scene) {
	this.followRotation = false;
	this.posChanged = true;
	this.x = 0;
	this.posChanged = true;
	this.y = 0;
	this.posChanged = true;
	this.scaleX = 1;
	this.posChanged = true;
	this.scaleY = 1;
	this.posChanged = true;
	this.rotation = 0;
	this.posChanged = true;
	this.anchorX = 0;
	this.posChanged = true;
	this.anchorY = 0;
	this.viewX = 0;
	this.viewY = 0;
	this.viewW = 1;
	this.viewH = 1;
	this.visible = true;
	if(scene != null) {
		scene.addCamera(this);
	}
};
$hxClasses["h2d.Camera"] = h2d_Camera;
h2d_Camera.__name__ = "h2d.Camera";
h2d_Camera.prototype = {
	layerVisible: function(layer) {
		return true;
	}
	,enter: function(ctx) {
		ctx.pushCamera(this);
		if(this.clipViewport) {
			var old = ctx.inFilter;
			ctx.inFilter = null;
			ctx.pushRenderZone(this.viewX * this.scene.width,this.viewY * this.scene.height,this.viewW * this.scene.width,this.viewH * this.scene.height);
			ctx.inFilter = old;
		}
	}
	,exit: function(ctx) {
		if(this.clipViewport) {
			var old = ctx.inFilter;
			ctx.inFilter = null;
			ctx.popRenderZone();
			ctx.inFilter = old;
		}
		ctx.popCamera();
	}
	,sync: function(ctx,force) {
		if(force == null) {
			force = false;
		}
		if(this.scene == null) {
			return;
		}
		if(this.follow != null) {
			this.posChanged = true;
			this.x = this.follow.absX;
			this.posChanged = true;
			this.y = this.follow.absY;
			if(this.followRotation) {
				this.posChanged = true;
				this.rotation = -this.follow.rotation;
			}
		}
		if(this.posChanged || force) {
			if(this.rotation == 0) {
				this.matA = this.scaleX;
				this.matB = 0;
				this.matC = 0;
				this.matD = this.scaleY;
			} else {
				var cr = Math.cos(this.rotation);
				var sr = Math.sin(this.rotation);
				this.matA = this.scaleX * cr;
				this.matB = this.scaleX * sr;
				this.matC = this.scaleY * -sr;
				this.matD = this.scaleY * cr;
			}
			this.absX = Math.round(-(this.x * this.matA + this.y * this.matC) + this.scene.width * this.anchorX * this.viewW + this.scene.width * this.viewX);
			this.absY = Math.round(-(this.x * this.matB + this.y * this.matD) + this.scene.height * this.anchorY * this.viewH + this.scene.height * this.viewY);
			this.invDet = 1 / (this.matA * this.matD - this.matB * this.matC);
			this.posChanged = false;
		}
	}
	,eventToCamera: function(e) {
		var x = (e.relX - this.scene.offsetX) / this.scene.viewportScaleX - this.absX;
		var y = (e.relY - this.scene.offsetY) / this.scene.viewportScaleY - this.absY;
		e.relX = (x * this.matD - y * this.matC) * this.invDet;
		e.relY = (-x * this.matB + y * this.matA) * this.invDet;
	}
	,__class__: h2d_Camera
};
var h2d_FlowAlign = $hxEnums["h2d.FlowAlign"] = { __ename__:true,__constructs__:null
	,Top: {_hx_name:"Top",_hx_index:0,__enum__:"h2d.FlowAlign",toString:$estr}
	,Left: {_hx_name:"Left",_hx_index:1,__enum__:"h2d.FlowAlign",toString:$estr}
	,Right: {_hx_name:"Right",_hx_index:2,__enum__:"h2d.FlowAlign",toString:$estr}
	,Middle: {_hx_name:"Middle",_hx_index:3,__enum__:"h2d.FlowAlign",toString:$estr}
	,Bottom: {_hx_name:"Bottom",_hx_index:4,__enum__:"h2d.FlowAlign",toString:$estr}
};
h2d_FlowAlign.__constructs__ = [h2d_FlowAlign.Top,h2d_FlowAlign.Left,h2d_FlowAlign.Right,h2d_FlowAlign.Middle,h2d_FlowAlign.Bottom];
h2d_FlowAlign.__empty_constructs__ = [h2d_FlowAlign.Top,h2d_FlowAlign.Left,h2d_FlowAlign.Right,h2d_FlowAlign.Middle,h2d_FlowAlign.Bottom];
var h2d_FlowLayout = $hxEnums["h2d.FlowLayout"] = { __ename__:true,__constructs__:null
	,Horizontal: {_hx_name:"Horizontal",_hx_index:0,__enum__:"h2d.FlowLayout",toString:$estr}
	,Vertical: {_hx_name:"Vertical",_hx_index:1,__enum__:"h2d.FlowLayout",toString:$estr}
	,Stack: {_hx_name:"Stack",_hx_index:2,__enum__:"h2d.FlowLayout",toString:$estr}
};
h2d_FlowLayout.__constructs__ = [h2d_FlowLayout.Horizontal,h2d_FlowLayout.Vertical,h2d_FlowLayout.Stack];
h2d_FlowLayout.__empty_constructs__ = [h2d_FlowLayout.Horizontal,h2d_FlowLayout.Vertical,h2d_FlowLayout.Stack];
var h2d_FlowOverflow = $hxEnums["h2d.FlowOverflow"] = { __ename__:true,__constructs__:null
	,Expand: {_hx_name:"Expand",_hx_index:0,__enum__:"h2d.FlowOverflow",toString:$estr}
	,Limit: {_hx_name:"Limit",_hx_index:1,__enum__:"h2d.FlowOverflow",toString:$estr}
	,Hidden: {_hx_name:"Hidden",_hx_index:2,__enum__:"h2d.FlowOverflow",toString:$estr}
	,Scroll: {_hx_name:"Scroll",_hx_index:3,__enum__:"h2d.FlowOverflow",toString:$estr}
};
h2d_FlowOverflow.__constructs__ = [h2d_FlowOverflow.Expand,h2d_FlowOverflow.Limit,h2d_FlowOverflow.Hidden,h2d_FlowOverflow.Scroll];
h2d_FlowOverflow.__empty_constructs__ = [h2d_FlowOverflow.Expand,h2d_FlowOverflow.Limit,h2d_FlowOverflow.Hidden,h2d_FlowOverflow.Scroll];
var h2d_FlowProperties = function(elt) {
	this.constraint = true;
	this.lineBreak = false;
	this.calculatedHeight = 0;
	this.calculatedWidth = 0;
	this.offsetY = 0;
	this.offsetX = 0;
	this.isAbsolute = false;
	this.paddingBottom = 0;
	this.paddingRight = 0;
	this.paddingTop = 0;
	this.paddingLeft = 0;
	this.elt = elt;
};
$hxClasses["h2d.FlowProperties"] = h2d_FlowProperties;
h2d_FlowProperties.__name__ = "h2d.FlowProperties";
h2d_FlowProperties.prototype = {
	set_isAbsolute: function(a) {
		if(a) {
			this.elt.constraintSize(-1,-1);
			this.isBreak = false;
		}
		return this.isAbsolute = a;
	}
	,__class__: h2d_FlowProperties
};
var h2d_Flow = function(parent) {
	this.realMinHeight = -1;
	this.realMinWidth = -1;
	this.realMaxHeight = -1;
	this.realMaxWidth = -1;
	this.constraintHeight = -1;
	this.constraintWidth = -1;
	this.contentHeight = 0.;
	this.contentWidth = 0.;
	this.calculatedHeight = 0.;
	this.calculatedWidth = 0.;
	this.properties = [];
	this.scrollPosY = 0.;
	this.scrollWheelSpeed = 30.;
	this.fillHeight = false;
	this.fillWidth = false;
	this.reverse = false;
	this.multiline = false;
	this.isInline = true;
	this.layout = h2d_FlowLayout.Horizontal;
	this.borderBottom = 0;
	this.borderTop = 0;
	this.borderRight = 0;
	this.borderLeft = 0;
	this.verticalSpacing = 0;
	this.horizontalSpacing = 0;
	this.paddingBottom = 0;
	this.paddingTop = 0;
	this.paddingRight = 0;
	this.paddingLeft = 0;
	this.overflow = h2d_FlowOverflow.Expand;
	this.needReflow = true;
	this.tmpBounds = new h2d_col_Bounds();
	h2d_Object.call(this,parent);
};
$hxClasses["h2d.Flow"] = h2d_Flow;
h2d_Flow.__name__ = "h2d.Flow";
h2d_Flow.__super__ = h2d_Object;
h2d_Flow.prototype = $extend(h2d_Object.prototype,{
	getProperties: function(e) {
		this.set_needReflow(true);
		return this.properties[this.getChildIndex(e)];
	}
	,set_layout: function(v) {
		if(this.layout == v) {
			return v;
		}
		this.set_needReflow(true);
		return this.layout = v == null ? h2d_FlowLayout.Horizontal : v;
	}
	,set_horizontalAlign: function(v) {
		if(this.horizontalAlign == v) {
			return v;
		}
		this.set_needReflow(true);
		return this.horizontalAlign = v;
	}
	,set_needReflow: function(v) {
		if(this.needReflow == v) {
			return v;
		}
		if(v) {
			if(this.parentContainer != null) {
				this.parentContainer.contentChanged(this);
			}
		}
		return this.needReflow = v;
	}
	,set_padding: function(v) {
		this.set_paddingLeft(v);
		this.set_paddingTop(v);
		this.set_paddingRight(v);
		this.set_paddingBottom(v);
		return v;
	}
	,set_scrollPosY: function(v) {
		if(this.needReflow) {
			this.reflow();
		}
		if(v < 0) {
			v = 0;
		}
		if(v > this.contentHeight - this.calculatedHeight) {
			v = this.contentHeight - this.calculatedHeight;
		}
		if(this.scrollPosY == v) {
			return v;
		}
		var delta = (v | 0) - (this.scrollPosY | 0);
		var i = 0;
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			var p = this.properties[i++];
			if(p.isAbsolute) {
				continue;
			}
			c.posChanged = true;
			c.y -= delta;
		}
		this.scrollPosY = v;
		this.updateScrollCursor();
		return v;
	}
	,updateScrollCursor: function() {
		if(this.scrollBarCursor == null) {
			return;
		}
		var prev = this.needReflow;
		var p = this.scrollBar.getProperties(this.scrollBarCursor);
		p.paddingTop = this.scrollPosY * (this.calculatedHeight - this.scrollBarCursor.minHeight) / (this.contentHeight - this.calculatedHeight) | 0;
		this.set_needReflow(prev);
	}
	,get_outerWidth: function() {
		if(this.needReflow) {
			this.reflow();
		}
		return Math.ceil(this.calculatedWidth);
	}
	,get_outerHeight: function() {
		if(this.needReflow) {
			this.reflow();
		}
		return Math.ceil(this.calculatedHeight);
	}
	,get_innerWidth: function() {
		if(this.needReflow) {
			this.reflow();
		}
		return Math.ceil(this.calculatedWidth) - (this.paddingLeft + this.paddingRight);
	}
	,get_innerHeight: function() {
		if(this.needReflow) {
			this.reflow();
		}
		return Math.ceil(this.calculatedHeight) - (this.paddingTop + this.paddingBottom);
	}
	,set_paddingLeft: function(v) {
		if(this.paddingLeft == v) {
			return v;
		}
		this.set_needReflow(true);
		return this.paddingLeft = v;
	}
	,set_paddingRight: function(v) {
		if(this.paddingRight == v) {
			return v;
		}
		this.set_needReflow(true);
		return this.paddingRight = v;
	}
	,set_paddingTop: function(v) {
		if(this.paddingTop == v) {
			return v;
		}
		this.set_needReflow(true);
		return this.paddingTop = v;
	}
	,set_paddingBottom: function(v) {
		if(this.paddingBottom == v) {
			return v;
		}
		this.set_needReflow(true);
		return this.paddingBottom = v;
	}
	,constraintSize: function(width,height) {
		this.constraintWidth = width;
		this.constraintHeight = height;
		this.isConstraint = true;
		this.updateConstraint();
	}
	,onHierarchyMoved: function(parentChanged) {
		h2d_Object.prototype.onHierarchyMoved.call(this,parentChanged);
		this.isConstraint = false;
		this.constraintWidth = -1;
		this.constraintHeight = -1;
		this.updateConstraint();
	}
	,contentChanged: function(s) {
		while(s.parent != this) s = s.parent;
		var p = this.getProperties(s);
		if(p != null && p.isAbsolute) {
			return;
		}
		this.set_needReflow(true);
		if(this.parentContainer != null) {
			this.parentContainer.contentChanged(this);
		}
	}
	,getBoundsRec: function(relativeTo,out,forSize) {
		if(this.needReflow) {
			this.reflow();
		}
		if(forSize) {
			if(!this.isInline) {
				h2d_Object.prototype.getBoundsRec.call(this,relativeTo,out,true);
			}
			if(this.calculatedWidth != 0) {
				if(this.posChanged) {
					this.calcAbsPos();
					var _g = 0;
					var _g1 = this.children;
					while(_g < _g1.length) {
						var c = _g1[_g];
						++_g;
						c.posChanged = true;
					}
					this.posChanged = false;
				}
				this.addBounds(relativeTo,out,0,0,this.calculatedWidth,this.calculatedHeight);
			}
		} else {
			h2d_Object.prototype.getBoundsRec.call(this,relativeTo,out,forSize);
		}
	}
	,setParentContainer: function(c) {
		this.parentContainer = c;
	}
	,addChildAt: function(s,pos) {
		if(this.background != null) {
			++pos;
		}
		if(this.interactive != null) {
			++pos;
		}
		if(this.scrollBar != null && pos == this.children.length) {
			--pos;
		}
		var fp = this.getProperties(s);
		h2d_Object.prototype.addChildAt.call(this,s,pos);
		if(fp == null) {
			fp = new h2d_FlowProperties(s);
		} else {
			HxOverrides.remove(this.properties,fp);
		}
		this.properties.splice(pos,0,fp);
		this.set_needReflow(true);
		s.setParentContainer(this);
	}
	,removeChild: function(s) {
		var index = this.getChildIndex(s);
		h2d_Object.prototype.removeChild.call(this,s);
		if(index >= 0) {
			this.set_needReflow(true);
			this.properties.splice(index,1);
			s.constraintSize(-1,-1);
		}
		if(s != null) {
			if(s == this.background) {
				this.set_backgroundTile(null);
			}
			if(s == this.interactive) {
				this.set_enableInteractive(false);
			}
		}
	}
	,removeChildren: function() {
		var k = 0;
		while(this.children.length > k) {
			var c = this.getChildAt(k);
			if(c == this.background || c == this.interactive || c == this.debugGraphics || c == this.scrollBar) {
				++k;
			} else {
				this.removeChild(c);
			}
		}
	}
	,sync: function(ctx) {
		if(!this.isConstraint && (this.fillWidth || this.fillHeight)) {
			var scene = ctx.scene;
			var cw = this.fillWidth ? scene.width : -1;
			var ch = this.fillHeight ? scene.height : -1;
			if(cw != this.constraintWidth || ch != this.constraintHeight) {
				this.set_needReflow(true);
			}
		}
		if(this.needReflow) {
			this.reflow();
		}
		h2d_Object.prototype.sync.call(this,ctx);
	}
	,drawRec: function(ctx) {
		if(this.overflow == h2d_FlowOverflow.Hidden || this.overflow == h2d_FlowOverflow.Scroll) {
			if(this.posChanged) {
				this.calcAbsPos();
				var _g = 0;
				var _g1 = this.children;
				while(_g < _g1.length) {
					var c = _g1[_g];
					++_g;
					c.posChanged = true;
				}
				this.posChanged = false;
			}
			h2d_Mask.maskWith(ctx,this,Math.ceil(this.calculatedWidth),Math.ceil(this.calculatedHeight),0,0);
			h2d_Object.prototype.drawRec.call(this,ctx);
			h2d_Mask.unmask(ctx);
		} else {
			h2d_Object.prototype.drawRec.call(this,ctx);
		}
	}
	,updateConstraint: function() {
		var oldW = this.realMaxWidth;
		var oldH = this.realMaxHeight;
		var tmp;
		if(this.maxWidth == null) {
			tmp = this.constraintWidth;
		} else if(this.constraintWidth < 0) {
			tmp = this.maxWidth;
		} else {
			var a = this.maxWidth;
			var b = this.constraintWidth;
			tmp = a > b ? b : a;
		}
		this.realMaxWidth = tmp;
		var tmp;
		if(this.maxHeight == null) {
			tmp = this.constraintHeight;
		} else if(this.constraintHeight < 0) {
			tmp = this.maxHeight;
		} else {
			var a = this.maxHeight;
			var b = this.constraintHeight;
			tmp = a > b ? b : a;
		}
		this.realMaxHeight = tmp;
		if(this.minWidth != null && this.realMaxWidth < this.minWidth && this.realMaxWidth >= 0) {
			this.realMaxWidth = this.minWidth;
		}
		if(this.minHeight != null && this.realMaxHeight < this.minHeight && this.realMaxWidth >= 0) {
			this.realMaxHeight = this.minHeight;
		}
		if(this.realMaxWidth != oldW || this.realMaxHeight != oldH) {
			this.set_needReflow(true);
		}
		var oldW = this.realMinWidth;
		var oldH = this.realMinHeight;
		this.realMinWidth = this.minWidth == null && this.fillWidth ? Math.ceil(this.constraintWidth) : this.minWidth != null ? this.minWidth : -1;
		this.realMinHeight = this.minHeight == null && this.fillHeight ? Math.ceil(this.constraintHeight) : this.minHeight != null ? this.minHeight : -1;
		if(this.realMinWidth != oldW || this.realMinHeight != oldH) {
			this.set_needReflow(true);
		}
	}
	,set_minWidth: function(w) {
		if(this.minWidth == w) {
			return w;
		}
		this.set_needReflow(true);
		this.minWidth = w;
		this.updateConstraint();
		return w;
	}
	,set_minHeight: function(h) {
		if(this.minHeight == h) {
			return h;
		}
		this.set_needReflow(true);
		this.minHeight = h;
		this.updateConstraint();
		return h;
	}
	,set_horizontalSpacing: function(s) {
		if(this.horizontalSpacing == s) {
			return s;
		}
		this.set_needReflow(true);
		return this.horizontalSpacing = s;
	}
	,set_verticalSpacing: function(s) {
		if(this.verticalSpacing == s) {
			return s;
		}
		this.set_needReflow(true);
		return this.verticalSpacing = s;
	}
	,set_enableInteractive: function(b) {
		if(this.enableInteractive == b) {
			return b;
		}
		if(b) {
			if(this.interactive == null) {
				var interactive = new h2d_Interactive(0,0);
				this.addChildAt(interactive,0);
				this.interactive = interactive;
				interactive.set_cursor(hxd_Cursor.Default);
				this.getProperties(interactive).set_isAbsolute(true);
				if(!this.needReflow) {
					interactive.width = this.calculatedWidth;
					interactive.height = this.calculatedHeight;
				}
				interactive.onWheel = $bind(this,this.onMouseWheel);
			}
		} else if(this.interactive != null) {
			var _this = this.interactive;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
			this.interactive = null;
		}
		return this.enableInteractive = b;
	}
	,onMouseWheel: function(e) {
		if(this.overflow == h2d_FlowOverflow.Scroll) {
			this.set_scrollPosY(this.scrollPosY + e.wheelDelta * this.scrollWheelSpeed);
			e.propagate = false;
		}
	}
	,set_backgroundTile: function(t) {
		if(this.backgroundTile == t) {
			return t;
		}
		if(t != null) {
			if(this.background == null) {
				var background = new h2d_ScaleGrid(t,this.borderLeft,this.borderTop,this.borderRight,this.borderBottom);
				this.addChildAt(background,0);
				this.getProperties(background).set_isAbsolute(true);
				this.background = background;
				if(!this.needReflow) {
					background.set_width(Math.ceil(this.calculatedWidth));
					background.set_height(Math.ceil(this.calculatedHeight));
				}
			}
			this.background.tile = t;
		} else if(this.background != null) {
			var _this = this.background;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
			this.background = null;
		}
		return this.backgroundTile = t;
	}
	,reflow: function() {
		var _gthis = this;
		this.onBeforeReflow();
		this.syncPos();
		if(!this.isConstraint && (this.fillWidth || this.fillHeight)) {
			var scene = this.getScene();
			var cw = this.fillWidth ? scene.width : -1;
			var ch = this.fillHeight ? scene.height : -1;
			if(cw != this.constraintWidth || ch != this.constraintHeight) {
				this.constraintSize(cw,ch);
				this.isConstraint = false;
			}
		}
		var borderTop = 0;
		var borderBottom = 0;
		var borderLeft = 0;
		var borderRight = 0;
		var tmpBounds = this.tmpBounds;
		if(tmpBounds == null) {
			throw haxe_Exception.thrown("Recursive reflow");
		}
		this.tmpBounds = null;
		var isConstraintWidth = this.realMaxWidth >= 0;
		var isConstraintHeight = this.realMaxHeight >= 0;
		var maxTotWidth = this.realMaxWidth < 0 ? 100000000 : Math.floor(this.realMaxWidth);
		var maxTotHeight = this.realMaxHeight < 0 ? 100000000 : Math.floor(this.realMaxHeight);
		var maxInWidth = maxTotWidth - (this.paddingLeft + this.paddingRight + (borderLeft + borderRight));
		var maxInHeight = maxTotHeight - (this.paddingTop + this.paddingBottom + (borderTop + borderBottom));
		if(this.debug) {
			this.debugGraphics.clear();
		}
		var cw;
		var ch;
		switch(this.layout._hx_index) {
		case 0:
			var halign = this.horizontalAlign == null ? h2d_FlowAlign.Left : this.horizontalAlign;
			var valign = this.verticalAlign == null ? h2d_FlowAlign.Bottom : this.verticalAlign;
			var startX = this.paddingLeft + borderLeft;
			var x = startX;
			var y = this.paddingTop + borderTop;
			cw = x;
			var maxLineHeight = 0;
			var minLineHeight = this.lineHeight != null ? this.lineHeight : this.realMinHeight >= 0 && !this.multiline ? this.realMinHeight - (this.paddingTop + this.paddingBottom + borderTop + borderBottom) : 0;
			var lastIndex = 0;
			var _g = 0;
			var _g1 = this.children.length;
			while(_g < _g1) {
				var i = _g++;
				var p = _gthis.properties[_gthis.reverse ? _gthis.children.length - i - 1 : i];
				var isAbs = p.isAbsolute;
				if(isAbs && p.horizontalAlign == null && p.verticalAlign == null) {
					continue;
				}
				var c = _gthis.children[_gthis.reverse ? _gthis.children.length - i - 1 : i];
				if(!c.visible) {
					continue;
				}
				var pw = p.paddingLeft + p.paddingRight;
				var ph = p.paddingTop + p.paddingBottom;
				if(!isAbs) {
					c.constraintSize(isConstraintWidth && p.constraint ? (maxInWidth - pw) / Math.abs(c.scaleX) : -1,isConstraintHeight && p.constraint ? (maxInHeight - ph) / Math.abs(c.scaleX) : -1);
				}
				var b = tmpBounds;
				b.xMin = 1e20;
				b.yMin = 1e20;
				b.xMax = -1e20;
				b.yMax = -1e20;
				c.getBoundsRec(_gthis,b,true);
				if(b.xMax <= b.xMin || b.yMax <= b.yMin) {
					if(0 < b.xMin) {
						b.xMin = 0;
					}
					if(0 > b.xMax) {
						b.xMax = 0;
					}
					if(0 < b.yMin) {
						b.yMin = 0;
					}
					if(0 > b.yMax) {
						b.yMax = 0;
					}
				} else {
					var dx = -c.x;
					var dy = -c.y;
					b.xMin += dx;
					b.xMax += dx;
					b.yMin += dy;
					b.yMax += dy;
				}
				var b1 = b;
				var br = false;
				p.calculatedWidth = Math.ceil(b1.xMax) + pw;
				p.calculatedHeight = Math.ceil(b1.yMax) + ph;
				if(p.minWidth != null && p.calculatedWidth < p.minWidth) {
					p.calculatedWidth = p.minWidth;
				}
				if(p.minHeight != null && p.calculatedHeight < p.minHeight) {
					p.calculatedHeight = p.minHeight;
				}
				if(isAbs) {
					continue;
				}
				if((this.multiline && x - startX + p.calculatedWidth > maxInWidth || p.lineBreak) && x - startX > 0) {
					br = true;
					if(maxLineHeight < minLineHeight) {
						maxLineHeight = minLineHeight;
					} else if(_gthis.overflow != h2d_FlowOverflow.Expand && minLineHeight != 0) {
						maxLineHeight = minLineHeight;
					}
					var absHeight = maxLineHeight > maxInHeight && _gthis.overflow != h2d_FlowOverflow.Expand ? maxInHeight : maxLineHeight;
					var _g2 = lastIndex;
					var _g3 = i;
					while(_g2 < _g3) {
						var i1 = _g2++;
						var p1 = _gthis.properties[_gthis.reverse ? _gthis.children.length - i1 - 1 : i1];
						if(p1.isAbsolute && p1.verticalAlign == null) {
							continue;
						}
						var c1 = _gthis.children[_gthis.reverse ? _gthis.children.length - i1 - 1 : i1];
						if(!c1.visible) {
							continue;
						}
						var a = p1.verticalAlign != null ? p1.verticalAlign : valign;
						c1.posChanged = true;
						c1.y = y + p1.offsetY + p1.paddingTop;
						var height = p1.isAbsolute ? absHeight : maxLineHeight;
						if(a != null) {
							switch(a._hx_index) {
							case 3:
								c1.posChanged = true;
								c1.y += (height - p1.calculatedHeight) * 0.5 | 0;
								break;
							case 4:
								c1.posChanged = true;
								c1.y += height - (p1.calculatedHeight | 0);
								break;
							default:
							}
						}
					}
					lastIndex = i;
					y += maxLineHeight + this.verticalSpacing;
					maxLineHeight = 0;
					x = startX;
				}
				p.isBreak = br;
				x += p.calculatedWidth;
				if(x > cw) {
					cw = x;
				}
				x += this.horizontalSpacing;
				if(p.calculatedHeight > maxLineHeight) {
					maxLineHeight = p.calculatedHeight;
				}
			}
			var maxIndex = this.children.length;
			if(maxLineHeight < minLineHeight) {
				maxLineHeight = minLineHeight;
			} else if(_gthis.overflow != h2d_FlowOverflow.Expand && minLineHeight != 0) {
				maxLineHeight = minLineHeight;
			}
			var absHeight = maxLineHeight > maxInHeight && _gthis.overflow != h2d_FlowOverflow.Expand ? maxInHeight : maxLineHeight;
			var _g = lastIndex;
			var _g1 = maxIndex;
			while(_g < _g1) {
				var i = _g++;
				var p = _gthis.properties[_gthis.reverse ? _gthis.children.length - i - 1 : i];
				if(p.isAbsolute && p.verticalAlign == null) {
					continue;
				}
				var c = _gthis.children[_gthis.reverse ? _gthis.children.length - i - 1 : i];
				if(!c.visible) {
					continue;
				}
				var a = p.verticalAlign != null ? p.verticalAlign : valign;
				c.posChanged = true;
				c.y = y + p.offsetY + p.paddingTop;
				var height = p.isAbsolute ? absHeight : maxLineHeight;
				if(a != null) {
					switch(a._hx_index) {
					case 3:
						c.posChanged = true;
						c.y += (height - p.calculatedHeight) * 0.5 | 0;
						break;
					case 4:
						c.posChanged = true;
						c.y += height - (p.calculatedHeight | 0);
						break;
					default:
					}
				}
			}
			lastIndex = maxIndex;
			cw += this.paddingRight + borderRight;
			ch = y + maxLineHeight + this.paddingBottom + borderBottom;
			if(this.realMinWidth >= 0 && cw < this.realMinWidth) {
				cw = this.realMinWidth;
			}
			var endX = cw - (this.paddingRight + borderRight);
			var xmin = startX;
			var xmax = endX;
			var midSpace = 0;
			var curAlign = null;
			var _g = 0;
			var _g1 = this.children.length;
			while(_g < _g1) {
				var i = _g++;
				var p = _gthis.properties[_gthis.reverse ? _gthis.children.length - i - 1 : i];
				var c = _gthis.children[_gthis.reverse ? _gthis.children.length - i - 1 : i];
				if(!c.visible) {
					continue;
				}
				if(p.isAbsolute) {
					var _g2 = p.horizontalAlign;
					if(_g2 != null) {
						switch(_g2._hx_index) {
						case 1:
							c.posChanged = true;
							c.x = startX + p.offsetX;
							break;
						case 2:
							c.posChanged = true;
							c.x = endX - p.calculatedWidth + p.offsetX;
							break;
						case 3:
							c.posChanged = true;
							c.x = startX + ((endX - startX - p.calculatedWidth) * 0.5 | 0) + p.offsetX + startX;
							break;
						default:
						}
					}
					continue;
				}
				if(p.isBreak) {
					xmin = startX;
					xmax = endX;
					midSpace = 0;
				}
				var px;
				var align = p.horizontalAlign == null ? halign : p.horizontalAlign;
				if(curAlign != align) {
					curAlign = align;
					midSpace = 0;
				}
				if(align == null) {
					px = xmin;
					xmin += p.calculatedWidth + this.horizontalSpacing;
				} else {
					switch(align._hx_index) {
					case 2:
						if(midSpace == 0) {
							var p1 = p.calculatedWidth;
							var size = 0;
							var _g3 = i + 1;
							var _g4 = _gthis.children.length;
							while(_g3 < _g4) {
								var j = _g3++;
								var p2 = _gthis.properties[_gthis.reverse ? _gthis.children.length - j - 1 : j];
								if(p2.isAbsolute || !_gthis.children[_gthis.reverse ? _gthis.children.length - j - 1 : j].visible) {
									continue;
								}
								if(p2.isBreak) {
									break;
								}
								size += _gthis.horizontalSpacing + p2.calculatedWidth;
							}
							var remSize = p1 + size;
							midSpace = xmax - xmin - remSize;
							xmin += midSpace;
						}
						px = xmin;
						xmin += p.calculatedWidth + this.horizontalSpacing;
						break;
					case 3:
						if(midSpace == 0) {
							var p3 = p.calculatedWidth;
							var size1 = 0;
							var _g5 = i + 1;
							var _g6 = _gthis.children.length;
							while(_g5 < _g6) {
								var j1 = _g5++;
								var p4 = _gthis.properties[_gthis.reverse ? _gthis.children.length - j1 - 1 : j1];
								if(p4.isAbsolute || !_gthis.children[_gthis.reverse ? _gthis.children.length - j1 - 1 : j1].visible) {
									continue;
								}
								if(p4.isBreak) {
									break;
								}
								size1 += _gthis.horizontalSpacing + p4.calculatedWidth;
							}
							var remSize1 = p3 + size1;
							midSpace = (xmax - xmin - remSize1) * 0.5 | 0;
							xmin += midSpace;
						}
						px = xmin;
						xmin += p.calculatedWidth + this.horizontalSpacing;
						break;
					default:
						px = xmin;
						xmin += p.calculatedWidth + this.horizontalSpacing;
					}
				}
				c.posChanged = true;
				c.x = px + p.offsetX + p.paddingLeft;
				if(p.isAbsolute) {
					xmin = px;
				}
			}
			break;
		case 1:
			var halign = this.horizontalAlign == null ? h2d_FlowAlign.Left : this.horizontalAlign;
			var valign = this.verticalAlign == null ? h2d_FlowAlign.Top : this.verticalAlign;
			var startY = this.paddingTop + borderTop;
			var y = startY;
			var x = this.paddingLeft + borderLeft;
			ch = y;
			var maxColWidth = 0;
			var minColWidth = this.colWidth != null ? this.colWidth : this.realMinWidth >= 0 && !this.multiline ? this.realMinWidth - (this.paddingLeft + this.paddingRight + borderLeft + borderRight) : 0;
			var lastIndex = 0;
			var _g = 0;
			var _g1 = this.children.length;
			while(_g < _g1) {
				var i = _g++;
				var p = _gthis.properties[_gthis.reverse ? _gthis.children.length - i - 1 : i];
				var isAbs = p.isAbsolute;
				if(isAbs && p.horizontalAlign == null && p.verticalAlign == null) {
					continue;
				}
				var c = _gthis.children[_gthis.reverse ? _gthis.children.length - i - 1 : i];
				if(!c.visible) {
					continue;
				}
				var pw = p.paddingLeft + p.paddingRight;
				var ph = p.paddingTop + p.paddingBottom;
				if(!isAbs) {
					c.constraintSize(isConstraintWidth && p.constraint ? (maxInWidth - pw) / Math.abs(c.scaleX) : -1,isConstraintHeight && p.constraint ? (maxInHeight - ph) / Math.abs(c.scaleY) : -1);
				}
				var b = tmpBounds;
				b.xMin = 1e20;
				b.yMin = 1e20;
				b.xMax = -1e20;
				b.yMax = -1e20;
				c.getBoundsRec(_gthis,b,true);
				if(b.xMax <= b.xMin || b.yMax <= b.yMin) {
					if(0 < b.xMin) {
						b.xMin = 0;
					}
					if(0 > b.xMax) {
						b.xMax = 0;
					}
					if(0 < b.yMin) {
						b.yMin = 0;
					}
					if(0 > b.yMax) {
						b.yMax = 0;
					}
				} else {
					var dx = -c.x;
					var dy = -c.y;
					b.xMin += dx;
					b.xMax += dx;
					b.yMin += dy;
					b.yMax += dy;
				}
				var b1 = b;
				var br = false;
				p.calculatedWidth = Math.ceil(b1.xMax) + pw;
				p.calculatedHeight = Math.ceil(b1.yMax) + ph;
				if(p.minWidth != null && p.calculatedWidth < p.minWidth) {
					p.calculatedWidth = p.minWidth;
				}
				if(p.minHeight != null && p.calculatedHeight < p.minHeight) {
					p.calculatedHeight = p.minHeight;
				}
				if(isAbs) {
					continue;
				}
				if((this.multiline && y - startY + p.calculatedHeight > maxInHeight || p.lineBreak) && y - startY > 0) {
					br = true;
					if(maxColWidth < minColWidth) {
						maxColWidth = minColWidth;
					} else if(_gthis.overflow != h2d_FlowOverflow.Expand && minColWidth != 0) {
						maxColWidth = minColWidth;
					}
					var absWidth = maxColWidth > maxInWidth && _gthis.overflow != h2d_FlowOverflow.Expand ? maxInWidth : maxColWidth;
					var _g2 = lastIndex;
					var _g3 = i;
					while(_g2 < _g3) {
						var i1 = _g2++;
						var p1 = _gthis.properties[_gthis.reverse ? _gthis.children.length - i1 - 1 : i1];
						if(p1.isAbsolute && p1.horizontalAlign == null) {
							continue;
						}
						var c1 = _gthis.children[_gthis.reverse ? _gthis.children.length - i1 - 1 : i1];
						if(!c1.visible) {
							continue;
						}
						var a = p1.horizontalAlign != null ? p1.horizontalAlign : halign;
						c1.posChanged = true;
						c1.x = x + p1.offsetX + p1.paddingLeft;
						var width = p1.isAbsolute ? absWidth : maxColWidth;
						if(a != null) {
							switch(a._hx_index) {
							case 2:
								c1.posChanged = true;
								c1.x += width - p1.calculatedWidth;
								break;
							case 3:
								c1.posChanged = true;
								c1.x += (width - p1.calculatedWidth) * 0.5 | 0;
								break;
							default:
							}
						}
					}
					lastIndex = i;
					x += maxColWidth + this.horizontalSpacing;
					maxColWidth = 0;
					y = startY;
				}
				p.isBreak = br;
				c.posChanged = true;
				c.y = y + p.offsetY + p.paddingTop;
				y += p.calculatedHeight;
				if(y > ch) {
					ch = y;
				}
				y += this.verticalSpacing;
				if(p.calculatedWidth > maxColWidth) {
					maxColWidth = p.calculatedWidth;
				}
			}
			var maxIndex = this.children.length;
			if(maxColWidth < minColWidth) {
				maxColWidth = minColWidth;
			} else if(_gthis.overflow != h2d_FlowOverflow.Expand && minColWidth != 0) {
				maxColWidth = minColWidth;
			}
			var absWidth = maxColWidth > maxInWidth && _gthis.overflow != h2d_FlowOverflow.Expand ? maxInWidth : maxColWidth;
			var _g = lastIndex;
			var _g1 = maxIndex;
			while(_g < _g1) {
				var i = _g++;
				var p = _gthis.properties[_gthis.reverse ? _gthis.children.length - i - 1 : i];
				if(p.isAbsolute && p.horizontalAlign == null) {
					continue;
				}
				var c = _gthis.children[_gthis.reverse ? _gthis.children.length - i - 1 : i];
				if(!c.visible) {
					continue;
				}
				var a = p.horizontalAlign != null ? p.horizontalAlign : halign;
				c.posChanged = true;
				c.x = x + p.offsetX + p.paddingLeft;
				var width = p.isAbsolute ? absWidth : maxColWidth;
				if(a != null) {
					switch(a._hx_index) {
					case 2:
						c.posChanged = true;
						c.x += width - p.calculatedWidth;
						break;
					case 3:
						c.posChanged = true;
						c.x += (width - p.calculatedWidth) * 0.5 | 0;
						break;
					default:
					}
				}
			}
			lastIndex = maxIndex;
			ch += this.paddingBottom + borderBottom;
			cw = x + maxColWidth + this.paddingRight + borderRight;
			if(this.realMinHeight >= 0 && ch < this.realMinHeight) {
				ch = this.realMinHeight;
			}
			var endY = ch - (this.paddingBottom + borderBottom);
			var ymin = startY;
			var ymax = endY;
			var midSpace = 0;
			var curAlign = null;
			var _g = 0;
			var _g1 = this.children.length;
			while(_g < _g1) {
				var i = _g++;
				var p = _gthis.properties[_gthis.reverse ? _gthis.children.length - i - 1 : i];
				var c = _gthis.children[_gthis.reverse ? _gthis.children.length - i - 1 : i];
				if(!c.visible) {
					continue;
				}
				if(p.isAbsolute) {
					var _g2 = p.verticalAlign;
					if(_g2 != null) {
						switch(_g2._hx_index) {
						case 0:
							c.posChanged = true;
							c.y = startY + p.offsetY;
							break;
						case 3:
							c.posChanged = true;
							c.y = startY + ((endY - startY - p.calculatedHeight) * 0.5 | 0) + p.offsetY + startY;
							break;
						case 4:
							c.posChanged = true;
							c.y = endY - p.calculatedHeight + p.offsetY;
							break;
						default:
						}
					}
					continue;
				}
				if(p.isBreak) {
					ymin = startY;
					ymax = endY;
					midSpace = 0;
				}
				var py;
				var align = p.verticalAlign == null ? valign : p.verticalAlign;
				if(curAlign != align) {
					curAlign = align;
					midSpace = 0;
				}
				if(align == null) {
					py = ymin;
					ymin += p.calculatedHeight + this.verticalSpacing;
				} else {
					switch(align._hx_index) {
					case 3:
						if(midSpace == 0) {
							var p1 = p.calculatedHeight;
							var size = 0;
							var _g3 = i + 1;
							var _g4 = _gthis.children.length;
							while(_g3 < _g4) {
								var j = _g3++;
								var p2 = _gthis.properties[_gthis.reverse ? _gthis.children.length - j - 1 : j];
								if(p2.isAbsolute || !_gthis.children[_gthis.reverse ? _gthis.children.length - j - 1 : j].visible) {
									continue;
								}
								if(p2.isBreak) {
									break;
								}
								size += _gthis.verticalSpacing + p2.calculatedHeight;
							}
							var remSize = p1 + size;
							midSpace = (ymax - ymin - remSize) * 0.5 | 0;
							ymin += midSpace;
						}
						py = ymin;
						ymin += p.calculatedHeight + this.verticalSpacing;
						break;
					case 4:
						if(midSpace == 0) {
							var p3 = p.calculatedHeight;
							var size1 = 0;
							var _g5 = i + 1;
							var _g6 = _gthis.children.length;
							while(_g5 < _g6) {
								var j1 = _g5++;
								var p4 = _gthis.properties[_gthis.reverse ? _gthis.children.length - j1 - 1 : j1];
								if(p4.isAbsolute || !_gthis.children[_gthis.reverse ? _gthis.children.length - j1 - 1 : j1].visible) {
									continue;
								}
								if(p4.isBreak) {
									break;
								}
								size1 += _gthis.verticalSpacing + p4.calculatedHeight;
							}
							var remSize1 = p3 + size1;
							midSpace = ymax - ymin - remSize1;
							ymin += midSpace;
						}
						py = ymin;
						ymin += p.calculatedHeight + this.verticalSpacing;
						break;
					default:
						py = ymin;
						ymin += p.calculatedHeight + this.verticalSpacing;
					}
				}
				c.posChanged = true;
				c.y = py + p.offsetY + p.paddingTop;
			}
			break;
		case 2:
			var halign = this.horizontalAlign == null ? h2d_FlowAlign.Left : this.horizontalAlign;
			var valign = this.verticalAlign == null ? h2d_FlowAlign.Top : this.verticalAlign;
			var maxChildW = 0;
			var maxChildH = 0;
			var _g = 0;
			var _g1 = this.children.length;
			while(_g < _g1) {
				var i = _g++;
				var c = _gthis.children[_gthis.reverse ? _gthis.children.length - i - 1 : i];
				if(!c.visible) {
					continue;
				}
				var p = _gthis.properties[_gthis.reverse ? _gthis.children.length - i - 1 : i];
				var isAbs = p.isAbsolute;
				if(isAbs && p.verticalAlign == null && p.horizontalAlign == null) {
					continue;
				}
				var pw = p.paddingLeft + p.paddingRight;
				var ph = p.paddingTop + p.paddingBottom;
				if(!isAbs) {
					c.constraintSize(isConstraintWidth && p.constraint ? (maxInWidth - pw) / Math.abs(c.scaleX) : -1,isConstraintHeight && p.constraint ? (maxInHeight - ph) / Math.abs(c.scaleY) : -1);
				}
				var b = tmpBounds;
				b.xMin = 1e20;
				b.yMin = 1e20;
				b.xMax = -1e20;
				b.yMax = -1e20;
				c.getBoundsRec(_gthis,b,true);
				if(b.xMax <= b.xMin || b.yMax <= b.yMin) {
					if(0 < b.xMin) {
						b.xMin = 0;
					}
					if(0 > b.xMax) {
						b.xMax = 0;
					}
					if(0 < b.yMin) {
						b.yMin = 0;
					}
					if(0 > b.yMax) {
						b.yMax = 0;
					}
				} else {
					var dx = -c.x;
					var dy = -c.y;
					b.xMin += dx;
					b.xMax += dx;
					b.yMin += dy;
					b.yMax += dy;
				}
				var b1 = b;
				p.calculatedWidth = Math.ceil(b1.xMax) + pw;
				p.calculatedHeight = Math.ceil(b1.yMax) + ph;
				if(p.minWidth != null && p.calculatedWidth < p.minWidth) {
					p.calculatedWidth = p.minWidth;
				}
				if(p.minHeight != null && p.calculatedHeight < p.minHeight) {
					p.calculatedHeight = p.minHeight;
				}
				if(isAbs) {
					continue;
				}
				if(p.calculatedWidth > maxChildW) {
					maxChildW = p.calculatedWidth;
				}
				if(p.calculatedHeight > maxChildH) {
					maxChildH = p.calculatedHeight;
				}
			}
			var xmin = this.paddingLeft + borderLeft;
			var ymin = this.paddingTop + borderTop;
			var xmax;
			if(this.realMaxWidth > 0 && this.overflow != h2d_FlowOverflow.Expand) {
				xmax = Math.floor(this.realMaxWidth - (this.paddingRight + borderRight));
			} else {
				var a = xmin + maxChildW;
				var b = this.realMinWidth - (this.paddingRight + borderRight);
				xmax = a < b ? b : a;
			}
			var ymax;
			if(this.realMaxWidth > 0 && this.overflow != h2d_FlowOverflow.Expand) {
				ymax = Math.floor(this.realMaxHeight - (this.paddingBottom + borderBottom));
			} else {
				var a = ymin + maxChildH;
				var b = this.realMinHeight - (this.paddingBottom + borderBottom);
				ymax = a < b ? b : a;
			}
			cw = xmax + this.paddingRight + borderRight;
			ch = ymax + this.paddingBottom + borderBottom;
			var _g = 0;
			var _g1 = this.children.length;
			while(_g < _g1) {
				var i = _g++;
				var c = _gthis.children[_gthis.reverse ? _gthis.children.length - i - 1 : i];
				if(!c.visible) {
					continue;
				}
				var p = _gthis.properties[_gthis.reverse ? _gthis.children.length - i - 1 : i];
				var isAbs = p.isAbsolute;
				if(isAbs && p.verticalAlign == null && p.horizontalAlign == null) {
					continue;
				}
				var valign1 = p.verticalAlign == null ? valign : p.verticalAlign;
				var halign1 = p.horizontalAlign == null ? halign : p.horizontalAlign;
				var px;
				if(halign1 == null) {
					px = xmin;
				} else {
					switch(halign1._hx_index) {
					case 2:
						px = xmax - p.calculatedWidth;
						break;
					case 3:
						px = xmin + ((xmax - xmin - p.calculatedWidth) * 0.5 | 0);
						break;
					default:
						px = xmin;
					}
				}
				var py;
				if(valign1 == null) {
					py = ymin;
				} else {
					switch(valign1._hx_index) {
					case 3:
						py = ymin + ((ymax - ymin - p.calculatedHeight) * 0.5 | 0);
						break;
					case 4:
						py = ymax - p.calculatedHeight;
						break;
					default:
						py = ymin;
					}
				}
				if(!isAbs || p.horizontalAlign != null) {
					c.posChanged = true;
					c.x = px + p.offsetX + p.paddingLeft;
				}
				if(!isAbs || p.verticalAlign != null) {
					c.posChanged = true;
					c.y = py + p.offsetY + p.paddingTop;
				}
			}
			break;
		}
		if(this.scrollPosY != 0) {
			var i = 0;
			var sy = this.scrollPosY | 0;
			var _g = 0;
			var _g1 = this.children;
			while(_g < _g1.length) {
				var c = _g1[_g];
				++_g;
				var p = this.properties[i++];
				if(p.isAbsolute) {
					continue;
				}
				c.posChanged = true;
				c.y -= sy;
			}
		}
		if(this.realMinWidth >= 0 && cw < this.realMinWidth) {
			cw = this.realMinWidth;
		}
		if(this.realMinHeight >= 0 && ch < this.realMinHeight) {
			ch = this.realMinHeight;
		}
		this.contentWidth = cw;
		this.contentHeight = ch;
		if(this.overflow != h2d_FlowOverflow.Expand) {
			if(isConstraintWidth && cw > maxTotWidth) {
				cw = maxTotWidth;
			}
			if(isConstraintHeight && ch > maxTotHeight) {
				ch = maxTotHeight;
			}
		}
		if(this.interactive != null) {
			this.interactive.width = cw;
			this.interactive.height = ch;
		}
		if(this.background != null) {
			this.background.set_width(Math.ceil(cw));
			this.background.set_height(Math.ceil(ch));
		}
		this.calculatedWidth = cw;
		this.calculatedHeight = ch;
		if(this.scrollBar != null) {
			if(this.contentHeight <= this.calculatedHeight) {
				this.scrollBar.set_visible(false);
			} else {
				this.scrollBar.set_visible(true);
				this.scrollBar.set_minHeight(Math.ceil(this.calculatedHeight));
				var b = this.calculatedHeight * (1 - (this.contentHeight - this.calculatedHeight) / this.contentHeight) | 0;
				this.scrollBarCursor.set_minHeight(1 < b ? b : 1);
				this.updateScrollCursor();
			}
		}
		this.set_needReflow(false);
		if(this.overflow == h2d_FlowOverflow.Scroll || this.overflow == h2d_FlowOverflow.Hidden) {
			this.posChanged = true;
		}
		if(this.debug) {
			if(this.debugGraphics != this.children[this.children.length - 1]) {
				this.addChild(this.debugGraphics);
				this.set_needReflow(false);
			}
			if(this.paddingLeft != 0 || this.paddingRight != 0 || this.paddingTop != 0 || this.paddingBottom != 0) {
				this.debugGraphics.lineStyle(1,65280);
				this.debugGraphics.drawRect(this.paddingLeft,this.paddingTop,this.get_innerWidth(),this.get_innerHeight());
			}
			this.debugGraphics.lineStyle(1,33023);
			var _g = 0;
			var _g1 = this.children.length;
			while(_g < _g1) {
				var i = _g++;
				var p = _gthis.properties[_gthis.reverse ? _gthis.children.length - i - 1 : i];
				var c = _gthis.children[_gthis.reverse ? _gthis.children.length - i - 1 : i];
				if(p.isAbsolute || !c.visible) {
					continue;
				}
				this.debugGraphics.drawRect(c.x - p.offsetX - p.paddingLeft,c.y - p.offsetY - p.paddingTop,p.calculatedWidth,p.calculatedHeight);
			}
			this.debugGraphics.lineStyle(1,16711680);
			this.debugGraphics.drawRect(0,0,cw,ch);
		}
		this.tmpBounds = tmpBounds;
		this.onAfterReflow();
	}
	,onBeforeReflow: function() {
	}
	,onAfterReflow: function() {
	}
	,__class__: h2d_Flow
});
var h2d_Kerning = function(c,o) {
	this.prevChar = c;
	this.offset = o;
};
$hxClasses["h2d.Kerning"] = h2d_Kerning;
h2d_Kerning.__name__ = "h2d.Kerning";
h2d_Kerning.prototype = {
	__class__: h2d_Kerning
};
var h2d_FontChar = function(t,w) {
	this.t = t;
	this.width = w;
};
$hxClasses["h2d.FontChar"] = h2d_FontChar;
h2d_FontChar.__name__ = "h2d.FontChar";
h2d_FontChar.prototype = {
	addKerning: function(prevChar,offset) {
		var k = new h2d_Kerning(prevChar,offset);
		k.next = this.kerning;
		this.kerning = k;
	}
	,getKerningOffset: function(prevChar) {
		var k = this.kerning;
		while(k != null) {
			if(k.prevChar == prevChar) {
				return k.offset;
			}
			k = k.next;
		}
		return 0;
	}
	,__class__: h2d_FontChar
};
var h2d_FontType = $hxEnums["h2d.FontType"] = { __ename__:true,__constructs__:null
	,BitmapFont: {_hx_name:"BitmapFont",_hx_index:0,__enum__:"h2d.FontType",toString:$estr}
	,SignedDistanceField: ($_=function(channel,alphaCutoff,smoothing) { return {_hx_index:1,channel:channel,alphaCutoff:alphaCutoff,smoothing:smoothing,__enum__:"h2d.FontType",toString:$estr}; },$_._hx_name="SignedDistanceField",$_.__params__ = ["channel","alphaCutoff","smoothing"],$_)
};
h2d_FontType.__constructs__ = [h2d_FontType.BitmapFont,h2d_FontType.SignedDistanceField];
h2d_FontType.__empty_constructs__ = [h2d_FontType.BitmapFont];
var h2d_Font = function(name,size,type) {
	this.name = name;
	this.size = size;
	this.initSize = size;
	this.glyphs = new haxe_ds_IntMap();
	this.defaultChar = this.nullChar = new h2d_FontChar(new h2d_Tile(null,0,0,0,0),0);
	this.charset = hxd_Charset.getDefault();
	if(name != null) {
		this.tilePath = haxe_io_Path.withExtension(name,"png");
	}
	if(type == null) {
		this.type = h2d_FontType.BitmapFont;
	} else {
		this.type = type;
	}
};
$hxClasses["h2d.Font"] = h2d_Font;
h2d_Font.__name__ = "h2d.Font";
h2d_Font.prototype = {
	__class__: h2d_Font
};
var h2d_GPoint = function() {
};
$hxClasses["h2d.GPoint"] = h2d_GPoint;
h2d_GPoint.__name__ = "h2d.GPoint";
h2d_GPoint.prototype = {
	load: function(x,y,r,g,b,a) {
		this.x = x;
		this.y = y;
		this.r = r;
		this.g = g;
		this.b = b;
		this.a = a;
	}
	,__class__: h2d_GPoint
};
var h3d_prim_Primitive = function() {
	this.refCount = 0;
};
$hxClasses["h3d.prim.Primitive"] = h3d_prim_Primitive;
h3d_prim_Primitive.__name__ = "h3d.prim.Primitive";
h3d_prim_Primitive.prototype = {
	getBounds: function() {
		throw haxe_Exception.thrown("not implemented for " + Std.string(this));
	}
	,incref: function() {
		this.refCount++;
	}
	,decref: function() {
		this.refCount--;
		if(this.refCount <= 0) {
			this.refCount = 0;
			this.dispose();
		}
	}
	,alloc: function(engine) {
		throw haxe_Exception.thrown("not implemented");
	}
	,render: function(engine) {
		var tmp;
		if(this.buffer != null) {
			var _this = this.buffer;
			tmp = _this.buffer == null || _this.buffer.vbuf == null;
		} else {
			tmp = true;
		}
		if(tmp) {
			this.alloc(engine);
		}
		if(this.indexes == null) {
			if((this.buffer.flags & 1 << h3d_BufferFlag.Quads._hx_index) != 0) {
				engine.renderBuffer(this.buffer,engine.mem.quadIndexes,2,0,-1);
			} else {
				engine.renderBuffer(this.buffer,engine.mem.triIndexes,3,0,-1);
			}
		} else {
			engine.renderIndexed(this.buffer,this.indexes);
		}
	}
	,dispose: function() {
		if(this.buffer != null) {
			this.buffer.dispose();
			this.buffer = null;
		}
		if(this.indexes != null) {
			this.indexes.dispose();
			this.indexes = null;
		}
	}
	,toString: function() {
		var c = js_Boot.getClass(this);
		return c.__name__.split(".").pop();
	}
	,__class__: h3d_prim_Primitive
};
var h2d__$Graphics_GraphicsContent = function() {
	h3d_prim_Primitive.call(this);
	this.buffers = [];
	this.state = new h2d_impl_BatchDrawState();
};
$hxClasses["h2d._Graphics.GraphicsContent"] = h2d__$Graphics_GraphicsContent;
h2d__$Graphics_GraphicsContent.__name__ = "h2d._Graphics.GraphicsContent";
h2d__$Graphics_GraphicsContent.__super__ = h3d_prim_Primitive;
h2d__$Graphics_GraphicsContent.prototype = $extend(h3d_prim_Primitive.prototype,{
	setTile: function(tile) {
		if(tile != null) {
			this.state.setTexture(tile.innerTex);
		}
	}
	,next: function() {
		var nvect = this.tmp.pos >> 3;
		if(nvect < 32768) {
			return false;
		}
		this.buffers.push({ buf : this.tmp, idx : this.index, vbuf : null, ibuf : null, state : this.state});
		var this1 = hxd__$FloatBuffer_Float32Expand._new(0);
		this.tmp = this1;
		var this1 = new Array(0);
		this.index = this1;
		var tex = this.state.tail.texture;
		this.state = new h2d_impl_BatchDrawState();
		this.state.setTexture(tex);
		h3d_prim_Primitive.prototype.dispose.call(this);
		return true;
	}
	,alloc: function(engine) {
		if(this.index.length <= 0) {
			return;
		}
		var alloc = hxd_impl_Allocator.get();
		this.buffer = alloc.ofFloats(this.tmp,8,2);
		this.indexes = alloc.ofIndexes(this.index);
		var _g = 0;
		var _g1 = this.buffers;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			var tmp;
			if(b.vbuf != null) {
				var _this = b.vbuf;
				tmp = _this.buffer == null || _this.buffer.vbuf == null;
			} else {
				tmp = true;
			}
			if(tmp) {
				b.vbuf = alloc.ofFloats(b.buf,8,2);
			}
			if(b.ibuf == null || b.ibuf.isDisposed()) {
				b.ibuf = alloc.ofIndexes(b.idx);
			}
		}
		this.bufferDirty = false;
		this.indexDirty = false;
	}
	,doRender: function(ctx) {
		if(this.index.length == 0) {
			return;
		}
		this.flush();
		var _g = 0;
		var _g1 = this.buffers;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			b.state.drawIndexed(ctx,b.vbuf,b.ibuf);
		}
		this.state.drawIndexed(ctx,this.buffer,this.indexes);
	}
	,flush: function() {
		var tmp;
		if(this.buffer != null) {
			var _this = this.buffer;
			tmp = _this.buffer == null || _this.buffer.vbuf == null;
		} else {
			tmp = true;
		}
		if(tmp) {
			this.alloc(h3d_Engine.CURRENT);
		} else {
			var allocator = hxd_impl_Allocator.get();
			if(this.bufferDirty) {
				allocator.disposeBuffer(this.buffer);
				this.buffer = allocator.ofFloats(this.tmp,8,2);
				this.bufferDirty = false;
			}
			if(this.indexDirty) {
				allocator.disposeIndexBuffer(this.indexes);
				this.indexes = allocator.ofIndexes(this.index);
				this.indexDirty = false;
			}
		}
	}
	,dispose: function() {
		var _g = 0;
		var _g1 = this.buffers;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			if(b.vbuf != null) {
				hxd_impl_Allocator.get().disposeBuffer(b.vbuf);
			}
			if(b.ibuf != null) {
				hxd_impl_Allocator.get().disposeIndexBuffer(b.ibuf);
			}
			b.vbuf = null;
			b.ibuf = null;
			b.state.clear();
		}
		if(this.buffer != null) {
			hxd_impl_Allocator.get().disposeBuffer(this.buffer);
			this.buffer = null;
		}
		if(this.indexes != null) {
			hxd_impl_Allocator.get().disposeIndexBuffer(this.indexes);
			this.indexes = null;
		}
		this.state.clear();
		h3d_prim_Primitive.prototype.dispose.call(this);
	}
	,clear: function() {
		this.dispose();
		var this1 = hxd__$FloatBuffer_Float32Expand._new(0);
		this.tmp = this1;
		var this1 = new Array(0);
		this.index = this1;
		this.buffers = [];
	}
	,__class__: h2d__$Graphics_GraphicsContent
});
var h2d_Graphics = function(parent) {
	this.bevel = 0.25;
	this.my = 0.;
	this.mx = 0.;
	this.md = 1.;
	this.mc = 0.;
	this.mb = 0.;
	this.ma = 1.;
	h2d_Drawable.call(this,parent);
	this.content = new h2d__$Graphics_GraphicsContent();
	this.tile = h2d_Tile.fromColor(16777215);
	this.clear();
};
$hxClasses["h2d.Graphics"] = h2d_Graphics;
h2d_Graphics.__name__ = "h2d.Graphics";
h2d_Graphics.__super__ = h2d_Drawable;
h2d_Graphics.prototype = $extend(h2d_Drawable.prototype,{
	onRemove: function() {
		h2d_Drawable.prototype.onRemove.call(this);
		this.clear();
	}
	,clear: function() {
		this.content.clear();
		this.tmpPoints = [];
		this.pindex = 0;
		this.lineSize = 0;
		this.xMin = Infinity;
		this.yMin = Infinity;
		this.yMax = -Infinity;
		this.xMax = -Infinity;
	}
	,getBoundsRec: function(relativeTo,out,forSize) {
		h2d_Drawable.prototype.getBoundsRec.call(this,relativeTo,out,forSize);
		if(this.tile != null) {
			this.addBounds(relativeTo,out,this.xMin,this.yMin,this.xMax - this.xMin,this.yMax - this.yMin);
		}
	}
	,isConvex: function(points) {
		var first = true;
		var sign = false;
		var _g = 0;
		var _g1 = points.length;
		while(_g < _g1) {
			var i = _g++;
			var p1 = points[i];
			var p2 = points[(i + 1) % points.length];
			var p3 = points[(i + 2) % points.length];
			var s = (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x) > 0;
			if(first) {
				first = false;
				sign = s;
			} else if(sign != s) {
				return false;
			}
		}
		return true;
	}
	,flushLine: function(start) {
		var pts = this.tmpPoints;
		var last = pts.length - 1;
		var prev = pts[last];
		var p = pts[0];
		this.content.setTile(h2d_Tile.fromColor(16777215));
		var closed = p.x == prev.x && p.y == prev.y;
		var count = pts.length;
		if(!closed) {
			var prevLast = pts[last - 1];
			if(prevLast == null) {
				prevLast = p;
			}
			var gp = new h2d_GPoint();
			gp.load(prev.x * 2 - prevLast.x,prev.y * 2 - prevLast.y,0,0,0,0);
			pts.push(gp);
			var pNext = pts[1];
			if(pNext == null) {
				pNext = p;
			}
			var gp = new h2d_GPoint();
			gp.load(p.x * 2 - pNext.x,p.y * 2 - pNext.y,0,0,0,0);
			prev = gp;
		} else if(p != prev) {
			--count;
			--last;
			prev = pts[last];
		}
		var _g = 0;
		var _g1 = count;
		while(_g < _g1) {
			var i = _g++;
			var next = pts[(i + 1) % pts.length];
			var nx1 = prev.y - p.y;
			var ny1 = p.x - prev.x;
			var ns1 = 1. / Math.sqrt(nx1 * nx1 + ny1 * ny1);
			var nx2 = p.y - next.y;
			var ny2 = next.x - p.x;
			var ns2 = 1. / Math.sqrt(nx2 * nx2 + ny2 * ny2);
			var nx = nx1 * ns1 + nx2 * ns2;
			var ny = ny1 * ns1 + ny2 * ns2;
			var ns = 1. / Math.sqrt(nx * nx + ny * ny);
			nx *= ns;
			ny *= ns;
			var size = nx * nx1 * ns1 + ny * ny1 * ns1;
			if(size < 0.1) {
				size = 0.1;
			}
			var d = this.lineSize * 0.5 / size;
			nx *= d;
			ny *= d;
			if(size > this.bevel) {
				var _this = this.content;
				var x = p.x + nx;
				var y = p.y + ny;
				var r = p.r;
				var g = p.g;
				var b = p.b;
				var a = p.a;
				var this1 = _this.tmp;
				if(this1.pos == this1.array.length) {
					var newSize = this1.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					var newArray = new Float32Array(newSize);
					newArray.set(this1.array);
					this1.array = newArray;
				}
				this1.array[this1.pos++] = x;
				var this2 = _this.tmp;
				if(this2.pos == this2.array.length) {
					var newSize1 = this2.array.length << 1;
					if(newSize1 < 128) {
						newSize1 = 128;
					}
					var newArray1 = new Float32Array(newSize1);
					newArray1.set(this2.array);
					this2.array = newArray1;
				}
				this2.array[this2.pos++] = y;
				var this3 = _this.tmp;
				if(this3.pos == this3.array.length) {
					var newSize2 = this3.array.length << 1;
					if(newSize2 < 128) {
						newSize2 = 128;
					}
					var newArray2 = new Float32Array(newSize2);
					newArray2.set(this3.array);
					this3.array = newArray2;
				}
				this3.array[this3.pos++] = 0;
				var this4 = _this.tmp;
				if(this4.pos == this4.array.length) {
					var newSize3 = this4.array.length << 1;
					if(newSize3 < 128) {
						newSize3 = 128;
					}
					var newArray3 = new Float32Array(newSize3);
					newArray3.set(this4.array);
					this4.array = newArray3;
				}
				this4.array[this4.pos++] = 0;
				var this5 = _this.tmp;
				if(this5.pos == this5.array.length) {
					var newSize4 = this5.array.length << 1;
					if(newSize4 < 128) {
						newSize4 = 128;
					}
					var newArray4 = new Float32Array(newSize4);
					newArray4.set(this5.array);
					this5.array = newArray4;
				}
				this5.array[this5.pos++] = r;
				var this6 = _this.tmp;
				if(this6.pos == this6.array.length) {
					var newSize5 = this6.array.length << 1;
					if(newSize5 < 128) {
						newSize5 = 128;
					}
					var newArray5 = new Float32Array(newSize5);
					newArray5.set(this6.array);
					this6.array = newArray5;
				}
				this6.array[this6.pos++] = g;
				var this7 = _this.tmp;
				if(this7.pos == this7.array.length) {
					var newSize6 = this7.array.length << 1;
					if(newSize6 < 128) {
						newSize6 = 128;
					}
					var newArray6 = new Float32Array(newSize6);
					newArray6.set(this7.array);
					this7.array = newArray6;
				}
				this7.array[this7.pos++] = b;
				var this8 = _this.tmp;
				if(this8.pos == this8.array.length) {
					var newSize7 = this8.array.length << 1;
					if(newSize7 < 128) {
						newSize7 = 128;
					}
					var newArray7 = new Float32Array(newSize7);
					newArray7.set(this8.array);
					this8.array = newArray7;
				}
				this8.array[this8.pos++] = a;
				_this.bufferDirty = true;
				var _this1 = this.content;
				var x1 = p.x - nx;
				var y1 = p.y - ny;
				var r1 = p.r;
				var g1 = p.g;
				var b1 = p.b;
				var a1 = p.a;
				var this9 = _this1.tmp;
				if(this9.pos == this9.array.length) {
					var newSize8 = this9.array.length << 1;
					if(newSize8 < 128) {
						newSize8 = 128;
					}
					var newArray8 = new Float32Array(newSize8);
					newArray8.set(this9.array);
					this9.array = newArray8;
				}
				this9.array[this9.pos++] = x1;
				var this10 = _this1.tmp;
				if(this10.pos == this10.array.length) {
					var newSize9 = this10.array.length << 1;
					if(newSize9 < 128) {
						newSize9 = 128;
					}
					var newArray9 = new Float32Array(newSize9);
					newArray9.set(this10.array);
					this10.array = newArray9;
				}
				this10.array[this10.pos++] = y1;
				var this11 = _this1.tmp;
				if(this11.pos == this11.array.length) {
					var newSize10 = this11.array.length << 1;
					if(newSize10 < 128) {
						newSize10 = 128;
					}
					var newArray10 = new Float32Array(newSize10);
					newArray10.set(this11.array);
					this11.array = newArray10;
				}
				this11.array[this11.pos++] = 0;
				var this12 = _this1.tmp;
				if(this12.pos == this12.array.length) {
					var newSize11 = this12.array.length << 1;
					if(newSize11 < 128) {
						newSize11 = 128;
					}
					var newArray11 = new Float32Array(newSize11);
					newArray11.set(this12.array);
					this12.array = newArray11;
				}
				this12.array[this12.pos++] = 0;
				var this13 = _this1.tmp;
				if(this13.pos == this13.array.length) {
					var newSize12 = this13.array.length << 1;
					if(newSize12 < 128) {
						newSize12 = 128;
					}
					var newArray12 = new Float32Array(newSize12);
					newArray12.set(this13.array);
					this13.array = newArray12;
				}
				this13.array[this13.pos++] = r1;
				var this14 = _this1.tmp;
				if(this14.pos == this14.array.length) {
					var newSize13 = this14.array.length << 1;
					if(newSize13 < 128) {
						newSize13 = 128;
					}
					var newArray13 = new Float32Array(newSize13);
					newArray13.set(this14.array);
					this14.array = newArray13;
				}
				this14.array[this14.pos++] = g1;
				var this15 = _this1.tmp;
				if(this15.pos == this15.array.length) {
					var newSize14 = this15.array.length << 1;
					if(newSize14 < 128) {
						newSize14 = 128;
					}
					var newArray14 = new Float32Array(newSize14);
					newArray14.set(this15.array);
					this15.array = newArray14;
				}
				this15.array[this15.pos++] = b1;
				var this16 = _this1.tmp;
				if(this16.pos == this16.array.length) {
					var newSize15 = this16.array.length << 1;
					if(newSize15 < 128) {
						newSize15 = 128;
					}
					var newArray15 = new Float32Array(newSize15);
					newArray15.set(this16.array);
					this16.array = newArray15;
				}
				this16.array[this16.pos++] = a1;
				_this1.bufferDirty = true;
				var pnext = i == last ? start : this.pindex + 2;
				if(i < count - 1 || closed) {
					var _this2 = this.content;
					_this2.index.push(this.pindex);
					var _this3 = _this2.state;
					_this3.tail.count += 1;
					_this3.totalCount += 1;
					_this2.indexDirty = true;
					var _this4 = this.content;
					_this4.index.push(this.pindex + 1);
					var _this5 = _this4.state;
					_this5.tail.count += 1;
					_this5.totalCount += 1;
					_this4.indexDirty = true;
					var _this6 = this.content;
					_this6.index.push(pnext);
					var _this7 = _this6.state;
					_this7.tail.count += 1;
					_this7.totalCount += 1;
					_this6.indexDirty = true;
					var _this8 = this.content;
					_this8.index.push(this.pindex + 1);
					var _this9 = _this8.state;
					_this9.tail.count += 1;
					_this9.totalCount += 1;
					_this8.indexDirty = true;
					var _this10 = this.content;
					_this10.index.push(pnext);
					var _this11 = _this10.state;
					_this11.tail.count += 1;
					_this11.totalCount += 1;
					_this10.indexDirty = true;
					var _this12 = this.content;
					_this12.index.push(pnext + 1);
					var _this13 = _this12.state;
					_this13.tail.count += 1;
					_this13.totalCount += 1;
					_this12.indexDirty = true;
				}
				this.pindex += 2;
			} else {
				var n0x = next.x - p.x;
				var n0y = next.y - p.y;
				var sign = n0x * nx + n0y * ny;
				var nnx = -ny;
				var nny = nx;
				var size1 = nnx * nx1 * ns1 + nny * ny1 * ns1;
				var d1 = this.lineSize * 0.5 / size1;
				nnx *= d1;
				nny *= d1;
				var pnext1 = i == last ? start : this.pindex + 3;
				if(sign > 0) {
					var _this14 = this.content;
					var x2 = p.x + nx;
					var y2 = p.y + ny;
					var r2 = p.r;
					var g2 = p.g;
					var b2 = p.b;
					var a2 = p.a;
					var this17 = _this14.tmp;
					if(this17.pos == this17.array.length) {
						var newSize16 = this17.array.length << 1;
						if(newSize16 < 128) {
							newSize16 = 128;
						}
						var newArray16 = new Float32Array(newSize16);
						newArray16.set(this17.array);
						this17.array = newArray16;
					}
					this17.array[this17.pos++] = x2;
					var this18 = _this14.tmp;
					if(this18.pos == this18.array.length) {
						var newSize17 = this18.array.length << 1;
						if(newSize17 < 128) {
							newSize17 = 128;
						}
						var newArray17 = new Float32Array(newSize17);
						newArray17.set(this18.array);
						this18.array = newArray17;
					}
					this18.array[this18.pos++] = y2;
					var this19 = _this14.tmp;
					if(this19.pos == this19.array.length) {
						var newSize18 = this19.array.length << 1;
						if(newSize18 < 128) {
							newSize18 = 128;
						}
						var newArray18 = new Float32Array(newSize18);
						newArray18.set(this19.array);
						this19.array = newArray18;
					}
					this19.array[this19.pos++] = 0;
					var this20 = _this14.tmp;
					if(this20.pos == this20.array.length) {
						var newSize19 = this20.array.length << 1;
						if(newSize19 < 128) {
							newSize19 = 128;
						}
						var newArray19 = new Float32Array(newSize19);
						newArray19.set(this20.array);
						this20.array = newArray19;
					}
					this20.array[this20.pos++] = 0;
					var this21 = _this14.tmp;
					if(this21.pos == this21.array.length) {
						var newSize20 = this21.array.length << 1;
						if(newSize20 < 128) {
							newSize20 = 128;
						}
						var newArray20 = new Float32Array(newSize20);
						newArray20.set(this21.array);
						this21.array = newArray20;
					}
					this21.array[this21.pos++] = r2;
					var this22 = _this14.tmp;
					if(this22.pos == this22.array.length) {
						var newSize21 = this22.array.length << 1;
						if(newSize21 < 128) {
							newSize21 = 128;
						}
						var newArray21 = new Float32Array(newSize21);
						newArray21.set(this22.array);
						this22.array = newArray21;
					}
					this22.array[this22.pos++] = g2;
					var this23 = _this14.tmp;
					if(this23.pos == this23.array.length) {
						var newSize22 = this23.array.length << 1;
						if(newSize22 < 128) {
							newSize22 = 128;
						}
						var newArray22 = new Float32Array(newSize22);
						newArray22.set(this23.array);
						this23.array = newArray22;
					}
					this23.array[this23.pos++] = b2;
					var this24 = _this14.tmp;
					if(this24.pos == this24.array.length) {
						var newSize23 = this24.array.length << 1;
						if(newSize23 < 128) {
							newSize23 = 128;
						}
						var newArray23 = new Float32Array(newSize23);
						newArray23.set(this24.array);
						this24.array = newArray23;
					}
					this24.array[this24.pos++] = a2;
					_this14.bufferDirty = true;
					var _this15 = this.content;
					var x3 = p.x - nnx;
					var y3 = p.y - nny;
					var r3 = p.r;
					var g3 = p.g;
					var b3 = p.b;
					var a3 = p.a;
					var this25 = _this15.tmp;
					if(this25.pos == this25.array.length) {
						var newSize24 = this25.array.length << 1;
						if(newSize24 < 128) {
							newSize24 = 128;
						}
						var newArray24 = new Float32Array(newSize24);
						newArray24.set(this25.array);
						this25.array = newArray24;
					}
					this25.array[this25.pos++] = x3;
					var this26 = _this15.tmp;
					if(this26.pos == this26.array.length) {
						var newSize25 = this26.array.length << 1;
						if(newSize25 < 128) {
							newSize25 = 128;
						}
						var newArray25 = new Float32Array(newSize25);
						newArray25.set(this26.array);
						this26.array = newArray25;
					}
					this26.array[this26.pos++] = y3;
					var this27 = _this15.tmp;
					if(this27.pos == this27.array.length) {
						var newSize26 = this27.array.length << 1;
						if(newSize26 < 128) {
							newSize26 = 128;
						}
						var newArray26 = new Float32Array(newSize26);
						newArray26.set(this27.array);
						this27.array = newArray26;
					}
					this27.array[this27.pos++] = 0;
					var this28 = _this15.tmp;
					if(this28.pos == this28.array.length) {
						var newSize27 = this28.array.length << 1;
						if(newSize27 < 128) {
							newSize27 = 128;
						}
						var newArray27 = new Float32Array(newSize27);
						newArray27.set(this28.array);
						this28.array = newArray27;
					}
					this28.array[this28.pos++] = 0;
					var this29 = _this15.tmp;
					if(this29.pos == this29.array.length) {
						var newSize28 = this29.array.length << 1;
						if(newSize28 < 128) {
							newSize28 = 128;
						}
						var newArray28 = new Float32Array(newSize28);
						newArray28.set(this29.array);
						this29.array = newArray28;
					}
					this29.array[this29.pos++] = r3;
					var this30 = _this15.tmp;
					if(this30.pos == this30.array.length) {
						var newSize29 = this30.array.length << 1;
						if(newSize29 < 128) {
							newSize29 = 128;
						}
						var newArray29 = new Float32Array(newSize29);
						newArray29.set(this30.array);
						this30.array = newArray29;
					}
					this30.array[this30.pos++] = g3;
					var this31 = _this15.tmp;
					if(this31.pos == this31.array.length) {
						var newSize30 = this31.array.length << 1;
						if(newSize30 < 128) {
							newSize30 = 128;
						}
						var newArray30 = new Float32Array(newSize30);
						newArray30.set(this31.array);
						this31.array = newArray30;
					}
					this31.array[this31.pos++] = b3;
					var this32 = _this15.tmp;
					if(this32.pos == this32.array.length) {
						var newSize31 = this32.array.length << 1;
						if(newSize31 < 128) {
							newSize31 = 128;
						}
						var newArray31 = new Float32Array(newSize31);
						newArray31.set(this32.array);
						this32.array = newArray31;
					}
					this32.array[this32.pos++] = a3;
					_this15.bufferDirty = true;
					var _this16 = this.content;
					var x4 = p.x + nnx;
					var y4 = p.y + nny;
					var r4 = p.r;
					var g4 = p.g;
					var b4 = p.b;
					var a4 = p.a;
					var this33 = _this16.tmp;
					if(this33.pos == this33.array.length) {
						var newSize32 = this33.array.length << 1;
						if(newSize32 < 128) {
							newSize32 = 128;
						}
						var newArray32 = new Float32Array(newSize32);
						newArray32.set(this33.array);
						this33.array = newArray32;
					}
					this33.array[this33.pos++] = x4;
					var this34 = _this16.tmp;
					if(this34.pos == this34.array.length) {
						var newSize33 = this34.array.length << 1;
						if(newSize33 < 128) {
							newSize33 = 128;
						}
						var newArray33 = new Float32Array(newSize33);
						newArray33.set(this34.array);
						this34.array = newArray33;
					}
					this34.array[this34.pos++] = y4;
					var this35 = _this16.tmp;
					if(this35.pos == this35.array.length) {
						var newSize34 = this35.array.length << 1;
						if(newSize34 < 128) {
							newSize34 = 128;
						}
						var newArray34 = new Float32Array(newSize34);
						newArray34.set(this35.array);
						this35.array = newArray34;
					}
					this35.array[this35.pos++] = 0;
					var this36 = _this16.tmp;
					if(this36.pos == this36.array.length) {
						var newSize35 = this36.array.length << 1;
						if(newSize35 < 128) {
							newSize35 = 128;
						}
						var newArray35 = new Float32Array(newSize35);
						newArray35.set(this36.array);
						this36.array = newArray35;
					}
					this36.array[this36.pos++] = 0;
					var this37 = _this16.tmp;
					if(this37.pos == this37.array.length) {
						var newSize36 = this37.array.length << 1;
						if(newSize36 < 128) {
							newSize36 = 128;
						}
						var newArray36 = new Float32Array(newSize36);
						newArray36.set(this37.array);
						this37.array = newArray36;
					}
					this37.array[this37.pos++] = r4;
					var this38 = _this16.tmp;
					if(this38.pos == this38.array.length) {
						var newSize37 = this38.array.length << 1;
						if(newSize37 < 128) {
							newSize37 = 128;
						}
						var newArray37 = new Float32Array(newSize37);
						newArray37.set(this38.array);
						this38.array = newArray37;
					}
					this38.array[this38.pos++] = g4;
					var this39 = _this16.tmp;
					if(this39.pos == this39.array.length) {
						var newSize38 = this39.array.length << 1;
						if(newSize38 < 128) {
							newSize38 = 128;
						}
						var newArray38 = new Float32Array(newSize38);
						newArray38.set(this39.array);
						this39.array = newArray38;
					}
					this39.array[this39.pos++] = b4;
					var this40 = _this16.tmp;
					if(this40.pos == this40.array.length) {
						var newSize39 = this40.array.length << 1;
						if(newSize39 < 128) {
							newSize39 = 128;
						}
						var newArray39 = new Float32Array(newSize39);
						newArray39.set(this40.array);
						this40.array = newArray39;
					}
					this40.array[this40.pos++] = a4;
					_this16.bufferDirty = true;
					var _this17 = this.content;
					_this17.index.push(this.pindex);
					var _this18 = _this17.state;
					_this18.tail.count += 1;
					_this18.totalCount += 1;
					_this17.indexDirty = true;
					var _this19 = this.content;
					_this19.index.push(pnext1);
					var _this20 = _this19.state;
					_this20.tail.count += 1;
					_this20.totalCount += 1;
					_this19.indexDirty = true;
					var _this21 = this.content;
					_this21.index.push(this.pindex + 2);
					var _this22 = _this21.state;
					_this22.tail.count += 1;
					_this22.totalCount += 1;
					_this21.indexDirty = true;
					var _this23 = this.content;
					_this23.index.push(this.pindex + 2);
					var _this24 = _this23.state;
					_this24.tail.count += 1;
					_this24.totalCount += 1;
					_this23.indexDirty = true;
					var _this25 = this.content;
					_this25.index.push(pnext1);
					var _this26 = _this25.state;
					_this26.tail.count += 1;
					_this26.totalCount += 1;
					_this25.indexDirty = true;
					var _this27 = this.content;
					_this27.index.push(pnext1 + 1);
					var _this28 = _this27.state;
					_this28.tail.count += 1;
					_this28.totalCount += 1;
					_this27.indexDirty = true;
				} else {
					var _this29 = this.content;
					var x5 = p.x + nnx;
					var y5 = p.y + nny;
					var r5 = p.r;
					var g5 = p.g;
					var b5 = p.b;
					var a5 = p.a;
					var this41 = _this29.tmp;
					if(this41.pos == this41.array.length) {
						var newSize40 = this41.array.length << 1;
						if(newSize40 < 128) {
							newSize40 = 128;
						}
						var newArray40 = new Float32Array(newSize40);
						newArray40.set(this41.array);
						this41.array = newArray40;
					}
					this41.array[this41.pos++] = x5;
					var this42 = _this29.tmp;
					if(this42.pos == this42.array.length) {
						var newSize41 = this42.array.length << 1;
						if(newSize41 < 128) {
							newSize41 = 128;
						}
						var newArray41 = new Float32Array(newSize41);
						newArray41.set(this42.array);
						this42.array = newArray41;
					}
					this42.array[this42.pos++] = y5;
					var this43 = _this29.tmp;
					if(this43.pos == this43.array.length) {
						var newSize42 = this43.array.length << 1;
						if(newSize42 < 128) {
							newSize42 = 128;
						}
						var newArray42 = new Float32Array(newSize42);
						newArray42.set(this43.array);
						this43.array = newArray42;
					}
					this43.array[this43.pos++] = 0;
					var this44 = _this29.tmp;
					if(this44.pos == this44.array.length) {
						var newSize43 = this44.array.length << 1;
						if(newSize43 < 128) {
							newSize43 = 128;
						}
						var newArray43 = new Float32Array(newSize43);
						newArray43.set(this44.array);
						this44.array = newArray43;
					}
					this44.array[this44.pos++] = 0;
					var this45 = _this29.tmp;
					if(this45.pos == this45.array.length) {
						var newSize44 = this45.array.length << 1;
						if(newSize44 < 128) {
							newSize44 = 128;
						}
						var newArray44 = new Float32Array(newSize44);
						newArray44.set(this45.array);
						this45.array = newArray44;
					}
					this45.array[this45.pos++] = r5;
					var this46 = _this29.tmp;
					if(this46.pos == this46.array.length) {
						var newSize45 = this46.array.length << 1;
						if(newSize45 < 128) {
							newSize45 = 128;
						}
						var newArray45 = new Float32Array(newSize45);
						newArray45.set(this46.array);
						this46.array = newArray45;
					}
					this46.array[this46.pos++] = g5;
					var this47 = _this29.tmp;
					if(this47.pos == this47.array.length) {
						var newSize46 = this47.array.length << 1;
						if(newSize46 < 128) {
							newSize46 = 128;
						}
						var newArray46 = new Float32Array(newSize46);
						newArray46.set(this47.array);
						this47.array = newArray46;
					}
					this47.array[this47.pos++] = b5;
					var this48 = _this29.tmp;
					if(this48.pos == this48.array.length) {
						var newSize47 = this48.array.length << 1;
						if(newSize47 < 128) {
							newSize47 = 128;
						}
						var newArray47 = new Float32Array(newSize47);
						newArray47.set(this48.array);
						this48.array = newArray47;
					}
					this48.array[this48.pos++] = a5;
					_this29.bufferDirty = true;
					var _this30 = this.content;
					var x6 = p.x - nx;
					var y6 = p.y - ny;
					var r6 = p.r;
					var g6 = p.g;
					var b6 = p.b;
					var a6 = p.a;
					var this49 = _this30.tmp;
					if(this49.pos == this49.array.length) {
						var newSize48 = this49.array.length << 1;
						if(newSize48 < 128) {
							newSize48 = 128;
						}
						var newArray48 = new Float32Array(newSize48);
						newArray48.set(this49.array);
						this49.array = newArray48;
					}
					this49.array[this49.pos++] = x6;
					var this50 = _this30.tmp;
					if(this50.pos == this50.array.length) {
						var newSize49 = this50.array.length << 1;
						if(newSize49 < 128) {
							newSize49 = 128;
						}
						var newArray49 = new Float32Array(newSize49);
						newArray49.set(this50.array);
						this50.array = newArray49;
					}
					this50.array[this50.pos++] = y6;
					var this51 = _this30.tmp;
					if(this51.pos == this51.array.length) {
						var newSize50 = this51.array.length << 1;
						if(newSize50 < 128) {
							newSize50 = 128;
						}
						var newArray50 = new Float32Array(newSize50);
						newArray50.set(this51.array);
						this51.array = newArray50;
					}
					this51.array[this51.pos++] = 0;
					var this52 = _this30.tmp;
					if(this52.pos == this52.array.length) {
						var newSize51 = this52.array.length << 1;
						if(newSize51 < 128) {
							newSize51 = 128;
						}
						var newArray51 = new Float32Array(newSize51);
						newArray51.set(this52.array);
						this52.array = newArray51;
					}
					this52.array[this52.pos++] = 0;
					var this53 = _this30.tmp;
					if(this53.pos == this53.array.length) {
						var newSize52 = this53.array.length << 1;
						if(newSize52 < 128) {
							newSize52 = 128;
						}
						var newArray52 = new Float32Array(newSize52);
						newArray52.set(this53.array);
						this53.array = newArray52;
					}
					this53.array[this53.pos++] = r6;
					var this54 = _this30.tmp;
					if(this54.pos == this54.array.length) {
						var newSize53 = this54.array.length << 1;
						if(newSize53 < 128) {
							newSize53 = 128;
						}
						var newArray53 = new Float32Array(newSize53);
						newArray53.set(this54.array);
						this54.array = newArray53;
					}
					this54.array[this54.pos++] = g6;
					var this55 = _this30.tmp;
					if(this55.pos == this55.array.length) {
						var newSize54 = this55.array.length << 1;
						if(newSize54 < 128) {
							newSize54 = 128;
						}
						var newArray54 = new Float32Array(newSize54);
						newArray54.set(this55.array);
						this55.array = newArray54;
					}
					this55.array[this55.pos++] = b6;
					var this56 = _this30.tmp;
					if(this56.pos == this56.array.length) {
						var newSize55 = this56.array.length << 1;
						if(newSize55 < 128) {
							newSize55 = 128;
						}
						var newArray55 = new Float32Array(newSize55);
						newArray55.set(this56.array);
						this56.array = newArray55;
					}
					this56.array[this56.pos++] = a6;
					_this30.bufferDirty = true;
					var _this31 = this.content;
					var x7 = p.x - nnx;
					var y7 = p.y - nny;
					var r7 = p.r;
					var g7 = p.g;
					var b7 = p.b;
					var a7 = p.a;
					var this57 = _this31.tmp;
					if(this57.pos == this57.array.length) {
						var newSize56 = this57.array.length << 1;
						if(newSize56 < 128) {
							newSize56 = 128;
						}
						var newArray56 = new Float32Array(newSize56);
						newArray56.set(this57.array);
						this57.array = newArray56;
					}
					this57.array[this57.pos++] = x7;
					var this58 = _this31.tmp;
					if(this58.pos == this58.array.length) {
						var newSize57 = this58.array.length << 1;
						if(newSize57 < 128) {
							newSize57 = 128;
						}
						var newArray57 = new Float32Array(newSize57);
						newArray57.set(this58.array);
						this58.array = newArray57;
					}
					this58.array[this58.pos++] = y7;
					var this59 = _this31.tmp;
					if(this59.pos == this59.array.length) {
						var newSize58 = this59.array.length << 1;
						if(newSize58 < 128) {
							newSize58 = 128;
						}
						var newArray58 = new Float32Array(newSize58);
						newArray58.set(this59.array);
						this59.array = newArray58;
					}
					this59.array[this59.pos++] = 0;
					var this60 = _this31.tmp;
					if(this60.pos == this60.array.length) {
						var newSize59 = this60.array.length << 1;
						if(newSize59 < 128) {
							newSize59 = 128;
						}
						var newArray59 = new Float32Array(newSize59);
						newArray59.set(this60.array);
						this60.array = newArray59;
					}
					this60.array[this60.pos++] = 0;
					var this61 = _this31.tmp;
					if(this61.pos == this61.array.length) {
						var newSize60 = this61.array.length << 1;
						if(newSize60 < 128) {
							newSize60 = 128;
						}
						var newArray60 = new Float32Array(newSize60);
						newArray60.set(this61.array);
						this61.array = newArray60;
					}
					this61.array[this61.pos++] = r7;
					var this62 = _this31.tmp;
					if(this62.pos == this62.array.length) {
						var newSize61 = this62.array.length << 1;
						if(newSize61 < 128) {
							newSize61 = 128;
						}
						var newArray61 = new Float32Array(newSize61);
						newArray61.set(this62.array);
						this62.array = newArray61;
					}
					this62.array[this62.pos++] = g7;
					var this63 = _this31.tmp;
					if(this63.pos == this63.array.length) {
						var newSize62 = this63.array.length << 1;
						if(newSize62 < 128) {
							newSize62 = 128;
						}
						var newArray62 = new Float32Array(newSize62);
						newArray62.set(this63.array);
						this63.array = newArray62;
					}
					this63.array[this63.pos++] = b7;
					var this64 = _this31.tmp;
					if(this64.pos == this64.array.length) {
						var newSize63 = this64.array.length << 1;
						if(newSize63 < 128) {
							newSize63 = 128;
						}
						var newArray63 = new Float32Array(newSize63);
						newArray63.set(this64.array);
						this64.array = newArray63;
					}
					this64.array[this64.pos++] = a7;
					_this31.bufferDirty = true;
					var _this32 = this.content;
					_this32.index.push(this.pindex + 1);
					var _this33 = _this32.state;
					_this33.tail.count += 1;
					_this33.totalCount += 1;
					_this32.indexDirty = true;
					var _this34 = this.content;
					_this34.index.push(pnext1);
					var _this35 = _this34.state;
					_this35.tail.count += 1;
					_this35.totalCount += 1;
					_this34.indexDirty = true;
					var _this36 = this.content;
					_this36.index.push(this.pindex + 2);
					var _this37 = _this36.state;
					_this37.tail.count += 1;
					_this37.totalCount += 1;
					_this36.indexDirty = true;
					var _this38 = this.content;
					_this38.index.push(this.pindex + 1);
					var _this39 = _this38.state;
					_this39.tail.count += 1;
					_this39.totalCount += 1;
					_this38.indexDirty = true;
					var _this40 = this.content;
					_this40.index.push(pnext1);
					var _this41 = _this40.state;
					_this41.tail.count += 1;
					_this41.totalCount += 1;
					_this40.indexDirty = true;
					var _this42 = this.content;
					_this42.index.push(pnext1 + 1);
					var _this43 = _this42.state;
					_this43.tail.count += 1;
					_this43.totalCount += 1;
					_this42.indexDirty = true;
				}
				var _this44 = this.content;
				_this44.index.push(this.pindex);
				var _this45 = _this44.state;
				_this45.tail.count += 1;
				_this45.totalCount += 1;
				_this44.indexDirty = true;
				var _this46 = this.content;
				_this46.index.push(this.pindex + 1);
				var _this47 = _this46.state;
				_this47.tail.count += 1;
				_this47.totalCount += 1;
				_this46.indexDirty = true;
				var _this48 = this.content;
				_this48.index.push(this.pindex + 2);
				var _this49 = _this48.state;
				_this49.tail.count += 1;
				_this49.totalCount += 1;
				_this48.indexDirty = true;
				this.pindex += 3;
			}
			prev = p;
			p = next;
		}
		this.content.setTile(this.tile);
	}
	,flushFill: function(i0) {
		if(this.tmpPoints.length < 3) {
			return;
		}
		var pts = this.tmpPoints;
		var p0 = pts[0];
		var p1 = pts[pts.length - 1];
		var last = null;
		var tmp;
		var f = p0.x - p1.x;
		if((f < 0 ? -f : f) < 1e-9) {
			var f = p0.y - p1.y;
			tmp = (f < 0 ? -f : f) < 1e-9;
		} else {
			tmp = false;
		}
		if(tmp) {
			last = pts.pop();
		}
		if(this.isConvex(pts)) {
			var _g = 1;
			var _g1 = pts.length - 1;
			while(_g < _g1) {
				var i = _g++;
				var _this = this.content;
				_this.index.push(i0);
				var _this1 = _this.state;
				_this1.tail.count += 1;
				_this1.totalCount += 1;
				_this.indexDirty = true;
				var _this2 = this.content;
				_this2.index.push(i0 + i);
				var _this3 = _this2.state;
				_this3.tail.count += 1;
				_this3.totalCount += 1;
				_this2.indexDirty = true;
				var _this4 = this.content;
				_this4.index.push(i0 + i + 1);
				var _this5 = _this4.state;
				_this5.tail.count += 1;
				_this5.totalCount += 1;
				_this4.indexDirty = true;
			}
		} else {
			var ear = h2d_Graphics.EARCUT;
			if(ear == null) {
				ear = new hxd_earcut_Earcut();
				h2d_Graphics.EARCUT = ear;
			}
			var _g = 0;
			var _g1 = ear.triangulate_h2d_GPoint(pts);
			while(_g < _g1.length) {
				var i = _g1[_g];
				++_g;
				var _this = this.content;
				_this.index.push(i + i0);
				var _this1 = _this.state;
				_this1.tail.count += 1;
				_this1.totalCount += 1;
				_this.indexDirty = true;
			}
		}
		if(last != null) {
			pts.push(last);
		}
	}
	,flush: function() {
		if(this.tmpPoints.length == 0) {
			return;
		}
		if(this.doFill) {
			this.flushFill(this.pindex);
			this.pindex += this.tmpPoints.length;
			if(this.content.next()) {
				this.pindex = 0;
			}
		}
		if(this.lineSize > 0) {
			this.flushLine(this.pindex);
			if(this.content.next()) {
				this.pindex = 0;
			}
		}
		this.tmpPoints = [];
	}
	,lineStyle: function(size,color,alpha) {
		if(alpha == null) {
			alpha = 1.;
		}
		if(color == null) {
			color = 0;
		}
		if(size == null) {
			size = 0;
		}
		this.flush();
		this.lineSize = size;
		this.lineA = alpha;
		this.lineR = (color >> 16 & 255) / 255.;
		this.lineG = (color >> 8 & 255) / 255.;
		this.lineB = (color & 255) / 255.;
	}
	,drawRect: function(x,y,w,h) {
		this.flush();
		this.addVertex(x,y,this.curR,this.curG,this.curB,this.curA,x * this.ma + y * this.mc + this.mx,x * this.mb + y * this.md + this.my);
		var x1 = x + w;
		this.addVertex(x1,y,this.curR,this.curG,this.curB,this.curA,x1 * this.ma + y * this.mc + this.mx,x1 * this.mb + y * this.md + this.my);
		var x1 = x + w;
		var y1 = y + h;
		this.addVertex(x1,y1,this.curR,this.curG,this.curB,this.curA,x1 * this.ma + y1 * this.mc + this.mx,x1 * this.mb + y1 * this.md + this.my);
		var y1 = y + h;
		this.addVertex(x,y1,this.curR,this.curG,this.curB,this.curA,x * this.ma + y1 * this.mc + this.mx,x * this.mb + y1 * this.md + this.my);
		this.addVertex(x,y,this.curR,this.curG,this.curB,this.curA,x * this.ma + y * this.mc + this.mx,x * this.mb + y * this.md + this.my);
		var e = 0.01;
		this.tmpPoints[0].x += e;
		this.tmpPoints[0].y += e;
		this.tmpPoints[1].y += e;
		this.tmpPoints[3].x += e;
		this.tmpPoints[4].x += e;
		this.tmpPoints[4].y += e;
		this.flush();
	}
	,addVertex: function(x,y,r,g,b,a,u,v) {
		if(v == null) {
			v = 0.;
		}
		if(u == null) {
			u = 0.;
		}
		if(x < this.xMin) {
			this.xMin = x;
		}
		if(y < this.yMin) {
			this.yMin = y;
		}
		if(x > this.xMax) {
			this.xMax = x;
		}
		if(y > this.yMax) {
			this.yMax = y;
		}
		if(this.doFill) {
			var _this = this.content;
			var this1 = _this.tmp;
			if(this1.pos == this1.array.length) {
				var newSize = this1.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(this1.array);
				this1.array = newArray;
			}
			this1.array[this1.pos++] = x;
			var this1 = _this.tmp;
			if(this1.pos == this1.array.length) {
				var newSize = this1.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(this1.array);
				this1.array = newArray;
			}
			this1.array[this1.pos++] = y;
			var this1 = _this.tmp;
			if(this1.pos == this1.array.length) {
				var newSize = this1.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(this1.array);
				this1.array = newArray;
			}
			this1.array[this1.pos++] = u;
			var this1 = _this.tmp;
			if(this1.pos == this1.array.length) {
				var newSize = this1.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(this1.array);
				this1.array = newArray;
			}
			this1.array[this1.pos++] = v;
			var this1 = _this.tmp;
			if(this1.pos == this1.array.length) {
				var newSize = this1.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(this1.array);
				this1.array = newArray;
			}
			this1.array[this1.pos++] = r;
			var this1 = _this.tmp;
			if(this1.pos == this1.array.length) {
				var newSize = this1.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(this1.array);
				this1.array = newArray;
			}
			this1.array[this1.pos++] = g;
			var this1 = _this.tmp;
			if(this1.pos == this1.array.length) {
				var newSize = this1.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(this1.array);
				this1.array = newArray;
			}
			this1.array[this1.pos++] = b;
			var this1 = _this.tmp;
			if(this1.pos == this1.array.length) {
				var newSize = this1.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(this1.array);
				this1.array = newArray;
			}
			this1.array[this1.pos++] = a;
			_this.bufferDirty = true;
		}
		var gp = new h2d_GPoint();
		gp.load(x,y,this.lineR,this.lineG,this.lineB,this.lineA);
		this.tmpPoints.push(gp);
	}
	,draw: function(ctx) {
		if(!ctx.beginDrawBatchState(this)) {
			return;
		}
		this.content.doRender(ctx);
	}
	,sync: function(ctx) {
		h2d_Drawable.prototype.sync.call(this,ctx);
		this.flush();
		this.content.flush();
	}
	,__class__: h2d_Graphics
});
var h2d_Text = function(font,parent) {
	this.realMaxWidth = -1;
	this.constraintWidth = -1;
	this.lineBreak = true;
	this.lineSpacing = 0;
	this.letterSpacing = 0;
	h2d_Drawable.call(this,parent);
	this.set_font(font);
	this.set_textAlign(h2d_Align.Left);
	this.set_text("");
	this.currentText = "";
	this.set_textColor(16777215);
};
$hxClasses["h2d.Text"] = h2d_Text;
h2d_Text.__name__ = "h2d.Text";
h2d_Text.__super__ = h2d_Drawable;
h2d_Text.prototype = $extend(h2d_Drawable.prototype,{
	set_font: function(font) {
		if(this.font == font) {
			return font;
		}
		this.font = font;
		if(font != null) {
			var _g = font.type;
			switch(_g._hx_index) {
			case 0:
				if(this.sdfShader != null) {
					this.removeShader(this.sdfShader);
					this.sdfShader = null;
				}
				break;
			case 1:
				var channel = _g.channel;
				var alphaCutoff = _g.alphaCutoff;
				var smoothing = _g.smoothing;
				if(this.sdfShader == null) {
					this.sdfShader = new h3d_shader_SignedDistanceField();
					this.addShader(this.sdfShader);
				}
				if(this.smooth == null) {
					this.smooth = true;
				}
				this.sdfShader.alphaCutoff__ = alphaCutoff;
				this.sdfShader.smoothing__ = smoothing;
				var _this = this.sdfShader;
				_this.constModified = true;
				_this.channel__ = channel;
				var _this = this.sdfShader;
				_this.constModified = true;
				_this.autoSmoothing__ = smoothing == -1;
				break;
			}
		}
		if(this.glyphs != null) {
			var _this = this.glyphs;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
		}
		this.glyphs = new h2d_TileGroup(font == null ? null : font.tile,this);
		this.glyphs.set_visible(false);
		this.rebuild();
		return font;
	}
	,set_textAlign: function(a) {
		if(this.textAlign == a) {
			return a;
		}
		this.textAlign = a;
		this.rebuild();
		return a;
	}
	,constraintSize: function(width,height) {
		this.constraintWidth = width;
		this.updateConstraint();
	}
	,onAdd: function() {
		h2d_Drawable.prototype.onAdd.call(this);
		this.rebuild();
	}
	,sync: function(ctx) {
		h2d_Drawable.prototype.sync.call(this,ctx);
		if(this.textChanged && this.text != this.currentText) {
			this.textChanged = false;
			this.currentText = this.text;
			this.calcDone = false;
			this.needsRebuild = true;
		}
		if(this.needsRebuild) {
			this.initGlyphs(this.currentText);
		}
	}
	,draw: function(ctx) {
		if(this.glyphs == null) {
			this.emitTile(ctx,h2d_Tile.fromColor(16711935,16,16));
			return;
		}
		if(this.textChanged && this.text != this.currentText) {
			this.textChanged = false;
			this.currentText = this.text;
			this.calcDone = false;
			this.needsRebuild = true;
		}
		if(this.needsRebuild) {
			this.initGlyphs(this.currentText);
		}
		if(this.dropShadow != null) {
			var oldX = this.absX;
			var oldY = this.absY;
			this.absX += this.dropShadow.dx * this.matA + this.dropShadow.dy * this.matC;
			this.absY += this.dropShadow.dx * this.matB + this.dropShadow.dy * this.matD;
			var oldR = this.color.x;
			var oldG = this.color.y;
			var oldB = this.color.z;
			var oldA = this.color.w;
			var _this = this.color;
			var c = this.dropShadow.color;
			_this.x = (c >> 16 & 255) / 255;
			_this.y = (c >> 8 & 255) / 255;
			_this.z = (c & 255) / 255;
			_this.w = (c >>> 24) / 255;
			this.color.w = this.dropShadow.alpha * oldA;
			this.glyphs.drawWith(ctx,this);
			this.absX = oldX;
			this.absY = oldY;
			var _this = this.color;
			var x = oldR;
			var y = oldG;
			var z = oldB;
			var w = oldA;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		}
		this.glyphs.drawWith(ctx,this);
	}
	,set_text: function(t) {
		var t1 = t == null ? "null" : t;
		if(t1 == this.text) {
			return t1;
		}
		this.text = t1;
		this.textChanged = true;
		this.validateText();
		if(this.parentContainer != null) {
			this.parentContainer.contentChanged(this);
		}
		return t1;
	}
	,validateText: function() {
	}
	,rebuild: function() {
		this.calcDone = false;
		this.needsRebuild = true;
		if(this.parentContainer != null) {
			this.parentContainer.contentChanged(this);
		}
	}
	,splitRawText: function(text,leftMargin,afterData,font,sizes,prevChar) {
		if(prevChar == null) {
			prevChar = -1;
		}
		if(afterData == null) {
			afterData = 0.;
		}
		if(leftMargin == null) {
			leftMargin = 0.;
		}
		var maxWidth = this.realMaxWidth;
		if(maxWidth < 0) {
			if(sizes == null) {
				return text;
			} else {
				maxWidth = Infinity;
			}
		}
		if(font == null) {
			font = this.font;
		}
		var lines = [];
		var restPos = 0;
		var x = leftMargin;
		var _g = 0;
		var _g1 = text.length;
		while(_g < _g1) {
			var i = _g++;
			var cc = HxOverrides.cca(text,i);
			var c = font.glyphs.h[cc];
			if(c == null) {
				c = font.charset.resolveChar(cc,font.glyphs);
				if(c == null) {
					c = cc == 13 || cc == 10 ? font.nullChar : font.defaultChar;
				}
			}
			var e = c;
			var newline = cc == 10;
			var esize = e.width + e.getKerningOffset(prevChar);
			var nc = HxOverrides.cca(text,i + 1);
			if(font.charset.isBreakChar(cc) && (nc == null || !font.charset.isComplementChar(nc))) {
				if(lines.length == 0 && leftMargin > 0 && x > maxWidth) {
					lines.push("");
					if(sizes != null) {
						sizes.push(leftMargin);
					}
					x -= leftMargin;
				}
				var size = x + esize + this.letterSpacing;
				var k = i + 1;
				var max = text.length;
				var prevChar1 = prevChar;
				var breakFound = false;
				while(size <= maxWidth && k < max) {
					var cc1 = HxOverrides.cca(text,k++);
					if(this.lineBreak && (font.charset.isSpace(cc1) || cc1 == 10)) {
						breakFound = true;
						break;
					}
					var c1 = font.glyphs.h[cc1];
					if(c1 == null) {
						c1 = font.charset.resolveChar(cc1,font.glyphs);
						if(c1 == null) {
							c1 = cc1 == 13 || cc1 == 10 ? font.nullChar : font.defaultChar;
						}
					}
					var e1 = c1;
					size += e1.width + this.letterSpacing + e1.getKerningOffset(prevChar1);
					prevChar1 = cc1;
					var nc1 = HxOverrides.cca(text,k + 1);
					if(font.charset.isBreakChar(cc1) && (nc1 == null || !font.charset.isComplementChar(nc1))) {
						break;
					}
				}
				if(this.lineBreak && (size > maxWidth || !breakFound && size + afterData > maxWidth)) {
					newline = true;
					if(font.charset.isSpace(cc)) {
						lines.push(HxOverrides.substr(text,restPos,i - restPos));
						e = null;
					} else {
						lines.push(HxOverrides.substr(text,restPos,i + 1 - restPos));
					}
					restPos = i + 1;
				}
			}
			if(e != null && cc != 10) {
				x += esize + this.letterSpacing;
			}
			if(newline) {
				if(sizes != null) {
					sizes.push(x);
				}
				x = 0;
				prevChar = -1;
			} else {
				prevChar = cc;
			}
		}
		if(restPos < text.length) {
			if(lines.length == 0 && leftMargin > 0 && x + afterData - this.letterSpacing > maxWidth) {
				lines.push("");
				if(sizes != null) {
					sizes.push(leftMargin);
				}
				x -= leftMargin;
			}
			lines.push(HxOverrides.substr(text,restPos,text.length - restPos));
			if(sizes != null) {
				sizes.push(x);
			}
		}
		return lines.join("\n");
	}
	,initGlyphs: function(text,rebuild) {
		if(rebuild == null) {
			rebuild = true;
		}
		if(rebuild) {
			this.glyphs.clear();
		}
		var x = 0.;
		var y = 0.;
		var xMax = 0.;
		var xMin = 0.;
		var yMin = 0.;
		var prevChar = -1;
		var linei = 0;
		var align = this.textAlign;
		var lines = [];
		var dl = this.font.lineHeight + this.lineSpacing;
		var t = this.splitRawText(text,0,0,null,lines);
		var _g = 0;
		while(_g < lines.length) {
			var lw = lines[_g];
			++_g;
			if(lw > x) {
				x = lw;
			}
		}
		this.calcWidth = x;
		switch(align._hx_index) {
		case 0:
			x = 0;
			break;
		case 1:case 2:case 3:case 4:
			var max = align == h2d_Align.MultilineCenter || align == h2d_Align.MultilineRight ? Math.ceil(this.calcWidth) : this.realMaxWidth < 0 ? 0 : Math.ceil(this.realMaxWidth);
			var k = align == h2d_Align.Center || align == h2d_Align.MultilineCenter ? 0.5 : 1;
			var _g = 0;
			var _g1 = lines.length;
			while(_g < _g1) {
				var i = _g++;
				lines[i] = Math.floor((max - lines[i]) * k);
			}
			x = lines[0];
			xMin = x;
			break;
		}
		var _g = 0;
		var _g1 = t.length;
		while(_g < _g1) {
			var i = _g++;
			var cc = HxOverrides.cca(t,i);
			var _this = this.font;
			var c = _this.glyphs.h[cc];
			if(c == null) {
				c = _this.charset.resolveChar(cc,_this.glyphs);
				if(c == null) {
					c = cc == 13 || cc == 10 ? _this.nullChar : _this.defaultChar;
				}
			}
			var e = c;
			var offs = e.getKerningOffset(prevChar);
			var esize = e.width + offs;
			if(cc == 10) {
				if(x > xMax) {
					xMax = x;
				}
				switch(align._hx_index) {
				case 0:
					x = 0;
					break;
				case 1:case 2:case 3:case 4:
					x = lines[++linei];
					if(x < xMin) {
						xMin = x;
					}
					break;
				}
				y += dl;
				prevChar = -1;
			} else {
				if(e != null) {
					if(rebuild) {
						var _this1 = this.glyphs;
						_this1.content.add(x + offs,y,_this1.curColor.x,_this1.curColor.y,_this1.curColor.z,_this1.curColor.w,e.t);
					}
					if(y == 0 && e.t.dy < yMin) {
						yMin = e.t.dy;
					}
					x += esize + this.letterSpacing;
				}
				prevChar = cc;
			}
		}
		if(x > xMax) {
			xMax = x;
		}
		this.calcXMin = xMin;
		this.calcYMin = yMin;
		this.calcWidth = xMax - xMin;
		this.calcHeight = y + this.font.lineHeight;
		this.calcSizeHeight = y + (this.font.baseLine > 0 ? this.font.baseLine : this.font.lineHeight);
		this.calcDone = true;
		if(rebuild) {
			this.needsRebuild = false;
		}
	}
	,get_textHeight: function() {
		if(this.textChanged && this.text != this.currentText) {
			this.textChanged = false;
			this.currentText = this.text;
			this.calcDone = false;
			this.needsRebuild = true;
		}
		if(!this.calcDone) {
			this.initGlyphs(this.text,this.needsRebuild);
		}
		return this.calcHeight;
	}
	,get_textWidth: function() {
		if(this.textChanged && this.text != this.currentText) {
			this.textChanged = false;
			this.currentText = this.text;
			this.calcDone = false;
			this.needsRebuild = true;
		}
		if(!this.calcDone) {
			this.initGlyphs(this.text,this.needsRebuild);
		}
		return this.calcWidth;
	}
	,set_maxWidth: function(w) {
		if(this.maxWidth == w) {
			return w;
		}
		this.maxWidth = w;
		this.updateConstraint();
		return w;
	}
	,updateConstraint: function() {
		var old = this.realMaxWidth;
		if(this.maxWidth == null) {
			this.realMaxWidth = this.constraintWidth;
		} else if(this.constraintWidth < 0) {
			this.realMaxWidth = this.maxWidth;
		} else {
			var a = this.maxWidth;
			var b = this.constraintWidth;
			this.realMaxWidth = a > b ? b : a;
		}
		if(this.realMaxWidth != old) {
			this.rebuild();
		}
	}
	,set_textColor: function(c) {
		if(this.textColor == c) {
			return c;
		}
		this.textColor = c;
		var a = this.color.w;
		var _this = this.color;
		_this.x = (c >> 16 & 255) / 255;
		_this.y = (c >> 8 & 255) / 255;
		_this.z = (c & 255) / 255;
		_this.w = (c >>> 24) / 255;
		this.color.w = a;
		return c;
	}
	,getBoundsRec: function(relativeTo,out,forSize) {
		h2d_Drawable.prototype.getBoundsRec.call(this,relativeTo,out,forSize);
		if(this.textChanged && this.text != this.currentText) {
			this.textChanged = false;
			this.currentText = this.text;
			this.calcDone = false;
			this.needsRebuild = true;
		}
		if(!this.calcDone) {
			this.initGlyphs(this.text,this.needsRebuild);
		}
		var x;
		var y;
		var w;
		var h;
		if(forSize) {
			x = this.calcXMin;
			y = 0.;
			w = this.calcWidth;
			h = this.calcSizeHeight;
		} else {
			x = this.calcXMin;
			y = this.calcYMin;
			w = this.calcWidth;
			h = this.calcHeight - this.calcYMin;
		}
		this.addBounds(relativeTo,out,x,y,w,h);
	}
	,__class__: h2d_Text
});
var hxd_Interactive = function() { };
$hxClasses["hxd.Interactive"] = hxd_Interactive;
hxd_Interactive.__name__ = "hxd.Interactive";
hxd_Interactive.__isInterface__ = true;
hxd_Interactive.prototype = {
	__class__: hxd_Interactive
};
var h2d_Interactive = function(width,height,parent,shape) {
	this.shapeY = 0;
	this.shapeX = 0;
	this.lastClickFrame = -1;
	this.mouseDownButton = -1;
	this.allowMultiClick = false;
	this.enableRightButton = false;
	this.propagateEvents = false;
	this.cancelEvents = false;
	this.cursor = hxd_Cursor.Button;
	h2d_Object.call(this,parent);
	this.width = width;
	this.height = height;
	this.shape = shape;
};
$hxClasses["h2d.Interactive"] = h2d_Interactive;
h2d_Interactive.__name__ = "h2d.Interactive";
h2d_Interactive.__interfaces__ = [hxd_Interactive];
h2d_Interactive.__super__ = h2d_Object;
h2d_Interactive.prototype = $extend(h2d_Object.prototype,{
	onAdd: function() {
		this.scene = this.getScene();
		if(this.scene != null) {
			this.scene.addEventTarget(this);
		}
		h2d_Object.prototype.onAdd.call(this);
	}
	,draw: function(ctx) {
		this.maskedBounds = ctx.getCurrentRenderZone();
		if(this.backgroundColor != null) {
			this.emitTile(ctx,h2d_Tile.fromColor(this.backgroundColor,this.width | 0,this.height | 0,(this.backgroundColor >>> 24) / 255));
		}
	}
	,getBoundsRec: function(relativeTo,out,forSize) {
		h2d_Object.prototype.getBoundsRec.call(this,relativeTo,out,forSize);
		if(this.backgroundColor != null || forSize) {
			this.addBounds(relativeTo,out,0,0,this.width | 0,this.height | 0);
		}
	}
	,onHierarchyMoved: function(parentChanged) {
		h2d_Object.prototype.onHierarchyMoved.call(this,parentChanged);
		if(this.scene != null) {
			this.scene.removeEventTarget(this);
			this.scene = this.getScene();
			if(this.scene != null) {
				this.scene.addEventTarget(this);
			}
		}
	}
	,onRemove: function() {
		if(this.scene != null) {
			this.scene.removeEventTarget(this,true);
			this.scene = null;
		}
		h2d_Object.prototype.onRemove.call(this);
	}
	,checkBounds: function(e) {
		switch(e.kind._hx_index) {
		case 4:case 6:case 7:case 10:
			return false;
		default:
			return true;
		}
	}
	,getInteractiveScene: function() {
		return this.scene;
	}
	,handleEvent: function(e) {
		if(this.maskedBounds != null && this.checkBounds(e)) {
			var pt = new h2d_col_Point(e.relX,e.relY);
			this.localToGlobal(pt);
			if(pt.x < this.maskedBounds.xMin || pt.y < this.maskedBounds.yMin || pt.x > this.maskedBounds.xMax || pt.y > this.maskedBounds.yMax) {
				e.cancel = true;
				return;
			}
		}
		if(this.shape == null && this.isEllipse && this.checkBounds(e)) {
			var cx = this.width * 0.5;
			var cy = this.height * 0.5;
			var dx = (e.relX - cx) / cx;
			var dy = (e.relY - cy) / cy;
			if(dx * dx + dy * dy > 1) {
				e.cancel = true;
				return;
			}
		}
		if(this.propagateEvents) {
			e.propagate = true;
		}
		if(this.cancelEvents) {
			e.cancel = true;
		}
		switch(e.kind._hx_index) {
		case 0:
			if(this.enableRightButton || e.button == 0) {
				this.mouseDownButton = e.button;
				this.onPush(e);
				if(e.cancel) {
					this.mouseDownButton = -1;
				}
			}
			break;
		case 1:
			if(this.enableRightButton || e.button == 0) {
				this.onRelease(e);
				var frame = hxd_Timer.frameCount;
				if(this.mouseDownButton == e.button && (this.lastClickFrame != frame || this.allowMultiClick)) {
					this.onClick(e);
					this.lastClickFrame = frame;
				}
			}
			this.mouseDownButton = -1;
			break;
		case 2:
			this.onMove(e);
			break;
		case 3:
			this.onOver(e);
			break;
		case 4:
			this.onOut(e);
			break;
		case 5:
			e.propagate = true;
			this.onWheel(e);
			break;
		case 6:
			this.onFocus(e);
			break;
		case 7:
			this.onFocusLost(e);
			break;
		case 8:
			this.onKeyDown(e);
			break;
		case 9:
			this.onKeyUp(e);
			break;
		case 10:
			if(this.enableRightButton || e.button == 0) {
				this.onRelease(e);
				if(this.mouseDownButton == e.button) {
					this.onReleaseOutside(e);
				}
			}
			this.mouseDownButton = -1;
			break;
		case 11:
			this.onTextInput(e);
			break;
		case 12:
			this.onCheck(e);
			break;
		}
	}
	,calcAbsPos: function() {
		h2d_Object.prototype.calcAbsPos.call(this);
		this.invDet = 1 / (this.matA * this.matD - this.matB * this.matC);
	}
	,set_cursor: function(c) {
		this.cursor = c;
		if(this.scene != null && this.scene.events != null) {
			this.scene.events.updateCursor(this);
		}
		return c;
	}
	,onOver: function(e) {
	}
	,onOut: function(e) {
	}
	,onPush: function(e) {
	}
	,onRelease: function(e) {
	}
	,onReleaseOutside: function(e) {
	}
	,onClick: function(e) {
	}
	,onMove: function(e) {
	}
	,onWheel: function(e) {
	}
	,onFocus: function(e) {
	}
	,onFocusLost: function(e) {
	}
	,onKeyUp: function(e) {
	}
	,onKeyDown: function(e) {
	}
	,onCheck: function(e) {
	}
	,onTextInput: function(e) {
	}
	,__class__: h2d_Interactive
});
var h2d_Layers = function(parent) {
	h2d_Object.call(this,parent);
	this.layersIndexes = [];
	this.layerCount = 0;
};
$hxClasses["h2d.Layers"] = h2d_Layers;
h2d_Layers.__name__ = "h2d.Layers";
h2d_Layers.__super__ = h2d_Object;
h2d_Layers.prototype = $extend(h2d_Object.prototype,{
	addChild: function(s) {
		this.add(s,-1);
	}
	,add: function(s,layer,index) {
		if(index == null) {
			index = -1;
		}
		if(layer == null) {
			layer = -1;
		}
		if(s.parent == this) {
			var old = s.allocated;
			s.allocated = false;
			this.removeChild(s);
			s.allocated = old;
		}
		if(layer == -1) {
			layer = this.layerCount == 0 ? 0 : this.layerCount - 1;
		}
		while(layer >= this.layerCount) this.layersIndexes[this.layerCount++] = this.children.length;
		if(index != -1) {
			if(layer == 0) {
				var b = this.layersIndexes[layer];
				var b1 = index > b ? b : index;
				h2d_Object.prototype.addChildAt.call(this,s,0 < b1 ? b1 : 0);
			} else if(index < 0) {
				h2d_Object.prototype.addChildAt.call(this,s,this.layersIndexes[layer - 1]);
			} else {
				var a = this.layersIndexes[layer - 1] + index;
				var b = this.layersIndexes[layer];
				h2d_Object.prototype.addChildAt.call(this,s,a > b ? b : a);
			}
		} else {
			h2d_Object.prototype.addChildAt.call(this,s,this.layersIndexes[layer]);
		}
		var _g = layer;
		var _g1 = this.layerCount;
		while(_g < _g1) {
			var i = _g++;
			this.layersIndexes[i]++;
		}
	}
	,addChildAt: function(s,index) {
		this.add(s,-1,index);
	}
	,removeChild: function(s) {
		var _g = 0;
		var _g1 = this.children.length;
		while(_g < _g1) {
			var i = _g++;
			if(this.children[i] == s) {
				this.children.splice(i,1);
				if(s.allocated) {
					s.onRemove();
				}
				s.parent = null;
				s.posChanged = true;
				if(s.parentContainer != null) {
					s.setParentContainer(null);
				}
				var k = this.layerCount - 1;
				while(k >= 0 && this.layersIndexes[k] > i) {
					this.layersIndexes[k]--;
					--k;
				}
				if(this.parentContainer != null) {
					this.parentContainer.contentChanged(this);
				}
				break;
			}
		}
	}
	,__class__: h2d_Layers
});
var h2d_Mask = function(width,height,parent) {
	this.scrollY = 0;
	this.scrollX = 0;
	h2d_Object.call(this,parent);
	this.width = width;
	this.height = height;
};
$hxClasses["h2d.Mask"] = h2d_Mask;
h2d_Mask.__name__ = "h2d.Mask";
h2d_Mask.maskWith = function(ctx,object,width,height,scrollX,scrollY) {
	if(scrollY == null) {
		scrollY = 0;
	}
	if(scrollX == null) {
		scrollX = 0;
	}
	var x1 = object.absX + scrollX;
	var y1 = object.absY + scrollY;
	var x2 = width * object.matA + height * object.matC + x1;
	var y2 = width * object.matB + height * object.matD + y1;
	var tmp;
	if(x1 > x2) {
		tmp = x1;
		x1 = x2;
		x2 = tmp;
	}
	if(y1 > y2) {
		tmp = y1;
		y1 = y2;
		y2 = tmp;
	}
	ctx.clipRenderZone(x1,y1,x2 - x1,y2 - y1);
};
h2d_Mask.unmask = function(ctx) {
	ctx.popRenderZone();
};
h2d_Mask.__super__ = h2d_Object;
h2d_Mask.prototype = $extend(h2d_Object.prototype,{
	calcAbsPos: function() {
		h2d_Object.prototype.calcAbsPos.call(this);
		this.absX -= this.scrollX;
		this.absY -= this.scrollY;
	}
	,getBoundsRec: function(relativeTo,out,forSize) {
		var xMin = out.xMin;
		var yMin = out.yMin;
		var xMax = out.xMax;
		var yMax = out.yMax;
		out.xMin = 1e20;
		out.yMin = 1e20;
		out.xMax = -1e20;
		out.yMax = -1e20;
		if(this.posChanged) {
			this.calcAbsPos();
			var _g = 0;
			var _g1 = this.children;
			while(_g < _g1.length) {
				var c = _g1[_g];
				++_g;
				c.posChanged = true;
			}
			this.posChanged = false;
		}
		this.addBounds(relativeTo,out,this.scrollX,this.scrollY,this.width,this.height);
		var bxMin = out.xMin;
		var byMin = out.yMin;
		var bxMax = out.xMax;
		var byMax = out.yMax;
		out.xMin = xMin;
		out.xMax = xMax;
		out.yMin = yMin;
		out.yMax = yMax;
		h2d_Object.prototype.getBoundsRec.call(this,relativeTo,out,forSize);
		if(out.xMin < bxMin) {
			out.xMin = xMin > bxMin ? bxMin : xMin;
		}
		if(out.yMin < byMin) {
			out.yMin = yMin > byMin ? byMin : yMin;
		}
		if(out.xMax > bxMax) {
			out.xMax = xMax < bxMax ? bxMax : xMax;
		}
		if(out.yMax > byMax) {
			out.yMax = yMax < byMax ? byMax : yMax;
		}
	}
	,drawRec: function(ctx) {
		h2d_Mask.maskWith(ctx,this,this.width,this.height,this.scrollX,this.scrollY);
		h2d_Object.prototype.drawRec.call(this,ctx);
		h2d_Mask.unmask(ctx);
	}
	,__class__: h2d_Mask
});
var h3d_impl_RenderContext = function() {
	this.engine = h3d_Engine.CURRENT;
	this.frame = 0;
	this.time = 0.;
	this.elapsedTime = 1. / hxd_System.getDefaultFrameRate();
	this.textures = new h3d_impl_TextureCache(this);
};
$hxClasses["h3d.impl.RenderContext"] = h3d_impl_RenderContext;
h3d_impl_RenderContext.__name__ = "h3d.impl.RenderContext";
h3d_impl_RenderContext.prototype = {
	dispose: function() {
		this.textures.dispose();
	}
	,__class__: h3d_impl_RenderContext
};
var h2d_RenderContext = function(scene) {
	this.renderZoneIndex = 0;
	this.renderZoneStack = [];
	this.tmpBounds = new h2d_col_Bounds();
	this.defaultSmooth = false;
	this.globalAlpha = 1.;
	h3d_impl_RenderContext.call(this);
	this.scene = scene;
	this.bufPos = 0;
	this.manager = new h3d_pass_ShaderManager();
	this.pass = new h3d_mat_Pass("",null);
	this.pass.depth(true,h3d_mat_Compare.Always);
	this.pass.set_culling(h3d_mat_Face.None);
	this.baseShader = new h3d_shader_Base2d();
	this.baseShader.setPriority(100);
	this.baseShader.zValue__ = 0.;
	this.baseShaderList = new hxsl_ShaderList(this.baseShader);
	this.targetsStack = [];
	this.targetsStackIndex = 0;
	this.cameraStack = [];
	this.cameraStackIndex = 0;
	this.filterStack = [];
	this.filterStackIndex = 0;
};
$hxClasses["h2d.RenderContext"] = h2d_RenderContext;
h2d_RenderContext.__name__ = "h2d.RenderContext";
h2d_RenderContext.__super__ = h3d_impl_RenderContext;
h2d_RenderContext.prototype = $extend(h3d_impl_RenderContext.prototype,{
	dispose: function() {
		h3d_impl_RenderContext.prototype.dispose.call(this);
		if(this.fixedBuffer != null) {
			this.fixedBuffer.dispose();
		}
	}
	,begin: function() {
		this.texture = null;
		this.currentObj = null;
		this.bufPos = 0;
		this.stride = 0;
		this.viewA = this.scene.viewportA;
		this.viewB = 0;
		this.viewC = 0;
		this.viewD = this.scene.viewportD;
		this.viewX = this.scene.viewportX;
		this.viewY = this.scene.viewportY;
		this.targetFlipY = this.engine.driver.hasFeature(h3d_impl_Feature.BottomLeftCoords) ? -1 : 1;
		this.baseFlipY = this.engine.getCurrentTarget() != null ? this.targetFlipY : 1;
		this.inFilter = null;
		this.manager.globals.set("time",this.time);
		this.manager.globals.set("global.time",this.time);
		var _this = this.baseShader;
		_this.constModified = true;
		_this.pixelAlign__ = false;
		var _this = this.baseShader.halfPixelInverse__;
		var x = 0.5 / this.engine.width;
		var y = 0.5 / this.engine.height;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = 0.;
		_this.w = 1.;
		var _this = this.baseShader.viewportA__;
		var x = this.scene.viewportA;
		var y = 0;
		var z = this.scene.viewportX;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		_this.w = 1.;
		var _this = this.baseShader.viewportB__;
		var x = 0;
		var y = this.scene.viewportD * -this.baseFlipY;
		var z = this.scene.viewportY * -this.baseFlipY;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		_this.w = 1.;
		var _this = this.baseShader.filterMatrixA__;
		var x = 1;
		var y = 0;
		var z = 0;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		_this.w = 1.;
		var _this = this.baseShader.filterMatrixB__;
		var x = 0;
		var y = 1;
		var z = 0;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		_this.w = 1.;
		this.baseShaderList.next = null;
		this.initShaders(this.baseShaderList);
		this.engine.selectMaterial(this.pass);
		this.textures.begin();
	}
	,initShaders: function(shaders) {
		this.currentShaders = shaders;
		this.compiledShader = this.manager.compileShaders(shaders);
		if(this.buffers == null) {
			this.buffers = new h3d_shader_Buffers(this.compiledShader);
		} else {
			var _this = this.buffers;
			var s = this.compiledShader;
			_this.vertex.grow(s.vertex);
			_this.fragment.grow(s.fragment);
		}
		this.manager.fillGlobals(this.buffers,this.compiledShader);
		this.engine.selectShader(this.compiledShader);
		this.engine.uploadShaderBuffers(this.buffers,0);
	}
	,end: function() {
		this.texture = null;
		this.currentObj = null;
		this.baseShaderList.next = null;
		if(this.targetsStackIndex != 0) {
			throw haxe_Exception.thrown("Missing popTarget()");
		}
		if(this.cameraStackIndex != 0) {
			throw haxe_Exception.thrown("Missing popCamera()");
		}
	}
	,pushCamera: function(cam) {
		var entry = this.cameraStack[this.cameraStackIndex++];
		if(entry == null) {
			entry = { va : 0, vb : 0, vc : 0, vd : 0, vx : 0, vy : 0};
			this.cameraStack.push(entry);
		}
		var tmpA = this.viewA;
		var tmpB = this.viewB;
		var tmpC = this.viewC;
		var tmpD = this.viewD;
		entry.va = tmpA;
		entry.vb = tmpB;
		entry.vc = tmpC;
		entry.vd = tmpD;
		entry.vx = this.viewX;
		entry.vy = this.viewY;
		this.viewA = cam.matA * tmpA + cam.matB * tmpC;
		this.viewB = cam.matA * tmpB + cam.matB * tmpD;
		this.viewC = cam.matC * tmpA + cam.matD * tmpC;
		this.viewD = cam.matC * tmpB + cam.matD * tmpD;
		this.viewX = cam.absX * tmpA + cam.absY * tmpC + this.viewX;
		this.viewY = cam.absX * tmpB + cam.absY * tmpD + this.viewY;
		var flipY = this.curTarget != null ? -this.targetFlipY : -this.baseFlipY;
		var _this = this.baseShader.viewportA__;
		var x = this.viewA;
		var y = this.viewC;
		var z = this.viewX;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		_this.w = 1.;
		var _this = this.baseShader.viewportB__;
		var x = this.viewB * flipY;
		var y = this.viewD * flipY;
		var z = this.viewY * flipY;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		_this.w = 1.;
	}
	,popCamera: function() {
		if(this.cameraStackIndex == 0) {
			throw haxe_Exception.thrown("Too many popCamera()");
		}
		var inf = this.cameraStack[--this.cameraStackIndex];
		this.viewA = inf.va;
		this.viewB = inf.vb;
		this.viewC = inf.vc;
		this.viewD = inf.vd;
		this.viewX = inf.vx;
		this.viewY = inf.vy;
		var flipY = this.curTarget != null ? -this.targetFlipY : -this.baseFlipY;
		var _this = this.baseShader.viewportA__;
		var x = this.viewA;
		var y = this.viewC;
		var z = this.viewX;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		_this.w = 1.;
		var _this = this.baseShader.viewportB__;
		var x = this.viewB * flipY;
		var y = this.viewD * flipY;
		var z = this.viewY * flipY;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		_this.w = 1.;
	}
	,pushFilter: function(spr) {
		if(this.filterStack.length == 0 && this.onEnterFilter != null) {
			if(!this.onEnterFilter(spr)) {
				return false;
			}
		}
		this.inFilter = this.filterStack[this.filterStackIndex++];
		if(this.inFilter == null) {
			this.inFilter = { spr : null, scaleX : 1, scaleY : 1};
			this.filterStack.push(this.inFilter);
		}
		this.inFilter.spr = spr;
		this.inFilter.scaleX = 1;
		this.inFilter.scaleY = 1;
		return true;
	}
	,setFilterScale: function(scaleX,scaleY) {
		if(this.inFilter != null) {
			this.inFilter.scaleX = scaleX;
			this.inFilter.scaleY = scaleY;
		}
	}
	,popFilter: function() {
		this.inFilter.spr = null;
		this.filterStackIndex--;
		if(this.filterStackIndex > 0) {
			this.inFilter = this.filterStack[this.filterStackIndex - 1];
		} else {
			this.inFilter = null;
			if(this.onLeaveFilter != null) {
				this.onLeaveFilter(this.filterStack[this.filterStackIndex].spr);
			}
		}
	}
	,pushTarget: function(t,startX,startY,width,height) {
		if(height == null) {
			height = -1;
		}
		if(width == null) {
			width = -1;
		}
		if(startY == null) {
			startY = 0;
		}
		if(startX == null) {
			startX = 0;
		}
		this.engine.pushTarget(t);
		this.initShaders(this.baseShaderList);
		var entry = this.targetsStack[this.targetsStackIndex++];
		if(entry == null) {
			entry = { t : null, va : 0, vb : 0, vc : 0, vd : 0, vx : 0, vy : 0, hasRZ : false, rzX : 0, rzY : 0, rzW : 0, rzH : 0};
			this.targetsStack.push(entry);
		}
		entry.t = this.curTarget;
		entry.va = this.viewA;
		entry.vb = this.viewB;
		entry.vc = this.viewC;
		entry.vd = this.viewD;
		entry.vx = this.viewX;
		entry.vy = this.viewY;
		entry.hasRZ = this.hasRenderZone;
		entry.rzX = this.renderX;
		entry.rzY = this.renderY;
		entry.rzW = this.renderW;
		entry.rzH = this.renderH;
		if(width < 0) {
			width = t == null ? this.scene.width : t.width;
		}
		if(height < 0) {
			height = t == null ? this.scene.height : t.height;
		}
		this.viewA = 2 / width;
		this.viewB = 0;
		this.viewC = 0;
		this.viewD = 2 / height;
		this.viewX = -1 - startX * this.viewA;
		this.viewY = -1 - startY * this.viewD;
		var _this = this.baseShader.halfPixelInverse__;
		var x = 0.5 / (t == null ? this.engine.width : t.width);
		var y = 0.5 / (t == null ? this.engine.height : t.height);
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = 0.;
		_this.w = 1.;
		var _this = this.baseShader.viewportA__;
		var x = this.viewA;
		var y = this.viewC;
		var z = this.viewX;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		_this.w = 1.;
		var _this = this.baseShader.viewportB__;
		var x = this.viewB * -this.targetFlipY;
		var y = this.viewD * -this.targetFlipY;
		var z = this.viewY * -this.targetFlipY;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		_this.w = 1.;
		this.curTarget = t;
		this.currentBlend = null;
		if(this.hasRenderZone) {
			this.hasRenderZone = false;
			this.engine.setRenderZone();
		}
	}
	,pushTargets: function(texs) {
		this.pushTarget(texs[0]);
		if(texs.length > 1) {
			this.engine.popTarget();
			this.engine.pushTargets(texs);
		}
	}
	,popTarget: function() {
		if(this.targetsStackIndex <= 0) {
			throw haxe_Exception.thrown("Too many popTarget()");
		}
		this.engine.popTarget();
		var tinf = this.targetsStack[--this.targetsStackIndex];
		var t = this.curTarget = tinf.t;
		this.viewA = tinf.va;
		this.viewB = tinf.vb;
		this.viewC = tinf.vc;
		this.viewD = tinf.vd;
		this.viewX = tinf.vx;
		this.viewY = tinf.vy;
		var flipY = t == null ? -this.baseFlipY : -this.targetFlipY;
		this.initShaders(this.baseShaderList);
		var _this = this.baseShader.halfPixelInverse__;
		var x = 0.5 / (t == null ? this.engine.width : t.width);
		var y = 0.5 / (t == null ? this.engine.height : t.height);
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = 0.;
		_this.w = 1.;
		var _this = this.baseShader.viewportA__;
		var x = this.viewA;
		var y = this.viewC;
		var z = this.viewX;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		_this.w = 1.;
		var _this = this.baseShader.viewportB__;
		var x = this.viewB * flipY;
		var y = this.viewD * flipY;
		var z = this.viewY * flipY;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		_this.w = 1.;
		if(tinf.hasRZ) {
			this.setRZ(tinf.rzX,tinf.rzY,tinf.rzW,tinf.rzH);
		}
	}
	,pushRenderZone: function(x,y,w,h) {
		var inf = this.renderZoneStack[this.renderZoneIndex++];
		if(inf == null) {
			inf = { hasRZ : this.hasRenderZone, x : this.renderX, y : this.renderY, w : this.renderW, h : this.renderH};
			this.renderZoneStack[this.renderZoneIndex - 1] = inf;
		} else if(this.hasRenderZone) {
			inf.hasRZ = true;
			inf.x = this.renderX;
			inf.y = this.renderY;
			inf.w = this.renderW;
			inf.h = this.renderH;
		} else {
			inf.hasRZ = false;
		}
		this.setRZ(x,y,w,h);
	}
	,popRenderZone: function() {
		if(this.renderZoneIndex == 0) {
			throw haxe_Exception.thrown("Too many popRenderZone()");
		}
		var inf = this.renderZoneStack[--this.renderZoneIndex];
		if(inf.hasRZ) {
			this.setRZ(inf.x,inf.y,inf.w,inf.h);
		} else {
			this.hasRenderZone = false;
			this.engine.setRenderZone();
		}
	}
	,getCurrentRenderZone: function() {
		if(!this.hasRenderZone) {
			return null;
		}
		var x0 = this.renderX;
		var y0 = this.renderY;
		var width = this.renderW;
		var height = this.renderH;
		var b = new h2d_col_Bounds();
		b.xMin = x0;
		b.yMin = y0;
		b.xMax = x0 + width;
		b.yMax = y0 + height;
		return b;
	}
	,clipRenderZone: function(x,y,w,h) {
		if(!this.hasRenderZone) {
			this.pushRenderZone(x,y,w,h);
			return;
		}
		x = Math.max(x,this.renderX);
		y = Math.max(y,this.renderY);
		var x2 = Math.min(x + w,this.renderX + this.renderW);
		var y2 = Math.min(y + h,this.renderY + this.renderH);
		if(x2 < x) {
			x2 = x;
		}
		if(y2 < y) {
			y2 = y;
		}
		this.pushRenderZone(x,y,x2 - x,y2 - y);
	}
	,setRZ: function(x,y,w,h) {
		this.hasRenderZone = true;
		this.renderX = x;
		this.renderY = y;
		this.renderW = w;
		this.renderH = h;
		var scaleX = this.scene.viewportA * this.engine.width / 2;
		var scaleY = this.scene.viewportD * this.engine.height / 2;
		if(this.inFilter != null) {
			var fa = this.baseShader.filterMatrixA__;
			var fb = this.baseShader.filterMatrixB__;
			var x2 = x + w;
			var y2 = y + h;
			var rx1 = x * fa.x + y * fa.y + fa.z;
			var ry1 = x * fb.x + y * fb.y + fb.z;
			var rx2 = x2 * fa.x + y2 * fa.y + fa.z;
			var ry2 = x2 * fb.x + y2 * fb.y + fb.z;
			x = rx1;
			y = ry1;
			w = rx2 - rx1;
			h = ry2 - ry1;
		}
		this.engine.setRenderZone(x * scaleX + (this.scene.viewportX + 1) * (this.engine.width / 2) + 1e-10 | 0,y * scaleY + (this.scene.viewportY + 1) * (this.engine.height / 2) + 1e-10 | 0,w * scaleX + 1e-10 | 0,h * scaleY + 1e-10 | 0);
	}
	,drawScene: function() {
		this.scene.drawRec(this);
	}
	,beforeDraw: function() {
		if(this.texture == null) {
			this.texture = h3d_mat_Texture.fromColor(16711935);
		}
		this.baseShader.texture__ = this.texture;
		this.texture.set_filter((this.currentObj.smooth == null ? this.defaultSmooth : this.currentObj.smooth) ? h3d_mat_Filter.Linear : h3d_mat_Filter.Nearest);
		this.texture.set_wrap(this.currentObj.tileWrap && (this.currentObj.filter == null || this.inFilter != null) ? h3d_mat_Wrap.Repeat : h3d_mat_Wrap.Clamp);
		var blend = this.currentObj.blendMode;
		if(this.inFilter != null && this.inFilter.spr == this.currentObj && blend == h2d_BlendMode.Erase) {
			blend = h2d_BlendMode.Add;
		}
		if(this.inFilterBlend != null) {
			blend = this.inFilterBlend;
		}
		if(blend != this.currentBlend) {
			this.currentBlend = blend;
			this.pass.setBlendMode(blend);
			if(blend == h2d_BlendMode.Alpha || blend == h2d_BlendMode.Add) {
				this.pass.set_blendAlphaSrc(h3d_mat_Blend.One);
				if(this.inFilterBlend != null) {
					this.pass.set_blendSrc(h3d_mat_Blend.One);
				}
			}
		}
		this.manager.fillParams(this.buffers,this.compiledShader,this.currentShaders);
		this.engine.selectMaterial(this.pass);
		this.engine.uploadShaderBuffers(this.buffers,1);
		this.engine.uploadShaderBuffers(this.buffers,2);
		this.engine.uploadShaderBuffers(this.buffers,3);
	}
	,beginDrawBatchState: function(obj) {
		if(!this.beginDraw(obj,null,true)) {
			return false;
		}
		if(this.inFilter != null && this.inFilter.spr == obj) {
			var _this = this.baseShader.color__;
			var x = obj.color.x;
			var y = obj.color.y;
			var z = obj.color.z;
			var w = obj.color.w;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		} else if(this.inFilterBlend != null) {
			var _this = this.baseShader.color__;
			var x = this.globalAlpha;
			var y = this.globalAlpha;
			var z = this.globalAlpha;
			var w = this.globalAlpha;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		} else {
			var _this = this.baseShader.color__;
			var x = obj.color.x;
			var y = obj.color.y;
			var z = obj.color.z;
			var w = obj.color.w * this.globalAlpha;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		}
		var _this = this.baseShader.absoluteMatrixA__;
		var x = obj.matA;
		var y = obj.matC;
		var z = obj.absX;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		_this.w = 1.;
		var _this = this.baseShader.absoluteMatrixB__;
		var x = obj.matB;
		var y = obj.matD;
		var z = obj.absY;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		_this.w = 1.;
		return true;
	}
	,drawTile: function(obj,tile) {
		var matA;
		var matB;
		var matC;
		var matD;
		var absX;
		var absY;
		if(this.inFilter != null) {
			var f1 = this.baseShader.filterMatrixA__;
			var f2 = this.baseShader.filterMatrixB__;
			var tmpA = obj.matA * f1.x + obj.matB * f1.y;
			var tmpB = obj.matA * f2.x + obj.matB * f2.y;
			var tmpC = obj.matC * f1.x + obj.matD * f1.y;
			var tmpD = obj.matC * f2.x + obj.matD * f2.y;
			var tmpX = obj.absX * f1.x + obj.absY * f1.y + f1.z;
			var tmpY = obj.absX * f2.x + obj.absY * f2.y + f2.z;
			matA = tmpA * this.viewA + tmpB * this.viewC;
			matB = tmpA * this.viewB + tmpB * this.viewD;
			matC = tmpC * this.viewA + tmpD * this.viewC;
			matD = tmpC * this.viewB + tmpD * this.viewD;
			absX = tmpX * this.viewA + tmpY * this.viewC + this.viewX;
			absY = tmpX * this.viewB + tmpY * this.viewD + this.viewY;
		} else {
			matA = obj.matA * this.viewA + obj.matB * this.viewC;
			matB = obj.matA * this.viewB + obj.matB * this.viewD;
			matC = obj.matC * this.viewA + obj.matD * this.viewC;
			matD = obj.matC * this.viewB + obj.matD * this.viewD;
			absX = obj.absX * this.viewA + obj.absY * this.viewC + this.viewX;
			absY = obj.absX * this.viewB + obj.absY * this.viewD + this.viewY;
		}
		if(matB == 0 && matC == 0) {
			var tx = tile.dx + tile.width * 0.5;
			var ty = tile.dy + tile.height * 0.5;
			var a = matA < 0 ? -matA : matA;
			var b = matD < 0 ? -matD : matD;
			var tr = (tile.width > tile.height ? tile.width : tile.height) * 1.5 * (a < b ? b : a);
			var cx = absX + tx * matA;
			var cy = absY + ty * matD;
			if(cx + tr < -1 || cx - tr > 1 || cy + tr < -1 || cy - tr > 1) {
				return false;
			}
		} else {
			var xMin = 1e20;
			var yMin = 1e20;
			var xMax = -1e20;
			var yMax = -1e20;
			var hw = tile.width * 0.5;
			var hh = tile.height * 0.5;
			var px = tile.dx * matA + tile.dy * matC;
			var py = tile.dx * matB + tile.dy * matD;
			if(px < xMin) {
				xMin = px;
			}
			if(px > xMax) {
				xMax = px;
			}
			if(py < yMin) {
				yMin = py;
			}
			if(py > yMax) {
				yMax = py;
			}
			var x = tile.width;
			var px = (x + tile.dx) * matA + tile.dy * matC;
			var py = (x + tile.dx) * matB + tile.dy * matD;
			if(px < xMin) {
				xMin = px;
			}
			if(px > xMax) {
				xMax = px;
			}
			if(py < yMin) {
				yMin = py;
			}
			if(py > yMax) {
				yMax = py;
			}
			var y = tile.height;
			var px = tile.dx * matA + (y + tile.dy) * matC;
			var py = tile.dx * matB + (y + tile.dy) * matD;
			if(px < xMin) {
				xMin = px;
			}
			if(px > xMax) {
				xMax = px;
			}
			if(py < yMin) {
				yMin = py;
			}
			if(py > yMax) {
				yMax = py;
			}
			var x = tile.width;
			var y = tile.height;
			var px = (x + tile.dx) * matA + (y + tile.dy) * matC;
			var py = (x + tile.dx) * matB + (y + tile.dy) * matD;
			if(px < xMin) {
				xMin = px;
			}
			if(px > xMax) {
				xMax = px;
			}
			if(py < yMin) {
				yMin = py;
			}
			if(py > yMax) {
				yMax = py;
			}
			if(absX + xMax < -1 || absY + yMax < -1 || absX + xMin > 1 || absY + yMin > 1) {
				return false;
			}
		}
		if(!this.beginDraw(obj,tile.innerTex,true,true)) {
			return false;
		}
		if(this.inFilter != null && this.inFilter.spr == obj) {
			var _this = this.baseShader.color__;
			var x = obj.color.x;
			var y = obj.color.y;
			var z = obj.color.z;
			var w = obj.color.w;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		} else if(this.inFilterBlend != null) {
			var _this = this.baseShader.color__;
			var x = this.globalAlpha;
			var y = this.globalAlpha;
			var z = this.globalAlpha;
			var w = this.globalAlpha;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		} else {
			var _this = this.baseShader.color__;
			var x = obj.color.x;
			var y = obj.color.y;
			var z = obj.color.z;
			var w = obj.color.w * this.globalAlpha;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		}
		var _this = this.baseShader.absoluteMatrixA__;
		var x = tile.width * obj.matA;
		var y = tile.height * obj.matC;
		var z = obj.absX + tile.dx * obj.matA + tile.dy * obj.matC;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		_this.w = 1.;
		var _this = this.baseShader.absoluteMatrixB__;
		var x = tile.width * obj.matB;
		var y = tile.height * obj.matD;
		var z = obj.absY + tile.dx * obj.matB + tile.dy * obj.matD;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		_this.w = 1.;
		var _this = this.baseShader.uvPos__;
		var x = tile.u;
		var y = tile.v;
		var z = tile.u2 - tile.u;
		var w = tile.v2 - tile.v;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		_this.w = w;
		this.beforeDraw();
		var tmp;
		if(this.fixedBuffer != null) {
			var _this = this.fixedBuffer;
			tmp = _this.buffer == null || _this.buffer.vbuf == null;
		} else {
			tmp = true;
		}
		if(tmp) {
			this.fixedBuffer = new h3d_Buffer(4,8,[h3d_BufferFlag.Quads,h3d_BufferFlag.RawFormat]);
			var this1 = hxd__$FloatBuffer_Float32Expand._new(0);
			var k = this1;
			var v = 0;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 0;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 0;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 0;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 0;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 0;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 0;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 0;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			this.fixedBuffer.uploadVector(k,0,4);
		}
		var _this = this.engine;
		_this.renderBuffer(this.fixedBuffer,_this.mem.quadIndexes,2,0,-1);
		return true;
	}
	,beginDraw: function(obj,texture,isRelative,hasUVPos) {
		if(hasUVPos == null) {
			hasUVPos = false;
		}
		if(this.onBeginDraw != null && !this.onBeginDraw(obj)) {
			return false;
		}
		var stride = 8;
		var shaderChanged = false;
		var paramsChanged = false;
		var objShaders = obj.shaders;
		var curShaders = this.currentShaders.next;
		while(objShaders != null && curShaders != null) {
			var s = objShaders.s;
			var t = curShaders.s;
			objShaders = objShaders.next;
			curShaders = curShaders.next;
			var prevInst = t.instance;
			if(s != t) {
				paramsChanged = true;
			}
			s.updateConstants(this.manager.globals);
			if(s.instance != prevInst) {
				shaderChanged = true;
			}
		}
		if(objShaders != null || curShaders != null || this.baseShader.isRelative__ != isRelative || this.baseShader.hasUVPos__ != hasUVPos || this.baseShader.killAlpha__ != this.killAlpha) {
			shaderChanged = true;
		}
		if(shaderChanged) {
			var _this = this.baseShader;
			_this.constModified = true;
			_this.hasUVPos__ = hasUVPos;
			var _this = this.baseShader;
			_this.constModified = true;
			_this.isRelative__ = isRelative;
			var _this = this.baseShader;
			_this.constModified = true;
			_this.killAlpha__ = this.killAlpha;
			this.baseShader.updateConstants(this.manager.globals);
			this.baseShaderList.next = obj.shaders;
			this.initShaders(this.baseShaderList);
		} else if(paramsChanged) {
			if(this.currentShaders != this.baseShaderList) {
				throw haxe_Exception.thrown("!");
			}
			this.currentShaders.next = obj.shaders;
		}
		this.texture = texture;
		this.stride = stride;
		this.currentObj = obj;
		return true;
	}
	,__class__: h2d_RenderContext
});
var h2d_TileGroup = function(t,parent) {
	h2d_Drawable.call(this,parent);
	this.tile = t;
	this.rangeMin = this.rangeMax = -1;
	this.curColor = new h3d_Vector(1,1,1,1);
	this.content = new h2d_TileLayerContent();
};
$hxClasses["h2d.TileGroup"] = h2d_TileGroup;
h2d_TileGroup.__name__ = "h2d.TileGroup";
h2d_TileGroup.__super__ = h2d_Drawable;
h2d_TileGroup.prototype = $extend(h2d_Drawable.prototype,{
	getBoundsRec: function(relativeTo,out,forSize) {
		h2d_Drawable.prototype.getBoundsRec.call(this,relativeTo,out,forSize);
		this.addBounds(relativeTo,out,this.content.xMin,this.content.yMin,this.content.xMax - this.content.xMin,this.content.yMax - this.content.yMin);
	}
	,clear: function() {
		this.content.clear();
	}
	,onRemove: function() {
		this.content.dispose();
		h2d_Drawable.prototype.onRemove.call(this);
	}
	,draw: function(ctx) {
		this.drawWith(ctx,this);
	}
	,sync: function(ctx) {
		h2d_Drawable.prototype.sync.call(this,ctx);
		if(this.visible) {
			var _this = this.content;
			var tmp;
			if(_this.buffer != null) {
				var _this1 = _this.buffer;
				tmp = _this1.buffer == null || _this1.buffer.vbuf == null;
			} else {
				tmp = true;
			}
			if(tmp) {
				_this.alloc(h3d_Engine.CURRENT);
			}
		}
	}
	,drawWith: function(ctx,obj) {
		var max = this.content.triCount();
		if(max == 0) {
			return;
		}
		if(!ctx.beginDrawBatchState(obj)) {
			return;
		}
		var min = this.rangeMin < 0 ? 0 : this.rangeMin * 2;
		if(this.rangeMax > 0 && this.rangeMax < max * 2) {
			max = this.rangeMax * 2;
		}
		var _this = this.content;
		var tmp;
		if(_this.buffer != null) {
			var _this1 = _this.buffer;
			tmp = _this1.buffer == null || _this1.buffer.vbuf == null;
		} else {
			tmp = true;
		}
		if(tmp) {
			_this.alloc(h3d_Engine.CURRENT);
		}
		_this.state.drawQuads(ctx,_this.buffer,min,max - min);
	}
	,__class__: h2d_TileGroup
});
var h2d_ScaleGrid = function(tile,borderL,borderT,borderR,borderB,parent) {
	this.currentScaleY = 1.;
	this.currentScaleX = 1.;
	this.borderScale = 1.0;
	h2d_TileGroup.call(this,tile,parent);
	this.set_borderLeft(borderL);
	this.set_borderRight(borderR != null ? borderR : borderL);
	this.set_borderTop(borderT);
	this.set_borderBottom(borderB != null ? borderB : borderT);
	this.set_width(tile.width);
	this.set_height(tile.height);
};
$hxClasses["h2d.ScaleGrid"] = h2d_ScaleGrid;
h2d_ScaleGrid.__name__ = "h2d.ScaleGrid";
h2d_ScaleGrid.__super__ = h2d_TileGroup;
h2d_ScaleGrid.prototype = $extend(h2d_TileGroup.prototype,{
	set_width: function(w) {
		if(this.width == w) {
			return w;
		}
		this.width = w;
		this.clear();
		return w;
	}
	,set_height: function(h) {
		if(this.height == h) {
			return h;
		}
		this.height = h;
		this.clear();
		return h;
	}
	,set_borderTop: function(top) {
		if(this.borderTop == top) {
			return top;
		}
		this.borderTop = top;
		this.clear();
		return top;
	}
	,set_borderBottom: function(bot) {
		if(this.borderBottom == bot) {
			return bot;
		}
		this.borderBottom = bot;
		this.clear();
		return bot;
	}
	,set_borderLeft: function(left) {
		if(this.borderLeft == left) {
			return left;
		}
		this.borderLeft = left;
		this.clear();
		return left;
	}
	,set_borderRight: function(right) {
		if(this.borderRight == right) {
			return right;
		}
		this.borderRight = right;
		this.clear();
		return right;
	}
	,getBoundsRec: function(relativeTo,out,forSize) {
		this.checkUpdate();
		h2d_TileGroup.prototype.getBoundsRec.call(this,relativeTo,out,forSize);
	}
	,checkUpdate: function() {
		var needUpdate = false;
		if(this.ignoreScale) {
			var _this = this.getAbsPos();
			var p = null;
			if(p == null) {
				p = new h2d_col_Point();
			}
			p.x = Math.sqrt(_this.a * _this.a + _this.b * _this.b);
			p.y = Math.sqrt(_this.c * _this.c + _this.d * _this.d);
			if(_this.a * _this.d - _this.b * _this.c < 0) {
				p.x *= -1;
				p.y *= -1;
			}
			var s = p;
			if(this.currentScaleX != s.x || this.currentScaleY != s.y) {
				needUpdate = true;
				this.currentScaleX = s.x;
				this.currentScaleY = s.y;
			}
		}
		if(this.content.isEmpty() || this.tile != this.contentTile) {
			this.contentTile = this.tile;
			needUpdate = true;
		}
		if(needUpdate) {
			this.clear();
			this.updateContent();
		}
	}
	,updateContent: function() {
		var bt = this.borderTop;
		var bb = this.borderBottom;
		var bl = this.borderLeft;
		var br = this.borderRight;
		var unscaledBl = bl * this.borderScale;
		var unscaledBr = br * this.borderScale;
		var unscaledBt = bt * this.borderScale;
		var unscaledBb = bb * this.borderScale;
		var invScaleX = 1.;
		var invScaleY = 1.;
		if(this.ignoreScale) {
			var _this = this.getAbsPos();
			var p = null;
			if(p == null) {
				p = new h2d_col_Point();
			}
			p.x = Math.sqrt(_this.a * _this.a + _this.b * _this.b);
			p.y = Math.sqrt(_this.c * _this.c + _this.d * _this.d);
			if(_this.a * _this.d - _this.b * _this.c < 0) {
				p.x *= -1;
				p.y *= -1;
			}
			var s = p;
			if(s.x == 0. || s.y == 0.) {
				return;
			}
			invScaleX /= s.x;
			invScaleY /= s.y;
			unscaledBl *= invScaleX;
			unscaledBr *= invScaleX;
			unscaledBt *= invScaleY;
			unscaledBb *= invScaleY;
		}
		var t = this.tile.sub(0,0,bl,bt);
		t.scaleToSize(unscaledBl,unscaledBt);
		var color = this.curColor;
		this.content.add(0,0,color.x,color.y,color.z,color.w,t);
		t = this.tile.sub(this.tile.width - br,0,br,bt);
		t.scaleToSize(unscaledBr,unscaledBt);
		var color = this.curColor;
		this.content.add(this.width - unscaledBr,0,color.x,color.y,color.z,color.w,t);
		t = this.tile.sub(0,this.tile.height - bb,bl,bb);
		t.scaleToSize(unscaledBl,unscaledBb);
		var color = this.curColor;
		this.content.add(0,this.height - unscaledBb,color.x,color.y,color.z,color.w,t);
		t = this.tile.sub(this.tile.width - br,this.tile.height - bb,br,bb);
		t.scaleToSize(unscaledBr,unscaledBb);
		var color = this.curColor;
		this.content.add(this.width - unscaledBr,this.height - unscaledBb,color.x,color.y,color.z,color.w,t);
		var innerTileWidth = this.tile.width - (br + bl);
		var innerTileHeight = this.tile.height - (bb + bt);
		var innerWidth = this.width - (unscaledBl + unscaledBr);
		var innerHeight = this.height - (unscaledBt + unscaledBb);
		if(!this.tileBorders) {
			var t = this.tile.sub(bl,0,innerTileWidth,bt);
			t.scaleToSize(innerWidth,unscaledBt);
			var color = this.curColor;
			this.content.add(unscaledBl,0,color.x,color.y,color.z,color.w,t);
			var t = this.tile.sub(bl,this.tile.height - bb,innerTileWidth,bb);
			t.scaleToSize(innerWidth,unscaledBb);
			var color = this.curColor;
			this.content.add(unscaledBl,innerHeight + unscaledBt,color.x,color.y,color.z,color.w,t);
			var t = this.tile.sub(0,bt,bl,innerTileHeight);
			t.scaleToSize(unscaledBl,innerHeight);
			var color = this.curColor;
			this.content.add(0,unscaledBt,color.x,color.y,color.z,color.w,t);
			var t = this.tile.sub(this.tile.width - br,bt,br,innerTileHeight);
			t.scaleToSize(unscaledBr,innerHeight);
			var color = this.curColor;
			this.content.add(innerWidth + unscaledBl,unscaledBt,color.x,color.y,color.z,color.w,t);
		} else {
			var unscaledInnerTileWidth = innerTileWidth * invScaleX;
			var unscaledInnerTileHeight = innerTileHeight * invScaleY;
			var rw = innerWidth / unscaledInnerTileWidth | 0;
			var _g = 0;
			var _g1 = rw;
			while(_g < _g1) {
				var x = _g++;
				var t = this.tile.sub(bl,0,innerTileWidth,bt);
				t.scaleToSize(unscaledInnerTileWidth,unscaledBt);
				var color = this.curColor;
				this.content.add(unscaledBl + x * unscaledInnerTileWidth,0,color.x,color.y,color.z,color.w,t);
				t = this.tile.sub(bl,this.tile.height - bb,innerTileWidth,bb);
				t.scaleToSize(unscaledInnerTileWidth,unscaledBb);
				var color1 = this.curColor;
				this.content.add(unscaledBl + x * unscaledInnerTileWidth,this.height - unscaledBb,color1.x,color1.y,color1.z,color1.w,t);
			}
			var dx = innerWidth - rw * unscaledInnerTileWidth;
			if(dx > 0) {
				var t = this.tile.sub(bl,0,dx / invScaleX,bt);
				t.scaleToSize(dx,unscaledBt);
				var color = this.curColor;
				this.content.add(unscaledBl + rw * unscaledInnerTileWidth,0,color.x,color.y,color.z,color.w,t);
				t = this.tile.sub(bl,this.tile.height - bb,dx / invScaleX,bb);
				t.scaleToSize(dx,unscaledBb);
				var color = this.curColor;
				this.content.add(unscaledBl + rw * unscaledInnerTileWidth,this.height - unscaledBb,color.x,color.y,color.z,color.w,t);
			}
			var rh = innerHeight / unscaledInnerTileHeight | 0;
			var _g = 0;
			var _g1 = rh;
			while(_g < _g1) {
				var y = _g++;
				var t = this.tile.sub(0,bt,bl,innerTileHeight);
				t.scaleToSize(unscaledBl,unscaledInnerTileHeight);
				var color = this.curColor;
				this.content.add(0,unscaledBt + y * unscaledInnerTileHeight,color.x,color.y,color.z,color.w,t);
				t = this.tile.sub(this.tile.width - br,bt,br,innerTileHeight);
				t.scaleToSize(unscaledBr,unscaledInnerTileHeight);
				var color1 = this.curColor;
				this.content.add(this.width - unscaledBr,unscaledBt + y * unscaledInnerTileHeight,color1.x,color1.y,color1.z,color1.w,t);
			}
			var dy = innerHeight - rh * unscaledInnerTileHeight;
			if(dy > 0) {
				var t = this.tile.sub(0,bt,bl,dy / invScaleY);
				t.scaleToSize(unscaledBl,dy);
				var color = this.curColor;
				this.content.add(0,bt + rh * unscaledInnerTileHeight,color.x,color.y,color.z,color.w,t);
				t = this.tile.sub(this.tile.width - br,bt,br,dy / invScaleY);
				t.scaleToSize(unscaledBr,dy);
				var color = this.curColor;
				this.content.add(this.width - unscaledBr,unscaledBt + rh * unscaledInnerTileHeight,color.x,color.y,color.z,color.w,t);
			}
		}
		if(!this.tileCenter) {
			var t = this.tile.sub(bl,bt,innerTileWidth,innerTileHeight);
			t.scaleToSize(this.width - (unscaledBr + unscaledBl),this.height - (unscaledBt + unscaledBb));
			var color = this.curColor;
			this.content.add(unscaledBl,unscaledBt,color.x,color.y,color.z,color.w,t);
		} else {
			var unscaledInnerTileWidth = innerTileWidth * invScaleX;
			var unscaledInnerTileHeight = innerTileHeight * invScaleY;
			var rw = (this.width - (unscaledBr + unscaledBl)) / unscaledInnerTileWidth | 0;
			var rh = innerHeight / unscaledInnerTileHeight | 0;
			var _g = 0;
			var _g1 = rh;
			while(_g < _g1) {
				var y = _g++;
				var _g2 = 0;
				var _g3 = rw;
				while(_g2 < _g3) {
					var x = _g2++;
					var t = this.tile.sub(bl,bt,unscaledInnerTileWidth,unscaledInnerTileWidth);
					var color = this.curColor;
					this.content.add(unscaledBl + x * unscaledInnerTileWidth,unscaledBt + y * unscaledInnerTileHeight,color.x,color.y,color.z,color.w,t);
				}
			}
			var dx = innerWidth - rw * unscaledInnerTileWidth;
			if(dx > 0) {
				var _g = 0;
				var _g1 = rh;
				while(_g < _g1) {
					var y = _g++;
					var t = this.tile.sub(bl,bt,dx,unscaledInnerTileWidth);
					var color = this.curColor;
					this.content.add(unscaledBl + rw * unscaledInnerTileWidth,unscaledBt + y * unscaledInnerTileHeight,color.x,color.y,color.z,color.w,t);
				}
			}
			var dy = innerHeight - rh * unscaledInnerTileHeight;
			if(dy > 0) {
				var _g = 0;
				var _g1 = rw;
				while(_g < _g1) {
					var x = _g++;
					var t = this.tile.sub(bl,bt,unscaledInnerTileWidth,dy);
					var color = this.curColor;
					this.content.add(unscaledBl + x * unscaledInnerTileWidth,unscaledBt + rh * unscaledInnerTileHeight,color.x,color.y,color.z,color.w,t);
				}
			}
			if(dx > 0 && dy > 0) {
				var t = this.tile.sub(bl,bt,dx,dy);
				var color = this.curColor;
				this.content.add(unscaledBl + rw * unscaledInnerTileWidth,unscaledBt + rh * unscaledInnerTileHeight,color.x,color.y,color.z,color.w,t);
			}
		}
	}
	,sync: function(ctx) {
		this.checkUpdate();
		h2d_TileGroup.prototype.sync.call(this,ctx);
	}
	,__class__: h2d_ScaleGrid
});
var h2d_ScaleModeAlign = $hxEnums["h2d.ScaleModeAlign"] = { __ename__:true,__constructs__:null
	,Left: {_hx_name:"Left",_hx_index:0,__enum__:"h2d.ScaleModeAlign",toString:$estr}
	,Right: {_hx_name:"Right",_hx_index:1,__enum__:"h2d.ScaleModeAlign",toString:$estr}
	,Center: {_hx_name:"Center",_hx_index:2,__enum__:"h2d.ScaleModeAlign",toString:$estr}
	,Top: {_hx_name:"Top",_hx_index:3,__enum__:"h2d.ScaleModeAlign",toString:$estr}
	,Bottom: {_hx_name:"Bottom",_hx_index:4,__enum__:"h2d.ScaleModeAlign",toString:$estr}
};
h2d_ScaleModeAlign.__constructs__ = [h2d_ScaleModeAlign.Left,h2d_ScaleModeAlign.Right,h2d_ScaleModeAlign.Center,h2d_ScaleModeAlign.Top,h2d_ScaleModeAlign.Bottom];
h2d_ScaleModeAlign.__empty_constructs__ = [h2d_ScaleModeAlign.Left,h2d_ScaleModeAlign.Right,h2d_ScaleModeAlign.Center,h2d_ScaleModeAlign.Top,h2d_ScaleModeAlign.Bottom];
var h2d_ScaleMode = $hxEnums["h2d.ScaleMode"] = { __ename__:true,__constructs__:null
	,Resize: {_hx_name:"Resize",_hx_index:0,__enum__:"h2d.ScaleMode",toString:$estr}
	,Stretch: ($_=function(width,height) { return {_hx_index:1,width:width,height:height,__enum__:"h2d.ScaleMode",toString:$estr}; },$_._hx_name="Stretch",$_.__params__ = ["width","height"],$_)
	,LetterBox: ($_=function(width,height,integerScale,horizontalAlign,verticalAlign) { return {_hx_index:2,width:width,height:height,integerScale:integerScale,horizontalAlign:horizontalAlign,verticalAlign:verticalAlign,__enum__:"h2d.ScaleMode",toString:$estr}; },$_._hx_name="LetterBox",$_.__params__ = ["width","height","integerScale","horizontalAlign","verticalAlign"],$_)
	,Fixed: ($_=function(width,height,zoom,horizontalAlign,verticalAlign) { return {_hx_index:3,width:width,height:height,zoom:zoom,horizontalAlign:horizontalAlign,verticalAlign:verticalAlign,__enum__:"h2d.ScaleMode",toString:$estr}; },$_._hx_name="Fixed",$_.__params__ = ["width","height","zoom","horizontalAlign","verticalAlign"],$_)
	,Zoom: ($_=function(level) { return {_hx_index:4,level:level,__enum__:"h2d.ScaleMode",toString:$estr}; },$_._hx_name="Zoom",$_.__params__ = ["level"],$_)
	,AutoZoom: ($_=function(minWidth,minHeight,integerScaling) { return {_hx_index:5,minWidth:minWidth,minHeight:minHeight,integerScaling:integerScaling,__enum__:"h2d.ScaleMode",toString:$estr}; },$_._hx_name="AutoZoom",$_.__params__ = ["minWidth","minHeight","integerScaling"],$_)
};
h2d_ScaleMode.__constructs__ = [h2d_ScaleMode.Resize,h2d_ScaleMode.Stretch,h2d_ScaleMode.LetterBox,h2d_ScaleMode.Fixed,h2d_ScaleMode.Zoom,h2d_ScaleMode.AutoZoom];
h2d_ScaleMode.__empty_constructs__ = [h2d_ScaleMode.Resize];
var hxd_InteractiveScene = function() { };
$hxClasses["hxd.InteractiveScene"] = hxd_InteractiveScene;
hxd_InteractiveScene.__name__ = "hxd.InteractiveScene";
hxd_InteractiveScene.__isInterface__ = true;
hxd_InteractiveScene.prototype = {
	__class__: hxd_InteractiveScene
};
var h2d_Scene = function() {
	this.scaleMode = h2d_ScaleMode.Resize;
	h2d_Layers.call(this,null);
	var e = h3d_Engine.CURRENT;
	this.ctx = new h2d_RenderContext(this);
	this._cameras = [];
	new h2d_Camera(this);
	this.set_interactiveCamera(this._cameras[0]);
	this.width = e.width;
	this.height = e.height;
	this.viewportA = 2 / e.width;
	this.viewportD = 2 / e.height;
	this.viewportX = -1;
	this.viewportY = -1;
	this.viewportScaleX = 1;
	this.viewportScaleY = 1;
	this.offsetX = 0;
	this.offsetY = 0;
	this.interactive = [];
	this.eventListeners = [];
	this.shapePoint = new h2d_col_Point();
	this.window = hxd_Window.getInstance();
	this.posChanged = true;
};
$hxClasses["h2d.Scene"] = h2d_Scene;
h2d_Scene.__name__ = "h2d.Scene";
h2d_Scene.__interfaces__ = [hxd_InteractiveScene,h3d_IDrawable];
h2d_Scene.__super__ = h2d_Layers;
h2d_Scene.prototype = $extend(h2d_Layers.prototype,{
	setEvents: function(events) {
		this.events = events;
	}
	,set_interactiveCamera: function(cam) {
		if(cam == null) {
			throw haxe_Exception.thrown("Interactive cammera cannot be null!");
		}
		if(cam.scene != this) {
			this.addCamera(cam);
		}
		return this.interactiveCamera = cam;
	}
	,addCamera: function(cam,pos) {
		if(cam.scene != null) {
			cam.scene.removeCamera(cam);
		}
		cam.scene = this;
		cam.posChanged = true;
		if(pos != null) {
			this._cameras.splice(pos,0,cam);
		} else {
			this._cameras.push(cam);
		}
	}
	,removeCamera: function(cam) {
		if(cam == this.interactiveCamera) {
			throw haxe_Exception.thrown("Current interactive Camera cannot be removed from camera list!");
		}
		cam.scene = null;
		HxOverrides.remove(this._cameras,cam);
	}
	,checkResize: function() {
		var _gthis = this;
		var engine = h3d_Engine.CURRENT;
		if(engine == null) {
			return;
		}
		var _g = this.scaleMode;
		switch(_g._hx_index) {
		case 0:
			var w = engine.width;
			var h = engine.height;
			if(w != _gthis.width || h != _gthis.height) {
				_gthis.width = w;
				_gthis.height = h;
				_gthis.posChanged = true;
			}
			_gthis.viewportScaleX = 1;
			_gthis.viewportScaleY = 1;
			_gthis.viewportA = 2 / _gthis.width;
			_gthis.viewportD = 2 / _gthis.height;
			_gthis.viewportX = -1;
			_gthis.viewportY = -1;
			break;
		case 1:
			var _width = _g.width;
			var _height = _g.height;
			if(_width != _gthis.width || _height != _gthis.height) {
				_gthis.width = _width;
				_gthis.height = _height;
				_gthis.posChanged = true;
			}
			_gthis.viewportScaleX = engine.width / _width;
			_gthis.viewportScaleY = engine.height / _height;
			_gthis.viewportA = 2 / _gthis.width;
			_gthis.viewportD = 2 / _gthis.height;
			_gthis.viewportX = -1;
			_gthis.viewportY = -1;
			break;
		case 2:
			var _width = _g.width;
			var _height = _g.height;
			var integerScale = _g.integerScale;
			var horizontalAlign = _g.horizontalAlign;
			var verticalAlign = _g.verticalAlign;
			if(_width != _gthis.width || _height != _gthis.height) {
				_gthis.width = _width;
				_gthis.height = _height;
				_gthis.posChanged = true;
			}
			var a = engine.width / _width;
			var b = engine.height / _height;
			var zoom = a > b ? b : a;
			if(integerScale) {
				zoom = zoom | 0;
				if(zoom == 0) {
					zoom = 1;
				}
			}
			var horizontal = horizontalAlign;
			var vertical = verticalAlign;
			_gthis.viewportA = zoom * 2 / engine.width;
			_gthis.viewportD = zoom * 2 / engine.height;
			_gthis.viewportScaleX = zoom;
			_gthis.viewportScaleY = zoom;
			if(horizontal == null) {
				horizontal = h2d_ScaleModeAlign.Center;
			}
			switch(horizontal._hx_index) {
			case 0:
				_gthis.viewportX = -1;
				_gthis.offsetX = 0;
				break;
			case 1:
				_gthis.viewportX = 1 - _gthis.width * _gthis.viewportA;
				_gthis.offsetX = engine.width - _gthis.width * zoom;
				break;
			default:
				_gthis.viewportX = Math.floor((engine.width - _gthis.width * zoom) / (zoom * 2)) * _gthis.viewportA - 1.;
				_gthis.offsetX = Math.floor((engine.width - _gthis.width * zoom) / 2);
			}
			if(vertical == null) {
				vertical = h2d_ScaleModeAlign.Center;
			}
			switch(vertical._hx_index) {
			case 3:
				_gthis.viewportY = -1;
				_gthis.offsetY = 0;
				break;
			case 4:
				_gthis.viewportY = 1 - _gthis.height * _gthis.viewportD;
				_gthis.offsetY = engine.height - _gthis.height * zoom;
				break;
			default:
				_gthis.viewportY = Math.floor((engine.height - _gthis.height * zoom) / (zoom * 2)) * _gthis.viewportD - 1.;
				_gthis.offsetY = Math.floor((engine.height - _gthis.height * zoom) / 2);
			}
			break;
		case 3:
			var _width = _g.width;
			var _height = _g.height;
			var zoom = _g.zoom;
			var horizontalAlign = _g.horizontalAlign;
			var verticalAlign = _g.verticalAlign;
			if(_width != _gthis.width || _height != _gthis.height) {
				_gthis.width = _width;
				_gthis.height = _height;
				_gthis.posChanged = true;
			}
			var horizontal = horizontalAlign;
			var vertical = verticalAlign;
			_gthis.viewportA = zoom * 2 / engine.width;
			_gthis.viewportD = zoom * 2 / engine.height;
			_gthis.viewportScaleX = zoom;
			_gthis.viewportScaleY = zoom;
			if(horizontal == null) {
				horizontal = h2d_ScaleModeAlign.Center;
			}
			switch(horizontal._hx_index) {
			case 0:
				_gthis.viewportX = -1;
				_gthis.offsetX = 0;
				break;
			case 1:
				_gthis.viewportX = 1 - _gthis.width * _gthis.viewportA;
				_gthis.offsetX = engine.width - _gthis.width * zoom;
				break;
			default:
				_gthis.viewportX = Math.floor((engine.width - _gthis.width * zoom) / (zoom * 2)) * _gthis.viewportA - 1.;
				_gthis.offsetX = Math.floor((engine.width - _gthis.width * zoom) / 2);
			}
			if(vertical == null) {
				vertical = h2d_ScaleModeAlign.Center;
			}
			switch(vertical._hx_index) {
			case 3:
				_gthis.viewportY = -1;
				_gthis.offsetY = 0;
				break;
			case 4:
				_gthis.viewportY = 1 - _gthis.height * _gthis.viewportD;
				_gthis.offsetY = engine.height - _gthis.height * zoom;
				break;
			default:
				_gthis.viewportY = Math.floor((engine.height - _gthis.height * zoom) / (zoom * 2)) * _gthis.viewportD - 1.;
				_gthis.offsetY = Math.floor((engine.height - _gthis.height * zoom) / 2);
			}
			break;
		case 4:
			var level = _g.level;
			var w = Math.ceil(engine.width / level);
			var h = Math.ceil(engine.height / level);
			if(w != _gthis.width || h != _gthis.height) {
				_gthis.width = w;
				_gthis.height = h;
				_gthis.posChanged = true;
			}
			_gthis.viewportScaleX = level;
			_gthis.viewportScaleY = level;
			_gthis.viewportA = 2 / _gthis.width;
			_gthis.viewportD = 2 / _gthis.height;
			_gthis.viewportX = -1;
			_gthis.viewportY = -1;
			break;
		case 5:
			var minWidth = _g.minWidth;
			var minHeight = _g.minHeight;
			var integerScaling = _g.integerScaling;
			var a = engine.width / minWidth;
			var b = engine.height / minHeight;
			var zoom = a > b ? b : a;
			if(integerScaling) {
				zoom = zoom | 0;
				if(zoom == 0) {
					zoom = 1;
				}
			}
			var w = Math.ceil(engine.width / zoom);
			var h = Math.ceil(engine.height / zoom);
			if(w != _gthis.width || h != _gthis.height) {
				_gthis.width = w;
				_gthis.height = h;
				_gthis.posChanged = true;
			}
			_gthis.viewportScaleX = zoom;
			_gthis.viewportScaleY = zoom;
			_gthis.viewportA = 2 / _gthis.width;
			_gthis.viewportD = 2 / _gthis.height;
			_gthis.viewportX = -1;
			_gthis.viewportY = -1;
			break;
		}
	}
	,get_mouseX: function() {
		this.syncPos();
		var mx = this.window.get_mouseX();
		var _this = this.interactiveCamera;
		var mx = this.window.get_mouseX();
		var my = this.window.get_mouseY();
		var dx = (((mx - _this.scene.offsetX) / _this.scene.viewportScaleX - _this.absX) * _this.matD - ((my - _this.scene.offsetY) / _this.scene.viewportScaleY - _this.absY) * _this.matC) * _this.invDet - this.absX;
		if(this.matC == 0) {
			return dx / this.matA;
		}
		var my = this.window.get_mouseY();
		var _this = this.interactiveCamera;
		var mx = this.window.get_mouseX();
		var my = this.window.get_mouseY();
		var dy = (-((mx - _this.scene.offsetX) / _this.scene.viewportScaleX - _this.absX) * _this.matB + ((my - _this.scene.offsetY) / _this.scene.viewportScaleY - _this.absY) * _this.matA) * _this.invDet - this.absY;
		return (dx * this.matD - dy * this.matC) / (this.matA * this.matD - this.matB * this.matC);
	}
	,get_mouseY: function() {
		this.syncPos();
		var my = this.window.get_mouseY();
		var _this = this.interactiveCamera;
		var mx = this.window.get_mouseX();
		var my = this.window.get_mouseY();
		var dy = (-((mx - _this.scene.offsetX) / _this.scene.viewportScaleX - _this.absX) * _this.matB + ((my - _this.scene.offsetY) / _this.scene.viewportScaleY - _this.absY) * _this.matA) * _this.invDet - this.absY;
		if(this.matB == 0) {
			return dy / this.matD;
		}
		var mx = this.window.get_mouseX();
		var _this = this.interactiveCamera;
		var mx = this.window.get_mouseX();
		var my = this.window.get_mouseY();
		var dx = (((mx - _this.scene.offsetX) / _this.scene.viewportScaleX - _this.absX) * _this.matD - ((my - _this.scene.offsetY) / _this.scene.viewportScaleY - _this.absY) * _this.matC) * _this.invDet - this.absX;
		return (dy * this.matA - dx * this.matB) / (this.matA * this.matD - this.matB * this.matC);
	}
	,dispatchListeners: function(event) {
		this.screenToViewport(event);
		var _g = 0;
		var _g1 = this.eventListeners;
		while(_g < _g1.length) {
			var l = _g1[_g];
			++_g;
			l(event);
			if(!event.propagate) {
				break;
			}
		}
	}
	,isInteractiveVisible: function(i) {
		var s = i;
		while(s != this) {
			if(s == null || !s.visible) {
				return false;
			}
			s = s.parent;
		}
		return true;
	}
	,screenToViewport: function(e) {
		this.interactiveCamera.eventToCamera(e);
	}
	,dispatchEvent: function(event,to) {
		var i = to;
		this.screenToViewport(event);
		var dx = event.relX - i.absX;
		var dy = event.relY - i.absY;
		var rx = (dx * i.matD - dy * i.matC) * i.invDet;
		var ry = (dy * i.matA - dx * i.matB) * i.invDet;
		event.relX = rx;
		event.relY = ry;
		i.handleEvent(event);
	}
	,handleEvent: function(event,last) {
		this.screenToViewport(event);
		var ex = event.relX;
		var ey = event.relY;
		var index = last == null ? 0 : this.interactive.indexOf(last) + 1;
		var pt = this.shapePoint;
		var _g = index;
		var _g1 = this.interactive.length;
		while(_g < _g1) {
			var idx = _g++;
			var i = this.interactive[idx];
			if(i == null) {
				break;
			}
			if(i.invDet == 0) {
				continue;
			}
			var dx = ex - i.absX;
			var dy = ey - i.absY;
			var rx = (dx * i.matD - dy * i.matC) * i.invDet;
			var ry = (dy * i.matA - dx * i.matB) * i.invDet;
			if(i.shape != null) {
				var x = rx + i.shapeX;
				var y = ry + i.shapeY;
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				pt.x = x;
				pt.y = y;
				if(!i.shape.contains(pt)) {
					continue;
				}
			} else if(ry < 0 || rx < 0 || rx >= i.width || ry >= i.height) {
				continue;
			}
			var visible = true;
			var p = i;
			while(p != null) {
				if(!p.visible) {
					visible = false;
					break;
				}
				p = p.parent;
			}
			if(!visible) {
				continue;
			}
			event.relX = rx;
			event.relY = ry;
			i.handleEvent(event);
			if(event.cancel) {
				event.cancel = false;
				event.propagate = false;
				continue;
			}
			return i;
		}
		return null;
	}
	,addEventListener: function(f) {
		this.eventListeners.push(f);
	}
	,removeEventListener: function(f) {
		var _g = 0;
		var _g1 = this.eventListeners;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			if(Reflect.compareMethods(e,f)) {
				HxOverrides.remove(this.eventListeners,e);
				return true;
			}
		}
		return false;
	}
	,addEventTarget: function(i) {
		var i1 = i;
		var lv = 0;
		while(i1 != null) {
			i1 = i1.parent;
			++lv;
		}
		var level = lv;
		var _g = 0;
		var _g1 = this.interactive.length;
		while(_g < _g1) {
			var index = _g++;
			var i1 = i;
			var i2 = this.interactive[index];
			var lv1 = level;
			var i3 = i2;
			var lv = 0;
			while(i3 != null) {
				i3 = i3.parent;
				++lv;
			}
			var lv2 = lv;
			var p1 = i1;
			var p2 = i2;
			while(lv1 > lv2) {
				i1 = p1;
				p1 = p1.parent;
				--lv1;
			}
			while(lv2 > lv1) {
				i2 = p2;
				p2 = p2.parent;
				--lv2;
			}
			while(p1 != p2) {
				i1 = p1;
				p1 = p1.parent;
				i2 = p2;
				p2 = p2.parent;
			}
			var id = -1;
			var _g2 = 0;
			var _g3 = p1.children.length;
			while(_g2 < _g3) {
				var k = _g2++;
				if(p1.children[k] == i1) {
					id = k;
					break;
				}
			}
			var tmp = id;
			var id1 = -1;
			var _g4 = 0;
			var _g5 = p2.children.length;
			while(_g4 < _g5) {
				var k1 = _g4++;
				if(p2.children[k1] == i2) {
					id1 = k1;
					break;
				}
			}
			if(tmp > id1) {
				this.interactive.splice(index,0,i);
				return;
			}
		}
		this.interactive.push(i);
	}
	,removeEventTarget: function(i,notify) {
		if(notify == null) {
			notify = false;
		}
		HxOverrides.remove(this.interactive,i);
		if(notify && this.events != null) {
			this.events.onRemove(i);
		}
	}
	,dispose: function() {
		if(this.allocated) {
			this.onRemove();
		}
		this.ctx.dispose();
	}
	,setElapsedTime: function(v) {
		this.ctx.elapsedTime = v;
	}
	,drawImplTo: function(s,texs,outputs) {
		var _g = 0;
		while(_g < texs.length) {
			var t = texs[_g];
			++_g;
			if((t.flags & 1 << h3d_mat_TextureFlags.Target._hx_index) == 0) {
				throw haxe_Exception.thrown("Can only draw to texture created with Target flag");
			}
		}
		this.ctx.engine = h3d_Engine.CURRENT;
		var oldBG = this.ctx.engine.backgroundColor;
		var inRender = this.ctx.engine.inRender;
		this.ctx.engine.backgroundColor = null;
		this.ctx.globalAlpha = this.alpha;
		if(!inRender) {
			this.ctx.engine.begin();
			this.ctx.begin();
		} else if(this.ctx.targetFlipY == 0) {
			this.ctx.begin();
		}
		this.ctx.pushTargets(texs);
		if(outputs != null) {
			this.ctx.manager.setOutput(outputs);
		}
		s.drawRec(this.ctx);
		if(outputs != null) {
			this.ctx.manager.setOutput();
		}
		this.ctx.popTarget();
		this.ctx.engine.backgroundColor = oldBG;
		if(!inRender) {
			this.ctx.end();
			this.ctx.engine.end();
		}
	}
	,render: function(engine) {
		this.ctx.engine = engine;
		this.ctx.frame++;
		this.ctx.time += this.ctx.elapsedTime;
		this.ctx.globalAlpha = this.alpha;
		this.sync(this.ctx);
		if(this.children.length == 0) {
			return;
		}
		this.ctx.begin();
		this.ctx.drawScene();
		this.ctx.end();
	}
	,sync: function(ctx) {
		var forceCamSync = this.posChanged;
		if(!this.allocated) {
			this.onAdd();
		}
		h2d_Layers.prototype.sync.call(this,ctx);
		var _g = 0;
		var _g1 = this._cameras;
		while(_g < _g1.length) {
			var cam = _g1[_g];
			++_g;
			cam.sync(ctx,forceCamSync);
		}
	}
	,clipBounds: function(ctx,bounds,scaleX,scaleY) {
		if(scaleY == null) {
			scaleY = 1.;
		}
		if(scaleX == null) {
			scaleX = 1.;
		}
		var matA;
		var matB;
		var matC;
		var matD;
		var absX;
		var absY;
		if(ctx.inFilter != null) {
			var f1 = ctx.baseShader.filterMatrixA__;
			var f2 = ctx.baseShader.filterMatrixB__;
			var tmpA = this.matA * f1.x + this.matB * f1.y;
			var tmpB = this.matA * f2.x + this.matB * f2.y;
			var tmpC = this.matC * f1.x + this.matD * f1.y;
			var tmpD = this.matC * f2.x + this.matD * f2.y;
			var tmpX = this.absX * f1.x + this.absY * f1.y + f1.z;
			var tmpY = this.absX * f2.x + this.absY * f2.y + f2.z;
			matA = (tmpA * ctx.viewA + tmpB * ctx.viewC) / scaleX;
			matB = (tmpA * ctx.viewB + tmpB * ctx.viewD) / scaleY;
			matC = (tmpC * ctx.viewA + tmpD * ctx.viewC) / scaleX;
			matD = (tmpC * ctx.viewB + tmpD * ctx.viewD) / scaleY;
			absX = tmpX * ctx.viewA + tmpY * ctx.viewC + ctx.viewX;
			absY = tmpX * ctx.viewB + tmpY * ctx.viewD + ctx.viewY;
		} else {
			matA = (this.matA * ctx.viewA + this.matB * ctx.viewC) / scaleX;
			matB = (this.matA * ctx.viewB + this.matB * ctx.viewD) / scaleY;
			matC = (this.matC * ctx.viewA + this.matD * ctx.viewC) / scaleX;
			matD = (this.matC * ctx.viewB + this.matD * ctx.viewD) / scaleY;
			absX = this.absX * ctx.viewA + this.absY * ctx.viewC + ctx.viewX;
			absY = this.absX * ctx.viewB + this.absY * ctx.viewD + ctx.viewY;
		}
		var invDet = 1 / (matA * matD - matB * matC);
		bounds.xMin = ((-1 - absX) * matD + (absY + 1) * matC) * invDet;
		bounds.yMin = ((absX + 1) * matB + (-1 - absY) * matA) * invDet;
		bounds.xMax = ((1 - absX) * matD + (absY - 1) * matC) * invDet;
		bounds.yMax = ((absX - 1) * matB + (1 - absY) * matA) * invDet;
	}
	,drawContent: function(ctx) {
		if(ctx.front2back) {
			var _g = 0;
			var _g1 = this._cameras;
			while(_g < _g1.length) {
				var cam = _g1[_g];
				++_g;
				if(!cam.visible) {
					continue;
				}
				var i = this.children.length;
				var l = this.layerCount;
				cam.enter(ctx);
				while(l-- > 0) {
					var top = l == 0 ? 0 : this.layersIndexes[l - 1];
					if(cam.layerVisible(l)) {
						while(i >= top) this.children[i--].drawRec(ctx);
					} else {
						i = top - 1;
					}
				}
				cam.exit(ctx);
			}
			this.draw(ctx);
		} else {
			this.draw(ctx);
			var _g = 0;
			var _g1 = this._cameras;
			while(_g < _g1.length) {
				var cam = _g1[_g];
				++_g;
				if(!cam.visible) {
					continue;
				}
				var i = 0;
				var l = 0;
				cam.enter(ctx);
				while(l < this.layerCount) {
					var top = this.layersIndexes[l++];
					if(cam.layerVisible(l - 1)) {
						while(i < top) this.children[i++].drawRec(ctx);
					} else {
						i = top;
					}
				}
				cam.exit(ctx);
			}
		}
	}
	,onAdd: function() {
		this.checkResize();
		h2d_Layers.prototype.onAdd.call(this);
		this.window.addResizeEvent($bind(this,this.checkResize));
	}
	,onRemove: function() {
		h2d_Layers.prototype.onRemove.call(this);
		this.window.removeResizeEvent($bind(this,this.checkResize));
	}
	,__class__: h2d_Scene
});
var h2d_Align = $hxEnums["h2d.Align"] = { __ename__:true,__constructs__:null
	,Left: {_hx_name:"Left",_hx_index:0,__enum__:"h2d.Align",toString:$estr}
	,Right: {_hx_name:"Right",_hx_index:1,__enum__:"h2d.Align",toString:$estr}
	,Center: {_hx_name:"Center",_hx_index:2,__enum__:"h2d.Align",toString:$estr}
	,MultilineRight: {_hx_name:"MultilineRight",_hx_index:3,__enum__:"h2d.Align",toString:$estr}
	,MultilineCenter: {_hx_name:"MultilineCenter",_hx_index:4,__enum__:"h2d.Align",toString:$estr}
};
h2d_Align.__constructs__ = [h2d_Align.Left,h2d_Align.Right,h2d_Align.Center,h2d_Align.MultilineRight,h2d_Align.MultilineCenter];
h2d_Align.__empty_constructs__ = [h2d_Align.Left,h2d_Align.Right,h2d_Align.Center,h2d_Align.MultilineRight,h2d_Align.MultilineCenter];
var h2d_Tile = function(tex,x,y,w,h,dx,dy) {
	if(dy == null) {
		dy = 0;
	}
	if(dx == null) {
		dx = 0;
	}
	this.innerTex = tex;
	this.x = x;
	this.y = y;
	this.width = w;
	this.height = h;
	this.dx = dx;
	this.dy = dy;
	if(tex != null) {
		this.setTexture(tex);
	}
};
$hxClasses["h2d.Tile"] = h2d_Tile;
h2d_Tile.__name__ = "h2d.Tile";
h2d_Tile.fromColor = function(color,width,height,alpha) {
	if(alpha == null) {
		alpha = 1.;
	}
	if(height == null) {
		height = 1;
	}
	if(width == null) {
		width = 1;
	}
	var t = new h2d_Tile(h3d_mat_Texture.fromColor(color,alpha),0,0,1,1);
	t.width = width;
	t.height = height;
	return t;
};
h2d_Tile.fromTexture = function(t) {
	return new h2d_Tile(t,0,0,t.width,t.height);
};
h2d_Tile.prototype = {
	setTexture: function(tex) {
		this.innerTex = tex;
		if(tex != null) {
			this.u = this.x / tex.width;
			this.v = this.y / tex.height;
			this.u2 = (this.x + this.width) / tex.width;
			this.v2 = (this.y + this.height) / tex.height;
		}
	}
	,sub: function(x,y,w,h,dx,dy) {
		if(dy == null) {
			dy = 0.;
		}
		if(dx == null) {
			dx = 0.;
		}
		return new h2d_Tile(this.innerTex,this.x + x,this.y + y,w,h,dx,dy);
	}
	,setPosition: function(x,y) {
		this.x = x;
		this.y = y;
		var tex = this.innerTex;
		if(tex != null) {
			this.u = x / tex.width;
			this.v = y / tex.height;
			this.u2 = (x + this.width) / tex.width;
			this.v2 = (y + this.height) / tex.height;
		}
	}
	,setSize: function(w,h) {
		this.width = w;
		this.height = h;
		var tex = this.innerTex;
		if(tex != null) {
			this.u2 = (this.x + w) / tex.width;
			this.v2 = (this.y + h) / tex.height;
		}
	}
	,scaleToSize: function(w,h) {
		this.width = w;
		this.height = h;
	}
	,clone: function() {
		var t = new h2d_Tile(null,this.x,this.y,this.width,this.height,this.dx,this.dy);
		t.innerTex = this.innerTex;
		t.u = this.u;
		t.u2 = this.u2;
		t.v = this.v;
		t.v2 = this.v2;
		return t;
	}
	,__class__: h2d_Tile
};
var h2d_TileLayerContent = function() {
	this.useAllocatorLimit = 1024;
	h3d_prim_Primitive.call(this);
	this.state = new h2d_impl_BatchDrawState();
	this.clear();
};
$hxClasses["h2d.TileLayerContent"] = h2d_TileLayerContent;
h2d_TileLayerContent.__name__ = "h2d.TileLayerContent";
h2d_TileLayerContent.__super__ = h3d_prim_Primitive;
h2d_TileLayerContent.prototype = $extend(h3d_prim_Primitive.prototype,{
	clear: function() {
		var this1 = hxd__$FloatBuffer_Float32Expand._new(0);
		this.tmp = this1;
		if(this.buffer != null) {
			if(this.buffer.vertices * 8 < this.useAllocatorLimit) {
				hxd_impl_Allocator.get().disposeBuffer(this.buffer);
			} else {
				this.buffer.dispose();
			}
		}
		this.buffer = null;
		this.xMin = Infinity;
		this.yMin = Infinity;
		this.xMax = -Infinity;
		this.yMax = -Infinity;
		this.state.clear();
	}
	,isEmpty: function() {
		return this.triCount() == 0;
	}
	,triCount: function() {
		if(this.buffer == null) {
			return this.tmp.pos >> 4;
		} else {
			return this.buffer.totalVertices() >> 1;
		}
	}
	,add: function(x,y,r,g,b,a,t) {
		var sx = x + t.dx;
		var sy = y + t.dy;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = sx;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = sy;
		var this1 = this.tmp;
		var v = t.u;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = t.v;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = r;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = g;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = b;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = a;
		var this1 = this.tmp;
		var v = sx + t.width;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = sy;
		var this1 = this.tmp;
		var v = t.u2;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = t.v;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = r;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = g;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = b;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = a;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = sx;
		var this1 = this.tmp;
		var v = sy + t.height;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = t.u;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = t.v2;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = r;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = g;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = b;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = a;
		var this1 = this.tmp;
		var v = sx + t.width;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = sy + t.height;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = t.u2;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = t.v2;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = r;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = g;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = b;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = a;
		var x1 = x + t.dx;
		var y1 = y + t.dy;
		if(x1 < this.xMin) {
			this.xMin = x1;
		}
		if(y1 < this.yMin) {
			this.yMin = y1;
		}
		x1 += t.width;
		y1 += t.height;
		if(x1 > this.xMax) {
			this.xMax = x1;
		}
		if(y1 > this.yMax) {
			this.yMax = y1;
		}
		if(t != null) {
			this.state.setTexture(t.innerTex);
		}
		var _this = this.state;
		_this.tail.count += 4;
		_this.totalCount += 4;
	}
	,alloc: function(engine) {
		if(this.tmp == null) {
			this.clear();
		}
		if(this.tmp.pos > 0) {
			this.buffer = this.tmp.pos < this.useAllocatorLimit ? hxd_impl_Allocator.get().ofFloats(this.tmp,8,3) : h3d_Buffer.ofFloats(this.tmp,8,[h3d_BufferFlag.Quads,h3d_BufferFlag.RawFormat]);
		}
	}
	,dispose: function() {
		if(this.buffer != null) {
			if(this.buffer.vertices * 8 < this.useAllocatorLimit) {
				hxd_impl_Allocator.get().disposeBuffer(this.buffer);
			} else {
				this.buffer.dispose();
			}
			this.buffer = null;
		}
		h3d_prim_Primitive.prototype.dispose.call(this);
	}
	,__class__: h2d_TileLayerContent
});
var h2d_col_Collider = function() { };
$hxClasses["h2d.col.Collider"] = h2d_col_Collider;
h2d_col_Collider.__name__ = "h2d.col.Collider";
h2d_col_Collider.__isInterface__ = true;
h2d_col_Collider.prototype = {
	__class__: h2d_col_Collider
};
var h2d_col_Bounds = function() {
	this.xMin = 1e20;
	this.yMin = 1e20;
	this.xMax = -1e20;
	this.yMax = -1e20;
};
$hxClasses["h2d.col.Bounds"] = h2d_col_Bounds;
h2d_col_Bounds.__name__ = "h2d.col.Bounds";
h2d_col_Bounds.__interfaces__ = [h2d_col_Collider];
h2d_col_Bounds.prototype = {
	contains: function(p) {
		if(p.x >= this.xMin && p.x < this.xMax && p.y >= this.yMin) {
			return p.y < this.yMax;
		} else {
			return false;
		}
	}
	,__class__: h2d_col_Bounds
};
var h2d_col_Matrix = function() {
	this.a = 1;
	this.b = 0;
	this.c = 0;
	this.d = 1;
	this.x = 0;
	this.y = 0;
};
$hxClasses["h2d.col.Matrix"] = h2d_col_Matrix;
h2d_col_Matrix.__name__ = "h2d.col.Matrix";
h2d_col_Matrix.prototype = {
	__class__: h2d_col_Matrix
};
var h2d_filter_Blur = function(radius,gain,quality,linear) {
	if(linear == null) {
		linear = 0.;
	}
	if(quality == null) {
		quality = 1.;
	}
	if(gain == null) {
		gain = 1.;
	}
	if(radius == null) {
		radius = 1.;
	}
	h2d_filter_Filter.call(this);
	this.smooth = true;
	this.pass = new h3d_pass_Blur(radius,gain,linear,quality);
};
$hxClasses["h2d.filter.Blur"] = h2d_filter_Blur;
h2d_filter_Blur.__name__ = "h2d.filter.Blur";
h2d_filter_Blur.__super__ = h2d_filter_Filter;
h2d_filter_Blur.prototype = $extend(h2d_filter_Filter.prototype,{
	sync: function(ctx,s) {
		this.boundsExtend = this.pass.radius * 2;
	}
	,draw: function(ctx,t) {
		var out = t.innerTex;
		var old = out.filter;
		out.set_filter(h3d_mat_Filter.Linear);
		this.pass.apply(ctx,out);
		out.set_filter(old);
		return t;
	}
	,__class__: h2d_filter_Blur
});
var h2d_filter_Glow = function(color,alpha,radius,gain,quality,smoothColor) {
	if(smoothColor == null) {
		smoothColor = false;
	}
	if(quality == null) {
		quality = 1.;
	}
	if(gain == null) {
		gain = 1.;
	}
	if(radius == null) {
		radius = 1.;
	}
	if(alpha == null) {
		alpha = 1.;
	}
	if(color == null) {
		color = 16777215;
	}
	h2d_filter_Blur.call(this,radius,gain,quality);
	this.color = color;
	this.alpha = alpha;
	this.smoothColor = smoothColor;
	var _this = this.pass.shader;
	_this.constModified = true;
	_this.hasFixedColor__ = true;
};
$hxClasses["h2d.filter.Glow"] = h2d_filter_Glow;
h2d_filter_Glow.__name__ = "h2d.filter.Glow";
h2d_filter_Glow.__super__ = h2d_filter_Blur;
h2d_filter_Glow.prototype = $extend(h2d_filter_Blur.prototype,{
	setParams: function() {
		var _this = this.pass.shader.fixedColor__;
		var c = this.color;
		_this.x = (c >> 16 & 255) / 255;
		_this.y = (c >> 8 & 255) / 255;
		_this.z = (c & 255) / 255;
		_this.w = (c >>> 24) / 255;
		this.pass.shader.fixedColor__.w = this.smoothColor ? this.alpha * 1.5 : this.alpha;
		var _this = this.pass.shader;
		_this.constModified = true;
		_this.smoothFixedColor__ = this.smoothColor;
	}
	,draw: function(ctx,t) {
		this.setParams();
		var tex = t.innerTex;
		var old = tex.filter;
		var save = ctx.textures.allocTileTarget("glowSave",t);
		h3d_pass_Copy.run(tex,save,h2d_BlendMode.None);
		tex.set_filter(h3d_mat_Filter.Linear);
		this.pass.apply(ctx,tex);
		tex.set_filter(old);
		if(this.knockout) {
			h3d_pass_Copy.run(save,tex,h2d_BlendMode.Erase);
		} else {
			h3d_pass_Copy.run(save,tex,h2d_BlendMode.Alpha);
		}
		return t;
	}
	,__class__: h2d_filter_Glow
});
var h2d_filter_DropShadow = function(distance,angle,color,alpha,radius,gain,quality,smoothColor) {
	if(smoothColor == null) {
		smoothColor = false;
	}
	if(quality == null) {
		quality = 1.;
	}
	if(gain == null) {
		gain = 1;
	}
	if(radius == null) {
		radius = 1.;
	}
	if(alpha == null) {
		alpha = 1.;
	}
	if(color == null) {
		color = 0;
	}
	if(angle == null) {
		angle = 0.785;
	}
	if(distance == null) {
		distance = 4.;
	}
	this.alphaPass = new h3d_mat_Pass("");
	h2d_filter_Glow.call(this,color,alpha,radius,gain,quality,smoothColor);
	this.distance = distance;
	this.angle = angle;
	this.alphaPass.addShader(new h3d_shader_UVDelta());
};
$hxClasses["h2d.filter.DropShadow"] = h2d_filter_DropShadow;
h2d_filter_DropShadow.__name__ = "h2d.filter.DropShadow";
h2d_filter_DropShadow.__super__ = h2d_filter_Glow;
h2d_filter_DropShadow.prototype = $extend(h2d_filter_Glow.prototype,{
	sync: function(ctx,s) {
		h2d_filter_Glow.prototype.sync.call(this,ctx,s);
		var f = Math.cos(this.angle) * this.distance;
		var a = f < 0 ? -f : f;
		var f = Math.sin(this.angle) * this.distance;
		var b = f < 0 ? -f : f;
		this.boundsExtend += a < b ? b : a;
	}
	,draw: function(ctx,t) {
		this.setParams();
		var save = ctx.textures.allocTileTarget("glowSave",t);
		h3d_pass_Copy.run(t.innerTex,save,h2d_BlendMode.None);
		this.pass.apply(ctx,save);
		var dx = Math.round(Math.cos(this.angle) * this.distance);
		var dy = Math.round(Math.sin(this.angle) * this.distance);
		var _this = this.alphaPass.getShader(h3d_shader_UVDelta).uvDelta__;
		var x = dx / t.width;
		var y = dy / t.height;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = 0.;
		_this.w = 1.;
		h3d_pass_Copy.run(t.innerTex,save,h2d_BlendMode.Alpha,this.alphaPass);
		var ret = h2d_Tile.fromTexture(save);
		ret.dx = dx;
		ret.dy = dy;
		return ret;
	}
	,__class__: h2d_filter_DropShadow
});
var h2d_filter_Group = function(filters) {
	h2d_filter_Filter.call(this);
	this.filters = filters == null ? [] : filters;
};
$hxClasses["h2d.filter.Group"] = h2d_filter_Group;
h2d_filter_Group.__name__ = "h2d.filter.Group";
h2d_filter_Group.__super__ = h2d_filter_Filter;
h2d_filter_Group.prototype = $extend(h2d_filter_Filter.prototype,{
	get_enable: function() {
		if(!this.enable) {
			return false;
		}
		var _g = 0;
		var _g1 = this.filters;
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			if(this.enable) {
				return true;
			}
		}
		return false;
	}
	,bind: function(s) {
		var _g = 0;
		var _g1 = this.filters;
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			if(f.get_enable()) {
				f.bind(s);
			}
		}
	}
	,unbind: function(s) {
		var _g = 0;
		var _g1 = this.filters;
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			if(f.get_enable()) {
				f.unbind(s);
			}
		}
	}
	,sync: function(ctx,s) {
		this.autoBounds = true;
		this.boundsExtend = 0;
		var _g = 0;
		var _g1 = this.filters;
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			if(!f.get_enable()) {
				continue;
			}
			f.sync(ctx,s);
			if(f.boundsExtend > 0) {
				this.boundsExtend += f.boundsExtend;
			}
			if(!f.autoBounds) {
				this.autoBounds = false;
			}
		}
	}
	,getBounds: function(s,bounds,scale) {
		var _g = 0;
		var _g1 = this.filters;
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			if(f.get_enable() && !f.autoBounds) {
				f.getBounds(s,bounds,scale);
			}
		}
	}
	,draw: function(ctx,input) {
		var xMin = input.dx;
		var yMin = input.dy;
		var start = input;
		var _g = 0;
		var _g1 = this.filters;
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			if(!f.get_enable()) {
				continue;
			}
			var prev = input;
			input = f.draw(ctx,input);
			if(input == null) {
				return null;
			}
			if(input != prev) {
				input.dx += xMin;
				input.dy += yMin;
			}
		}
		if(start != input) {
			input.dx -= xMin;
			input.dy -= yMin;
		}
		return input;
	}
	,__class__: h2d_filter_Group
});
var h2d_impl_BatchDrawState = function() {
	this.head = this.tail = new h2d_impl__$BatchDrawState_StateEntry(null);
	this.totalCount = 0;
};
$hxClasses["h2d.impl.BatchDrawState"] = h2d_impl_BatchDrawState;
h2d_impl_BatchDrawState.__name__ = "h2d.impl.BatchDrawState";
h2d_impl_BatchDrawState.prototype = {
	setTexture: function(texture) {
		if(texture != null) {
			if(this.tail.texture == null) {
				this.tail.texture = texture;
			} else if(this.tail.texture != texture) {
				var cur = this.tail;
				if(cur.count == 0) {
					cur.set(texture);
				} else if(cur.next == null) {
					cur.next = this.tail = new h2d_impl__$BatchDrawState_StateEntry(texture);
				} else {
					this.tail = cur.next.set(texture);
				}
			}
		}
	}
	,clear: function() {
		var state = this.head;
		while(true) {
			state.texture = null;
			state = state.next;
			if(!(state != null)) {
				break;
			}
		}
		this.tail = this.head;
		this.tail.count = 0;
		this.totalCount = 0;
	}
	,drawQuads: function(ctx,buffer,offset,length) {
		if(length == null) {
			length = -1;
		}
		if(offset == null) {
			offset = 0;
		}
		var state = this.head;
		var last = this.tail.next;
		var engine = ctx.engine;
		var stateLen;
		if(offset == 0 && length == -1) {
			while(true) {
				ctx.texture = state.texture;
				ctx.beforeDraw();
				stateLen = state.count >> 1;
				var start = offset;
				var max = stateLen;
				if(max == null) {
					max = -1;
				}
				if(start == null) {
					start = 0;
				}
				engine.renderBuffer(buffer,engine.mem.quadIndexes,2,start,max);
				offset += stateLen;
				state = state.next;
				if(!(state != last)) {
					break;
				}
			}
		} else {
			if(length == -1) {
				length = (this.totalCount >> 1) - offset;
			}
			var caret = 0;
			while(true) {
				stateLen = state.count >> 1;
				if(caret + stateLen >= offset) {
					var stateMin = offset >= caret ? offset : caret;
					var stateLen1 = length > stateLen ? stateLen : length;
					ctx.texture = state.texture;
					ctx.beforeDraw();
					var start = stateMin;
					var max = stateLen1;
					if(max == null) {
						max = -1;
					}
					if(start == null) {
						start = 0;
					}
					engine.renderBuffer(buffer,engine.mem.quadIndexes,2,start,max);
					length -= stateLen1;
					if(length == 0) {
						break;
					}
				}
				caret += stateLen;
				state = state.next;
				if(!(state != last)) {
					break;
				}
			}
		}
	}
	,drawIndexed: function(ctx,buffer,indices,offset,length) {
		if(length == null) {
			length = -1;
		}
		if(offset == null) {
			offset = 0;
		}
		var state = this.head;
		var last = this.tail.next;
		var engine = ctx.engine;
		var stateLen;
		if(offset == 0 && length == -1) {
			while(true) {
				ctx.texture = state.texture;
				ctx.beforeDraw();
				stateLen = state.count / 3 | 0;
				engine.renderIndexed(buffer,indices,offset,stateLen);
				offset += stateLen;
				state = state.next;
				if(!(state != last)) {
					break;
				}
			}
		} else {
			if(length == -1) {
				length = this.totalCount / 3 | 0;
			}
			var caret = 0;
			while(true) {
				stateLen = state.count / 3 | 0;
				if(caret + stateLen >= offset) {
					var stateMin = offset >= caret ? offset : caret;
					var stateLen1 = length > stateLen ? stateLen : length;
					ctx.texture = state.texture;
					ctx.beforeDraw();
					engine.renderIndexed(buffer,indices,stateMin,stateLen1);
					length -= stateLen1;
					if(length == 0) {
						break;
					}
				}
				caret += stateLen;
				state = state.next;
				if(!(state != last)) {
					break;
				}
			}
		}
	}
	,__class__: h2d_impl_BatchDrawState
};
var h2d_impl__$BatchDrawState_StateEntry = function(texture) {
	this.texture = texture;
	this.count = 0;
};
$hxClasses["h2d.impl._BatchDrawState.StateEntry"] = h2d_impl__$BatchDrawState_StateEntry;
h2d_impl__$BatchDrawState_StateEntry.__name__ = "h2d.impl._BatchDrawState.StateEntry";
h2d_impl__$BatchDrawState_StateEntry.prototype = {
	set: function(texture) {
		this.texture = texture;
		this.count = 0;
		return this;
	}
	,__class__: h2d_impl__$BatchDrawState_StateEntry
};
var h3d_BufferFlag = $hxEnums["h3d.BufferFlag"] = { __ename__:true,__constructs__:null
	,Dynamic: {_hx_name:"Dynamic",_hx_index:0,__enum__:"h3d.BufferFlag",toString:$estr}
	,Triangles: {_hx_name:"Triangles",_hx_index:1,__enum__:"h3d.BufferFlag",toString:$estr}
	,Quads: {_hx_name:"Quads",_hx_index:2,__enum__:"h3d.BufferFlag",toString:$estr}
	,Managed: {_hx_name:"Managed",_hx_index:3,__enum__:"h3d.BufferFlag",toString:$estr}
	,RawFormat: {_hx_name:"RawFormat",_hx_index:4,__enum__:"h3d.BufferFlag",toString:$estr}
	,NoAlloc: {_hx_name:"NoAlloc",_hx_index:5,__enum__:"h3d.BufferFlag",toString:$estr}
	,UniformBuffer: {_hx_name:"UniformBuffer",_hx_index:6,__enum__:"h3d.BufferFlag",toString:$estr}
	,LargeBuffer: {_hx_name:"LargeBuffer",_hx_index:7,__enum__:"h3d.BufferFlag",toString:$estr}
};
h3d_BufferFlag.__constructs__ = [h3d_BufferFlag.Dynamic,h3d_BufferFlag.Triangles,h3d_BufferFlag.Quads,h3d_BufferFlag.Managed,h3d_BufferFlag.RawFormat,h3d_BufferFlag.NoAlloc,h3d_BufferFlag.UniformBuffer,h3d_BufferFlag.LargeBuffer];
h3d_BufferFlag.__empty_constructs__ = [h3d_BufferFlag.Dynamic,h3d_BufferFlag.Triangles,h3d_BufferFlag.Quads,h3d_BufferFlag.Managed,h3d_BufferFlag.RawFormat,h3d_BufferFlag.NoAlloc,h3d_BufferFlag.UniformBuffer,h3d_BufferFlag.LargeBuffer];
var h3d_Buffer = function(vertices,stride,flags) {
	this.id = h3d_Buffer.GUID++;
	this.vertices = vertices;
	var this1 = 0;
	this.flags = this1;
	if(flags != null) {
		var _g = 0;
		while(_g < flags.length) {
			var f = flags[_g];
			++_g;
			this.flags |= 1 << f._hx_index;
		}
	}
	if((this.flags & 1 << h3d_BufferFlag.NoAlloc._hx_index) == 0) {
		h3d_Engine.CURRENT.mem.allocBuffer(this,stride);
	}
};
$hxClasses["h3d.Buffer"] = h3d_Buffer;
h3d_Buffer.__name__ = "h3d.Buffer";
h3d_Buffer.ofFloats = function(v,stride,flags) {
	var nvert = v.pos / stride | 0;
	var b = new h3d_Buffer(nvert,stride,flags);
	b.uploadVector(v,0,nvert);
	return b;
};
h3d_Buffer.prototype = {
	dispose: function() {
		if(this.buffer != null) {
			this.buffer.freeBuffer(this);
			this.buffer = null;
			if(this.next != null) {
				this.next.dispose();
			}
		}
	}
	,totalVertices: function() {
		var count = 0;
		var b = this;
		while(b != null) {
			count += b.vertices;
			b = b.next;
		}
		return count;
	}
	,uploadVector: function(buf,bufPos,vertices,startVertice) {
		if(startVertice == null) {
			startVertice = 0;
		}
		var cur = this;
		while(cur != null && startVertice >= cur.vertices) {
			startVertice -= cur.vertices;
			cur = cur.next;
		}
		while(vertices > 0) {
			if(cur == null) {
				throw haxe_Exception.thrown("Too many vertices");
			}
			var count = vertices + startVertice > cur.vertices ? cur.vertices - startVertice : vertices;
			cur.buffer.uploadVertexBuffer(cur.position + startVertice,count,buf,bufPos);
			startVertice = 0;
			bufPos += count * this.buffer.stride;
			vertices -= count;
			cur = cur.next;
		}
	}
	,__class__: h3d_Buffer
};
var h3d_BufferOffset = function(buffer,offset) {
	this.buffer = buffer;
	this.offset = offset;
};
$hxClasses["h3d.BufferOffset"] = h3d_BufferOffset;
h3d_BufferOffset.__name__ = "h3d.BufferOffset";
h3d_BufferOffset.prototype = {
	dispose: function() {
		if(this.buffer != null) {
			this.buffer.dispose();
			this.buffer = null;
		}
		this.next = null;
	}
	,__class__: h3d_BufferOffset
};
var h3d_Camera = function(fovY,zoom,screenRatio,zNear,zFar,rightHanded) {
	if(rightHanded == null) {
		rightHanded = false;
	}
	if(zFar == null) {
		zFar = 4000.;
	}
	if(zNear == null) {
		zNear = 0.02;
	}
	if(screenRatio == null) {
		screenRatio = 1.333333;
	}
	if(zoom == null) {
		zoom = 1.;
	}
	if(fovY == null) {
		fovY = 25.;
	}
	this.viewY = 0.;
	this.viewX = 0.;
	this.fovY = fovY;
	this.zoom = zoom;
	this.screenRatio = screenRatio;
	this.zNear = zNear;
	this.zFar = zFar;
	this.rightHanded = rightHanded;
	this.pos = new h3d_Vector(2,3,4);
	this.up = new h3d_Vector(0,0,1);
	this.target = new h3d_Vector(0,0,0);
	this.m = new h3d_Matrix();
	this.mcam = new h3d_Matrix();
	this.mproj = new h3d_Matrix();
	this.frustum = new h3d_col_Frustum();
	this.update();
};
$hxClasses["h3d.Camera"] = h3d_Camera;
h3d_Camera.__name__ = "h3d.Camera";
h3d_Camera.prototype = {
	getInverseViewProj: function() {
		if(this.minv == null) {
			this.minv = new h3d_Matrix();
		}
		if(this.needInv) {
			this.minv.initInverse(this.m);
			this.needInv = false;
		}
		return this.minv;
	}
	,getInverseView: function() {
		if(this.mcamInv == null) {
			this.mcamInv = new h3d_Matrix();
			this.mcamInv._44 = 0;
		}
		if(this.mcamInv._44 == 0) {
			this.mcamInv.initInverse(this.mcam);
		}
		return this.mcamInv;
	}
	,unproject: function(screenX,screenY,camZ) {
		var p = new h3d_Vector(screenX,screenY,camZ);
		var m = this.getInverseViewProj();
		var px = p.x * m._11 + p.y * m._21 + p.z * m._31 + p.w * m._41;
		var py = p.x * m._12 + p.y * m._22 + p.z * m._32 + p.w * m._42;
		var pz = p.x * m._13 + p.y * m._23 + p.z * m._33 + p.w * m._43;
		var iw = 1 / (p.x * m._14 + p.y * m._24 + p.z * m._34 + p.w * m._44);
		p.x = px * iw;
		p.y = py * iw;
		p.z = pz * iw;
		p.w = 1;
		return p;
	}
	,update: function() {
		if(this.follow != null) {
			var fpos = this.follow.pos.localToGlobal();
			var ftarget = this.follow.target.localToGlobal();
			var _this = this.pos;
			var x = fpos.x;
			var y = fpos.y;
			var z = fpos.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = 1.;
			var _this = this.target;
			var x = ftarget.x;
			var y = ftarget.y;
			var z = ftarget.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = 1.;
			if(this.follow.pos.name != null) {
				var p = this.follow.pos;
				while(p != null) {
					if(p.currentAnimation != null) {
						var v = p.currentAnimation.getPropValue(this.follow.pos.name,"FOVY");
						if(v != null) {
							this.fovY = v;
							break;
						}
					}
					p = p.parent;
				}
			}
		}
		this.makeCameraMatrix(this.mcam);
		this.makeFrustumMatrix(this.mproj);
		this.m.multiply(this.mcam,this.mproj);
		this.needInv = true;
		if(this.mcamInv != null) {
			this.mcamInv._44 = 0;
		}
		if(this.mprojInv != null) {
			this.mprojInv._44 = 0;
		}
		this.frustum.loadMatrix(this.m);
	}
	,makeCameraMatrix: function(m) {
		var _this = this.target;
		var v = this.pos;
		var x = _this.x - v.x;
		var y = _this.y - v.y;
		var z = _this.z - v.z;
		var w = _this.w - v.w;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var az_x = x;
		var az_y = y;
		var az_z = z;
		var az_w = w;
		if(this.rightHanded) {
			az_x *= -1;
			az_y *= -1;
			az_z *= -1;
		}
		var k = az_x * az_x + az_y * az_y + az_z * az_z;
		if(k < 1e-10) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		az_x *= k;
		az_y *= k;
		az_z *= k;
		var _this = this.up;
		var x = _this.y * az_z - _this.z * az_y;
		var y = _this.z * az_x - _this.x * az_z;
		var z = _this.x * az_y - _this.y * az_x;
		var w = 1;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var ax_x = x;
		var ax_y = y;
		var ax_z = z;
		var ax_w = w;
		var k = ax_x * ax_x + ax_y * ax_y + ax_z * ax_z;
		if(k < 1e-10) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		ax_x *= k;
		ax_y *= k;
		ax_z *= k;
		if(Math.sqrt(ax_x * ax_x + ax_y * ax_y + ax_z * ax_z) == 0) {
			ax_x = az_y;
			ax_y = az_z;
			ax_z = az_x;
		}
		var x = az_y * ax_z - az_z * ax_y;
		var y = az_z * ax_x - az_x * ax_z;
		var z = az_x * ax_y - az_y * ax_x;
		var w = 1;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var ay_x = x;
		var ay_y = y;
		var ay_z = z;
		var ay_w = w;
		m._11 = ax_x;
		m._12 = ay_x;
		m._13 = az_x;
		m._14 = 0;
		m._21 = ax_y;
		m._22 = ay_y;
		m._23 = az_y;
		m._24 = 0;
		m._31 = ax_z;
		m._32 = ay_z;
		m._33 = az_z;
		m._34 = 0;
		var v = this.pos;
		m._41 = -(ax_x * v.x + ax_y * v.y + ax_z * v.z);
		var v = this.pos;
		m._42 = -(ay_x * v.x + ay_y * v.y + ay_z * v.z);
		var v = this.pos;
		m._43 = -(az_x * v.x + az_y * v.y + az_z * v.z);
		m._44 = 1;
	}
	,makeFrustumMatrix: function(m) {
		m.zero();
		var bounds = this.orthoBounds;
		if(bounds != null) {
			var w = 1 / (bounds.xMax - bounds.xMin);
			var h = 1 / (bounds.yMax - bounds.yMin);
			var d = 1 / (bounds.zMax - bounds.zMin);
			m._11 = 2 * w;
			m._22 = 2 * h;
			m._33 = d;
			m._41 = -(bounds.xMin + bounds.xMax) * w;
			m._42 = -(bounds.yMin + bounds.yMax) * h;
			m._43 = -bounds.zMin * d;
			m._44 = 1;
		} else {
			var degToRad = Math.PI / 180;
			var halfFovX = Math.atan(Math.tan(this.fovY * 0.5 * degToRad) * this.screenRatio);
			var scale = this.zoom / Math.tan(halfFovX);
			m._11 = scale;
			m._22 = scale * this.screenRatio;
			m._33 = this.zFar / (this.zFar - this.zNear);
			m._34 = 1;
			m._43 = -(this.zNear * this.zFar) / (this.zFar - this.zNear);
		}
		m._11 += this.viewX * m._14;
		m._21 += this.viewX * m._24;
		m._31 += this.viewX * m._34;
		m._41 += this.viewX * m._44;
		m._12 += this.viewY * m._14;
		m._22 += this.viewY * m._24;
		m._32 += this.viewY * m._34;
		m._42 += this.viewY * m._44;
		if(this.rightHanded) {
			m._33 *= -1;
			m._34 *= -1;
		}
	}
	,distanceToDepth: function(dist) {
		var min = this.zNear;
		var max = this.zFar;
		if(max == null) {
			max = 1.;
		}
		if(min == null) {
			min = 0.;
		}
		return ((this.zFar + this.zNear - 2.0 * this.zNear * this.zFar / (dist < min ? min : dist > max ? max : dist)) / (this.zFar - this.zNear) + 1.0) / 2.0;
	}
	,__class__: h3d_Camera
};
var h3d__$Engine_TargetTmp = function(t,n,l,m) {
	this.t = t;
	this.next = n;
	this.layer = l;
	this.mipLevel = m;
};
$hxClasses["h3d._Engine.TargetTmp"] = h3d__$Engine_TargetTmp;
h3d__$Engine_TargetTmp.__name__ = "h3d._Engine.TargetTmp";
h3d__$Engine_TargetTmp.prototype = {
	__class__: h3d__$Engine_TargetTmp
};
var h3d_Engine = function() {
	this.resCache = new haxe_ds_ObjectMap();
	this.ready = false;
	this.inRender = false;
	this.textureColorCache = new haxe_ds_IntMap();
	this.tmpVector = new h3d_Vector();
	this.backgroundColor = -16777216;
	this.hardware = !h3d_Engine.SOFTWARE_DRIVER;
	this.antiAlias = h3d_Engine.ANTIALIASING;
	this.autoResize = true;
	this.set_fullScreen(!hxd_System.getValue(hxd_SystemValue.IsWindowed));
	this.window = hxd_Window.getInstance();
	this.realFps = hxd_System.getDefaultFrameRate();
	this.lastTime = HxOverrides.now() / 1000;
	this.window.addResizeEvent($bind(this,this.onWindowResize));
	this.driver = js_Browser.get_supported() ? new h3d_impl_GlDriver(this.antiAlias) : new h3d_impl_NullDriver();
	h3d_Engine.CURRENT = this;
};
$hxClasses["h3d.Engine"] = h3d_Engine;
h3d_Engine.__name__ = "h3d.Engine";
h3d_Engine.prototype = {
	init: function() {
		this.driver.init($bind(this,this.onCreate),!this.hardware);
	}
	,selectShader: function(shader) {
		if(this.needFlushTarget) {
			this.doFlushTarget();
		}
		if(this.driver.selectShader(shader)) {
			this.shaderSwitches++;
		}
	}
	,selectMaterial: function(pass) {
		this.driver.selectMaterial(pass);
	}
	,uploadShaderBuffers: function(buffers,which) {
		this.driver.uploadShaderBuffers(buffers,which);
	}
	,selectBuffer: function(buf) {
		if(buf.buffer == null || buf.buffer.vbuf == null) {
			return false;
		}
		if(this.needFlushTarget) {
			this.doFlushTarget();
		}
		this.driver.selectBuffer(buf);
		return true;
	}
	,renderBuffer: function(b,indexes,vertPerTri,startTri,drawTri) {
		if(drawTri == null) {
			drawTri = -1;
		}
		if(startTri == null) {
			startTri = 0;
		}
		if(indexes.isDisposed()) {
			return;
		}
		while(true) {
			var ntri = b.vertices / vertPerTri | 0;
			var pos = b.position / vertPerTri | 0;
			if(startTri > 0) {
				if(startTri >= ntri) {
					startTri -= ntri;
					b = b.next;
					if(!(b != null)) {
						break;
					} else {
						continue;
					}
				}
				pos += startTri;
				ntri -= startTri;
				startTri = 0;
			}
			if(drawTri >= 0) {
				if(drawTri == 0) {
					return;
				}
				drawTri -= ntri;
				if(drawTri < 0) {
					ntri += drawTri;
					drawTri = 0;
				}
			}
			if(ntri > 0 && this.selectBuffer(b)) {
				this.driver.draw(indexes.ibuf,pos * 3,ntri);
				this.drawTriangles += ntri;
				this.drawCalls++;
			}
			b = b.next;
			if(!(b != null)) {
				break;
			}
		}
	}
	,renderIndexed: function(b,indexes,startTri,drawTri) {
		if(drawTri == null) {
			drawTri = -1;
		}
		if(startTri == null) {
			startTri = 0;
		}
		if(b.next != null) {
			throw haxe_Exception.thrown("Buffer is split");
		}
		if(indexes.isDisposed()) {
			return;
		}
		var maxTri = indexes.count / 3 | 0;
		if(drawTri < 0) {
			drawTri = maxTri - startTri;
		}
		if(drawTri > 0 && this.selectBuffer(b)) {
			this.driver.draw(indexes.ibuf,startTri * 3,drawTri);
			this.drawTriangles += drawTri;
			this.drawCalls++;
		}
	}
	,renderMultiBuffers: function(buffers,indexes,startTri,drawTri) {
		if(drawTri == null) {
			drawTri = -1;
		}
		if(startTri == null) {
			startTri = 0;
		}
		var maxTri = indexes.count / 3 | 0;
		if(maxTri <= 0) {
			return;
		}
		if(this.needFlushTarget) {
			this.doFlushTarget();
		}
		this.driver.selectMultiBuffers(buffers);
		if(indexes.isDisposed()) {
			return;
		}
		if(drawTri < 0) {
			drawTri = maxTri - startTri;
		}
		if(drawTri > 0) {
			this.driver.draw(indexes.ibuf,startTri * 3,drawTri);
			this.drawTriangles += drawTri;
			this.drawCalls++;
		}
	}
	,renderInstanced: function(buffers,indexes,commands) {
		if(this.needFlushTarget) {
			this.doFlushTarget();
		}
		this.driver.selectMultiBuffers(buffers);
		if(indexes.isDisposed()) {
			return;
		}
		if(commands.commandCount > 0) {
			this.driver.drawInstanced(indexes.ibuf,commands);
			this.drawTriangles += commands.triCount;
			this.drawCalls++;
		}
	}
	,set_debug: function(d) {
		this.debug = d;
		this.driver.setDebug(this.debug);
		return d;
	}
	,onCreate: function(disposed) {
		h3d_Engine.CURRENT = this;
		if(this.autoResize) {
			this.width = this.window.get_width();
			this.height = this.window.get_height();
		}
		if(disposed) {
			hxd_impl_Allocator.get().onContextLost();
			this.mem.onContextLost();
		} else {
			this.mem = new h3d_impl_MemoryManager(this.driver);
			this.mem.init();
			this.nullTexture = new h3d_mat_Texture(0,0,[h3d_mat_TextureFlags.NoAlloc]);
		}
		this.hardware = this.driver.hasFeature(h3d_impl_Feature.HardwareAccelerated);
		this.set_debug(this.debug);
		this.set_fullScreen(this.fullScreen);
		this.resize(this.width,this.height);
		if(disposed) {
			this.onContextLost();
		} else {
			this.onReady();
		}
		this.ready = true;
	}
	,onContextLost: function() {
	}
	,onReady: function() {
	}
	,onWindowResize: function() {
		if(this.autoResize && !this.driver.isDisposed()) {
			var w = this.window.get_width();
			var h = this.window.get_height();
			if(w != this.width || h != this.height) {
				this.resize(w,h);
			}
			this.onResized();
		}
	}
	,set_fullScreen: function(v) {
		this.fullScreen = v;
		if(this.mem != null && hxd_System.getValue(hxd_SystemValue.IsWindowed)) {
			this.window.set_displayMode(v ? hxd_DisplayMode.Borderless : hxd_DisplayMode.Windowed);
		}
		return v;
	}
	,onResized: function() {
	}
	,resize: function(width,height) {
		if(width < 32) {
			width = 32;
		}
		if(height < 32) {
			height = 32;
		}
		this.width = width;
		this.height = height;
		if(!this.driver.isDisposed()) {
			this.driver.resize(width,height);
		}
	}
	,begin: function() {
		if(this.driver.isDisposed()) {
			return false;
		}
		this.inRender = true;
		this.drawTriangles = 0;
		this.shaderSwitches = 0;
		this.drawCalls = 0;
		this.targetStack = null;
		this.needFlushTarget = this.currentTargetTex != null;
		this.driver.begin(hxd_Timer.frameCount);
		if(this.backgroundColor != null) {
			this.clear(this.backgroundColor,1,0);
		}
		return true;
	}
	,end: function() {
		this.inRender = false;
		this.driver.end();
	}
	,getCurrentTarget: function() {
		if(this.targetStack == null) {
			return null;
		} else if(this.targetStack.t == this.nullTexture) {
			return this.targetStack.textures[0];
		} else {
			return this.targetStack.t;
		}
	}
	,pushTarget: function(tex,layer,mipLevel) {
		if(mipLevel == null) {
			mipLevel = 0;
		}
		if(layer == null) {
			layer = 0;
		}
		var c = this.targetTmp;
		if(c == null) {
			c = new h3d__$Engine_TargetTmp(tex,this.targetStack,layer,mipLevel);
		} else {
			this.targetTmp = c.next;
			c.t = tex;
			c.next = this.targetStack;
			c.mipLevel = mipLevel;
			c.layer = layer;
		}
		this.targetStack = c;
		this.updateNeedFlush();
	}
	,updateNeedFlush: function() {
		var t = this.targetStack;
		if(t == null) {
			this.needFlushTarget = this.currentTargetTex != null;
		} else {
			this.needFlushTarget = this.currentTargetTex != t.t || this.currentTargetLayer != t.layer || this.currentTargetMip != t.mipLevel || t.textures != null;
		}
	}
	,pushTargets: function(textures) {
		this.pushTarget(this.nullTexture);
		this.targetStack.textures = textures;
		this.needFlushTarget = true;
	}
	,popTarget: function() {
		var c = this.targetStack;
		if(c == null) {
			throw haxe_Exception.thrown("popTarget() with no matching pushTarget()");
		}
		this.targetStack = c.next;
		this.updateNeedFlush();
		c.t = null;
		c.textures = null;
		c.next = this.targetTmp;
		this.targetTmp = c;
	}
	,doFlushTarget: function() {
		var t = this.targetStack;
		if(t == null) {
			this.driver.setRenderTarget(null);
			this.currentTargetTex = null;
		} else {
			if(t.textures != null) {
				this.driver.setRenderTargets(t.textures);
			} else {
				this.driver.setRenderTarget(t.t,t.layer,t.mipLevel);
			}
			this.currentTargetTex = t.t;
			this.currentTargetLayer = t.layer;
			this.currentTargetMip = t.mipLevel;
		}
		this.needFlushTarget = false;
	}
	,clear: function(color,depth,stencil) {
		if(color != null) {
			var _this = this.tmpVector;
			_this.x = (color >> 16 & 255) / 255;
			_this.y = (color >> 8 & 255) / 255;
			_this.z = (color & 255) / 255;
			_this.w = (color >>> 24) / 255;
		}
		if(this.needFlushTarget) {
			this.doFlushTarget();
		}
		this.driver.clear(color == null ? null : this.tmpVector,depth,stencil);
	}
	,setRenderZone: function(x,y,width,height) {
		if(height == null) {
			height = -1;
		}
		if(width == null) {
			width = -1;
		}
		if(y == null) {
			y = 0;
		}
		if(x == null) {
			x = 0;
		}
		if(this.needFlushTarget) {
			this.doFlushTarget();
		}
		this.driver.setRenderZone(x,y,width,height);
	}
	,render: function(obj) {
		if(!this.begin()) {
			return false;
		}
		obj.render(this);
		this.end();
		var delta = HxOverrides.now() / 1000 - this.lastTime;
		this.lastTime += delta;
		if(delta > 0) {
			var curFps = 1. / delta;
			if(curFps > this.realFps * 2) {
				curFps = this.realFps * 2;
			} else if(curFps < this.realFps * 0.5) {
				curFps = this.realFps * 0.5;
			}
			var f = delta / .5;
			if(f > 0.3) {
				f = 0.3;
			}
			this.realFps = this.realFps * (1 - f) + curFps * f;
		}
		return true;
	}
	,__class__: h3d_Engine
};
var h3d_Indexes = function(count,is32) {
	if(is32 == null) {
		is32 = false;
	}
	this.mem = h3d_Engine.CURRENT.mem;
	this.count = count;
	this.is32 = is32;
	this.mem.allocIndexes(this);
};
$hxClasses["h3d.Indexes"] = h3d_Indexes;
h3d_Indexes.__name__ = "h3d.Indexes";
h3d_Indexes.alloc = function(i,startPos,length) {
	if(length == null) {
		length = -1;
	}
	if(startPos == null) {
		startPos = 0;
	}
	if(length < 0) {
		length = i.length;
	}
	var idx = new h3d_Indexes(length);
	idx.upload(i,0,length);
	return idx;
};
h3d_Indexes.prototype = {
	isDisposed: function() {
		return this.ibuf == null;
	}
	,upload: function(indexes,pos,count,bufferPos) {
		if(bufferPos == null) {
			bufferPos = 0;
		}
		this.mem.driver.uploadIndexBuffer(this.ibuf,pos,count,indexes,bufferPos);
	}
	,dispose: function() {
		if(this.ibuf != null) {
			this.mem.deleteIndexes(this);
		}
	}
	,__class__: h3d_Indexes
};
var h3d_Matrix = function() {
};
$hxClasses["h3d.Matrix"] = h3d_Matrix;
h3d_Matrix.__name__ = "h3d.Matrix";
h3d_Matrix.I = function() {
	var m = new h3d_Matrix();
	m.identity();
	return m;
};
h3d_Matrix.L = function(a) {
	var m = new h3d_Matrix();
	m.loadValues(a);
	return m;
};
h3d_Matrix.prototype = {
	zero: function() {
		this._11 = 0.0;
		this._12 = 0.0;
		this._13 = 0.0;
		this._14 = 0.0;
		this._21 = 0.0;
		this._22 = 0.0;
		this._23 = 0.0;
		this._24 = 0.0;
		this._31 = 0.0;
		this._32 = 0.0;
		this._33 = 0.0;
		this._34 = 0.0;
		this._41 = 0.0;
		this._42 = 0.0;
		this._43 = 0.0;
		this._44 = 0.0;
	}
	,identity: function() {
		this._11 = 1.0;
		this._12 = 0.0;
		this._13 = 0.0;
		this._14 = 0.0;
		this._21 = 0.0;
		this._22 = 1.0;
		this._23 = 0.0;
		this._24 = 0.0;
		this._31 = 0.0;
		this._32 = 0.0;
		this._33 = 1.0;
		this._34 = 0.0;
		this._41 = 0.0;
		this._42 = 0.0;
		this._43 = 0.0;
		this._44 = 1.0;
	}
	,multiply3x4: function(a,b) {
		var m11 = a._11;
		var m12 = a._12;
		var m13 = a._13;
		var m21 = a._21;
		var m22 = a._22;
		var m23 = a._23;
		var a31 = a._31;
		var a32 = a._32;
		var a33 = a._33;
		var a41 = a._41;
		var a42 = a._42;
		var a43 = a._43;
		var b11 = b._11;
		var b12 = b._12;
		var b13 = b._13;
		var b21 = b._21;
		var b22 = b._22;
		var b23 = b._23;
		var b31 = b._31;
		var b32 = b._32;
		var b33 = b._33;
		var b41 = b._41;
		var b42 = b._42;
		var b43 = b._43;
		this._11 = m11 * b11 + m12 * b21 + m13 * b31;
		this._12 = m11 * b12 + m12 * b22 + m13 * b32;
		this._13 = m11 * b13 + m12 * b23 + m13 * b33;
		this._14 = 0;
		this._21 = m21 * b11 + m22 * b21 + m23 * b31;
		this._22 = m21 * b12 + m22 * b22 + m23 * b32;
		this._23 = m21 * b13 + m22 * b23 + m23 * b33;
		this._24 = 0;
		this._31 = a31 * b11 + a32 * b21 + a33 * b31;
		this._32 = a31 * b12 + a32 * b22 + a33 * b32;
		this._33 = a31 * b13 + a32 * b23 + a33 * b33;
		this._34 = 0;
		this._41 = a41 * b11 + a42 * b21 + a43 * b31 + b41;
		this._42 = a41 * b12 + a42 * b22 + a43 * b32 + b42;
		this._43 = a41 * b13 + a42 * b23 + a43 * b33 + b43;
		this._44 = 1;
	}
	,multiply: function(a,b) {
		var a11 = a._11;
		var a12 = a._12;
		var a13 = a._13;
		var a14 = a._14;
		var a21 = a._21;
		var a22 = a._22;
		var a23 = a._23;
		var a24 = a._24;
		var a31 = a._31;
		var a32 = a._32;
		var a33 = a._33;
		var a34 = a._34;
		var a41 = a._41;
		var a42 = a._42;
		var a43 = a._43;
		var a44 = a._44;
		var b11 = b._11;
		var b12 = b._12;
		var b13 = b._13;
		var b14 = b._14;
		var b21 = b._21;
		var b22 = b._22;
		var b23 = b._23;
		var b24 = b._24;
		var b31 = b._31;
		var b32 = b._32;
		var b33 = b._33;
		var b34 = b._34;
		var b41 = b._41;
		var b42 = b._42;
		var b43 = b._43;
		var b44 = b._44;
		this._11 = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		this._12 = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		this._13 = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		this._14 = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
		this._21 = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		this._22 = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		this._23 = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		this._24 = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
		this._31 = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		this._32 = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		this._33 = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		this._34 = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
		this._41 = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		this._42 = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		this._43 = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		this._44 = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
	}
	,inverse3x4: function(m) {
		var m11 = m._11;
		var m12 = m._12;
		var m13 = m._13;
		var m21 = m._21;
		var m22 = m._22;
		var m23 = m._23;
		var m31 = m._31;
		var m32 = m._32;
		var m33 = m._33;
		var m41 = m._41;
		var m42 = m._42;
		var m43 = m._43;
		this._11 = m22 * m33 - m23 * m32;
		this._12 = m13 * m32 - m12 * m33;
		this._13 = m12 * m23 - m13 * m22;
		this._14 = 0;
		this._21 = m23 * m31 - m21 * m33;
		this._22 = m11 * m33 - m13 * m31;
		this._23 = m13 * m21 - m11 * m23;
		this._24 = 0;
		this._31 = m21 * m32 - m22 * m31;
		this._32 = m12 * m31 - m11 * m32;
		this._33 = m11 * m22 - m12 * m21;
		this._34 = 0;
		this._41 = -m21 * m32 * m43 + m21 * m33 * m42 + m31 * m22 * m43 - m31 * m23 * m42 - m41 * m22 * m33 + m41 * m23 * m32;
		this._42 = m11 * m32 * m43 - m11 * m33 * m42 - m31 * m12 * m43 + m31 * m13 * m42 + m41 * m12 * m33 - m41 * m13 * m32;
		this._43 = -m11 * m22 * m43 + m11 * m23 * m42 + m21 * m12 * m43 - m21 * m13 * m42 - m41 * m12 * m23 + m41 * m13 * m22;
		this._44 = m11 * m22 * m33 - m11 * m23 * m32 - m21 * m12 * m33 + m21 * m13 * m32 + m31 * m12 * m23 - m31 * m13 * m22;
		this._44 = 1;
		var det = m11 * this._11 + m12 * this._21 + m13 * this._31;
		if((det < 0 ? -det : det) < 1e-10) {
			this.zero();
			return;
		}
		var invDet = 1.0 / det;
		this._11 *= invDet;
		this._12 *= invDet;
		this._13 *= invDet;
		this._21 *= invDet;
		this._22 *= invDet;
		this._23 *= invDet;
		this._31 *= invDet;
		this._32 *= invDet;
		this._33 *= invDet;
		this._41 *= invDet;
		this._42 *= invDet;
		this._43 *= invDet;
	}
	,initInverse: function(m) {
		var m11 = m._11;
		var m12 = m._12;
		var m13 = m._13;
		var m14 = m._14;
		var m21 = m._21;
		var m22 = m._22;
		var m23 = m._23;
		var m24 = m._24;
		var m31 = m._31;
		var m32 = m._32;
		var m33 = m._33;
		var m34 = m._34;
		var m41 = m._41;
		var m42 = m._42;
		var m43 = m._43;
		var m44 = m._44;
		this._11 = m22 * m33 * m44 - m22 * m34 * m43 - m32 * m23 * m44 + m32 * m24 * m43 + m42 * m23 * m34 - m42 * m24 * m33;
		this._12 = -m12 * m33 * m44 + m12 * m34 * m43 + m32 * m13 * m44 - m32 * m14 * m43 - m42 * m13 * m34 + m42 * m14 * m33;
		this._13 = m12 * m23 * m44 - m12 * m24 * m43 - m22 * m13 * m44 + m22 * m14 * m43 + m42 * m13 * m24 - m42 * m14 * m23;
		this._14 = -m12 * m23 * m34 + m12 * m24 * m33 + m22 * m13 * m34 - m22 * m14 * m33 - m32 * m13 * m24 + m32 * m14 * m23;
		this._21 = -m21 * m33 * m44 + m21 * m34 * m43 + m31 * m23 * m44 - m31 * m24 * m43 - m41 * m23 * m34 + m41 * m24 * m33;
		this._22 = m11 * m33 * m44 - m11 * m34 * m43 - m31 * m13 * m44 + m31 * m14 * m43 + m41 * m13 * m34 - m41 * m14 * m33;
		this._23 = -m11 * m23 * m44 + m11 * m24 * m43 + m21 * m13 * m44 - m21 * m14 * m43 - m41 * m13 * m24 + m41 * m14 * m23;
		this._24 = m11 * m23 * m34 - m11 * m24 * m33 - m21 * m13 * m34 + m21 * m14 * m33 + m31 * m13 * m24 - m31 * m14 * m23;
		this._31 = m21 * m32 * m44 - m21 * m34 * m42 - m31 * m22 * m44 + m31 * m24 * m42 + m41 * m22 * m34 - m41 * m24 * m32;
		this._32 = -m11 * m32 * m44 + m11 * m34 * m42 + m31 * m12 * m44 - m31 * m14 * m42 - m41 * m12 * m34 + m41 * m14 * m32;
		this._33 = m11 * m22 * m44 - m11 * m24 * m42 - m21 * m12 * m44 + m21 * m14 * m42 + m41 * m12 * m24 - m41 * m14 * m22;
		this._34 = -m11 * m22 * m34 + m11 * m24 * m32 + m21 * m12 * m34 - m21 * m14 * m32 - m31 * m12 * m24 + m31 * m14 * m22;
		this._41 = -m21 * m32 * m43 + m21 * m33 * m42 + m31 * m22 * m43 - m31 * m23 * m42 - m41 * m22 * m33 + m41 * m23 * m32;
		this._42 = m11 * m32 * m43 - m11 * m33 * m42 - m31 * m12 * m43 + m31 * m13 * m42 + m41 * m12 * m33 - m41 * m13 * m32;
		this._43 = -m11 * m22 * m43 + m11 * m23 * m42 + m21 * m12 * m43 - m21 * m13 * m42 - m41 * m12 * m23 + m41 * m13 * m22;
		this._44 = m11 * m22 * m33 - m11 * m23 * m32 - m21 * m12 * m33 + m21 * m13 * m32 + m31 * m12 * m23 - m31 * m13 * m22;
		var det = m11 * this._11 + m12 * this._21 + m13 * this._31 + m14 * this._41;
		if((det < 0 ? -det : det) < 1e-10) {
			this.zero();
			return;
		}
		det = 1.0 / det;
		this._11 *= det;
		this._12 *= det;
		this._13 *= det;
		this._14 *= det;
		this._21 *= det;
		this._22 *= det;
		this._23 *= det;
		this._24 *= det;
		this._31 *= det;
		this._32 *= det;
		this._33 *= det;
		this._34 *= det;
		this._41 *= det;
		this._42 *= det;
		this._43 *= det;
		this._44 *= det;
	}
	,loadValues: function(a) {
		this._11 = a[0];
		this._12 = a[1];
		this._13 = a[2];
		this._14 = a[3];
		this._21 = a[4];
		this._22 = a[5];
		this._23 = a[6];
		this._24 = a[7];
		this._31 = a[8];
		this._32 = a[9];
		this._33 = a[10];
		this._34 = a[11];
		this._41 = a[12];
		this._42 = a[13];
		this._43 = a[14];
		this._44 = a[15];
	}
	,__class__: h3d_Matrix
};
var h3d_Quat = function(x,y,z,w) {
	if(w == null) {
		w = 1.;
	}
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.x = x;
	this.y = y;
	this.z = z;
	this.w = w;
};
$hxClasses["h3d.Quat"] = h3d_Quat;
h3d_Quat.__name__ = "h3d.Quat";
h3d_Quat.prototype = {
	toMatrix: function(m) {
		if(m == null) {
			m = new h3d_Matrix();
		}
		var xx = this.x * this.x;
		var xy = this.x * this.y;
		var xz = this.x * this.z;
		var xw = this.x * this.w;
		var yy = this.y * this.y;
		var yz = this.y * this.z;
		var yw = this.y * this.w;
		var zz = this.z * this.z;
		var zw = this.z * this.w;
		m._11 = 1 - 2 * (yy + zz);
		m._12 = 2 * (xy + zw);
		m._13 = 2 * (xz - yw);
		m._14 = 0;
		m._21 = 2 * (xy - zw);
		m._22 = 1 - 2 * (xx + zz);
		m._23 = 2 * (yz + xw);
		m._24 = 0;
		m._31 = 2 * (xz + yw);
		m._32 = 2 * (yz - xw);
		m._33 = 1 - 2 * (xx + yy);
		m._34 = 0;
		m._41 = 0;
		m._42 = 0;
		m._43 = 0;
		m._44 = 1;
		return m;
	}
	,__class__: h3d_Quat
};
var h3d_Vector = function(x,y,z,w) {
	if(w == null) {
		w = 1.;
	}
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.x = x;
	this.y = y;
	this.z = z;
	this.w = w;
};
$hxClasses["h3d.Vector"] = h3d_Vector;
h3d_Vector.__name__ = "h3d.Vector";
h3d_Vector.prototype = {
	__class__: h3d_Vector
};
var h3d_anim_AnimatedObject = function() { };
$hxClasses["h3d.anim.AnimatedObject"] = h3d_anim_AnimatedObject;
h3d_anim_AnimatedObject.__name__ = "h3d.anim.AnimatedObject";
var h3d_anim_Animation = function(name,frameCount,sampling) {
	this.name = name;
	this.frameCount = frameCount;
	this.sampling = sampling;
	this.objects = [];
	this.lastEvent = -1;
	this.frame = 0.;
	this.speed = 1.;
	this.loop = true;
	this.pause = false;
};
$hxClasses["h3d.anim.Animation"] = h3d_anim_Animation;
h3d_anim_Animation.__name__ = "h3d.anim.Animation";
h3d_anim_Animation.prototype = {
	getPropValue: function(objectName,propName) {
		return null;
	}
	,sync: function(decompose) {
		if(decompose == null) {
			decompose = false;
		}
		throw haxe_Exception.thrown("assert");
	}
	,isPlaying: function() {
		if(!this.pause) {
			return (this.speed < 0 ? -this.speed : this.speed) > 0.000001;
		} else {
			return false;
		}
	}
	,endFrame: function() {
		return this.frameCount;
	}
	,update: function(dt) {
		if(!this.isInstance) {
			throw haxe_Exception.thrown("You must instanciate this animation first");
		}
		if(!this.isPlaying()) {
			return 0;
		}
		if(this.events != null && this.onEvent != null) {
			var f0 = this.frame | 0;
			var f1 = this.frame + dt * this.speed * this.sampling | 0;
			if(f1 >= this.frameCount) {
				f1 = this.frameCount - 1;
			}
			var _g = f0;
			var _g1 = f1 + 1;
			while(_g < _g1) {
				var f = _g++;
				if(f == this.lastEvent) {
					continue;
				}
				this.lastEvent = f;
				if(this.events[f] != null) {
					var oldF = this.frame;
					var oldDT = dt;
					dt -= (f - this.frame) / (this.speed * this.sampling);
					this.frame = f;
					var _g2 = 0;
					var _g3 = this.events[f];
					while(_g2 < _g3.length) {
						var e = _g3[_g2];
						++_g2;
						this.onEvent(e);
					}
					if(this.frame == f && f == this.frameCount - 1) {
						this.frame = oldF;
						dt = oldDT;
						break;
					} else {
						return dt;
					}
				}
			}
		}
		if(this.onAnimEnd != null) {
			var end = this.endFrame();
			var et = this.speed == 0 ? 0 : (end - this.frame) / (this.speed * this.sampling);
			if(et <= dt && et > 0) {
				this.frame = end;
				dt -= et;
				this.onAnimEnd();
				if(this.frame == end && this.isPlaying()) {
					if(this.loop) {
						this.frame = 0;
					} else {
						dt = 0;
					}
				}
				return dt;
			}
		}
		this.frame += dt * this.speed * this.sampling;
		if(this.frame >= this.frameCount) {
			if(this.loop) {
				this.frame %= this.frameCount;
			} else {
				this.frame = this.frameCount;
			}
		}
		return 0;
	}
	,__class__: h3d_anim_Animation
};
var h3d_col_Collider = function() { };
$hxClasses["h3d.col.Collider"] = h3d_col_Collider;
h3d_col_Collider.__name__ = "h3d.col.Collider";
h3d_col_Collider.__isInterface__ = true;
h3d_col_Collider.prototype = {
	__class__: h3d_col_Collider
};
var h3d_col_Bounds = function() {
	this.xMin = 1e20;
	this.xMax = -1e20;
	this.yMin = 1e20;
	this.yMax = -1e20;
	this.zMin = 1e20;
	this.zMax = -1e20;
};
$hxClasses["h3d.col.Bounds"] = h3d_col_Bounds;
h3d_col_Bounds.__name__ = "h3d.col.Bounds";
h3d_col_Bounds.__interfaces__ = [h3d_col_Collider];
h3d_col_Bounds.prototype = {
	inFrustum: function(f,m) {
		if(m != null) {
			throw haxe_Exception.thrown("Not implemented");
		}
		return f.hasBounds(this);
	}
	,rayIntersection: function(r,bestMatch) {
		var minTx = (this.xMin - r.px) / r.lx;
		var minTy = (this.yMin - r.py) / r.ly;
		var minTz = (this.zMin - r.pz) / r.lz;
		var maxTx = (this.xMax - r.px) / r.lx;
		var maxTy = (this.yMax - r.py) / r.ly;
		var maxTz = (this.zMax - r.pz) / r.lz;
		var realMinTx = minTx > maxTx ? maxTx : minTx;
		var realMinTy = minTy > maxTy ? maxTy : minTy;
		var realMinTz = minTz > maxTz ? maxTz : minTz;
		var realMaxTx = minTx < maxTx ? maxTx : minTx;
		var realMaxTy = minTy < maxTy ? maxTy : minTy;
		var realMaxTz = minTz < maxTz ? maxTz : minTz;
		var a = realMaxTx > realMaxTy ? realMaxTy : realMaxTx;
		var minmax = a > realMaxTz ? realMaxTz : a;
		var a = realMinTx < realMinTy ? realMinTy : realMinTx;
		var maxmin = a < realMinTz ? realMinTz : a;
		if(minmax < maxmin) {
			return -1;
		}
		return maxmin;
	}
	,transform: function(m) {
		var xMin = this.xMin;
		var yMin = this.yMin;
		var zMin = this.zMin;
		var xMax = this.xMax;
		var yMax = this.yMax;
		var zMax = this.zMax;
		this.xMin = 1e20;
		this.xMax = -1e20;
		this.yMin = 1e20;
		this.yMax = -1e20;
		this.zMin = 1e20;
		this.zMax = -1e20;
		if(xMax < xMin && yMax < yMin && zMax < zMin) {
			return;
		}
		var v_x = 0.;
		var v_y = 0.;
		var v_z = 0.;
		var x = xMin;
		var y = yMin;
		var z = zMin;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		v_x = x;
		v_y = y;
		v_z = z;
		var px = v_x * m._11 + v_y * m._21 + v_z * m._31 + m._41;
		var py = v_x * m._12 + v_y * m._22 + v_z * m._32 + m._42;
		var pz = v_x * m._13 + v_y * m._23 + v_z * m._33 + m._43;
		v_x = px;
		v_y = py;
		v_z = pz;
		if(v_x < this.xMin) {
			this.xMin = v_x;
		}
		if(v_x > this.xMax) {
			this.xMax = v_x;
		}
		if(v_y < this.yMin) {
			this.yMin = v_y;
		}
		if(v_y > this.yMax) {
			this.yMax = v_y;
		}
		if(v_z < this.zMin) {
			this.zMin = v_z;
		}
		if(v_z > this.zMax) {
			this.zMax = v_z;
		}
		var x = xMin;
		var y = yMin;
		var z = zMax;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		v_x = x;
		v_y = y;
		v_z = z;
		var px = v_x * m._11 + v_y * m._21 + v_z * m._31 + m._41;
		var py = v_x * m._12 + v_y * m._22 + v_z * m._32 + m._42;
		var pz = v_x * m._13 + v_y * m._23 + v_z * m._33 + m._43;
		v_x = px;
		v_y = py;
		v_z = pz;
		if(v_x < this.xMin) {
			this.xMin = v_x;
		}
		if(v_x > this.xMax) {
			this.xMax = v_x;
		}
		if(v_y < this.yMin) {
			this.yMin = v_y;
		}
		if(v_y > this.yMax) {
			this.yMax = v_y;
		}
		if(v_z < this.zMin) {
			this.zMin = v_z;
		}
		if(v_z > this.zMax) {
			this.zMax = v_z;
		}
		var x = xMin;
		var y = yMax;
		var z = zMin;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		v_x = x;
		v_y = y;
		v_z = z;
		var px = v_x * m._11 + v_y * m._21 + v_z * m._31 + m._41;
		var py = v_x * m._12 + v_y * m._22 + v_z * m._32 + m._42;
		var pz = v_x * m._13 + v_y * m._23 + v_z * m._33 + m._43;
		v_x = px;
		v_y = py;
		v_z = pz;
		if(v_x < this.xMin) {
			this.xMin = v_x;
		}
		if(v_x > this.xMax) {
			this.xMax = v_x;
		}
		if(v_y < this.yMin) {
			this.yMin = v_y;
		}
		if(v_y > this.yMax) {
			this.yMax = v_y;
		}
		if(v_z < this.zMin) {
			this.zMin = v_z;
		}
		if(v_z > this.zMax) {
			this.zMax = v_z;
		}
		var x = xMin;
		var y = yMax;
		var z = zMax;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		v_x = x;
		v_y = y;
		v_z = z;
		var px = v_x * m._11 + v_y * m._21 + v_z * m._31 + m._41;
		var py = v_x * m._12 + v_y * m._22 + v_z * m._32 + m._42;
		var pz = v_x * m._13 + v_y * m._23 + v_z * m._33 + m._43;
		v_x = px;
		v_y = py;
		v_z = pz;
		if(v_x < this.xMin) {
			this.xMin = v_x;
		}
		if(v_x > this.xMax) {
			this.xMax = v_x;
		}
		if(v_y < this.yMin) {
			this.yMin = v_y;
		}
		if(v_y > this.yMax) {
			this.yMax = v_y;
		}
		if(v_z < this.zMin) {
			this.zMin = v_z;
		}
		if(v_z > this.zMax) {
			this.zMax = v_z;
		}
		var x = xMax;
		var y = yMin;
		var z = zMin;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		v_x = x;
		v_y = y;
		v_z = z;
		var px = v_x * m._11 + v_y * m._21 + v_z * m._31 + m._41;
		var py = v_x * m._12 + v_y * m._22 + v_z * m._32 + m._42;
		var pz = v_x * m._13 + v_y * m._23 + v_z * m._33 + m._43;
		v_x = px;
		v_y = py;
		v_z = pz;
		if(v_x < this.xMin) {
			this.xMin = v_x;
		}
		if(v_x > this.xMax) {
			this.xMax = v_x;
		}
		if(v_y < this.yMin) {
			this.yMin = v_y;
		}
		if(v_y > this.yMax) {
			this.yMax = v_y;
		}
		if(v_z < this.zMin) {
			this.zMin = v_z;
		}
		if(v_z > this.zMax) {
			this.zMax = v_z;
		}
		var x = xMax;
		var y = yMin;
		var z = zMax;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		v_x = x;
		v_y = y;
		v_z = z;
		var px = v_x * m._11 + v_y * m._21 + v_z * m._31 + m._41;
		var py = v_x * m._12 + v_y * m._22 + v_z * m._32 + m._42;
		var pz = v_x * m._13 + v_y * m._23 + v_z * m._33 + m._43;
		v_x = px;
		v_y = py;
		v_z = pz;
		if(v_x < this.xMin) {
			this.xMin = v_x;
		}
		if(v_x > this.xMax) {
			this.xMax = v_x;
		}
		if(v_y < this.yMin) {
			this.yMin = v_y;
		}
		if(v_y > this.yMax) {
			this.yMax = v_y;
		}
		if(v_z < this.zMin) {
			this.zMin = v_z;
		}
		if(v_z > this.zMax) {
			this.zMax = v_z;
		}
		var x = xMax;
		var y = yMax;
		var z = zMin;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		v_x = x;
		v_y = y;
		v_z = z;
		var px = v_x * m._11 + v_y * m._21 + v_z * m._31 + m._41;
		var py = v_x * m._12 + v_y * m._22 + v_z * m._32 + m._42;
		var pz = v_x * m._13 + v_y * m._23 + v_z * m._33 + m._43;
		v_x = px;
		v_y = py;
		v_z = pz;
		if(v_x < this.xMin) {
			this.xMin = v_x;
		}
		if(v_x > this.xMax) {
			this.xMax = v_x;
		}
		if(v_y < this.yMin) {
			this.yMin = v_y;
		}
		if(v_y > this.yMax) {
			this.yMax = v_y;
		}
		if(v_z < this.zMin) {
			this.zMin = v_z;
		}
		if(v_z > this.zMax) {
			this.zMax = v_z;
		}
		var x = xMax;
		var y = yMax;
		var z = zMax;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		v_x = x;
		v_y = y;
		v_z = z;
		var px = v_x * m._11 + v_y * m._21 + v_z * m._31 + m._41;
		var py = v_x * m._12 + v_y * m._22 + v_z * m._32 + m._42;
		var pz = v_x * m._13 + v_y * m._23 + v_z * m._33 + m._43;
		v_x = px;
		v_y = py;
		v_z = pz;
		if(v_x < this.xMin) {
			this.xMin = v_x;
		}
		if(v_x > this.xMax) {
			this.xMax = v_x;
		}
		if(v_y < this.yMin) {
			this.yMin = v_y;
		}
		if(v_y > this.yMax) {
			this.yMax = v_y;
		}
		if(v_z < this.zMin) {
			this.zMin = v_z;
		}
		if(v_z > this.zMax) {
			this.zMax = v_z;
		}
	}
	,intersection: function(a,b) {
		var a1 = a.xMin;
		var b1 = b.xMin;
		var xMin = a1 < b1 ? b1 : a1;
		var a1 = a.yMin;
		var b1 = b.yMin;
		var yMin = a1 < b1 ? b1 : a1;
		var a1 = a.zMin;
		var b1 = b.zMin;
		var zMin = a1 < b1 ? b1 : a1;
		var a1 = a.xMax;
		var b1 = b.xMax;
		var xMax = a1 > b1 ? b1 : a1;
		var a1 = a.yMax;
		var b1 = b.yMax;
		var yMax = a1 > b1 ? b1 : a1;
		var a1 = a.zMax;
		var b1 = b.zMax;
		var zMax = a1 > b1 ? b1 : a1;
		this.xMin = xMin;
		this.xMax = xMax;
		this.yMin = yMin;
		this.yMax = yMax;
		this.zMin = zMin;
		this.zMax = zMax;
	}
	,load: function(b) {
		this.xMin = b.xMin;
		this.xMax = b.xMax;
		this.yMin = b.yMin;
		this.yMax = b.yMax;
		this.zMin = b.zMin;
		this.zMax = b.zMax;
	}
	,scaleCenter: function(v) {
		var dx = (this.xMax - this.xMin) * 0.5 * v;
		var dy = (this.yMax - this.yMin) * 0.5 * v;
		var dz = (this.zMax - this.zMin) * 0.5 * v;
		var mx = (this.xMax + this.xMin) * 0.5;
		var my = (this.yMax + this.yMin) * 0.5;
		var mz = (this.zMax + this.zMin) * 0.5;
		this.xMin = mx - dx;
		this.yMin = my - dy;
		this.zMin = mz - dz;
		this.xMax = mx + dx;
		this.yMax = my + dy;
		this.zMax = mz + dz;
	}
	,__class__: h3d_col_Bounds
};
var h3d_col_Frustum = function(mvp) {
	this.checkNearFar = true;
	this.pleft = new h3d_col_Plane(1,0,0,0.0);
	this.pright = new h3d_col_Plane(1,0,0,0.0);
	this.ptop = new h3d_col_Plane(1,0,0,0.0);
	this.pbottom = new h3d_col_Plane(1,0,0,0.0);
	this.pnear = new h3d_col_Plane(1,0,0,0.0);
	this.pfar = new h3d_col_Plane(1,0,0,0.0);
	if(mvp != null) {
		this.loadMatrix(mvp);
	}
};
$hxClasses["h3d.col.Frustum"] = h3d_col_Frustum;
h3d_col_Frustum.__name__ = "h3d.col.Frustum";
h3d_col_Frustum.prototype = {
	loadMatrix: function(mvp) {
		var _this = this.pleft;
		var p_nx = mvp._14 + mvp._11;
		var p_ny = mvp._24 + mvp._21;
		var p_nz = mvp._34 + mvp._31;
		var p_d = -(mvp._44 + mvp._41);
		_this.nx = p_nx;
		_this.ny = p_ny;
		_this.nz = p_nz;
		_this.d = p_d;
		var _this = this.pright;
		var p_nx = mvp._14 - mvp._11;
		var p_ny = mvp._24 - mvp._21;
		var p_nz = mvp._34 - mvp._31;
		var p_d = mvp._41 - mvp._44;
		_this.nx = p_nx;
		_this.ny = p_ny;
		_this.nz = p_nz;
		_this.d = p_d;
		var _this = this.ptop;
		var p_nx = mvp._14 - mvp._12;
		var p_ny = mvp._24 - mvp._22;
		var p_nz = mvp._34 - mvp._32;
		var p_d = mvp._42 - mvp._44;
		_this.nx = p_nx;
		_this.ny = p_ny;
		_this.nz = p_nz;
		_this.d = p_d;
		var _this = this.pbottom;
		var p_nx = mvp._14 + mvp._12;
		var p_ny = mvp._24 + mvp._22;
		var p_nz = mvp._34 + mvp._32;
		var p_d = -(mvp._44 + mvp._42);
		_this.nx = p_nx;
		_this.ny = p_ny;
		_this.nz = p_nz;
		_this.d = p_d;
		var _this = this.pnear;
		var p_nx = mvp._13;
		var p_ny = mvp._23;
		var p_nz = mvp._33;
		var p_d = -mvp._43;
		_this.nx = p_nx;
		_this.ny = p_ny;
		_this.nz = p_nz;
		_this.d = p_d;
		var _this = this.pfar;
		var p_nx = mvp._14 - mvp._13;
		var p_ny = mvp._24 - mvp._23;
		var p_nz = mvp._34 - mvp._33;
		var p_d = mvp._43 - mvp._44;
		_this.nx = p_nx;
		_this.ny = p_ny;
		_this.nz = p_nz;
		_this.d = p_d;
		var _this = this.pleft;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
		var _this = this.pright;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
		var _this = this.ptop;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
		var _this = this.pbottom;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
		var _this = this.pnear;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
		var _this = this.pfar;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
	}
	,hasSphere: function(s) {
		var x = s.x;
		var y = s.y;
		var z = s.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var p_x = x;
		var p_y = y;
		var p_z = z;
		var _this = this.pleft;
		if(_this.nx * p_x + _this.ny * p_y + _this.nz * p_z - _this.d < -s.r) {
			return false;
		}
		var _this = this.pright;
		if(_this.nx * p_x + _this.ny * p_y + _this.nz * p_z - _this.d < -s.r) {
			return false;
		}
		var _this = this.ptop;
		if(_this.nx * p_x + _this.ny * p_y + _this.nz * p_z - _this.d < -s.r) {
			return false;
		}
		var _this = this.pbottom;
		if(_this.nx * p_x + _this.ny * p_y + _this.nz * p_z - _this.d < -s.r) {
			return false;
		}
		if(this.checkNearFar) {
			var _this = this.pnear;
			if(_this.nx * p_x + _this.ny * p_y + _this.nz * p_z - _this.d < -s.r) {
				return false;
			}
			var _this = this.pfar;
			if(_this.nx * p_x + _this.ny * p_y + _this.nz * p_z - _this.d < -s.r) {
				return false;
			}
		}
		return true;
	}
	,hasBounds: function(b) {
		var p = this.pleft;
		var a = p.nx;
		var b1 = p.ny;
		var c = p.nz;
		var dd = a * (b.xMax + b.xMin) + b1 * (b.yMax + b.yMin) + c * (b.zMax + b.zMin);
		if(a < 0) {
			a = -a;
		}
		if(b1 < 0) {
			b1 = -b1;
		}
		if(c < 0) {
			c = -c;
		}
		var rr = a * (b.xMax - b.xMin) + b1 * (b.yMax - b.yMin) + c * (b.zMax - b.zMin);
		if(dd + rr - p.d * 2 < 0) {
			return false;
		}
		var p = this.pright;
		var a = p.nx;
		var b1 = p.ny;
		var c = p.nz;
		var dd = a * (b.xMax + b.xMin) + b1 * (b.yMax + b.yMin) + c * (b.zMax + b.zMin);
		if(a < 0) {
			a = -a;
		}
		if(b1 < 0) {
			b1 = -b1;
		}
		if(c < 0) {
			c = -c;
		}
		var rr = a * (b.xMax - b.xMin) + b1 * (b.yMax - b.yMin) + c * (b.zMax - b.zMin);
		if(dd + rr - p.d * 2 < 0) {
			return false;
		}
		var p = this.ptop;
		var a = p.nx;
		var b1 = p.ny;
		var c = p.nz;
		var dd = a * (b.xMax + b.xMin) + b1 * (b.yMax + b.yMin) + c * (b.zMax + b.zMin);
		if(a < 0) {
			a = -a;
		}
		if(b1 < 0) {
			b1 = -b1;
		}
		if(c < 0) {
			c = -c;
		}
		var rr = a * (b.xMax - b.xMin) + b1 * (b.yMax - b.yMin) + c * (b.zMax - b.zMin);
		if(dd + rr - p.d * 2 < 0) {
			return false;
		}
		var p = this.ptop;
		var a = p.nx;
		var b1 = p.ny;
		var c = p.nz;
		var dd = a * (b.xMax + b.xMin) + b1 * (b.yMax + b.yMin) + c * (b.zMax + b.zMin);
		if(a < 0) {
			a = -a;
		}
		if(b1 < 0) {
			b1 = -b1;
		}
		if(c < 0) {
			c = -c;
		}
		var rr = a * (b.xMax - b.xMin) + b1 * (b.yMax - b.yMin) + c * (b.zMax - b.zMin);
		if(dd + rr - p.d * 2 < 0) {
			return false;
		}
		var p = this.pnear;
		var a = p.nx;
		var b1 = p.ny;
		var c = p.nz;
		var dd = a * (b.xMax + b.xMin) + b1 * (b.yMax + b.yMin) + c * (b.zMax + b.zMin);
		if(a < 0) {
			a = -a;
		}
		if(b1 < 0) {
			b1 = -b1;
		}
		if(c < 0) {
			c = -c;
		}
		var rr = a * (b.xMax - b.xMin) + b1 * (b.yMax - b.yMin) + c * (b.zMax - b.zMin);
		if(dd + rr - p.d * 2 < 0) {
			return false;
		}
		var p = this.pfar;
		var a = p.nx;
		var b1 = p.ny;
		var c = p.nz;
		var dd = a * (b.xMax + b.xMin) + b1 * (b.yMax + b.yMin) + c * (b.zMax + b.zMin);
		if(a < 0) {
			a = -a;
		}
		if(b1 < 0) {
			b1 = -b1;
		}
		if(c < 0) {
			c = -c;
		}
		var rr = a * (b.xMax - b.xMin) + b1 * (b.yMax - b.yMin) + c * (b.zMax - b.zMin);
		if(dd + rr - p.d * 2 < 0) {
			return false;
		}
		return true;
	}
	,__class__: h3d_col_Frustum
};
var h3d_col_Ray = function() {
};
$hxClasses["h3d.col.Ray"] = h3d_col_Ray;
h3d_col_Ray.__name__ = "h3d.col.Ray";
h3d_col_Ray.prototype = {
	normalize: function() {
		var l = this.lx * this.lx + this.ly * this.ly + this.lz * this.lz;
		if(l == 1.) {
			return;
		}
		if(l < 1e-10) {
			l = 0;
		} else {
			l = 1. / Math.sqrt(l);
		}
		this.lx *= l;
		this.ly *= l;
		this.lz *= l;
	}
	,__class__: h3d_col_Ray
};
var h3d_col_Plane = function(nx,ny,nz,d) {
	this.nx = nx;
	this.ny = ny;
	this.nz = nz;
	this.d = d;
};
$hxClasses["h3d.col.Plane"] = h3d_col_Plane;
h3d_col_Plane.__name__ = "h3d.col.Plane";
h3d_col_Plane.prototype = {
	__class__: h3d_col_Plane
};
var h3d_col_Point = function(x,y,z) {
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.x = x;
	this.y = y;
	this.z = z;
};
$hxClasses["h3d.col.Point"] = h3d_col_Point;
h3d_col_Point.__name__ = "h3d.col.Point";
h3d_col_Point.prototype = {
	__class__: h3d_col_Point
};
var h3d_scene_Object = function(parent) {
	var this1 = 0;
	this.flags = this1;
	this.absPos = new h3d_Matrix();
	this.absPos.identity();
	this.x = 0;
	var f = 1;
	var b = true;
	if(b) {
		this.flags |= f;
	} else {
		this.flags &= ~f;
	}
	this.y = 0;
	var f = 1;
	var b = true;
	if(b) {
		this.flags |= f;
	} else {
		this.flags &= ~f;
	}
	this.z = 0;
	var f = 1;
	var b = true;
	if(b) {
		this.flags |= f;
	} else {
		this.flags &= ~f;
	}
	this.scaleX = 1;
	var f = 1;
	var b = true;
	if(b) {
		this.flags |= f;
	} else {
		this.flags &= ~f;
	}
	this.scaleY = 1;
	var f = 1;
	var b = true;
	if(b) {
		this.flags |= f;
	} else {
		this.flags &= ~f;
	}
	this.scaleZ = 1;
	var f = 1;
	var b = true;
	if(b) {
		this.flags |= f;
	} else {
		this.flags &= ~f;
	}
	this.qRot = new h3d_Quat();
	var f = 1;
	var b = this.follow != null;
	if(b) {
		this.flags |= f;
	} else {
		this.flags &= ~f;
	}
	var f = 2;
	this.flags |= f;
	this.children = [];
	if(parent != null) {
		parent.addChild(this);
	}
};
$hxClasses["h3d.scene.Object"] = h3d_scene_Object;
h3d_scene_Object.__name__ = "h3d.scene.Object";
h3d_scene_Object.prototype = {
	set_cullingCollider: function(c) {
		this.cullingCollider = c;
		var f = 4096;
		this.flags &= ~f;
		return c;
	}
	,localToGlobal: function(pt) {
		this.syncPos();
		if(pt == null) {
			pt = new h3d_col_Point();
		}
		var m = this.absPos;
		var px = pt.x * m._11 + pt.y * m._21 + pt.z * m._31 + m._41;
		var py = pt.x * m._12 + pt.y * m._22 + pt.z * m._32 + m._42;
		var pz = pt.x * m._13 + pt.y * m._23 + pt.z * m._33 + m._43;
		pt.x = px;
		pt.y = py;
		pt.z = pz;
		return pt;
	}
	,getInvPos: function() {
		this.syncPos();
		if(this.invPos == null) {
			this.invPos = new h3d_Matrix();
			this.invPos._44 = 0;
		}
		if(this.invPos._44 == 0) {
			this.invPos.inverse3x4(this.absPos);
		}
		return this.invPos;
	}
	,addChild: function(o) {
		this.addChildAt(o,this.children.length);
	}
	,addChildAt: function(o,pos) {
		if(pos < 0) {
			pos = 0;
		}
		if(pos > this.children.length) {
			pos = this.children.length;
		}
		var p = this;
		while(p != null) {
			if(p == o) {
				throw haxe_Exception.thrown("Recursive addChild");
			}
			p = p.parent;
		}
		if(o.parent != null) {
			var old = (o.flags & 32) != 0;
			var f = 32;
			o.flags &= ~f;
			o.parent.removeChild(o);
			var f = 32;
			if(old) {
				o.flags |= f;
			} else {
				o.flags &= ~f;
			}
		}
		this.children.splice(pos,0,o);
		if((this.flags & 32) == 0 && (o.flags & 32) != 0) {
			o.onRemove();
		}
		o.parent = this;
		var f = 1;
		var b = true;
		if(b) {
			o.flags |= f;
		} else {
			o.flags &= ~f;
		}
		if((this.flags & 32) != 0) {
			if((o.flags & 32) == 0) {
				o.onAdd();
			} else {
				o.onParentChanged();
			}
		}
	}
	,iterVisibleMeshes: function(callb) {
		if((this.flags & 2) == 0 || (this.flags & 4) != 0 && (this.flags & 128) != 0) {
			return;
		}
		if((this.flags & 4) == 0) {
			var m = ((this) instanceof h3d_scene_Mesh) ? this : null;
			if(m != null) {
				callb(m);
			}
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var o = _g1[_g];
			++_g;
			o.iterVisibleMeshes(callb);
		}
	}
	,onParentChanged: function() {
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			c.onParentChanged();
		}
	}
	,onAdd: function() {
		var f = 32;
		this.flags |= f;
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			c.onAdd();
		}
	}
	,onRemove: function() {
		var f = 32;
		this.flags &= ~f;
		var i = this.children.length - 1;
		while(i >= 0) this.children[i--].onRemove();
	}
	,removeChild: function(o) {
		if(HxOverrides.remove(this.children,o)) {
			if((o.flags & 32) != 0) {
				o.onRemove();
			}
			o.parent = null;
			var f = 1;
			var b = true;
			if(b) {
				o.flags |= f;
			} else {
				o.flags &= ~f;
			}
		}
	}
	,getScene: function() {
		var p = this;
		while(p.parent != null) p = p.parent;
		if(((p) instanceof h3d_scene_Scene)) {
			return p;
		} else {
			return null;
		}
	}
	,getAbsPos: function() {
		this.syncPos();
		return this.absPos;
	}
	,draw: function(ctx) {
	}
	,calcAbsPos: function() {
		this.qRot.toMatrix(this.absPos);
		this.absPos._11 *= this.scaleX;
		this.absPos._12 *= this.scaleX;
		this.absPos._13 *= this.scaleX;
		this.absPos._21 *= this.scaleY;
		this.absPos._22 *= this.scaleY;
		this.absPos._23 *= this.scaleY;
		this.absPos._31 *= this.scaleZ;
		this.absPos._32 *= this.scaleZ;
		this.absPos._33 *= this.scaleZ;
		this.absPos._41 = this.x;
		this.absPos._42 = this.y;
		this.absPos._43 = this.z;
		if(this.follow != null) {
			this.follow.syncPos();
			if((this.flags & 8) != 0) {
				var _this = this.absPos;
				var a = this.absPos;
				var b = this.parent.absPos;
				var m11 = a._11;
				var m12 = a._12;
				var m13 = a._13;
				var m21 = a._21;
				var m22 = a._22;
				var m23 = a._23;
				var a31 = a._31;
				var a32 = a._32;
				var a33 = a._33;
				var a41 = a._41;
				var a42 = a._42;
				var a43 = a._43;
				var b11 = b._11;
				var b12 = b._12;
				var b13 = b._13;
				var b21 = b._21;
				var b22 = b._22;
				var b23 = b._23;
				var b31 = b._31;
				var b32 = b._32;
				var b33 = b._33;
				var b41 = b._41;
				var b42 = b._42;
				var b43 = b._43;
				_this._11 = m11 * b11 + m12 * b21 + m13 * b31;
				_this._12 = m11 * b12 + m12 * b22 + m13 * b32;
				_this._13 = m11 * b13 + m12 * b23 + m13 * b33;
				_this._14 = 0;
				_this._21 = m21 * b11 + m22 * b21 + m23 * b31;
				_this._22 = m21 * b12 + m22 * b22 + m23 * b32;
				_this._23 = m21 * b13 + m22 * b23 + m23 * b33;
				_this._24 = 0;
				_this._31 = a31 * b11 + a32 * b21 + a33 * b31;
				_this._32 = a31 * b12 + a32 * b22 + a33 * b32;
				_this._33 = a31 * b13 + a32 * b23 + a33 * b33;
				_this._34 = 0;
				_this._41 = a41 * b11 + a42 * b21 + a43 * b31 + b41;
				_this._42 = a41 * b12 + a42 * b22 + a43 * b32 + b42;
				_this._43 = a41 * b13 + a42 * b23 + a43 * b33 + b43;
				_this._44 = 1;
				this.absPos._41 = this.x + this.follow.absPos._41;
				this.absPos._42 = this.y + this.follow.absPos._42;
				this.absPos._43 = this.z + this.follow.absPos._43;
			} else {
				this.absPos.multiply3x4(this.absPos,this.follow.absPos);
			}
		} else if(this.parent != null && (this.flags & 2048) == 0) {
			var _this = this.absPos;
			var a = this.absPos;
			var b = this.parent.absPos;
			var m11 = a._11;
			var m12 = a._12;
			var m13 = a._13;
			var m21 = a._21;
			var m22 = a._22;
			var m23 = a._23;
			var a31 = a._31;
			var a32 = a._32;
			var a33 = a._33;
			var a41 = a._41;
			var a42 = a._42;
			var a43 = a._43;
			var b11 = b._11;
			var b12 = b._12;
			var b13 = b._13;
			var b21 = b._21;
			var b22 = b._22;
			var b23 = b._23;
			var b31 = b._31;
			var b32 = b._32;
			var b33 = b._33;
			var b41 = b._41;
			var b42 = b._42;
			var b43 = b._43;
			_this._11 = m11 * b11 + m12 * b21 + m13 * b31;
			_this._12 = m11 * b12 + m12 * b22 + m13 * b32;
			_this._13 = m11 * b13 + m12 * b23 + m13 * b33;
			_this._14 = 0;
			_this._21 = m21 * b11 + m22 * b21 + m23 * b31;
			_this._22 = m21 * b12 + m22 * b22 + m23 * b32;
			_this._23 = m21 * b13 + m22 * b23 + m23 * b33;
			_this._24 = 0;
			_this._31 = a31 * b11 + a32 * b21 + a33 * b31;
			_this._32 = a31 * b12 + a32 * b22 + a33 * b32;
			_this._33 = a31 * b13 + a32 * b23 + a33 * b33;
			_this._34 = 0;
			_this._41 = a41 * b11 + a42 * b21 + a43 * b31 + b41;
			_this._42 = a41 * b12 + a42 * b22 + a43 * b32 + b42;
			_this._43 = a41 * b13 + a42 * b23 + a43 * b33 + b43;
			_this._44 = 1;
		}
		if(this.defaultTransform != null) {
			var _this = this.absPos;
			var a = this.defaultTransform;
			var b = this.absPos;
			var m11 = a._11;
			var m12 = a._12;
			var m13 = a._13;
			var m21 = a._21;
			var m22 = a._22;
			var m23 = a._23;
			var a31 = a._31;
			var a32 = a._32;
			var a33 = a._33;
			var a41 = a._41;
			var a42 = a._42;
			var a43 = a._43;
			var b11 = b._11;
			var b12 = b._12;
			var b13 = b._13;
			var b21 = b._21;
			var b22 = b._22;
			var b23 = b._23;
			var b31 = b._31;
			var b32 = b._32;
			var b33 = b._33;
			var b41 = b._41;
			var b42 = b._42;
			var b43 = b._43;
			_this._11 = m11 * b11 + m12 * b21 + m13 * b31;
			_this._12 = m11 * b12 + m12 * b22 + m13 * b32;
			_this._13 = m11 * b13 + m12 * b23 + m13 * b33;
			_this._14 = 0;
			_this._21 = m21 * b11 + m22 * b21 + m23 * b31;
			_this._22 = m21 * b12 + m22 * b22 + m23 * b32;
			_this._23 = m21 * b13 + m22 * b23 + m23 * b33;
			_this._24 = 0;
			_this._31 = a31 * b11 + a32 * b21 + a33 * b31;
			_this._32 = a31 * b12 + a32 * b22 + a33 * b32;
			_this._33 = a31 * b13 + a32 * b23 + a33 * b33;
			_this._34 = 0;
			_this._41 = a41 * b11 + a42 * b21 + a43 * b31 + b41;
			_this._42 = a41 * b12 + a42 * b22 + a43 * b32 + b42;
			_this._43 = a41 * b13 + a42 * b23 + a43 * b33 + b43;
			_this._44 = 1;
		}
		if(this.invPos != null) {
			this.invPos._44 = 0;
		}
	}
	,sync: function(ctx) {
	}
	,syncRec: function(ctx) {
		if(this.currentAnimation != null) {
			var old = this.parent;
			var dt = ctx.elapsedTime;
			while(dt > 0 && this.currentAnimation != null) dt = this.currentAnimation.update(dt);
			if(this.currentAnimation != null && (ctx.visibleFlag && (this.flags & 2) != 0 && (this.flags & 4) == 0 || (this.flags & 64) != 0)) {
				this.currentAnimation.sync();
			}
			if(this.parent == null && old != null) {
				return;
			}
		}
		var old = ctx.visibleFlag;
		if((this.flags & 2) == 0 || (this.flags & 4) != 0 && (this.flags & 128) != 0) {
			ctx.visibleFlag = false;
		}
		if(ctx.cullingCollider != null && (this.cullingCollider == null || (this.flags & 4096) != 0)) {
			this.set_cullingCollider(ctx.cullingCollider);
			var f = 4096;
			this.flags |= f;
		} else if((this.flags & 4096) != 0) {
			this.set_cullingCollider(null);
		}
		var prevCollider = ctx.cullingCollider;
		if((this.flags & 128) != 0) {
			ctx.cullingCollider = this.cullingCollider;
		}
		var changed = (this.flags & 1) != 0;
		if(changed) {
			this.calcAbsPos();
		}
		if((this.flags & 8192) != 0) {
			if((this.flags & 16384) != 0 && !changed && !ctx.wasContextLost) {
				ctx.visibleFlag = old;
				ctx.cullingCollider = prevCollider;
				return;
			}
			var f = 16384;
			this.flags |= f;
		}
		this.sync(ctx);
		var f = 1;
		var b = this.follow != null;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		this.lastFrame = ctx.frame;
		var p = 0;
		var len = this.children.length;
		while(p < len) {
			var c = this.children[p];
			if(c == null) {
				break;
			}
			if(c.lastFrame != ctx.frame) {
				if(changed) {
					var f = 1;
					var b = true;
					if(b) {
						c.flags |= f;
					} else {
						c.flags &= ~f;
					}
				}
				c.syncRec(ctx);
			}
			if(this.children[p] != c) {
				p = 0;
				len = this.children.length;
			} else {
				++p;
			}
		}
		ctx.visibleFlag = old;
		ctx.cullingCollider = prevCollider;
	}
	,syncPos: function() {
		if(this.parent != null) {
			this.parent.syncPos();
		}
		if((this.flags & 1) != 0) {
			var f = 1;
			var b = this.follow != null;
			if(b) {
				this.flags |= f;
			} else {
				this.flags &= ~f;
			}
			this.calcAbsPos();
			var _g = 0;
			var _g1 = this.children;
			while(_g < _g1.length) {
				var c = _g1[_g];
				++_g;
				var f = 1;
				var b = true;
				if(b) {
					c.flags |= f;
				} else {
					c.flags &= ~f;
				}
			}
		}
	}
	,emit: function(ctx) {
	}
	,emitRec: function(ctx) {
		if((this.flags & 2) == 0 || (this.flags & 4) != 0 && (this.flags & 128) != 0 && !ctx.computingStatic) {
			return;
		}
		if((this.flags & 1) != 0) {
			if(this.currentAnimation != null) {
				this.currentAnimation.sync();
			}
			var f = 1;
			var b = this.follow != null;
			if(b) {
				this.flags |= f;
			} else {
				this.flags &= ~f;
			}
			this.calcAbsPos();
			var _g = 0;
			var _g1 = this.children;
			while(_g < _g1.length) {
				var c = _g1[_g];
				++_g;
				var f = 1;
				var b = true;
				if(b) {
					c.flags |= f;
				} else {
					c.flags &= ~f;
				}
			}
		}
		if((this.flags & 4) == 0 || ctx.computingStatic) {
			this.emit(ctx);
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			c.emitRec(ctx);
		}
	}
	,__class__: h3d_scene_Object
};
var h3d_col_Sphere = function(x,y,z,r) {
	if(r == null) {
		r = 0.;
	}
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	var sx = x;
	var sy = y;
	var sz = z;
	var sr = r;
	if(sr == null) {
		sr = 0.;
	}
	if(sz == null) {
		sz = 0.;
	}
	if(sy == null) {
		sy = 0.;
	}
	if(sx == null) {
		sx = 0.;
	}
	this.x = sx;
	this.y = sy;
	this.z = sz;
	this.r = sr;
};
$hxClasses["h3d.col.Sphere"] = h3d_col_Sphere;
h3d_col_Sphere.__name__ = "h3d.col.Sphere";
h3d_col_Sphere.__interfaces__ = [h3d_col_Collider];
h3d_col_Sphere.prototype = {
	rayIntersection: function(r,bestMatch) {
		var r2 = this.r * this.r;
		var px = r.px + r.lx;
		var py = r.py + r.ly;
		var pz = r.pz + r.lz;
		var a = r.lx * r.lx + r.ly * r.ly + r.lz * r.lz;
		var b = 2 * r.lx * (this.x - px) + 2 * r.ly * (this.y - py) + 2 * r.lz * (this.z - pz);
		var c = this.x * this.x + this.y * this.y + this.z * this.z + (px * px + py * py + pz * pz) - 2 * (this.x * px + this.y * py + this.z * pz) - r2;
		var d = b * b - 4 * a * c;
		if(d < 0) {
			return -1;
		}
		d = Math.sqrt(d);
		var t = (-b + d) / (2 * a);
		return 1 - t;
	}
	,inFrustum: function(f,m) {
		if(m != null) {
			return this.inFrustumMatrix(f,m);
		}
		return f.hasSphere(this);
	}
	,inFrustumMatrix: function(f,m) {
		var oldX = this.x;
		var oldY = this.y;
		var oldZ = this.z;
		var oldR = this.r;
		var x = this.x;
		var y = this.y;
		var z = this.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var v_x = x;
		var v_y = y;
		var v_z = z;
		var px = v_x * m._11 + v_y * m._21 + v_z * m._31 + m._41;
		var py = v_x * m._12 + v_y * m._22 + v_z * m._32 + m._42;
		var pz = v_x * m._13 + v_y * m._23 + v_z * m._33 + m._43;
		v_x = px;
		v_y = py;
		v_z = pz;
		this.x = v_x;
		this.y = v_y;
		this.z = v_z;
		var scale_x = 0.;
		var scale_y = 0.;
		var scale_z = 0.;
		var scale_w = 1.;
		scale_x = Math.sqrt(m._11 * m._11 + m._12 * m._12 + m._13 * m._13);
		scale_y = Math.sqrt(m._21 * m._21 + m._22 * m._22 + m._23 * m._23);
		scale_z = Math.sqrt(m._31 * m._31 + m._32 * m._32 + m._33 * m._33);
		if(m._11 * (m._22 * m._33 - m._23 * m._32) + m._12 * (m._23 * m._31 - m._21 * m._33) + m._13 * (m._21 * m._32 - m._22 * m._31) < 0) {
			scale_x *= -1;
			scale_y *= -1;
			scale_z *= -1;
		}
		this.r *= Math.max(Math.max(scale_x,scale_y),scale_z);
		var res = f.hasSphere(this);
		this.x = oldX;
		this.y = oldY;
		this.z = oldZ;
		this.r = oldR;
		return res;
	}
	,__class__: h3d_col_Sphere
};
var h3d_impl_Feature = $hxEnums["h3d.impl.Feature"] = { __ename__:true,__constructs__:null
	,StandardDerivatives: {_hx_name:"StandardDerivatives",_hx_index:0,__enum__:"h3d.impl.Feature",toString:$estr}
	,FloatTextures: {_hx_name:"FloatTextures",_hx_index:1,__enum__:"h3d.impl.Feature",toString:$estr}
	,AllocDepthBuffer: {_hx_name:"AllocDepthBuffer",_hx_index:2,__enum__:"h3d.impl.Feature",toString:$estr}
	,HardwareAccelerated: {_hx_name:"HardwareAccelerated",_hx_index:3,__enum__:"h3d.impl.Feature",toString:$estr}
	,MultipleRenderTargets: {_hx_name:"MultipleRenderTargets",_hx_index:4,__enum__:"h3d.impl.Feature",toString:$estr}
	,Queries: {_hx_name:"Queries",_hx_index:5,__enum__:"h3d.impl.Feature",toString:$estr}
	,SRGBTextures: {_hx_name:"SRGBTextures",_hx_index:6,__enum__:"h3d.impl.Feature",toString:$estr}
	,ShaderModel3: {_hx_name:"ShaderModel3",_hx_index:7,__enum__:"h3d.impl.Feature",toString:$estr}
	,BottomLeftCoords: {_hx_name:"BottomLeftCoords",_hx_index:8,__enum__:"h3d.impl.Feature",toString:$estr}
	,Wireframe: {_hx_name:"Wireframe",_hx_index:9,__enum__:"h3d.impl.Feature",toString:$estr}
	,InstancedRendering: {_hx_name:"InstancedRendering",_hx_index:10,__enum__:"h3d.impl.Feature",toString:$estr}
};
h3d_impl_Feature.__constructs__ = [h3d_impl_Feature.StandardDerivatives,h3d_impl_Feature.FloatTextures,h3d_impl_Feature.AllocDepthBuffer,h3d_impl_Feature.HardwareAccelerated,h3d_impl_Feature.MultipleRenderTargets,h3d_impl_Feature.Queries,h3d_impl_Feature.SRGBTextures,h3d_impl_Feature.ShaderModel3,h3d_impl_Feature.BottomLeftCoords,h3d_impl_Feature.Wireframe,h3d_impl_Feature.InstancedRendering];
h3d_impl_Feature.__empty_constructs__ = [h3d_impl_Feature.StandardDerivatives,h3d_impl_Feature.FloatTextures,h3d_impl_Feature.AllocDepthBuffer,h3d_impl_Feature.HardwareAccelerated,h3d_impl_Feature.MultipleRenderTargets,h3d_impl_Feature.Queries,h3d_impl_Feature.SRGBTextures,h3d_impl_Feature.ShaderModel3,h3d_impl_Feature.BottomLeftCoords,h3d_impl_Feature.Wireframe,h3d_impl_Feature.InstancedRendering];
var h3d_impl_RenderFlag = $hxEnums["h3d.impl.RenderFlag"] = { __ename__:true,__constructs__:null
	,CameraHandness: {_hx_name:"CameraHandness",_hx_index:0,__enum__:"h3d.impl.RenderFlag",toString:$estr}
};
h3d_impl_RenderFlag.__constructs__ = [h3d_impl_RenderFlag.CameraHandness];
h3d_impl_RenderFlag.__empty_constructs__ = [h3d_impl_RenderFlag.CameraHandness];
var h3d_impl_InputNames = function(names) {
	this.id = h3d_impl_InputNames.UID++;
	this.names = names;
};
$hxClasses["h3d.impl.InputNames"] = h3d_impl_InputNames;
h3d_impl_InputNames.__name__ = "h3d.impl.InputNames";
h3d_impl_InputNames.get = function(names) {
	var key = names.join("|");
	var i = h3d_impl_InputNames.CACHE.h[key];
	if(i == null) {
		i = new h3d_impl_InputNames(names.slice());
		h3d_impl_InputNames.CACHE.h[key] = i;
	}
	return i;
};
h3d_impl_InputNames.prototype = {
	__class__: h3d_impl_InputNames
};
var h3d_impl_Driver = function() { };
$hxClasses["h3d.impl.Driver"] = h3d_impl_Driver;
h3d_impl_Driver.__name__ = "h3d.impl.Driver";
h3d_impl_Driver.prototype = {
	hasFeature: function(f) {
		return false;
	}
	,setRenderFlag: function(r,value) {
	}
	,isSupportedFormat: function(fmt) {
		return false;
	}
	,isDisposed: function() {
		return true;
	}
	,begin: function(frame) {
	}
	,generateMipMaps: function(texture) {
		throw haxe_Exception.thrown("Mipmaps auto generation is not supported on this platform");
	}
	,clear: function(color,depth,stencil) {
	}
	,init: function(onCreate,forceSoftware) {
		if(forceSoftware == null) {
			forceSoftware = false;
		}
	}
	,resize: function(width,height) {
	}
	,selectShader: function(shader) {
		return false;
	}
	,selectMaterial: function(pass) {
	}
	,uploadShaderBuffers: function(buffers,which) {
	}
	,getShaderInputNames: function() {
		return null;
	}
	,selectBuffer: function(buffer) {
	}
	,selectMultiBuffers: function(buffers) {
	}
	,draw: function(ibuf,startIndex,ntriangles) {
	}
	,drawInstanced: function(ibuf,commands) {
	}
	,setRenderZone: function(x,y,width,height) {
	}
	,setRenderTarget: function(tex,layer,mipLevel) {
		if(mipLevel == null) {
			mipLevel = 0;
		}
		if(layer == null) {
			layer = 0;
		}
	}
	,setRenderTargets: function(textures) {
	}
	,allocDepthBuffer: function(b) {
		return null;
	}
	,disposeDepthBuffer: function(b) {
	}
	,getDefaultDepthBuffer: function() {
		return null;
	}
	,end: function() {
	}
	,setDebug: function(b) {
	}
	,allocTexture: function(t) {
		return null;
	}
	,allocIndexes: function(count,is32) {
		return null;
	}
	,allocVertexes: function(m) {
		return null;
	}
	,disposeTexture: function(t) {
	}
	,disposeIndexes: function(i) {
	}
	,disposeVertexes: function(v) {
	}
	,uploadIndexBuffer: function(i,startIndice,indiceCount,buf,bufPos) {
	}
	,uploadVertexBuffer: function(v,startVertex,vertexCount,buf,bufPos) {
	}
	,uploadTextureBitmap: function(t,bmp,mipLevel,side) {
	}
	,uploadTexturePixels: function(t,pixels,mipLevel,side) {
	}
	,copyTexture: function(from,to) {
		return false;
	}
	,__class__: h3d_impl_Driver
};
var h3d_impl__$GlDriver_CompiledShader = function(s,vertex,shader) {
	this.s = s;
	this.vertex = vertex;
	this.shader = shader;
};
$hxClasses["h3d.impl._GlDriver.CompiledShader"] = h3d_impl__$GlDriver_CompiledShader;
h3d_impl__$GlDriver_CompiledShader.__name__ = "h3d.impl._GlDriver.CompiledShader";
h3d_impl__$GlDriver_CompiledShader.prototype = {
	__class__: h3d_impl__$GlDriver_CompiledShader
};
var h3d_impl__$GlDriver_CompiledAttribute = function() {
};
$hxClasses["h3d.impl._GlDriver.CompiledAttribute"] = h3d_impl__$GlDriver_CompiledAttribute;
h3d_impl__$GlDriver_CompiledAttribute.__name__ = "h3d.impl._GlDriver.CompiledAttribute";
h3d_impl__$GlDriver_CompiledAttribute.prototype = {
	__class__: h3d_impl__$GlDriver_CompiledAttribute
};
var h3d_impl__$GlDriver_CompiledProgram = function() {
};
$hxClasses["h3d.impl._GlDriver.CompiledProgram"] = h3d_impl__$GlDriver_CompiledProgram;
h3d_impl__$GlDriver_CompiledProgram.__name__ = "h3d.impl._GlDriver.CompiledProgram";
h3d_impl__$GlDriver_CompiledProgram.prototype = {
	__class__: h3d_impl__$GlDriver_CompiledProgram
};
var h3d_impl_GlDriver = function(antiAlias) {
	if(antiAlias == null) {
		antiAlias = 0;
	}
	this.features = new haxe_ds_EnumValueMap();
	this.maxCompressedTexturesSupport = 0;
	this.rightHanded = false;
	this.firstShader = true;
	this.boundTextures = [];
	this.curTargets = [];
	var _g = [];
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	this.currentDivisor = _g;
	this.curColorMask = -1;
	this.lastActiveIndex = 0;
	this.curStEnabled = false;
	this.curStMaskBits = -1;
	this.curStOpBits = -1;
	this.curMatBits = -1;
	this.maxIdxCurAttribs = 0;
	this.curAttribs = [];
	this.canvas = hxd_Window.getInstance().canvas;
	var options = { alpha : false, stencil : true, antialias : antiAlias > 0};
	if(h3d_impl_GlDriver.ALLOW_WEBGL2) {
		this.gl = this.canvas.getContext("webgl2",options);
	}
	if(this.gl == null) {
		this.gl = js_html__$CanvasElement_CanvasUtil.getContextWebGL(this.canvas,options);
	}
	if(this.gl == null) {
		throw haxe_Exception.thrown("Could not acquire GL context");
	}
	if(typeof(WebGLDebugUtils) != "undefined") {
		this.gl = WebGLDebugUtils.makeDebugContext(this.gl);
		this.glDebug = true;
	}
	this.commonFB = this.gl.createFramebuffer();
	this.programs = new haxe_ds_IntMap();
	this.defStencil = new h3d_mat_Stencil();
	this.frame = hxd_Timer.frameCount;
	var v = this.gl.getParameter(7938);
	var reg = new EReg("ES ([0-9]+\\.[0-9]+)","");
	if(reg.match(v)) {
		this.glES = parseFloat(reg.matched(1));
	}
	var reg = new EReg("[0-9]+\\.[0-9]+","");
	var v = this.gl.getParameter(35724);
	if(reg.match(v)) {
		this.glES = parseFloat(reg.matched(0));
		this.shaderVersion = Math.round(parseFloat(reg.matched(0)) * 100);
	}
	this.drawMode = 4;
	this.makeFeatures();
	if(this.hasFeature(h3d_impl_Feature.InstancedRendering) && this.glES < 3) {
		var extension = this.gl.getExtension("ANGLE_instanced_arrays");
		this.gl["vertexAttribDivisor"] = $bind(extension,extension.vertexAttribDivisorANGLE);
		this.gl["drawElementsInstanced"] = $bind(extension,extension.drawElementsInstancedANGLE);
	}
	hxsl_SharedShader.UNROLL_LOOPS = !this.hasFeature(h3d_impl_Feature.ShaderModel3);
	this.gl.pixelStorei(3333,1);
	this.gl.pixelStorei(3317,1);
};
$hxClasses["h3d.impl.GlDriver"] = h3d_impl_GlDriver;
h3d_impl_GlDriver.__name__ = "h3d.impl.GlDriver";
h3d_impl_GlDriver.__super__ = h3d_impl_Driver;
h3d_impl_GlDriver.prototype = $extend(h3d_impl_Driver.prototype,{
	setRenderFlag: function(r,value) {
		this.rightHanded = value > 0;
	}
	,setDebug: function(d) {
		this.debug = d;
	}
	,begin: function(frame) {
		this.frame = frame;
		this.resetStream();
		this.gl.useProgram(null);
		this.curShader = null;
		this.curBuffer = null;
	}
	,getShaderInputNames: function() {
		return this.curShader.inputs;
	}
	,makeCompiler: function() {
		var glout = new hxsl_GlslOut();
		glout.glES = this.glES;
		glout.version = this.shaderVersion;
		glout.intelDriverFix = this.isIntelGpu;
		return glout;
	}
	,getDriverName: function(details) {
		var render = this.gl.getParameter(7937);
		if(details) {
			render += " GLv" + Std.string(this.gl.getParameter(7938));
		} else {
			render = render.split("/").shift();
		}
		render = render.split("WebGL ").join("");
		return "OpenGL " + render;
	}
	,compileShader: function(glout,shader) {
		var type = shader.vertex ? 35633 : 35632;
		var s = this.gl.createShader(type);
		if(shader.code == null) {
			shader.code = glout.run(shader.data);
			shader.data.funs = null;
		}
		this.gl.shaderSource(s,shader.code);
		this.gl.compileShader(s);
		var log = this.gl.getShaderInfoLog(s);
		if(this.gl.getShaderParameter(s,35713) != 1) {
			var log = this.gl.getShaderInfoLog(s);
			var lid = Std.parseInt(HxOverrides.substr(log,9,null));
			var line = lid == null ? null : shader.code.split("\n")[lid - 1];
			if(line == null) {
				line = "";
			} else {
				line = "(" + StringTools.trim(line) + ")";
			}
			var codeLines = shader.code.split("\n");
			var _g = 0;
			var _g1 = codeLines.length;
			while(_g < _g1) {
				var i = _g++;
				codeLines[i] = i + 1 + "\t" + codeLines[i];
			}
			throw haxe_Exception.thrown("An error occurred compiling the shaders: " + log + line + "\n\n" + codeLines.join("\n"));
		}
		return new h3d_impl__$GlDriver_CompiledShader(s,shader.vertex,shader);
	}
	,initShader: function(p,s,shader,rt) {
		var prefix = s.vertex ? "vertex" : "fragment";
		s.globals = this.gl.getUniformLocation(p.p,prefix + "Globals");
		s.params = this.gl.getUniformLocation(p.p,prefix + "Params");
		s.textures = [];
		var index = 0;
		var curT = null;
		var mode = 0;
		var name = "";
		var t = shader.textures;
		while(t != null) {
			var tt = t.type;
			var count = 1;
			switch(tt._hx_index) {
			case 15:
				var _g = tt.size;
				if(_g._hx_index == 0) {
					var n = _g.v;
					var t1 = tt.t;
					tt = t1;
					count = n;
				}
				break;
			case 17:
				var _g1 = tt.size;
				tt = hxsl_Type.TSampler2D;
				break;
			default:
			}
			if(tt != curT) {
				curT = tt;
				switch(tt._hx_index) {
				case 10:
					mode = 3553;
					name = "Textures";
					break;
				case 11:
					mode = 35866;
					name = "TexturesArray";
					break;
				case 12:
					mode = 34067;
					name = "TexturesCube";
					break;
				default:
					throw haxe_Exception.thrown("Unsupported texture type " + Std.string(tt));
				}
				index = 0;
			}
			var _g2 = 0;
			var _g3 = count;
			while(_g2 < _g3) {
				var i = _g2++;
				var loc = this.gl.getUniformLocation(p.p,prefix + name + "[" + index + "]");
				if(loc == null) {
					throw haxe_Exception.thrown("Texture " + rt.spec.instances[t.instance].shader.data.name + "." + t.name + " is missing from generated shader");
				}
				s.textures.push({ u : loc, t : curT, mode : mode});
				++index;
			}
			t = t.next;
		}
		if(shader.bufferCount > 0) {
			var _g = [];
			var _g1 = 0;
			var _g2 = shader.bufferCount;
			while(_g1 < _g2) {
				var i = _g1++;
				_g.push(this.gl.getUniformBlockIndex(p.p,(shader.vertex ? "vertex_" : "") + "uniform_buffer" + i));
			}
			s.buffers = _g;
			var start = 0;
			if(!s.vertex) {
				start = rt.vertex.bufferCount;
			}
			var _g = 0;
			var _g1 = shader.bufferCount;
			while(_g < _g1) {
				var i = _g++;
				this.gl.uniformBlockBinding(p.p,s.buffers[i],i + start);
			}
		}
	}
	,selectShader: function(shader) {
		var p = this.programs.h[shader.id];
		if(p == null) {
			p = new h3d_impl__$GlDriver_CompiledProgram();
			var glout = this.makeCompiler();
			p.vertex = this.compileShader(glout,shader.vertex);
			p.fragment = this.compileShader(glout,shader.fragment);
			p.p = this.gl.createProgram();
			this.gl.attachShader(p.p,p.vertex.s);
			this.gl.attachShader(p.p,p.fragment.s);
			var log = null;
			try {
				this.gl.linkProgram(p.p);
				if(this.gl.getProgramParameter(p.p,35714) != 1) {
					log = this.gl.getProgramInfoLog(p.p);
				}
			} catch( _g ) {
				var e = haxe_Exception.caught(_g).unwrap();
				throw haxe_Exception.thrown("Shader linkage error: " + Std.string(e) + " (" + this.getDriverName(false) + ")");
			}
			this.gl.deleteShader(p.vertex.s);
			this.gl.deleteShader(p.fragment.s);
			if(log != null) {
				this.gl.deleteProgram(p.p);
				throw haxe_Exception.thrown("Program linkage failure: " + log + "\nVertex=\n" + shader.vertex.code + "\n\nFragment=\n" + shader.fragment.code);
			}
			this.firstShader = false;
			this.initShader(p,p.vertex,shader.vertex,shader);
			this.initShader(p,p.fragment,shader.fragment,shader);
			var attribNames = [];
			p.attribs = [];
			p.hasAttribIndex = [];
			p.stride = 0;
			var _g = 0;
			var _g1 = shader.vertex.data.vars;
			while(_g < _g1.length) {
				var v = _g1[_g];
				++_g;
				if(v.kind._hx_index == 1) {
					var t = 5126;
					var size;
					var _g2 = v.type;
					switch(_g2._hx_index) {
					case 3:
						size = 1;
						break;
					case 5:
						var _g3 = _g2.t;
						var n = _g2.size;
						size = n;
						break;
					case 9:
						var n1 = _g2.size;
						t = 5120;
						size = n1;
						break;
					default:
						throw haxe_Exception.thrown("assert " + Std.string(v.type));
					}
					var index = this.gl.getAttribLocation(p.p,glout.varNames.h.hasOwnProperty(v.id) ? glout.varNames.h[v.id] : v.name);
					if(index < 0) {
						p.stride += size;
						continue;
					}
					var a = new h3d_impl__$GlDriver_CompiledAttribute();
					a.type = t;
					a.size = size;
					a.index = index;
					a.offset = p.stride;
					a.divisor = 0;
					if(v.qualifiers != null) {
						var _g4 = 0;
						var _g5 = v.qualifiers;
						while(_g4 < _g5.length) {
							var q = _g5[_g4];
							++_g4;
							if(q._hx_index == 9) {
								var n2 = q.v;
								a.divisor = n2;
							}
						}
					}
					p.attribs.push(a);
					p.hasAttribIndex[a.index] = true;
					attribNames.push(v.name);
					p.stride += size;
				}
			}
			p.inputs = h3d_impl_InputNames.get(attribNames);
			this.programs.h[shader.id] = p;
		}
		if(this.curShader == p) {
			return false;
		}
		this.setProgram(p);
		return true;
	}
	,setProgram: function(p) {
		this.gl.useProgram(p.p);
		var _g = 0;
		var _g1 = p.attribs;
		while(_g < _g1.length) {
			var a = _g1[_g];
			++_g;
			if(!this.curAttribs[a.index]) {
				this.gl.enableVertexAttribArray(a.index);
				this.curAttribs[a.index] = true;
				if(this.maxIdxCurAttribs < a.index) {
					this.maxIdxCurAttribs = a.index;
				}
			}
		}
		var lastIdxCurAttribTrue = 0;
		var _g = 0;
		var _g1 = this.maxIdxCurAttribs + 1;
		while(_g < _g1) {
			var i = _g++;
			if(this.curAttribs[i] && !p.hasAttribIndex[i]) {
				this.gl.disableVertexAttribArray(i);
				this.curAttribs[i] = false;
			} else if(this.curAttribs[i]) {
				lastIdxCurAttribTrue = i;
			}
		}
		this.maxIdxCurAttribs = lastIdxCurAttribTrue;
		this.curShader = p;
		this.curBuffer = null;
		var _g = 0;
		var _g1 = this.boundTextures.length;
		while(_g < _g1) {
			var i = _g++;
			this.boundTextures[i] = null;
		}
	}
	,uploadShaderBuffers: function(buf,which) {
		this.uploadBuffer(buf,this.curShader.vertex,buf.vertex,which);
		this.uploadBuffer(buf,this.curShader.fragment,buf.fragment,which);
	}
	,uploadBuffer: function(buffer,s,buf,which) {
		switch(which) {
		case 0:
			if(s.globals != null) {
				var a = buf.globals.subarray(0,s.shader.globalsSize * 4);
				this.gl.uniform4fv(s.globals,a);
			}
			break;
		case 1:
			if(s.params != null) {
				var a = buf.params.subarray(0,s.shader.paramsSize * 4);
				this.gl.uniform4fv(s.params,a);
			}
			break;
		case 2:
			var tcount = s.textures.length;
			var _g = 0;
			var _g1 = s.textures.length;
			while(_g < _g1) {
				var i = _g++;
				var t = buf.tex[i];
				var pt = s.textures[i];
				if(t == null || t.t == null && t.realloc == null) {
					switch(pt.t._hx_index) {
					case 10:
						var color = h3d_mat_Defaults.loadingTextureColor;
						t = h3d_mat_Texture.fromColor(color,(color >>> 24) / 255);
						break;
					case 12:
						t = h3d_mat_Texture.defaultCubeTexture();
						break;
					default:
						throw haxe_Exception.thrown("Missing texture");
					}
				}
				if(t != null && t.t == null && t.realloc != null) {
					var s1 = this.curShader;
					t.alloc();
					t.realloc();
					if(this.curShader != s1) {
						this.setProgram(s1);
						this.uploadShaderBuffers(buffer,0);
						this.uploadShaderBuffers(buffer,1);
						this.uploadShaderBuffers(buffer,2);
						return;
					}
				}
				t.set_lastFrame(this.frame);
				if(pt.u == null) {
					continue;
				}
				var idx = s.vertex ? i : this.curShader.vertex.textures.length + i;
				if(this.boundTextures[idx] != t.t) {
					this.boundTextures[idx] = t.t;
					var mode = this.getBindType(t);
					if(mode != pt.mode) {
						throw haxe_Exception.thrown("Texture format mismatch: " + Std.string(t) + " should be " + Std.string(pt.t));
					}
					this.gl.activeTexture(33984 + idx);
					this.gl.uniform1i(pt.u,idx);
					this.gl.bindTexture(mode,t.t.t);
					this.lastActiveIndex = idx;
				}
				var mip = t.mipMap._hx_index;
				var filter = t.filter._hx_index;
				var wrap = t.wrap._hx_index;
				var bits = mip | filter << 3 | wrap << 6;
				if(bits != t.t.bits) {
					t.t.bits = bits;
					var flags = h3d_impl_GlDriver.TFILTERS[mip][filter];
					var mode1 = pt.mode;
					this.gl.texParameteri(mode1,10240,flags[0]);
					this.gl.texParameteri(mode1,10241,flags[1]);
					var w = h3d_impl_GlDriver.TWRAP[wrap];
					this.gl.texParameteri(mode1,10242,w);
					this.gl.texParameteri(mode1,10243,w);
				}
			}
			break;
		case 3:
			if(s.buffers != null) {
				var start = 0;
				if(!s.vertex && this.curShader.vertex.buffers != null) {
					start = this.curShader.vertex.buffers.length;
				}
				var _g = 0;
				var _g1 = s.buffers.length;
				while(_g < _g1) {
					var i = _g++;
					this.gl.bindBufferBase(35345,i + start,buf.buffers[i].buffer.vbuf.b);
				}
			}
			break;
		}
	}
	,selectMaterial: function(pass) {
		var bits = pass.bits;
		if(this.curTarget == null == this.rightHanded) {
			switch(pass.culling._hx_index) {
			case 1:
				bits = bits & -4 | 2;
				break;
			case 2:
				bits = bits & -4 | 1;
				break;
			default:
			}
		}
		this.selectMaterialBits(bits);
		if(this.curColorMask != pass.colorMask) {
			var m = pass.colorMask;
			this.gl.colorMask((m & 1) != 0,(m & 2) != 0,(m & 4) != 0,(m & 8) != 0);
			this.curColorMask = m;
		}
		var s = this.defStencil;
		if(pass.stencil == null) {
			if(this.curStEnabled) {
				this.gl.disable(2960);
				this.curStEnabled = false;
			}
		} else {
			s = pass.stencil;
			if(!this.curStEnabled) {
				this.gl.enable(2960);
				this.curStEnabled = true;
			}
		}
		this.selectStencilBits(s.opBits,s.maskBits);
	}
	,selectMaterialBits: function(bits) {
		var diff = bits ^ this.curMatBits;
		if(this.curMatBits < 0) {
			diff = -1;
		}
		if(diff == 0) {
			return;
		}
		var wireframe = (bits & 268435456) != 0;
		this.drawMode = wireframe ? 3 : 4;
		if((diff & 3) != 0) {
			var cull = bits & 3;
			if(cull == 0) {
				this.gl.disable(2884);
			} else {
				if(this.curMatBits < 0 || (this.curMatBits & 3) == 0) {
					this.gl.enable(2884);
				}
				this.gl.cullFace(h3d_impl_GlDriver.FACES[cull]);
			}
		}
		if((diff & 4194240) != 0) {
			var csrc = bits >> 6 & 15;
			var cdst = bits >> 10 & 15;
			var asrc = bits >> 14 & 15;
			var adst = bits >> 18 & 15;
			if(csrc == asrc && cdst == adst) {
				if(csrc == 0 && cdst == 1) {
					this.gl.disable(3042);
				} else {
					if(this.curMatBits < 0 || (this.curMatBits >> 6 & 15) == 0 && (this.curMatBits >> 10 & 15) == 1) {
						this.gl.enable(3042);
					}
					this.gl.blendFunc(h3d_impl_GlDriver.BLEND[csrc],h3d_impl_GlDriver.BLEND[cdst]);
				}
			} else {
				if(this.curMatBits < 0 || (this.curMatBits >> 6 & 15) == 0 && (this.curMatBits >> 10 & 15) == 1) {
					this.gl.enable(3042);
				}
				this.gl.blendFuncSeparate(h3d_impl_GlDriver.BLEND[csrc],h3d_impl_GlDriver.BLEND[cdst],h3d_impl_GlDriver.BLEND[asrc],h3d_impl_GlDriver.BLEND[adst]);
			}
		}
		if((diff & 264241152) != 0) {
			var cop = bits >> 22 & 7;
			var aop = bits >> 25 & 7;
			if(cop == aop) {
				this.gl.blendEquation(h3d_impl_GlDriver.OP[cop]);
			} else {
				this.gl.blendEquationSeparate(h3d_impl_GlDriver.OP[cop],h3d_impl_GlDriver.OP[aop]);
			}
		}
		if((diff & 4) != 0) {
			this.gl.depthMask((bits >> 2 & 1) != 0);
		}
		if((diff & 56) != 0) {
			var cmp = bits >> 3 & 7;
			if(cmp == 0) {
				this.gl.disable(2929);
			} else {
				if(this.curMatBits < 0 || (this.curMatBits >> 3 & 7) == 0) {
					this.gl.enable(2929);
				}
				this.gl.depthFunc(h3d_impl_GlDriver.COMPARE[cmp]);
			}
		}
		this.curMatBits = bits;
	}
	,selectStencilBits: function(opBits,maskBits) {
		var diffOp = opBits ^ this.curStOpBits;
		var diffMask = maskBits ^ this.curStMaskBits;
		if((diffOp | diffMask) == 0) {
			return;
		}
		if((diffOp & 4088) != 0) {
			this.gl.stencilOpSeparate(h3d_impl_GlDriver.FACES[2],h3d_impl_GlDriver.STENCIL_OP[opBits >> 6 & 7],h3d_impl_GlDriver.STENCIL_OP[opBits >> 9 & 7],h3d_impl_GlDriver.STENCIL_OP[opBits >> 3 & 7]);
		}
		if((diffOp & 16744448) != 0) {
			this.gl.stencilOpSeparate(h3d_impl_GlDriver.FACES[1],h3d_impl_GlDriver.STENCIL_OP[opBits >> 18 & 7],h3d_impl_GlDriver.STENCIL_OP[opBits >> 21 & 7],h3d_impl_GlDriver.STENCIL_OP[opBits >> 15 & 7]);
		}
		if((diffOp & 7 | diffMask & 16711935) != 0) {
			this.gl.stencilFuncSeparate(h3d_impl_GlDriver.FACES[2],h3d_impl_GlDriver.COMPARE[opBits & 7],maskBits >> 16 & 255,maskBits & 255);
		}
		if((diffOp & 28672 | diffMask & 16711935) != 0) {
			this.gl.stencilFuncSeparate(h3d_impl_GlDriver.FACES[1],h3d_impl_GlDriver.COMPARE[opBits >> 12 & 7],maskBits >> 16 & 255,maskBits & 255);
		}
		if((diffMask & 65280) != 0) {
			var w = maskBits >> 8 & 255;
			this.gl.stencilMaskSeparate(h3d_impl_GlDriver.FACES[2],w);
			this.gl.stencilMaskSeparate(h3d_impl_GlDriver.FACES[1],w);
		}
		this.curStOpBits = opBits;
		this.curStMaskBits = maskBits;
	}
	,clear: function(color,depth,stencil) {
		var bits = 0;
		if(color != null) {
			this.gl.colorMask(true,true,true,true);
			this.curColorMask = 15;
			this.gl.clearColor(color.x,color.y,color.z,color.w);
			bits |= 16384;
		}
		if(depth != null) {
			this.gl.depthMask(true);
			if(this.curMatBits >= 0) {
				this.curMatBits |= 4;
			}
			this.gl.clearDepth(depth);
			bits |= 256;
		}
		if(stencil != null) {
			this.selectStencilBits(this.defStencil.opBits,this.defStencil.maskBits);
			this.gl.clearStencil(stencil);
			bits |= 1024;
		}
		if(bits != 0) {
			this.gl.clear(bits);
		}
		if(this.curTarget != null) {
			this.curTarget.flags |= 1 << h3d_mat_TextureFlags.WasCleared._hx_index;
		}
	}
	,resize: function(width,height) {
		if(this.canvas.style.width == "") {
			var tmp = width / window.devicePixelRatio | 0;
			this.canvas.style.width = tmp + "px";
			var tmp = height / window.devicePixelRatio | 0;
			this.canvas.style.height = tmp + "px";
		}
		this.canvas.width = width;
		this.canvas.height = height;
		this.bufferWidth = width;
		this.bufferHeight = height;
		this.gl.viewport(0,0,width,height);
		if(this.defaultDepth != null) {
			this.disposeDepthBuffer(this.defaultDepth);
			this.defaultDepth.width = this.bufferWidth;
			this.defaultDepth.height = this.bufferHeight;
			this.defaultDepth.b = this.allocDepthBuffer(this.defaultDepth);
		}
	}
	,getChannels: function(t) {
		switch(t.internalFmt) {
		case 6407:
			return 6407;
		case 6408:
			return 6408;
		case 32857:
			return 6408;
		case 6403:case 33321:case 33325:case 33326:
			return 6403;
		case 33319:case 33323:case 33327:case 33328:
			return 33319;
		case 33777:case 33778:case 33779:
			return 6408;
		case 34836:case 34842:
			return 6408;
		case 34837:case 34843:
			return 6407;
		case 35898:
			return 6407;
		case 35904:case 35905:
			return 6407;
		default:
			throw haxe_Exception.thrown("Invalid format " + t.internalFmt);
		}
	}
	,isSupportedFormat: function(fmt) {
		switch(fmt._hx_index) {
		case 2:
			return true;
		case 3:case 4:
			return this.hasFeature(h3d_impl_Feature.FloatTextures);
		case 5:case 6:case 7:case 8:case 9:case 10:case 11:case 12:case 13:case 16:case 17:
			return this.glES >= 3;
		case 14:case 15:
			return this.hasFeature(h3d_impl_Feature.SRGBTextures);
		case 21:
			var n = fmt.v;
			return n <= this.maxCompressedTexturesSupport;
		default:
			return false;
		}
	}
	,getBindType: function(t) {
		var isCube = (t.flags & 1 << h3d_mat_TextureFlags.Cube._hx_index) != 0;
		var isArray = (t.flags & 1 << h3d_mat_TextureFlags.IsArray._hx_index) != 0;
		if(isCube) {
			return 34067;
		} else if(isArray) {
			return 35866;
		} else {
			return 3553;
		}
	}
	,allocTexture: function(t) {
		var _gthis = this;
		if(h3d_impl_GlDriver.outOfMemoryCheck) {
			this.gl.getError();
		}
		var tt = this.gl.createTexture();
		var bind = this.getBindType(t);
		var tt1 = { t : tt, width : t.width, height : t.height, internalFmt : 6408, pixelFmt : 5121, bits : -1, bind : bind, bias : 0};
		var _g = t.format;
		switch(_g._hx_index) {
		case 1:
			tt1.internalFmt = 32856;
			break;
		case 2:
			break;
		case 3:
			if(this.hasFeature(h3d_impl_Feature.FloatTextures)) {
				tt1.pixelFmt = 5131;
				tt1.internalFmt = 34842;
			} else {
				throw haxe_Exception.thrown("Unsupported texture format " + Std.string(t.format));
			}
			break;
		case 4:
			if(this.hasFeature(h3d_impl_Feature.FloatTextures)) {
				tt1.internalFmt = 34836;
				tt1.pixelFmt = 5126;
			} else {
				throw haxe_Exception.thrown("Unsupported texture format " + Std.string(t.format));
			}
			break;
		case 5:
			tt1.internalFmt = 33321;
			break;
		case 6:
			tt1.internalFmt = 33325;
			tt1.pixelFmt = 5131;
			break;
		case 7:
			tt1.internalFmt = 33326;
			tt1.pixelFmt = 5126;
			break;
		case 8:
			tt1.internalFmt = 33323;
			break;
		case 9:
			tt1.internalFmt = 33327;
			tt1.pixelFmt = 5131;
			break;
		case 10:
			tt1.internalFmt = 33328;
			tt1.pixelFmt = 5126;
			break;
		case 11:
			tt1.internalFmt = 6407;
			break;
		case 12:
			tt1.internalFmt = 34843;
			tt1.pixelFmt = 5131;
			break;
		case 13:
			tt1.internalFmt = 34837;
			tt1.pixelFmt = 5126;
			break;
		case 14:
			tt1.internalFmt = 35905;
			break;
		case 16:
			tt1.internalFmt = 32857;
			tt1.pixelFmt = 33640;
			break;
		case 17:
			tt1.internalFmt = 35898;
			tt1.pixelFmt = 35899;
			break;
		case 21:
			var n = _g.v;
			if(n <= this.maxCompressedTexturesSupport) {
				if((t.width & 3) != 0 || (t.height & 3) != 0) {
					throw haxe_Exception.thrown("Compressed texture " + Std.string(t) + " has size " + t.width + "x" + t.height + " - must be a multiple of 4");
				}
				switch(n) {
				case 1:
					tt1.internalFmt = 33777;
					break;
				case 2:
					tt1.internalFmt = 33778;
					break;
				case 3:
					tt1.internalFmt = 33779;
					break;
				default:
					throw haxe_Exception.thrown("Unsupported texture format " + Std.string(t.format));
				}
			} else {
				throw haxe_Exception.thrown("Unsupported texture format " + Std.string(t.format));
			}
			break;
		default:
			throw haxe_Exception.thrown("Unsupported texture format " + Std.string(t.format));
		}
		t.set_lastFrame(this.frame);
		t.flags &= -1 - (1 << h3d_mat_TextureFlags.WasCleared._hx_index);
		this.gl.bindTexture(bind,tt1.t);
		var outOfMem = false;
		this.gl.texParameteri(bind,33084,0);
		this.gl.texParameteri(bind,33085,t.get_mipLevels() - 1);
		var _g = 0;
		var _g1 = t.get_mipLevels();
		while(_g < _g1) {
			var mip = _g++;
			var b = tt1.width >> mip;
			var w = 1 < b ? b : 1;
			var b1 = tt1.height >> mip;
			var h = 1 < b1 ? b1 : 1;
			if((t.flags & 1 << h3d_mat_TextureFlags.Cube._hx_index) != 0) {
				var _g2 = 0;
				while(_g2 < 6) {
					var i = _g2++;
					this.gl.texImage2D(h3d_impl_GlDriver.CUBE_FACES[i],mip,tt1.internalFmt,w,h,0,this.getChannels(tt1),tt1.pixelFmt,null);
					var tmp;
					if(!h3d_impl_GlDriver.outOfMemoryCheck) {
						tmp = false;
					} else {
						var err = _gthis.gl.getError();
						if(err == 1285) {
							outOfMem = true;
							tmp = true;
						} else {
							if(err != 0) {
								throw haxe_Exception.thrown("Failed to alloc texture " + Std.string(t.format) + "(error " + err + ")");
							}
							tmp = false;
						}
					}
					if(tmp) {
						break;
					}
				}
			} else if((t.flags & 1 << h3d_mat_TextureFlags.IsArray._hx_index) != 0) {
				this.gl.texImage3D(bind,mip,tt1.internalFmt,w,h,t.get_layerCount(),0,this.getChannels(tt1),tt1.pixelFmt,null);
				if(h3d_impl_GlDriver.outOfMemoryCheck) {
					var err1 = _gthis.gl.getError();
					if(err1 == 1285) {
						outOfMem = true;
					} else if(err1 != 0) {
						throw haxe_Exception.thrown("Failed to alloc texture " + Std.string(t.format) + "(error " + err1 + ")");
					}
				}
			} else {
				var _g3 = t.format;
				var tmp1;
				if(_g3._hx_index == 21) {
					var _g4 = _g3.v;
					tmp1 = true;
				} else {
					tmp1 = false;
				}
				if(!tmp1) {
					this.gl.texImage2D(bind,mip,tt1.internalFmt,w,h,0,this.getChannels(tt1),tt1.pixelFmt,null);
				}
				if(h3d_impl_GlDriver.outOfMemoryCheck) {
					var err2 = _gthis.gl.getError();
					if(err2 == 1285) {
						outOfMem = true;
					} else if(err2 != 0) {
						throw haxe_Exception.thrown("Failed to alloc texture " + Std.string(t.format) + "(error " + err2 + ")");
					}
				}
			}
		}
		this.restoreBind();
		if(outOfMem) {
			this.gl.deleteTexture(tt1.t);
			return null;
		}
		return tt1;
	}
	,restoreBind: function() {
		var t = this.boundTextures[this.lastActiveIndex];
		if(t == null) {
			this.gl.bindTexture(3553,null);
		} else {
			this.gl.bindTexture(t.bind,t.t);
		}
	}
	,allocDepthBuffer: function(b) {
		var r = this.gl.createRenderbuffer();
		if(b.format == null) {
			b.format = this.glES >= 3 ? h3d_mat_DepthFormat.Depth24Stencil8 : h3d_mat_DepthFormat.Depth16;
		}
		var format;
		switch(b.format._hx_index) {
		case 0:
			format = 33189;
			break;
		case 1:
			if(this.glES >= 3) {
				format = 33190;
			} else {
				throw haxe_Exception.thrown("Unsupported depth format " + Std.string(b.format));
			}
			break;
		case 2:
			format = 34041;
			break;
		default:
			throw haxe_Exception.thrown("Unsupported depth format " + Std.string(b.format));
		}
		this.gl.bindRenderbuffer(36161,r);
		this.gl.renderbufferStorage(36161,format,b.width,b.height);
		this.gl.bindRenderbuffer(36161,null);
		return { r : r};
	}
	,disposeDepthBuffer: function(b) {
		if(b.b != null && b.b.r != null) {
			this.gl.deleteRenderbuffer(b.b.r);
			b.b = null;
		}
	}
	,getDefaultDepthBuffer: function() {
		if(this.defaultDepth != null) {
			return this.defaultDepth;
		}
		this.defaultDepth = new h3d_mat_DepthBuffer(0,0);
		this.defaultDepth.width = this.bufferWidth;
		this.defaultDepth.height = this.bufferHeight;
		this.defaultDepth.b = this.allocDepthBuffer(this.defaultDepth);
		return this.defaultDepth;
	}
	,allocVertexes: function(m) {
		if(h3d_impl_GlDriver.outOfMemoryCheck) {
			this.gl.getError();
		}
		var b = this.gl.createBuffer();
		this.gl.bindBuffer(34962,b);
		if(m.size * m.stride == 0) {
			throw haxe_Exception.thrown("assert");
		}
		this.gl.bufferData(34962,m.size * m.stride * 4,(m.flags & 1 << h3d_BufferFlag.Dynamic._hx_index) != 0 ? 35048 : 35044);
		var outOfMem = h3d_impl_GlDriver.outOfMemoryCheck && this.gl.getError() == 1285;
		this.gl.bindBuffer(34962,null);
		if(outOfMem) {
			this.gl.deleteBuffer(b);
			return null;
		}
		return { b : b, stride : m.stride};
	}
	,allocIndexes: function(count,is32) {
		if(h3d_impl_GlDriver.outOfMemoryCheck) {
			this.gl.getError();
		}
		var b = this.gl.createBuffer();
		var size = is32 ? 4 : 2;
		this.gl.bindBuffer(34963,b);
		this.gl.bufferData(34963,count * size,35044);
		var outOfMem = h3d_impl_GlDriver.outOfMemoryCheck && this.gl.getError() == 1285;
		this.gl.bindBuffer(34963,null);
		this.curIndexBuffer = null;
		if(outOfMem) {
			this.gl.deleteBuffer(b);
			return null;
		}
		return { b : b, is32 : is32};
	}
	,disposeTexture: function(t) {
		var tt = t.t;
		if(tt == null) {
			return;
		}
		t.t = null;
		var _g = 0;
		var _g1 = this.boundTextures.length;
		while(_g < _g1) {
			var i = _g++;
			if(this.boundTextures[i] == tt) {
				this.boundTextures[i] = null;
			}
		}
		this.gl.deleteTexture(tt.t);
	}
	,disposeIndexes: function(i) {
		this.gl.deleteBuffer(i.b);
	}
	,disposeVertexes: function(v) {
		this.gl.deleteBuffer(v.b);
	}
	,generateMipMaps: function(t) {
		var bind = this.getBindType(t);
		this.gl.bindTexture(bind,t.t.t);
		this.gl.generateMipmap(bind);
		this.restoreBind();
	}
	,uploadTextureBitmap: function(t,bmp,mipLevel,side) {
		if(t.format != hxd_PixelFormat.RGBA || t.get_layerCount() != 1) {
			var pixels = bmp.getPixels();
			this.uploadTexturePixels(t,pixels,mipLevel,side);
			pixels.dispose();
		} else {
			var img = bmp.ctx;
			this.gl.bindTexture(3553,t.t.t);
			this.gl.texImage2D(3553,mipLevel,t.t.internalFmt,this.getChannels(t.t),t.t.pixelFmt,img.getImageData(0,0,bmp.ctx.canvas.width,bmp.ctx.canvas.height));
			this.restoreBind();
		}
	}
	,resetStream: function() {
	}
	,uploadTexturePixels: function(t,pixels,mipLevel,side) {
		var cubic = (t.flags & 1 << h3d_mat_TextureFlags.Cube._hx_index) != 0;
		var face = cubic ? h3d_impl_GlDriver.CUBE_FACES[side] : (t.flags & 1 << h3d_mat_TextureFlags.IsArray._hx_index) != 0 ? 35866 : 3553;
		var bind = this.getBindType(t);
		this.gl.bindTexture(bind,t.t.t);
		pixels.convert(t.format);
		pixels.setFlip(false);
		var dataLen = pixels.dataSize;
		var buffer;
		switch(t.format._hx_index) {
		case 3:case 6:case 9:case 12:
			buffer = new Uint16Array(pixels.bytes.b.buffer,pixels.offset,dataLen >> 1);
			break;
		case 4:case 7:case 10:case 13:
			buffer = new Float32Array(pixels.bytes.b.buffer,pixels.offset,dataLen >> 2);
			break;
		case 16:case 17:
			buffer = new Uint32Array(pixels.bytes.b.buffer,pixels.offset,dataLen >> 2);
			break;
		default:
			buffer = new Uint8Array(pixels.bytes.b.buffer,pixels.offset,dataLen);
		}
		var _g = t.format;
		var tmp;
		if(_g._hx_index == 21) {
			var _g1 = _g.v;
			tmp = true;
		} else {
			tmp = false;
		}
		if(tmp) {
			if((t.flags & 1 << h3d_mat_TextureFlags.IsArray._hx_index) != 0) {
				this.gl.compressedTexSubImage3D(face,mipLevel,0,0,side,pixels.width,pixels.height,1,t.t.internalFmt,buffer);
			} else {
				this.gl.compressedTexImage2D(face,mipLevel,t.t.internalFmt,pixels.width,pixels.height,0,buffer);
			}
		} else if((t.flags & 1 << h3d_mat_TextureFlags.IsArray._hx_index) != 0) {
			this.gl.texSubImage3D(face,mipLevel,0,0,side,pixels.width,pixels.height,1,this.getChannels(t.t),t.t.pixelFmt,buffer);
		} else {
			this.gl.texImage2D(face,mipLevel,t.t.internalFmt,pixels.width,pixels.height,0,this.getChannels(t.t),t.t.pixelFmt,buffer);
		}
		t.flags |= 1 << h3d_mat_TextureFlags.WasCleared._hx_index;
		this.restoreBind();
	}
	,uploadVertexBuffer: function(v,startVertex,vertexCount,buf,bufPos) {
		var stride = v.stride;
		this.gl.bindBuffer(34962,v.b);
		var buf1 = buf.array;
		var sub = new Float32Array(buf1.buffer,bufPos * 4,vertexCount * stride);
		this.gl.bufferSubData(34962,startVertex * stride * 4,sub);
		this.gl.bindBuffer(34962,null);
	}
	,uploadIndexBuffer: function(i,startIndice,indiceCount,buf,bufPos) {
		var bits = i.is32 ? 2 : 1;
		this.gl.bindBuffer(34963,i.b);
		var buf1 = new Uint16Array(buf);
		var sub = new Uint16Array(buf1.buffer,bufPos << bits,indiceCount);
		this.gl.bufferSubData(34963,startIndice << bits,sub);
		this.gl.bindBuffer(34963,null);
		this.curIndexBuffer = null;
	}
	,selectBuffer: function(v) {
		if(v == this.curBuffer) {
			return;
		}
		if(this.curBuffer != null && v.buffer == this.curBuffer.buffer && (v.buffer.flags & 1 << h3d_BufferFlag.RawFormat._hx_index) != 0 == ((this.curBuffer.flags & 1 << h3d_BufferFlag.RawFormat._hx_index) != 0)) {
			this.curBuffer = v;
			return;
		}
		if(this.curShader == null) {
			throw haxe_Exception.thrown("No shader selected");
		}
		this.curBuffer = v;
		var m = v.buffer.vbuf;
		if(m.stride < this.curShader.stride) {
			throw haxe_Exception.thrown("Buffer stride (" + m.stride + ") and shader stride (" + this.curShader.stride + ") mismatch");
		}
		this.gl.bindBuffer(34962,m.b);
		if((v.flags & 1 << h3d_BufferFlag.RawFormat._hx_index) != 0) {
			var _g = 0;
			var _g1 = this.curShader.attribs;
			while(_g < _g1.length) {
				var a = _g1[_g];
				++_g;
				var pos = a.offset;
				this.gl.vertexAttribPointer(a.index,a.size,a.type,false,m.stride * 4,pos * 4);
				if(this.currentDivisor[a.index] != a.divisor) {
					this.currentDivisor[a.index] = a.divisor;
					this.gl.vertexAttribDivisor(a.index,a.divisor);
				}
			}
		} else {
			var offset = 8;
			var _g = 0;
			var _g1 = this.curShader.attribs.length;
			while(_g < _g1) {
				var i = _g++;
				var a = this.curShader.attribs[i];
				var pos;
				var _g2 = this.curShader.inputs.names[i];
				switch(_g2) {
				case "normal":
					if(m.stride < 6) {
						throw haxe_Exception.thrown("Buffer is missing NORMAL data, set it to RAW format ?");
					}
					pos = 3;
					break;
				case "position":
					pos = 0;
					break;
				case "uv":
					if(m.stride < 8) {
						throw haxe_Exception.thrown("Buffer is missing UV data, set it to RAW format ?");
					}
					pos = 6;
					break;
				default:
					var s = _g2;
					pos = offset;
					offset += a.size;
					if(offset > m.stride) {
						throw haxe_Exception.thrown("Buffer is missing '" + s + "' data, set it to RAW format ?");
					}
				}
				this.gl.vertexAttribPointer(a.index,a.size,a.type,false,m.stride * 4,pos * 4);
				if(this.currentDivisor[a.index] != a.divisor) {
					this.currentDivisor[a.index] = a.divisor;
					this.gl.vertexAttribDivisor(a.index,a.divisor);
				}
			}
		}
	}
	,selectMultiBuffers: function(buffers) {
		var _g = 0;
		var _g1 = this.curShader.attribs;
		while(_g < _g1.length) {
			var a = _g1[_g];
			++_g;
			this.gl.bindBuffer(34962,buffers.buffer.buffer.vbuf.b);
			this.gl.vertexAttribPointer(a.index,a.size,a.type,false,buffers.buffer.buffer.stride * 4,buffers.offset * 4);
			if(this.currentDivisor[a.index] != a.divisor) {
				this.currentDivisor[a.index] = a.divisor;
				this.gl.vertexAttribDivisor(a.index,a.divisor);
			}
			buffers = buffers.next;
		}
		this.curBuffer = null;
	}
	,draw: function(ibuf,startIndex,ntriangles) {
		if(ibuf != this.curIndexBuffer) {
			this.curIndexBuffer = ibuf;
			this.gl.bindBuffer(34963,ibuf.b);
		}
		if(ibuf.is32) {
			this.gl.drawElements(this.drawMode,ntriangles * 3,5125,startIndex * 4);
		} else {
			this.gl.drawElements(this.drawMode,ntriangles * 3,5123,startIndex * 2);
		}
	}
	,drawInstanced: function(ibuf,commands) {
		if(ibuf != this.curIndexBuffer) {
			this.curIndexBuffer = ibuf;
			this.gl.bindBuffer(34963,ibuf.b);
		}
		var kind;
		var size;
		if(ibuf.is32) {
			kind = 5125;
			size = 4;
		} else {
			kind = 5123;
			size = 2;
		}
		var args = commands.data;
		if(args != null) {
			var p = 0;
			var _g = 0;
			var _g1 = args.length / 3 | 0;
			while(_g < _g1) {
				var i = _g++;
				this.gl.drawElementsInstanced(this.drawMode,args[p++],kind,args[p++] * size,args[p++]);
			}
		} else {
			this.gl.drawElementsInstanced(this.drawMode,commands.indexCount,kind,commands.startIndex * size,commands.commandCount);
		}
	}
	,end: function() {
	}
	,isDisposed: function() {
		return this.gl.isContextLost();
	}
	,setRenderZone: function(x,y,width,height) {
		if(x == 0 && y == 0 && width < 0 && height < 0) {
			this.gl.disable(3089);
		} else {
			this.gl.enable(3089);
			if(this.curTarget == null) {
				y = this.bufferHeight - (y + height);
			}
			this.gl.scissor(x,y,width,height);
		}
	}
	,setDrawBuffers: function(k) {
		if(this.glES >= 3) {
			this.gl.drawBuffers(h3d_impl_GlDriver.CBUFFERS[k]);
		} else if(this.mrtExt != null) {
			this.mrtExt.drawBuffersWEBGL(h3d_impl_GlDriver.CBUFFERS[k]);
		}
	}
	,unbindTargets: function() {
		if(this.curTarget != null && this.numTargets > 1) {
			while(this.numTargets > 1) {
				this.gl.framebufferTexture2D(36160,36064 + --this.numTargets,3553,null,0);
				this.curTargets[this.numTargets] = null;
			}
			this.setDrawBuffers(1);
		}
	}
	,setRenderTarget: function(tex,layer,mipLevel) {
		if(mipLevel == null) {
			mipLevel = 0;
		}
		if(layer == null) {
			layer = 0;
		}
		this.unbindTargets();
		this.curTarget = tex;
		if(tex == null) {
			this.gl.bindFramebuffer(36160,null);
			this.gl.viewport(0,0,this.bufferWidth,this.bufferHeight);
			return;
		}
		if(tex.depthBuffer != null && (tex.depthBuffer.width != tex.width || tex.depthBuffer.height != tex.height)) {
			throw haxe_Exception.thrown("Invalid depth buffer size : does not match render target size");
		}
		if(mipLevel > 0 && this.glES == 1) {
			throw haxe_Exception.thrown("Cannot render to mipLevel in WebGL1, use upload() instead");
		}
		if(tex.t == null) {
			tex.alloc();
		}
		if((tex.flags & 1 << h3d_mat_TextureFlags.MipMapped._hx_index) != 0 && (tex.flags & 1 << h3d_mat_TextureFlags.WasCleared._hx_index) == 0) {
			var bind = this.getBindType(tex);
			this.gl.bindTexture(bind,tex.t.t);
			this.gl.generateMipmap(bind);
			this.restoreBind();
		}
		tex.set_lastFrame(this.frame);
		this.curTargetLayer = layer;
		this.curTargetMip = mipLevel;
		this.gl.bindFramebuffer(36160,this.commonFB);
		if((tex.flags & 1 << h3d_mat_TextureFlags.IsArray._hx_index) != 0) {
			this.gl.framebufferTextureLayer(36160,36064,tex.t.t,mipLevel,layer);
		} else {
			this.gl.framebufferTexture2D(36160,36064,(tex.flags & 1 << h3d_mat_TextureFlags.Cube._hx_index) != 0 ? h3d_impl_GlDriver.CUBE_FACES[layer] : 3553,tex.t.t,mipLevel);
		}
		if(tex.depthBuffer != null) {
			if(tex.depthBuffer.hasStencil() && tex.depthBuffer.format == h3d_mat_DepthFormat.Depth24Stencil8) {
				this.gl.framebufferRenderbuffer(36160,33306,36161,tex.depthBuffer.b.r);
			} else {
				this.gl.framebufferRenderbuffer(36160,33306,36161,null);
				this.gl.framebufferRenderbuffer(36160,36096,36161,tex.depthBuffer.b.r);
				this.gl.framebufferRenderbuffer(36160,36128,36161,tex.depthBuffer.hasStencil() ? tex.depthBuffer.b.r : null);
			}
		} else {
			this.gl.framebufferRenderbuffer(36160,33306,36161,null);
			this.gl.framebufferRenderbuffer(36160,36096,36161,null);
			this.gl.framebufferRenderbuffer(36160,36128,36161,null);
		}
		var w = tex.width >> mipLevel;
		if(w == 0) {
			w = 1;
		}
		var h = tex.height >> mipLevel;
		if(h == 0) {
			h = 1;
		}
		this.gl.viewport(0,0,w,h);
		var _g = 0;
		var _g1 = this.boundTextures.length;
		while(_g < _g1) {
			var i = _g++;
			this.boundTextures[i] = null;
		}
		if((tex.flags & 1 << h3d_mat_TextureFlags.WasCleared._hx_index) == 0) {
			tex.flags |= 1 << h3d_mat_TextureFlags.WasCleared._hx_index;
			this.clear(h3d_impl_GlDriver.BLACK);
		}
		if(this.glDebug) {
			var code = this.gl.checkFramebufferStatus(36160);
			if(code != 36053) {
				throw haxe_Exception.thrown("Invalid frame buffer: " + code);
			}
		}
	}
	,setRenderTargets: function(textures) {
		this.unbindTargets();
		this.setRenderTarget(textures[0]);
		if(textures.length < 2) {
			return;
		}
		this.numTargets = textures.length;
		var needClear = false;
		var _g = 1;
		var _g1 = textures.length;
		while(_g < _g1) {
			var i = _g++;
			var tex = textures[i];
			if(tex.t == null) {
				tex.alloc();
			}
			this.gl.framebufferTexture2D(36160,36064 + i,3553,tex.t.t,0);
			this.curTargets[i] = tex;
			tex.set_lastFrame(this.frame);
			if((tex.flags & 1 << h3d_mat_TextureFlags.WasCleared._hx_index) == 0) {
				tex.flags |= 1 << h3d_mat_TextureFlags.WasCleared._hx_index;
				needClear = true;
			}
		}
		this.setDrawBuffers(textures.length);
		if(needClear) {
			this.clear(h3d_impl_GlDriver.BLACK);
		}
	}
	,init: function(onCreate,forceSoftware) {
		if(forceSoftware == null) {
			forceSoftware = false;
		}
		if(window.document.readyState == "complete") {
			var _g = onCreate;
			var a1 = false;
			haxe_Timer.delay(function() {
				_g(a1);
			},1);
		} else {
			var onLoad = null;
			onLoad = function() {
				window.removeEventListener("load",onLoad);
				onCreate(false);
			};
			window.addEventListener("load",onLoad);
		}
	}
	,hasFeature: function(f) {
		return this.features.get(f);
	}
	,makeFeatures: function() {
		var _g = 0;
		var _g1 = h3d_impl_Feature.__empty_constructs__.slice();
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			this.features.set(f,this.checkFeature(f));
		}
		if(this.gl.getExtension("WEBGL_compressed_texture_s3tc") != null) {
			this.maxCompressedTexturesSupport = 3;
		}
	}
	,checkFeature: function(f) {
		switch(f._hx_index) {
		case 0:
			if(this.glES >= 3) {
				return true;
			} else {
				return this.gl.getExtension("OES_standard_derivatives") != null;
			}
			break;
		case 1:
			if(this.glES >= 3) {
				if(this.gl.getExtension("EXT_color_buffer_float") != null) {
					return this.gl.getExtension("OES_texture_float_linear") != null;
				} else {
					return false;
				}
			} else if(this.gl.getExtension("OES_texture_float") != null && this.gl.getExtension("OES_texture_float_linear") != null && this.gl.getExtension("OES_texture_half_float") != null) {
				return this.gl.getExtension("OES_texture_half_float_linear") != null;
			} else {
				return false;
			}
			break;
		case 2:case 3:case 8:case 9:
			return true;
		case 4:
			if(this.glES >= 3) {
				return true;
			} else if(this.mrtExt == null) {
				return (this.mrtExt = this.gl.getExtension("WEBGL_draw_buffers")) != null;
			} else {
				return true;
			}
			break;
		case 6:
			if(this.glES >= 3) {
				return true;
			} else {
				return this.gl.getExtension("EXT_sRGB") != null;
			}
			break;
		case 7:
			if(this.glES >= 3) {
				return true;
			} else {
				return false;
			}
			break;
		case 10:
			if(this.glES >= 3) {
				return true;
			} else {
				return this.gl.getExtension("ANGLE_instanced_arrays") != null;
			}
			break;
		default:
			return false;
		}
	}
	,__class__: h3d_impl_GlDriver
});
var h3d_impl_InstanceBuffer = function() {
	this.triCount = 0;
};
$hxClasses["h3d.impl.InstanceBuffer"] = h3d_impl_InstanceBuffer;
h3d_impl_InstanceBuffer.__name__ = "h3d.impl.InstanceBuffer";
h3d_impl_InstanceBuffer.prototype = {
	__class__: h3d_impl_InstanceBuffer
};
var h3d_impl__$ManagedBuffer_FreeCell = function(pos,count,next) {
	this.pos = pos;
	this.count = count;
	this.next = next;
};
$hxClasses["h3d.impl._ManagedBuffer.FreeCell"] = h3d_impl__$ManagedBuffer_FreeCell;
h3d_impl__$ManagedBuffer_FreeCell.__name__ = "h3d.impl._ManagedBuffer.FreeCell";
h3d_impl__$ManagedBuffer_FreeCell.prototype = {
	__class__: h3d_impl__$ManagedBuffer_FreeCell
};
var h3d_impl_ManagedBuffer = function(stride,size,flags) {
	var this1 = 0;
	this.flags = this1;
	if(flags != null) {
		var _g = 0;
		while(_g < flags.length) {
			var f = flags[_g];
			++_g;
			this.flags |= 1 << f._hx_index;
		}
	}
	this.size = size;
	this.stride = stride;
	this.freeList = new h3d_impl__$ManagedBuffer_FreeCell(0,size,null);
	this.mem = h3d_Engine.CURRENT.mem;
	this.mem.allocManaged(this);
};
$hxClasses["h3d.impl.ManagedBuffer"] = h3d_impl_ManagedBuffer;
h3d_impl_ManagedBuffer.__name__ = "h3d.impl.ManagedBuffer";
h3d_impl_ManagedBuffer.prototype = {
	uploadVertexBuffer: function(start,vertices,buf,bufPos) {
		if(bufPos == null) {
			bufPos = 0;
		}
		this.mem.driver.uploadVertexBuffer(this.vbuf,start,vertices,buf,bufPos);
	}
	,allocPosition: function(nvert,align) {
		var free = this.freeList;
		while(free != null) {
			if(free.count >= nvert) {
				var d = (align - free.pos % align) % align;
				if(d == 0) {
					break;
				}
				if(free.count >= nvert + d) {
					free.next = new h3d_impl__$ManagedBuffer_FreeCell(free.pos + d,free.count - d,free.next);
					free.count = d;
					free = free.next;
					break;
				}
			}
			free = free.next;
		}
		if(free == null) {
			return -1;
		}
		var pos = free.pos;
		free.pos += nvert;
		free.count -= nvert;
		return pos;
	}
	,allocBuffer: function(b) {
		var align = (b.flags & 1 << h3d_BufferFlag.Quads._hx_index) != 0 ? 4 : (b.flags & 1 << h3d_BufferFlag.Triangles._hx_index) != 0 ? 3 : 1;
		var p = this.allocPosition(b.vertices,align);
		if(p < 0) {
			return false;
		}
		b.position = p;
		b.buffer = this;
		return true;
	}
	,freeBuffer: function(b) {
		var prev = null;
		var f = this.freeList;
		var nvert = b.vertices;
		var end = b.position + nvert;
		while(f != null) {
			if(f.pos == end) {
				f.pos -= nvert;
				f.count += nvert;
				if(prev != null && prev.pos + prev.count == f.pos) {
					prev.count += f.count;
					prev.next = f.next;
				}
				nvert = 0;
				break;
			}
			if(f.pos > end) {
				if(prev != null && prev.pos + prev.count == b.position) {
					prev.count += nvert;
				} else {
					var n = new h3d_impl__$ManagedBuffer_FreeCell(b.position,nvert,f);
					if(prev == null) {
						this.freeList = n;
					} else {
						prev.next = n;
					}
				}
				nvert = 0;
				break;
			}
			prev = f;
			f = f.next;
		}
		if(nvert != 0) {
			throw haxe_Exception.thrown("assert");
		}
		if(this.freeList.count == this.size && (this.flags & 1 << h3d_BufferFlag.Managed._hx_index) == 0) {
			this.dispose();
		}
	}
	,dispose: function() {
		this.mem.freeManaged(this);
	}
	,__class__: h3d_impl_ManagedBuffer
};
var h3d_impl_MemoryManager = function(driver) {
	this.bufferCount = 0;
	this.texMemory = 0;
	this.usedMemory = 0;
	this.driver = driver;
};
$hxClasses["h3d.impl.MemoryManager"] = h3d_impl_MemoryManager;
h3d_impl_MemoryManager.__name__ = "h3d.impl.MemoryManager";
h3d_impl_MemoryManager.prototype = {
	init: function() {
		this.indexes = [];
		this.textures = [];
		this.buffers = [];
		this.depths = [];
		this.initIndexes();
	}
	,initIndexes: function() {
		var this1 = new Array(0);
		var indices = this1;
		var _g = 0;
		while(_g < 65533) {
			var i = _g++;
			indices.push(i);
		}
		this.triIndexes = h3d_Indexes.alloc(indices);
		var this1 = new Array(0);
		var indices = this1;
		var p = 0;
		var _g = 0;
		var _g1 = 16383;
		while(_g < _g1) {
			var i = _g++;
			var k = i << 2;
			indices.push(k);
			indices.push(k + 1);
			indices.push(k + 2);
			indices.push(k + 2);
			indices.push(k + 1);
			indices.push(k + 3);
		}
		indices.push(65533);
		this.quadIndexes = h3d_Indexes.alloc(indices);
	}
	,garbage: function() {
	}
	,cleanManagedBuffers: function() {
		var _g = 1;
		var _g1 = this.buffers.length;
		while(_g < _g1) {
			var i = _g++;
			var b = this.buffers[i];
			var prev = null;
			while(b != null) {
				if(b.freeList.count == b.size) {
					b.dispose();
					if(prev == null) {
						this.buffers[i] = b.next;
					} else {
						prev.next = b.next;
					}
				} else {
					prev = b;
				}
				b = b.next;
			}
		}
	}
	,allocManaged: function(m) {
		if(m.vbuf != null) {
			return;
		}
		var mem = m.size * m.stride * 4;
		if(mem == 0) {
			return;
		}
		while(this.usedMemory + mem > 4294967296. || this.bufferCount >= 65536 || (m.vbuf = this.driver.allocVertexes(m)) == null) {
			if(this.driver.isDisposed()) {
				return;
			}
			var size = this.usedMemory - this.freeMemorySize();
			this.garbage();
			this.cleanManagedBuffers();
			if(this.usedMemory - this.freeMemorySize() == size) {
				if(this.bufferCount >= 65536) {
					throw haxe_Exception.thrown("Too many buffers");
				}
				throw haxe_Exception.thrown("Memory full (" + Math.ceil(size / 1024) + " KB," + this.bufferCount + " buffers)");
			}
		}
		this.usedMemory += mem;
		this.bufferCount++;
	}
	,freeManaged: function(m) {
		if(m.vbuf == null) {
			return;
		}
		this.driver.disposeVertexes(m.vbuf);
		m.vbuf = null;
		this.usedMemory -= m.size * m.stride * 4;
		this.bufferCount--;
		if((m.flags & 1 << h3d_BufferFlag.Managed._hx_index) == 0) {
			var c = this.buffers[0];
			var prev = null;
			while(c != null) {
				if(c == m) {
					if(prev == null) {
						this.buffers[0] = m.next;
					} else {
						prev.next = m.next;
					}
					break;
				}
				prev = c;
				c = c.next;
			}
		}
	}
	,allocBuffer: function(b,stride) {
		var max = (b.flags & 1 << h3d_BufferFlag.Quads._hx_index) != 0 ? 65532 : (b.flags & 1 << h3d_BufferFlag.Triangles._hx_index) != 0 ? 65533 : 65534;
		if(b.vertices > max && (b.flags & 1 << h3d_BufferFlag.UniformBuffer._hx_index) == 0 && (b.flags & 1 << h3d_BufferFlag.LargeBuffer._hx_index) == 0) {
			if(max == 65534) {
				throw haxe_Exception.thrown("Cannot split buffer with " + b.vertices + " vertices if it's not Quads/Triangles");
			}
			var rem = b.vertices - max;
			b.vertices = max;
			this.allocBuffer(b,stride);
			var n = b;
			while(n.next != null) n = n.next;
			var flags = [];
			var _g = 0;
			var _g1 = h3d_impl_MemoryManager.ALL_FLAGS;
			while(_g < _g1.length) {
				var f = _g1[_g];
				++_g;
				if((b.flags & 1 << f._hx_index) != 0) {
					flags.push(f);
				}
			}
			n.next = new h3d_Buffer(rem,stride,flags);
			return;
		}
		if((b.flags & 1 << h3d_BufferFlag.Managed._hx_index) == 0) {
			var flags = null;
			if((b.flags & 1 << h3d_BufferFlag.Dynamic._hx_index) != 0) {
				if(flags == null) {
					flags = [];
				}
				flags.push(h3d_BufferFlag.Dynamic);
			}
			if((b.flags & 1 << h3d_BufferFlag.UniformBuffer._hx_index) != 0) {
				if(flags == null) {
					flags = [];
				}
				flags.push(h3d_BufferFlag.UniformBuffer);
			}
			var m = new h3d_impl_ManagedBuffer(stride,b.vertices,flags);
			m.next = this.buffers[0];
			this.buffers[0] = m;
			if(!m.allocBuffer(b)) {
				throw haxe_Exception.thrown("assert");
			}
			return;
		}
		var m = this.buffers[stride];
		var prev = null;
		while(m != null) {
			if(m.allocBuffer(b)) {
				return;
			}
			prev = m;
			m = m.next;
		}
		var align = (b.flags & 1 << h3d_BufferFlag.Triangles._hx_index) != 0 ? 3 : (b.flags & 1 << h3d_BufferFlag.Quads._hx_index) != 0 ? 4 : 0;
		if(m == null && align > 0) {
			var total = b.vertices;
			var size = total;
			while(size > 2048) {
				m = this.buffers[stride];
				size >>= 1;
				size -= size % align;
				b.vertices = size;
				while(m != null) {
					if(m.allocBuffer(b)) {
						var flags = [];
						var _g = 0;
						var _g1 = h3d_impl_MemoryManager.ALL_FLAGS;
						while(_g < _g1.length) {
							var f = _g1[_g];
							++_g;
							if((b.flags & 1 << f._hx_index) != 0) {
								flags.push(f);
							}
						}
						b.next = new h3d_Buffer(total - size,stride,flags);
						return;
					}
					m = m.next;
				}
			}
			b.vertices = total;
		}
		m = new h3d_impl_ManagedBuffer(stride,65533,[h3d_BufferFlag.Managed]);
		if(prev == null) {
			this.buffers[stride] = m;
		} else {
			prev.next = m;
		}
		if(!m.allocBuffer(b)) {
			throw haxe_Exception.thrown("assert");
		}
	}
	,deleteIndexes: function(i) {
		HxOverrides.remove(this.indexes,i);
		this.driver.disposeIndexes(i.ibuf);
		i.ibuf = null;
		this.usedMemory -= i.count * (i.is32 ? 4 : 2);
	}
	,allocIndexes: function(i) {
		i.ibuf = this.driver.allocIndexes(i.count,i.is32);
		this.indexes.push(i);
		this.usedMemory += i.count * (i.is32 ? 4 : 2);
	}
	,memSize: function(t) {
		if((t.flags & 1 << h3d_mat_TextureFlags.AsyncLoading._hx_index) != 0 && (t.flags & 1 << h3d_mat_TextureFlags.Loading._hx_index) != 0) {
			return 4;
		}
		var size = hxd_Pixels.calcDataSize(t.width,t.height,t.format);
		if(t.get_mipLevels() > 0) {
			var _g = 1;
			var _g1 = t.get_mipLevels();
			while(_g < _g1) {
				var i = _g++;
				var w = t.width >> i;
				if(w == 0) {
					w = 1;
				}
				var h = t.height >> i;
				if(h == 0) {
					h = 1;
				}
				size += hxd_Pixels.calcDataSize(w,h,t.format);
			}
		}
		return size * t.get_layerCount();
	}
	,cleanTextures: function(force) {
		if(force == null) {
			force = true;
		}
		this.textures.sort($bind(this,this.sortByLRU));
		var _g = 0;
		var _g1 = this.textures;
		while(_g < _g1.length) {
			var t = _g1[_g];
			++_g;
			if(t.realloc == null || t.t == null && t.realloc == null) {
				continue;
			}
			if((force || t.get_lastFrame() < hxd_Timer.frameCount - 3600) && t.get_lastFrame() != h3d_mat_Texture.PREVENT_AUTO_DISPOSE) {
				t.dispose();
				return true;
			}
		}
		return false;
	}
	,sortByLRU: function(t1,t2) {
		return t1.get_lastFrame() - t2.get_lastFrame();
	}
	,deleteTexture: function(t) {
		if(!HxOverrides.remove(this.textures,t)) {
			return;
		}
		this.driver.disposeTexture(t);
		this.texMemory -= this.memSize(t);
	}
	,allocTexture: function(t) {
		while(true) {
			var free = this.cleanTextures(false);
			t.t = this.driver.allocTexture(t);
			if(t.t != null) {
				break;
			}
			if(this.driver.isDisposed()) {
				return;
			}
			while(this.cleanTextures(false)) {
			}
			if(!free && !this.cleanTextures(true)) {
				throw haxe_Exception.thrown("Maximum texture memory reached");
			}
		}
		this.textures.push(t);
		this.texMemory += this.memSize(t);
	}
	,allocDepth: function(b) {
		while(true) {
			var free = this.cleanTextures(false);
			b.b = this.driver.allocDepthBuffer(b);
			if(b.b != null) {
				break;
			}
			if(this.driver.isDisposed()) {
				return;
			}
			while(this.cleanTextures(false)) {
			}
			if(!free && !this.cleanTextures(true)) {
				throw haxe_Exception.thrown("Maximum texture memory reached");
			}
		}
		this.depths.push(b);
		this.texMemory += b.width * b.height * 4;
	}
	,deleteDepth: function(b) {
		if(!HxOverrides.remove(this.depths,b)) {
			return;
		}
		this.driver.disposeDepthBuffer(b);
		this.texMemory -= b.width * b.height * 4;
	}
	,onContextLost: function() {
		this.dispose();
		this.initIndexes();
	}
	,dispose: function() {
		if(this.triIndexes != null) {
			this.triIndexes.dispose();
		}
		if(this.quadIndexes != null) {
			this.quadIndexes.dispose();
		}
		this.triIndexes = null;
		this.quadIndexes = null;
		var _g = 0;
		var _g1 = this.textures.slice();
		while(_g < _g1.length) {
			var t = _g1[_g];
			++_g;
			t.dispose();
		}
		var _g = 0;
		var _g1 = this.depths.slice();
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			b.dispose();
		}
		var _g = 0;
		var _g1 = this.buffers.slice();
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			var b1 = b;
			while(b1 != null) {
				b1.dispose();
				b1 = b1.next;
			}
		}
		var _g = 0;
		var _g1 = this.indexes.slice();
		while(_g < _g1.length) {
			var i = _g1[_g];
			++_g;
			i.dispose();
		}
		this.buffers = [];
		this.indexes = [];
		this.textures = [];
		this.bufferCount = 0;
		this.usedMemory = 0;
		this.texMemory = 0;
	}
	,freeMemorySize: function() {
		var size = 0;
		var _g = 0;
		var _g1 = this.buffers;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			var b1 = b;
			while(b1 != null) {
				var free = b1.freeList;
				while(free != null) {
					size += free.count * b1.stride * 4;
					free = free.next;
				}
				b1 = b1.next;
			}
		}
		return size;
	}
	,__class__: h3d_impl_MemoryManager
};
var h3d_impl_NullDriver = function() {
};
$hxClasses["h3d.impl.NullDriver"] = h3d_impl_NullDriver;
h3d_impl_NullDriver.__name__ = "h3d.impl.NullDriver";
h3d_impl_NullDriver.__super__ = h3d_impl_Driver;
h3d_impl_NullDriver.prototype = $extend(h3d_impl_Driver.prototype,{
	hasFeature: function(f) {
		return true;
	}
	,isSupportedFormat: function(fmt) {
		return true;
	}
	,isDisposed: function() {
		return false;
	}
	,init: function(onCreate,forceSoftware) {
		if(forceSoftware == null) {
			forceSoftware = false;
		}
		onCreate(false);
	}
	,selectShader: function(shader) {
		if(this.cur == shader) {
			return false;
		}
		this.cur = shader;
		return true;
	}
	,getShaderInputNames: function() {
		var names = [];
		var _g = 0;
		var _g1 = this.cur.vertex.data.vars;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			if(v.kind == hxsl_VarKind.Input) {
				names.push(v.name);
			}
		}
		return h3d_impl_InputNames.get(names);
	}
	,allocTexture: function(t) {
		return { };
	}
	,allocIndexes: function(count,is32) {
		return { };
	}
	,allocVertexes: function(m) {
		return { };
	}
	,__class__: h3d_impl_NullDriver
});
var h3d_impl_TextureCache = function(ctx) {
	this.position = 0;
	this.ctx = ctx;
	this.cache = [];
	var engine = h3d_Engine.CURRENT;
	this.defaultFormat = h3d_mat_Texture.nativeFormat;
	this.defaultDepthBuffer = h3d_mat_DepthBuffer.getDefault();
};
$hxClasses["h3d.impl.TextureCache"] = h3d_impl_TextureCache;
h3d_impl_TextureCache.__name__ = "h3d.impl.TextureCache";
h3d_impl_TextureCache.prototype = {
	begin: function() {
		while(this.cache.length > this.position) {
			var t = this.cache.pop();
			if(t != null) {
				t.dispose();
			}
		}
		this.position = 0;
	}
	,lookupTarget: function(name,width,height,format,isCube) {
		var t = this.cache[this.position];
		var _g = this.position + 1;
		var _g1 = this.cache.length;
		while(_g < _g1) {
			var i = _g++;
			var t2 = this.cache[i];
			if(t2 != null && !(t2.t == null && t2.realloc == null) && t2.width == width && t2.height == height && t2.format == format && isCube == ((t2.flags & 1 << h3d_mat_TextureFlags.Cube._hx_index) != 0)) {
				this.cache[this.position] = t2;
				this.cache[i] = t;
				return t2;
			}
		}
		if(t != null && t.name == name) {
			t.dispose();
			t = null;
		}
		var flags = [h3d_mat_TextureFlags.Target];
		if(isCube) {
			flags.push(h3d_mat_TextureFlags.Cube);
		}
		var newt = new h3d_mat_Texture(width,height,flags,format);
		newt.realloc = function() {
		};
		if(t != null) {
			this.cache.splice(this.position,0,newt);
		} else {
			this.cache[this.position] = newt;
		}
		return newt;
	}
	,allocTarget: function(name,width,height,defaultDepth,format,isCube) {
		if(isCube == null) {
			isCube = false;
		}
		if(defaultDepth == null) {
			defaultDepth = true;
		}
		var t = this.cache[this.position];
		if(format == null) {
			format = this.defaultFormat;
		}
		if(t == null || t.t == null && t.realloc == null || t.width != width || t.height != height || t.format != format || isCube != ((t.flags & 1 << h3d_mat_TextureFlags.Cube._hx_index) != 0)) {
			t = this.lookupTarget(name,width,height,format,isCube);
		}
		t.depthBuffer = defaultDepth ? this.defaultDepthBuffer : null;
		t.setName(name);
		this.position++;
		return t;
	}
	,allocTileTarget: function(name,tile,defaultDepth,format) {
		if(defaultDepth == null) {
			defaultDepth = false;
		}
		return this.allocTarget(name,Math.ceil(tile.width + tile.x) - Math.floor(tile.x),Math.ceil(tile.height + tile.y) - Math.floor(tile.y),defaultDepth,format);
	}
	,dispose: function() {
		var _g = 0;
		var _g1 = this.cache;
		while(_g < _g1.length) {
			var t = _g1[_g];
			++_g;
			t.dispose();
		}
		this.cache = [];
	}
	,__class__: h3d_impl_TextureCache
};
var hxd_impl_AnyProps = function() { };
$hxClasses["hxd.impl.AnyProps"] = hxd_impl_AnyProps;
hxd_impl_AnyProps.__name__ = "hxd.impl.AnyProps";
hxd_impl_AnyProps.prototype = {
	set_props: function(p) {
		this.props = p;
		this.refreshProps();
		return p;
	}
	,getDefaultProps: function(kind) {
		return { };
	}
	,refreshProps: function() {
	}
	,__class__: hxd_impl_AnyProps
};
var h3d_mat_BaseMaterial = function(shader) {
	if(shader != null) {
		this.addPass(new h3d_mat_Pass("default",null)).addShader(shader);
	}
};
$hxClasses["h3d.mat.BaseMaterial"] = h3d_mat_BaseMaterial;
h3d_mat_BaseMaterial.__name__ = "h3d.mat.BaseMaterial";
h3d_mat_BaseMaterial.__super__ = hxd_impl_AnyProps;
h3d_mat_BaseMaterial.prototype = $extend(hxd_impl_AnyProps.prototype,{
	addPass: function(p) {
		var prev = null;
		var cur = this.passes;
		while(cur != null) {
			prev = cur;
			cur = cur.nextPass;
		}
		if(prev == null) {
			this.passes = p;
		} else {
			prev.nextPass = p;
		}
		p.nextPass = null;
		return p;
	}
	,removePass: function(p) {
		var prev = null;
		var cur = this.passes;
		while(cur != null) {
			if(cur == p) {
				if(prev == null) {
					this.passes = p.nextPass;
				} else {
					prev.nextPass = p.nextPass;
				}
				p.nextPass = null;
				return true;
			}
			prev = cur;
			cur = cur.nextPass;
		}
		return false;
	}
	,getPass: function(name) {
		var p = this.passes;
		while(p != null) {
			if(p.name == name) {
				return p;
			}
			p = p.nextPass;
		}
		return null;
	}
	,__class__: h3d_mat_BaseMaterial
});
var h3d_mat_Face = $hxEnums["h3d.mat.Face"] = { __ename__:true,__constructs__:null
	,None: {_hx_name:"None",_hx_index:0,__enum__:"h3d.mat.Face",toString:$estr}
	,Back: {_hx_name:"Back",_hx_index:1,__enum__:"h3d.mat.Face",toString:$estr}
	,Front: {_hx_name:"Front",_hx_index:2,__enum__:"h3d.mat.Face",toString:$estr}
	,Both: {_hx_name:"Both",_hx_index:3,__enum__:"h3d.mat.Face",toString:$estr}
};
h3d_mat_Face.__constructs__ = [h3d_mat_Face.None,h3d_mat_Face.Back,h3d_mat_Face.Front,h3d_mat_Face.Both];
h3d_mat_Face.__empty_constructs__ = [h3d_mat_Face.None,h3d_mat_Face.Back,h3d_mat_Face.Front,h3d_mat_Face.Both];
var h3d_mat_Blend = $hxEnums["h3d.mat.Blend"] = { __ename__:true,__constructs__:null
	,One: {_hx_name:"One",_hx_index:0,__enum__:"h3d.mat.Blend",toString:$estr}
	,Zero: {_hx_name:"Zero",_hx_index:1,__enum__:"h3d.mat.Blend",toString:$estr}
	,SrcAlpha: {_hx_name:"SrcAlpha",_hx_index:2,__enum__:"h3d.mat.Blend",toString:$estr}
	,SrcColor: {_hx_name:"SrcColor",_hx_index:3,__enum__:"h3d.mat.Blend",toString:$estr}
	,DstAlpha: {_hx_name:"DstAlpha",_hx_index:4,__enum__:"h3d.mat.Blend",toString:$estr}
	,DstColor: {_hx_name:"DstColor",_hx_index:5,__enum__:"h3d.mat.Blend",toString:$estr}
	,OneMinusSrcAlpha: {_hx_name:"OneMinusSrcAlpha",_hx_index:6,__enum__:"h3d.mat.Blend",toString:$estr}
	,OneMinusSrcColor: {_hx_name:"OneMinusSrcColor",_hx_index:7,__enum__:"h3d.mat.Blend",toString:$estr}
	,OneMinusDstAlpha: {_hx_name:"OneMinusDstAlpha",_hx_index:8,__enum__:"h3d.mat.Blend",toString:$estr}
	,OneMinusDstColor: {_hx_name:"OneMinusDstColor",_hx_index:9,__enum__:"h3d.mat.Blend",toString:$estr}
	,ConstantColor: {_hx_name:"ConstantColor",_hx_index:10,__enum__:"h3d.mat.Blend",toString:$estr}
	,ConstantAlpha: {_hx_name:"ConstantAlpha",_hx_index:11,__enum__:"h3d.mat.Blend",toString:$estr}
	,OneMinusConstantColor: {_hx_name:"OneMinusConstantColor",_hx_index:12,__enum__:"h3d.mat.Blend",toString:$estr}
	,OneMinusConstantAlpha: {_hx_name:"OneMinusConstantAlpha",_hx_index:13,__enum__:"h3d.mat.Blend",toString:$estr}
	,SrcAlphaSaturate: {_hx_name:"SrcAlphaSaturate",_hx_index:14,__enum__:"h3d.mat.Blend",toString:$estr}
};
h3d_mat_Blend.__constructs__ = [h3d_mat_Blend.One,h3d_mat_Blend.Zero,h3d_mat_Blend.SrcAlpha,h3d_mat_Blend.SrcColor,h3d_mat_Blend.DstAlpha,h3d_mat_Blend.DstColor,h3d_mat_Blend.OneMinusSrcAlpha,h3d_mat_Blend.OneMinusSrcColor,h3d_mat_Blend.OneMinusDstAlpha,h3d_mat_Blend.OneMinusDstColor,h3d_mat_Blend.ConstantColor,h3d_mat_Blend.ConstantAlpha,h3d_mat_Blend.OneMinusConstantColor,h3d_mat_Blend.OneMinusConstantAlpha,h3d_mat_Blend.SrcAlphaSaturate];
h3d_mat_Blend.__empty_constructs__ = [h3d_mat_Blend.One,h3d_mat_Blend.Zero,h3d_mat_Blend.SrcAlpha,h3d_mat_Blend.SrcColor,h3d_mat_Blend.DstAlpha,h3d_mat_Blend.DstColor,h3d_mat_Blend.OneMinusSrcAlpha,h3d_mat_Blend.OneMinusSrcColor,h3d_mat_Blend.OneMinusDstAlpha,h3d_mat_Blend.OneMinusDstColor,h3d_mat_Blend.ConstantColor,h3d_mat_Blend.ConstantAlpha,h3d_mat_Blend.OneMinusConstantColor,h3d_mat_Blend.OneMinusConstantAlpha,h3d_mat_Blend.SrcAlphaSaturate];
var h3d_mat_Compare = $hxEnums["h3d.mat.Compare"] = { __ename__:true,__constructs__:null
	,Always: {_hx_name:"Always",_hx_index:0,__enum__:"h3d.mat.Compare",toString:$estr}
	,Never: {_hx_name:"Never",_hx_index:1,__enum__:"h3d.mat.Compare",toString:$estr}
	,Equal: {_hx_name:"Equal",_hx_index:2,__enum__:"h3d.mat.Compare",toString:$estr}
	,NotEqual: {_hx_name:"NotEqual",_hx_index:3,__enum__:"h3d.mat.Compare",toString:$estr}
	,Greater: {_hx_name:"Greater",_hx_index:4,__enum__:"h3d.mat.Compare",toString:$estr}
	,GreaterEqual: {_hx_name:"GreaterEqual",_hx_index:5,__enum__:"h3d.mat.Compare",toString:$estr}
	,Less: {_hx_name:"Less",_hx_index:6,__enum__:"h3d.mat.Compare",toString:$estr}
	,LessEqual: {_hx_name:"LessEqual",_hx_index:7,__enum__:"h3d.mat.Compare",toString:$estr}
};
h3d_mat_Compare.__constructs__ = [h3d_mat_Compare.Always,h3d_mat_Compare.Never,h3d_mat_Compare.Equal,h3d_mat_Compare.NotEqual,h3d_mat_Compare.Greater,h3d_mat_Compare.GreaterEqual,h3d_mat_Compare.Less,h3d_mat_Compare.LessEqual];
h3d_mat_Compare.__empty_constructs__ = [h3d_mat_Compare.Always,h3d_mat_Compare.Never,h3d_mat_Compare.Equal,h3d_mat_Compare.NotEqual,h3d_mat_Compare.Greater,h3d_mat_Compare.GreaterEqual,h3d_mat_Compare.Less,h3d_mat_Compare.LessEqual];
var h3d_mat_StencilOp = $hxEnums["h3d.mat.StencilOp"] = { __ename__:true,__constructs__:null
	,Keep: {_hx_name:"Keep",_hx_index:0,__enum__:"h3d.mat.StencilOp",toString:$estr}
	,Zero: {_hx_name:"Zero",_hx_index:1,__enum__:"h3d.mat.StencilOp",toString:$estr}
	,Replace: {_hx_name:"Replace",_hx_index:2,__enum__:"h3d.mat.StencilOp",toString:$estr}
	,Increment: {_hx_name:"Increment",_hx_index:3,__enum__:"h3d.mat.StencilOp",toString:$estr}
	,IncrementWrap: {_hx_name:"IncrementWrap",_hx_index:4,__enum__:"h3d.mat.StencilOp",toString:$estr}
	,Decrement: {_hx_name:"Decrement",_hx_index:5,__enum__:"h3d.mat.StencilOp",toString:$estr}
	,DecrementWrap: {_hx_name:"DecrementWrap",_hx_index:6,__enum__:"h3d.mat.StencilOp",toString:$estr}
	,Invert: {_hx_name:"Invert",_hx_index:7,__enum__:"h3d.mat.StencilOp",toString:$estr}
};
h3d_mat_StencilOp.__constructs__ = [h3d_mat_StencilOp.Keep,h3d_mat_StencilOp.Zero,h3d_mat_StencilOp.Replace,h3d_mat_StencilOp.Increment,h3d_mat_StencilOp.IncrementWrap,h3d_mat_StencilOp.Decrement,h3d_mat_StencilOp.DecrementWrap,h3d_mat_StencilOp.Invert];
h3d_mat_StencilOp.__empty_constructs__ = [h3d_mat_StencilOp.Keep,h3d_mat_StencilOp.Zero,h3d_mat_StencilOp.Replace,h3d_mat_StencilOp.Increment,h3d_mat_StencilOp.IncrementWrap,h3d_mat_StencilOp.Decrement,h3d_mat_StencilOp.DecrementWrap,h3d_mat_StencilOp.Invert];
var h3d_mat_MipMap = $hxEnums["h3d.mat.MipMap"] = { __ename__:true,__constructs__:null
	,None: {_hx_name:"None",_hx_index:0,__enum__:"h3d.mat.MipMap",toString:$estr}
	,Nearest: {_hx_name:"Nearest",_hx_index:1,__enum__:"h3d.mat.MipMap",toString:$estr}
	,Linear: {_hx_name:"Linear",_hx_index:2,__enum__:"h3d.mat.MipMap",toString:$estr}
};
h3d_mat_MipMap.__constructs__ = [h3d_mat_MipMap.None,h3d_mat_MipMap.Nearest,h3d_mat_MipMap.Linear];
h3d_mat_MipMap.__empty_constructs__ = [h3d_mat_MipMap.None,h3d_mat_MipMap.Nearest,h3d_mat_MipMap.Linear];
var h3d_mat_Filter = $hxEnums["h3d.mat.Filter"] = { __ename__:true,__constructs__:null
	,Nearest: {_hx_name:"Nearest",_hx_index:0,__enum__:"h3d.mat.Filter",toString:$estr}
	,Linear: {_hx_name:"Linear",_hx_index:1,__enum__:"h3d.mat.Filter",toString:$estr}
};
h3d_mat_Filter.__constructs__ = [h3d_mat_Filter.Nearest,h3d_mat_Filter.Linear];
h3d_mat_Filter.__empty_constructs__ = [h3d_mat_Filter.Nearest,h3d_mat_Filter.Linear];
var h3d_mat_Wrap = $hxEnums["h3d.mat.Wrap"] = { __ename__:true,__constructs__:null
	,Clamp: {_hx_name:"Clamp",_hx_index:0,__enum__:"h3d.mat.Wrap",toString:$estr}
	,Repeat: {_hx_name:"Repeat",_hx_index:1,__enum__:"h3d.mat.Wrap",toString:$estr}
};
h3d_mat_Wrap.__constructs__ = [h3d_mat_Wrap.Clamp,h3d_mat_Wrap.Repeat];
h3d_mat_Wrap.__empty_constructs__ = [h3d_mat_Wrap.Clamp,h3d_mat_Wrap.Repeat];
var h3d_mat_Operation = $hxEnums["h3d.mat.Operation"] = { __ename__:true,__constructs__:null
	,Add: {_hx_name:"Add",_hx_index:0,__enum__:"h3d.mat.Operation",toString:$estr}
	,Sub: {_hx_name:"Sub",_hx_index:1,__enum__:"h3d.mat.Operation",toString:$estr}
	,ReverseSub: {_hx_name:"ReverseSub",_hx_index:2,__enum__:"h3d.mat.Operation",toString:$estr}
	,Min: {_hx_name:"Min",_hx_index:3,__enum__:"h3d.mat.Operation",toString:$estr}
	,Max: {_hx_name:"Max",_hx_index:4,__enum__:"h3d.mat.Operation",toString:$estr}
};
h3d_mat_Operation.__constructs__ = [h3d_mat_Operation.Add,h3d_mat_Operation.Sub,h3d_mat_Operation.ReverseSub,h3d_mat_Operation.Min,h3d_mat_Operation.Max];
h3d_mat_Operation.__empty_constructs__ = [h3d_mat_Operation.Add,h3d_mat_Operation.Sub,h3d_mat_Operation.ReverseSub,h3d_mat_Operation.Min,h3d_mat_Operation.Max];
var h3d_mat_TextureFlags = $hxEnums["h3d.mat.TextureFlags"] = { __ename__:true,__constructs__:null
	,Target: {_hx_name:"Target",_hx_index:0,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,Cube: {_hx_name:"Cube",_hx_index:1,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,MipMapped: {_hx_name:"MipMapped",_hx_index:2,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,ManualMipMapGen: {_hx_name:"ManualMipMapGen",_hx_index:3,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,IsNPOT: {_hx_name:"IsNPOT",_hx_index:4,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,NoAlloc: {_hx_name:"NoAlloc",_hx_index:5,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,Dynamic: {_hx_name:"Dynamic",_hx_index:6,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,AlphaPremultiplied: {_hx_name:"AlphaPremultiplied",_hx_index:7,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,WasCleared: {_hx_name:"WasCleared",_hx_index:8,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,Loading: {_hx_name:"Loading",_hx_index:9,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,Serialize: {_hx_name:"Serialize",_hx_index:10,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,IsArray: {_hx_name:"IsArray",_hx_index:11,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,AsyncLoading: {_hx_name:"AsyncLoading",_hx_index:12,__enum__:"h3d.mat.TextureFlags",toString:$estr}
};
h3d_mat_TextureFlags.__constructs__ = [h3d_mat_TextureFlags.Target,h3d_mat_TextureFlags.Cube,h3d_mat_TextureFlags.MipMapped,h3d_mat_TextureFlags.ManualMipMapGen,h3d_mat_TextureFlags.IsNPOT,h3d_mat_TextureFlags.NoAlloc,h3d_mat_TextureFlags.Dynamic,h3d_mat_TextureFlags.AlphaPremultiplied,h3d_mat_TextureFlags.WasCleared,h3d_mat_TextureFlags.Loading,h3d_mat_TextureFlags.Serialize,h3d_mat_TextureFlags.IsArray,h3d_mat_TextureFlags.AsyncLoading];
h3d_mat_TextureFlags.__empty_constructs__ = [h3d_mat_TextureFlags.Target,h3d_mat_TextureFlags.Cube,h3d_mat_TextureFlags.MipMapped,h3d_mat_TextureFlags.ManualMipMapGen,h3d_mat_TextureFlags.IsNPOT,h3d_mat_TextureFlags.NoAlloc,h3d_mat_TextureFlags.Dynamic,h3d_mat_TextureFlags.AlphaPremultiplied,h3d_mat_TextureFlags.WasCleared,h3d_mat_TextureFlags.Loading,h3d_mat_TextureFlags.Serialize,h3d_mat_TextureFlags.IsArray,h3d_mat_TextureFlags.AsyncLoading];
var h3d_mat_Defaults = function() { };
$hxClasses["h3d.mat.Defaults"] = h3d_mat_Defaults;
h3d_mat_Defaults.__name__ = "h3d.mat.Defaults";
h3d_mat_Defaults.get_shadowShader = function() {
	var s = h3d_mat_Defaults.shadowShader;
	if(s == null) {
		s = new h3d_shader_Shadow();
		h3d_mat_Defaults.set_shadowShader(s);
		h3d_mat_Defaults.shadowShader.setPriority(-1);
	}
	return s;
};
h3d_mat_Defaults.set_shadowShader = function(s) {
	return h3d_mat_Defaults.shadowShader = s;
};
var h3d_mat_DepthFormat = $hxEnums["h3d.mat.DepthFormat"] = { __ename__:true,__constructs__:null
	,Depth16: {_hx_name:"Depth16",_hx_index:0,__enum__:"h3d.mat.DepthFormat",toString:$estr}
	,Depth24: {_hx_name:"Depth24",_hx_index:1,__enum__:"h3d.mat.DepthFormat",toString:$estr}
	,Depth24Stencil8: {_hx_name:"Depth24Stencil8",_hx_index:2,__enum__:"h3d.mat.DepthFormat",toString:$estr}
};
h3d_mat_DepthFormat.__constructs__ = [h3d_mat_DepthFormat.Depth16,h3d_mat_DepthFormat.Depth24,h3d_mat_DepthFormat.Depth24Stencil8];
h3d_mat_DepthFormat.__empty_constructs__ = [h3d_mat_DepthFormat.Depth16,h3d_mat_DepthFormat.Depth24,h3d_mat_DepthFormat.Depth24Stencil8];
var h3d_mat_DepthBuffer = function(width,height,format) {
	this.width = width;
	this.height = height;
	this.format = format;
	if(width > 0) {
		this.alloc();
	}
};
$hxClasses["h3d.mat.DepthBuffer"] = h3d_mat_DepthBuffer;
h3d_mat_DepthBuffer.__name__ = "h3d.mat.DepthBuffer";
h3d_mat_DepthBuffer.getDefault = function() {
	return h3d_Engine.CURRENT.driver.getDefaultDepthBuffer();
};
h3d_mat_DepthBuffer.prototype = {
	hasStencil: function() {
		switch(this.format._hx_index) {
		case 0:case 1:
			return false;
		case 2:
			return true;
		}
	}
	,alloc: function() {
		h3d_Engine.CURRENT.mem.allocDepth(this);
	}
	,dispose: function() {
		if(this.b != null) {
			h3d_Engine.CURRENT.mem.deleteDepth(this);
			this.b = null;
		}
	}
	,isDisposed: function() {
		return this.b == null;
	}
	,__class__: h3d_mat_DepthBuffer
};
var h3d_mat_Material = function(texture) {
	this.mshader = new h3d_shader_BaseMesh();
	this.set_blendMode(h2d_BlendMode.None);
	h3d_mat_BaseMaterial.call(this,this.mshader);
	this.set_texture(texture);
};
$hxClasses["h3d.mat.Material"] = h3d_mat_Material;
h3d_mat_Material.__name__ = "h3d.mat.Material";
h3d_mat_Material.__super__ = h3d_mat_BaseMaterial;
h3d_mat_Material.prototype = $extend(h3d_mat_BaseMaterial.prototype,{
	set_castShadows: function(v) {
		if(this.castShadows == v) {
			return v;
		}
		if(this.passes != null) {
			if(v) {
				this.addPass(new h3d_mat_Pass("shadow",null,this.passes)).set_isStatic(this.staticShadows);
			} else {
				this.removePass(this.getPass("shadow"));
			}
		}
		return this.castShadows = v;
	}
	,set_receiveShadows: function(v) {
		if(v == this.receiveShadows) {
			return v;
		}
		if(this.passes != null) {
			var shadows = h3d_mat_Defaults.get_shadowShader();
			if(v) {
				this.passes.addShader(shadows);
			} else {
				this.passes.removeShader(shadows);
			}
		}
		return this.receiveShadows = v;
	}
	,set_blendMode: function(v) {
		if(this.passes != null) {
			this.passes.setBlendMode(v);
			switch(v._hx_index) {
			case 0:
				this.passes.set_depthWrite(true);
				this.passes.setPassName("default");
				break;
			case 1:
				this.passes.set_depthWrite(true);
				this.passes.setPassName("alpha");
				break;
			case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:case 11:
				this.passes.set_depthWrite(false);
				this.passes.setPassName("additive");
				break;
			}
		}
		return this.blendMode = v;
	}
	,set_texture: function(t) {
		if(t == null) {
			if(this.textureShader != null) {
				this.passes.removeShader(this.textureShader);
				this.textureShader = null;
			}
		} else {
			if(this.textureShader == null) {
				this.textureShader = new h3d_shader_Texture();
				this.passes.addShader(this.textureShader);
			}
			this.textureShader.texture__ = t;
		}
		return t;
	}
	,getDefaultProps: function(type) {
		var props;
		if(type == null) {
			props = { kind : "Opaque", shadows : true, culling : true, light : true};
		} else {
			switch(type) {
			case "particles3D":case "trail3D":
				props = { kind : "Alpha", shadows : false, culling : false, light : true};
				break;
			case "ui":
				props = { kind : "Alpha", shadows : false, culling : false, light : false};
				break;
			default:
				props = { kind : "Opaque", shadows : true, culling : true, light : true};
			}
		}
		return props;
	}
	,refreshProps: function() {
		if(this.props == null || this.passes == null) {
			return;
		}
		var props = this.props;
		switch(props.kind) {
		case "Add":
			this.set_blendMode(h2d_BlendMode.Add);
			break;
		case "Alpha":
			this.set_blendMode(h2d_BlendMode.Alpha);
			break;
		case "AlphaKill":case "Hidden":case "Opaque":
			this.set_blendMode(h2d_BlendMode.None);
			break;
		case "SoftAdd":
			this.set_blendMode(h2d_BlendMode.SoftAdd);
			break;
		}
		var tshader = this.textureShader;
		if(tshader != null) {
			tshader.constModified = true;
			tshader.killAlpha__ = props.kind == "AlphaKill";
			tshader.killAlphaThreshold__ = 0.5;
		}
		this.passes.set_culling(props.kind == "Hidden" ? h3d_mat_Face.Both : props.culling ? h3d_mat_Face.Back : h3d_mat_Face.None);
		this.passes.set_enableLights(props.light);
		var v = props.shadows;
		this.set_castShadows(v);
		this.set_receiveShadows(v);
		if(this.castShadows && this.receiveShadows) {
			this.getPass("shadow").set_culling(this.passes.culling);
		}
	}
	,__class__: h3d_mat_Material
});
var h3d_mat_MaterialDatabase = function() {
};
$hxClasses["h3d.mat.MaterialDatabase"] = h3d_mat_MaterialDatabase;
h3d_mat_MaterialDatabase.__name__ = "h3d.mat.MaterialDatabase";
h3d_mat_MaterialDatabase.prototype = {
	__class__: h3d_mat_MaterialDatabase
};
var h3d_mat_MaterialSetup = function(name) {
	if(this.database == null) {
		this.database = new h3d_mat_MaterialDatabase();
	}
	this.name = name;
};
$hxClasses["h3d.mat.MaterialSetup"] = h3d_mat_MaterialSetup;
h3d_mat_MaterialSetup.__name__ = "h3d.mat.MaterialSetup";
h3d_mat_MaterialSetup.prototype = {
	createRenderer: function() {
		return new h3d_scene_fwd_Renderer();
	}
	,createLightSystem: function() {
		return new h3d_scene_fwd_LightSystem();
	}
	,createMaterial: function() {
		return new h3d_mat_Material();
	}
	,__class__: h3d_mat_MaterialSetup
};
var h3d_mat_Pass = function(name,shaders,parent) {
	this.layer = 0;
	this.bits = 0;
	this.parentPass = parent;
	this.shaders = shaders;
	this.setPassName(name);
	this.set_culling(h3d_mat_Face.Back);
	var src = h3d_mat_Blend.One;
	var dst = h3d_mat_Blend.Zero;
	this.set_blendSrc(src);
	this.set_blendAlphaSrc(src);
	this.set_blendDst(dst);
	this.set_blendAlphaDst(dst);
	this.depth(true,h3d_mat_Compare.Less);
	this.set_blendOp(this.set_blendAlphaOp(h3d_mat_Operation.Add));
	this.colorMask = 15;
};
$hxClasses["h3d.mat.Pass"] = h3d_mat_Pass;
h3d_mat_Pass.__name__ = "h3d.mat.Pass";
h3d_mat_Pass.prototype = {
	setPassName: function(name) {
		this.name = name;
		this.passId = hxsl_Globals.allocID(name);
	}
	,setBlendMode: function(b) {
		switch(b._hx_index) {
		case 0:
			var src = h3d_mat_Blend.One;
			var dst = h3d_mat_Blend.Zero;
			this.set_blendSrc(src);
			this.set_blendAlphaSrc(src);
			this.set_blendDst(dst);
			this.set_blendAlphaDst(dst);
			this.set_blendOp(h3d_mat_Operation.Add);
			this.set_blendAlphaOp(h3d_mat_Operation.Add);
			break;
		case 1:
			var src = h3d_mat_Blend.SrcAlpha;
			var dst = h3d_mat_Blend.OneMinusSrcAlpha;
			this.set_blendSrc(src);
			this.set_blendAlphaSrc(src);
			this.set_blendDst(dst);
			this.set_blendAlphaDst(dst);
			this.set_blendOp(h3d_mat_Operation.Add);
			this.set_blendAlphaOp(h3d_mat_Operation.Add);
			break;
		case 2:
			var src = h3d_mat_Blend.SrcAlpha;
			var dst = h3d_mat_Blend.One;
			this.set_blendSrc(src);
			this.set_blendAlphaSrc(src);
			this.set_blendDst(dst);
			this.set_blendAlphaDst(dst);
			this.set_blendOp(h3d_mat_Operation.Add);
			this.set_blendAlphaOp(h3d_mat_Operation.Add);
			break;
		case 3:
			var src = h3d_mat_Blend.One;
			var dst = h3d_mat_Blend.OneMinusSrcAlpha;
			this.set_blendSrc(src);
			this.set_blendAlphaSrc(src);
			this.set_blendDst(dst);
			this.set_blendAlphaDst(dst);
			this.set_blendOp(h3d_mat_Operation.Add);
			this.set_blendAlphaOp(h3d_mat_Operation.Add);
			break;
		case 4:
			var src = h3d_mat_Blend.OneMinusDstColor;
			var dst = h3d_mat_Blend.One;
			this.set_blendSrc(src);
			this.set_blendAlphaSrc(src);
			this.set_blendDst(dst);
			this.set_blendAlphaDst(dst);
			this.set_blendOp(h3d_mat_Operation.Add);
			this.set_blendAlphaOp(h3d_mat_Operation.Add);
			break;
		case 5:
			var src = h3d_mat_Blend.DstColor;
			var dst = h3d_mat_Blend.Zero;
			this.set_blendSrc(src);
			this.set_blendAlphaSrc(src);
			this.set_blendDst(dst);
			this.set_blendAlphaDst(dst);
			this.set_blendOp(h3d_mat_Operation.Add);
			this.set_blendAlphaOp(h3d_mat_Operation.Add);
			break;
		case 6:
			var src = h3d_mat_Blend.DstColor;
			var dst = h3d_mat_Blend.OneMinusSrcAlpha;
			this.set_blendSrc(src);
			this.set_blendAlphaSrc(src);
			this.set_blendDst(dst);
			this.set_blendAlphaDst(dst);
			this.set_blendOp(h3d_mat_Operation.Add);
			this.set_blendAlphaOp(h3d_mat_Operation.Add);
			break;
		case 7:
			var src = h3d_mat_Blend.Zero;
			var dst = h3d_mat_Blend.OneMinusSrcColor;
			this.set_blendSrc(src);
			this.set_blendAlphaSrc(src);
			this.set_blendDst(dst);
			this.set_blendAlphaDst(dst);
			this.set_blendOp(h3d_mat_Operation.Add);
			this.set_blendAlphaOp(h3d_mat_Operation.Add);
			break;
		case 8:
			var src = h3d_mat_Blend.One;
			var dst = h3d_mat_Blend.OneMinusSrcColor;
			this.set_blendSrc(src);
			this.set_blendAlphaSrc(src);
			this.set_blendDst(dst);
			this.set_blendAlphaDst(dst);
			this.set_blendOp(h3d_mat_Operation.Add);
			this.set_blendAlphaOp(h3d_mat_Operation.Add);
			break;
		case 9:
			var src = h3d_mat_Blend.SrcAlpha;
			var dst = h3d_mat_Blend.One;
			this.set_blendSrc(src);
			this.set_blendAlphaSrc(src);
			this.set_blendDst(dst);
			this.set_blendAlphaDst(dst);
			this.set_blendOp(h3d_mat_Operation.ReverseSub);
			this.set_blendAlphaOp(h3d_mat_Operation.ReverseSub);
			break;
		case 10:
			this.set_blendSrc(h3d_mat_Blend.Zero);
			this.set_blendAlphaSrc(h3d_mat_Blend.Zero);
			this.set_blendDst(h3d_mat_Blend.Zero);
			this.set_blendAlphaDst(h3d_mat_Blend.Zero);
			this.set_blendAlphaSrc(h3d_mat_Blend.Zero);
			this.set_blendAlphaDst(h3d_mat_Blend.Zero);
			this.set_blendAlphaOp(h3d_mat_Operation.Max);
			this.set_blendOp(h3d_mat_Operation.Max);
			break;
		case 11:
			this.set_blendSrc(h3d_mat_Blend.Zero);
			this.set_blendAlphaSrc(h3d_mat_Blend.Zero);
			this.set_blendDst(h3d_mat_Blend.Zero);
			this.set_blendAlphaDst(h3d_mat_Blend.Zero);
			this.set_blendAlphaSrc(h3d_mat_Blend.Zero);
			this.set_blendAlphaDst(h3d_mat_Blend.Zero);
			this.set_blendAlphaOp(h3d_mat_Operation.Min);
			this.set_blendOp(h3d_mat_Operation.Min);
			break;
		}
	}
	,depth: function(write,test) {
		this.set_depthWrite(write);
		this.set_depthTest(test);
	}
	,addShader: function(s) {
		if(s == null) {
			return null;
		}
		this.shaders = hxsl_ShaderList.addSort(s,this.shaders);
		return s;
	}
	,removeShader: function(s) {
		var sl = this.shaders;
		var prev = null;
		while(sl != null) {
			if(sl.s == s) {
				if(prev == null) {
					this.shaders = sl.next;
				} else {
					prev.next = sl.next;
				}
				return true;
			}
			prev = sl;
			sl = sl.next;
		}
		return false;
	}
	,getShader: function(t) {
		var s = this.shaders;
		while(s != this.parentShaders) {
			var value = s.s;
			var sh = js_Boot.__downcastCheck(value,t) ? value : null;
			if(sh != null) {
				return sh;
			}
			s = s.next;
		}
		return null;
	}
	,getShadersRec: function() {
		if(this.parentPass == null || this.parentShaders == this.parentPass.shaders) {
			return this.shaders;
		}
		var s = this.shaders;
		var prev = null;
		while(s != null && s != this.parentShaders) {
			prev = s;
			s = s.next;
		}
		this.parentShaders = this.parentPass.shaders;
		if(prev == null) {
			this.shaders = this.parentShaders;
		} else {
			prev.next = this.parentShaders;
		}
		return this.shaders;
	}
	,set_enableLights: function(v) {
		this.flags = this.flags & -2 | (v ? 1 : 0);
		return this.enableLights = v;
	}
	,set_isStatic: function(v) {
		this.flags = this.flags & -5 | (v ? 1 : 0) << 2;
		return this.isStatic = v;
	}
	,set_culling: function(v) {
		this.bits = this.bits & -4 | v._hx_index;
		return this.culling = v;
	}
	,set_depthWrite: function(v) {
		this.bits = this.bits & -5 | (v ? 1 : 0) << 2;
		return this.depthWrite = v;
	}
	,set_depthTest: function(v) {
		this.bits = this.bits & -57 | v._hx_index << 3;
		return this.depthTest = v;
	}
	,set_blendSrc: function(v) {
		this.bits = this.bits & -961 | v._hx_index << 6;
		return this.blendSrc = v;
	}
	,set_blendDst: function(v) {
		this.bits = this.bits & -15361 | v._hx_index << 10;
		return this.blendDst = v;
	}
	,set_blendAlphaSrc: function(v) {
		this.bits = this.bits & -245761 | v._hx_index << 14;
		return this.blendAlphaSrc = v;
	}
	,set_blendAlphaDst: function(v) {
		this.bits = this.bits & -3932161 | v._hx_index << 18;
		return this.blendAlphaDst = v;
	}
	,set_blendOp: function(v) {
		this.bits = this.bits & -29360129 | v._hx_index << 22;
		return this.blendOp = v;
	}
	,set_blendAlphaOp: function(v) {
		this.bits = this.bits & -234881025 | v._hx_index << 25;
		return this.blendAlphaOp = v;
	}
	,__class__: h3d_mat_Pass
};
var h3d_mat_Stencil = function() {
	this.opBits = 0;
	this.maskBits = 0;
	this.setOp(h3d_mat_StencilOp.Keep,h3d_mat_StencilOp.Keep,h3d_mat_StencilOp.Keep);
	this.setFunc(h3d_mat_Compare.Always);
};
$hxClasses["h3d.mat.Stencil"] = h3d_mat_Stencil;
h3d_mat_Stencil.__name__ = "h3d.mat.Stencil";
h3d_mat_Stencil.prototype = {
	setFront: function(stfail,dpfail,pass) {
		this.set_frontSTfail(stfail);
		this.set_frontDPfail(dpfail);
		this.set_frontPass(pass);
	}
	,setBack: function(stfail,dpfail,pass) {
		this.set_backSTfail(stfail);
		this.set_backDPfail(dpfail);
		this.set_backPass(pass);
	}
	,setOp: function(stfail,dpfail,pass) {
		this.setFront(stfail,dpfail,pass);
		this.setBack(stfail,dpfail,pass);
	}
	,setFunc: function(f,reference,readMask,writeMask) {
		if(writeMask == null) {
			writeMask = 255;
		}
		if(readMask == null) {
			readMask = 255;
		}
		if(reference == null) {
			reference = 0;
		}
		this.set_frontTest(this.set_backTest(f));
		this.set_reference(reference);
		this.set_readMask(readMask);
		this.set_writeMask(writeMask);
	}
	,set_readMask: function(v) {
		this.maskBits = this.maskBits & -256 | v & 255;
		return this.readMask = v;
	}
	,set_writeMask: function(v) {
		this.maskBits = this.maskBits & -65281 | (v & 255) << 8;
		return this.writeMask = v;
	}
	,set_reference: function(v) {
		this.maskBits = this.maskBits & -16711681 | (v & 255) << 16;
		return this.reference = v;
	}
	,set_frontTest: function(v) {
		this.opBits = this.opBits & -8 | v._hx_index;
		return this.frontTest = v;
	}
	,set_frontPass: function(v) {
		this.opBits = this.opBits & -57 | v._hx_index << 3;
		return this.frontPass = v;
	}
	,set_frontSTfail: function(v) {
		this.opBits = this.opBits & -449 | v._hx_index << 6;
		return this.frontSTfail = v;
	}
	,set_frontDPfail: function(v) {
		this.opBits = this.opBits & -3585 | v._hx_index << 9;
		return this.frontDPfail = v;
	}
	,set_backTest: function(v) {
		this.opBits = this.opBits & -28673 | v._hx_index << 12;
		return this.backTest = v;
	}
	,set_backPass: function(v) {
		this.opBits = this.opBits & -229377 | v._hx_index << 15;
		return this.backPass = v;
	}
	,set_backSTfail: function(v) {
		this.opBits = this.opBits & -1835009 | v._hx_index << 18;
		return this.backSTfail = v;
	}
	,set_backDPfail: function(v) {
		this.opBits = this.opBits & -14680065 | v._hx_index << 21;
		return this.backDPfail = v;
	}
	,__class__: h3d_mat_Stencil
};
var hxd_PixelFormat = $hxEnums["hxd.PixelFormat"] = { __ename__:true,__constructs__:null
	,ARGB: {_hx_name:"ARGB",_hx_index:0,__enum__:"hxd.PixelFormat",toString:$estr}
	,BGRA: {_hx_name:"BGRA",_hx_index:1,__enum__:"hxd.PixelFormat",toString:$estr}
	,RGBA: {_hx_name:"RGBA",_hx_index:2,__enum__:"hxd.PixelFormat",toString:$estr}
	,RGBA16F: {_hx_name:"RGBA16F",_hx_index:3,__enum__:"hxd.PixelFormat",toString:$estr}
	,RGBA32F: {_hx_name:"RGBA32F",_hx_index:4,__enum__:"hxd.PixelFormat",toString:$estr}
	,R8: {_hx_name:"R8",_hx_index:5,__enum__:"hxd.PixelFormat",toString:$estr}
	,R16F: {_hx_name:"R16F",_hx_index:6,__enum__:"hxd.PixelFormat",toString:$estr}
	,R32F: {_hx_name:"R32F",_hx_index:7,__enum__:"hxd.PixelFormat",toString:$estr}
	,RG8: {_hx_name:"RG8",_hx_index:8,__enum__:"hxd.PixelFormat",toString:$estr}
	,RG16F: {_hx_name:"RG16F",_hx_index:9,__enum__:"hxd.PixelFormat",toString:$estr}
	,RG32F: {_hx_name:"RG32F",_hx_index:10,__enum__:"hxd.PixelFormat",toString:$estr}
	,RGB8: {_hx_name:"RGB8",_hx_index:11,__enum__:"hxd.PixelFormat",toString:$estr}
	,RGB16F: {_hx_name:"RGB16F",_hx_index:12,__enum__:"hxd.PixelFormat",toString:$estr}
	,RGB32F: {_hx_name:"RGB32F",_hx_index:13,__enum__:"hxd.PixelFormat",toString:$estr}
	,SRGB: {_hx_name:"SRGB",_hx_index:14,__enum__:"hxd.PixelFormat",toString:$estr}
	,SRGB_ALPHA: {_hx_name:"SRGB_ALPHA",_hx_index:15,__enum__:"hxd.PixelFormat",toString:$estr}
	,RGB10A2: {_hx_name:"RGB10A2",_hx_index:16,__enum__:"hxd.PixelFormat",toString:$estr}
	,RG11B10UF: {_hx_name:"RG11B10UF",_hx_index:17,__enum__:"hxd.PixelFormat",toString:$estr}
	,R16U: {_hx_name:"R16U",_hx_index:18,__enum__:"hxd.PixelFormat",toString:$estr}
	,RGB16U: {_hx_name:"RGB16U",_hx_index:19,__enum__:"hxd.PixelFormat",toString:$estr}
	,RGBA16U: {_hx_name:"RGBA16U",_hx_index:20,__enum__:"hxd.PixelFormat",toString:$estr}
	,S3TC: ($_=function(v) { return {_hx_index:21,v:v,__enum__:"hxd.PixelFormat",toString:$estr}; },$_._hx_name="S3TC",$_.__params__ = ["v"],$_)
};
hxd_PixelFormat.__constructs__ = [hxd_PixelFormat.ARGB,hxd_PixelFormat.BGRA,hxd_PixelFormat.RGBA,hxd_PixelFormat.RGBA16F,hxd_PixelFormat.RGBA32F,hxd_PixelFormat.R8,hxd_PixelFormat.R16F,hxd_PixelFormat.R32F,hxd_PixelFormat.RG8,hxd_PixelFormat.RG16F,hxd_PixelFormat.RG32F,hxd_PixelFormat.RGB8,hxd_PixelFormat.RGB16F,hxd_PixelFormat.RGB32F,hxd_PixelFormat.SRGB,hxd_PixelFormat.SRGB_ALPHA,hxd_PixelFormat.RGB10A2,hxd_PixelFormat.RG11B10UF,hxd_PixelFormat.R16U,hxd_PixelFormat.RGB16U,hxd_PixelFormat.RGBA16U,hxd_PixelFormat.S3TC];
hxd_PixelFormat.__empty_constructs__ = [hxd_PixelFormat.ARGB,hxd_PixelFormat.BGRA,hxd_PixelFormat.RGBA,hxd_PixelFormat.RGBA16F,hxd_PixelFormat.RGBA32F,hxd_PixelFormat.R8,hxd_PixelFormat.R16F,hxd_PixelFormat.R32F,hxd_PixelFormat.RG8,hxd_PixelFormat.RG16F,hxd_PixelFormat.RG32F,hxd_PixelFormat.RGB8,hxd_PixelFormat.RGB16F,hxd_PixelFormat.RGB32F,hxd_PixelFormat.SRGB,hxd_PixelFormat.SRGB_ALPHA,hxd_PixelFormat.RGB10A2,hxd_PixelFormat.RG11B10UF,hxd_PixelFormat.R16U,hxd_PixelFormat.RGB16U,hxd_PixelFormat.RGBA16U];
var h3d_mat_Texture = function(w,h,flags,format) {
	var engine = h3d_Engine.CURRENT;
	this.mem = engine.mem;
	if(format == null) {
		format = h3d_mat_Texture.nativeFormat;
	}
	this.id = ++h3d_mat_Texture.UID;
	this.format = format;
	var this1 = 0;
	this.flags = this1;
	if(flags != null) {
		var _g = 0;
		while(_g < flags.length) {
			var f = flags[_g];
			++_g;
			this.flags |= 1 << f._hx_index;
		}
	}
	var tw = 1;
	var th = 1;
	while(tw < w) tw <<= 1;
	while(th < h) th <<= 1;
	if(tw != w || th != h) {
		this.flags |= 1 << h3d_mat_TextureFlags.IsNPOT._hx_index;
	}
	this.width = w;
	this.height = h;
	this.set_mipMap((this.flags & 1 << h3d_mat_TextureFlags.MipMapped._hx_index) != 0 ? h3d_mat_MipMap.Linear : h3d_mat_MipMap.None);
	this.set_filter(h3d_mat_Filter.Linear);
	this.set_wrap(h3d_mat_Wrap.Clamp);
	this.bits &= 32767;
	if((this.flags & 1 << h3d_mat_TextureFlags.NoAlloc._hx_index) == 0) {
		this.alloc();
	}
};
$hxClasses["h3d.mat.Texture"] = h3d_mat_Texture;
h3d_mat_Texture.__name__ = "h3d.mat.Texture";
h3d_mat_Texture.fromBitmap = function(bmp) {
	var t = new h3d_mat_Texture(bmp.ctx.canvas.width,bmp.ctx.canvas.height);
	t.uploadBitmap(bmp);
	return t;
};
h3d_mat_Texture.fromColor = function(color,alpha) {
	if(alpha == null) {
		alpha = 1.;
	}
	var engine = h3d_Engine.CURRENT;
	var aval = alpha * 255 | 0;
	if(aval < 0) {
		aval = 0;
	} else if(aval > 255) {
		aval = 255;
	}
	var key = color & 16777215 | aval << 24;
	var t = engine.textureColorCache.h[key];
	if(t != null) {
		return t;
	}
	var t = new h3d_mat_Texture(1,1,null);
	t.clear(color,alpha);
	t.realloc = function() {
		t.clear(color,alpha);
	};
	engine.textureColorCache.h[key] = t;
	return t;
};
h3d_mat_Texture.defaultCubeTexture = function() {
	var engine = h3d_Engine.CURRENT;
	var t = engine.resCache.h[h3d_mat_Texture.__id__];
	if(t != null) {
		return t;
	}
	t = new h3d_mat_Texture(1,1,[h3d_mat_TextureFlags.Cube]);
	t.clear(2105376);
	t.realloc = function() {
		t.clear(2105376);
	};
	engine.resCache.set(h3d_mat_Texture,t);
	return t;
};
h3d_mat_Texture.prototype = {
	set_lastFrame: function(lf) {
		if(this._lastFrame != h3d_mat_Texture.PREVENT_AUTO_DISPOSE) {
			this._lastFrame = lf;
		}
		return this._lastFrame;
	}
	,get_lastFrame: function() {
		return this._lastFrame;
	}
	,get_mipLevels: function() {
		if((this.flags & 1 << h3d_mat_TextureFlags.MipMapped._hx_index) == 0) {
			return 1;
		}
		if(this.customMipLevels > 0) {
			return this.customMipLevels;
		}
		var lv = 1;
		var w = this.width;
		var h = this.height;
		while(w >> lv >= 1 || h >> lv >= 1) ++lv;
		return lv;
	}
	,get_layerCount: function() {
		if((this.flags & 1 << h3d_mat_TextureFlags.Cube._hx_index) != 0) {
			return 6;
		} else {
			return 1;
		}
	}
	,alloc: function() {
		if(this.t == null) {
			this.mem.allocTexture(this);
		}
	}
	,toString: function() {
		var str = this.name;
		if(this.name == null) {
			str = "Texture_" + this.id;
		}
		return str + "(" + this.width + "x" + this.height + ")";
	}
	,setName: function(n) {
		this.name = n;
	}
	,set_mipMap: function(m) {
		this.bits = this.bits & -4 | m._hx_index;
		return this.mipMap = m;
	}
	,set_filter: function(f) {
		this.bits = this.bits & -25 | f._hx_index << 3;
		return this.filter = f;
	}
	,set_wrap: function(w) {
		this.bits = this.bits & -193 | w._hx_index << 6;
		return this.wrap = w;
	}
	,resize: function(width,height) {
		this.dispose();
		var tw = 1;
		var th = 1;
		while(tw < width) tw <<= 1;
		while(th < height) th <<= 1;
		if(tw != width || th != height) {
			this.flags |= 1 << h3d_mat_TextureFlags.IsNPOT._hx_index;
		} else {
			this.flags &= -1 - (1 << h3d_mat_TextureFlags.IsNPOT._hx_index);
		}
		this.width = width;
		this.height = height;
		if((this.flags & 1 << h3d_mat_TextureFlags.NoAlloc._hx_index) == 0) {
			this.alloc();
		}
	}
	,clear: function(color,alpha,layer) {
		if(layer == null) {
			layer = -1;
		}
		if(alpha == null) {
			alpha = 1.;
		}
		this.alloc();
		if(this.width == 0 || this.height == 0) {
			return;
		}
		if(this.width != 1 || this.height != 1) {
			var engine = h3d_Engine.CURRENT;
			color |= ((alpha < 0. ? 0. : alpha > 1. ? 1. : alpha) * 255 | 0) << 24;
			if(layer < 0) {
				var _g = 0;
				var _g1 = this.get_layerCount();
				while(_g < _g1) {
					var i = _g++;
					engine.pushTarget(this,i);
					engine.clear(color);
					engine.popTarget();
				}
			} else {
				engine.pushTarget(this,layer);
				engine.clear(color);
				engine.popTarget();
			}
		} else {
			var p = hxd_Pixels.alloc(this.width,this.height,h3d_mat_Texture.nativeFormat);
			var k = 0;
			var b = color & 255;
			var g = color >> 8 & 255;
			var r = color >> 16 & 255;
			var a = alpha * 255 | 0;
			if(a < 0) {
				a = 0;
			} else if(a > 255) {
				a = 255;
			}
			switch(h3d_mat_Texture.nativeFormat._hx_index) {
			case 1:
				var tmp = r;
				r = b;
				b = tmp;
				break;
			case 2:
				break;
			default:
				throw haxe_Exception.thrown("TODO");
			}
			var _g = 0;
			var _g1 = this.width * this.height;
			while(_g < _g1) {
				var i = _g++;
				p.bytes.b[k++] = r;
				p.bytes.b[k++] = g;
				p.bytes.b[k++] = b;
				p.bytes.b[k++] = a;
			}
			if(layer < 0) {
				var _g = 0;
				var _g1 = this.get_layerCount();
				while(_g < _g1) {
					var i = _g++;
					this.uploadPixels(p,0,i);
				}
			} else {
				this.uploadPixels(p,0,layer);
			}
			p.dispose();
		}
	}
	,checkSize: function(width,height,mip) {
		var mw = this.width >> mip;
		if(mw == 0) {
			mw = 1;
		}
		var mh = this.height >> mip;
		if(mh == 0) {
			mh = 1;
		}
		if(width != mw || height != mh) {
			throw haxe_Exception.thrown("Invalid upload size : " + width + "x" + height + " should be " + mw + "x" + mh);
		}
	}
	,checkMipMapGen: function(mipLevel,layer) {
		if(mipLevel == 0 && (this.flags & 1 << h3d_mat_TextureFlags.MipMapped._hx_index) != 0 && (this.flags & 1 << h3d_mat_TextureFlags.ManualMipMapGen._hx_index) == 0 && layer == this.get_layerCount() - 1) {
			this.mem.driver.generateMipMaps(this);
		}
	}
	,uploadBitmap: function(bmp,mipLevel,layer) {
		if(layer == null) {
			layer = 0;
		}
		if(mipLevel == null) {
			mipLevel = 0;
		}
		this.alloc();
		this.checkSize(bmp.ctx.canvas.width,bmp.ctx.canvas.height,mipLevel);
		this.mem.driver.uploadTextureBitmap(this,bmp,mipLevel,layer);
		this.flags |= 1 << h3d_mat_TextureFlags.WasCleared._hx_index;
		this.checkMipMapGen(mipLevel,layer);
	}
	,uploadPixels: function(pixels,mipLevel,layer) {
		if(layer == null) {
			layer = 0;
		}
		if(mipLevel == null) {
			mipLevel = 0;
		}
		this.alloc();
		this.checkSize(pixels.width,pixels.height,mipLevel);
		this.mem.driver.uploadTexturePixels(this,pixels,mipLevel,layer);
		this.flags |= 1 << h3d_mat_TextureFlags.WasCleared._hx_index;
		this.checkMipMapGen(mipLevel,layer);
	}
	,dispose: function() {
		if(this.t != null) {
			this.mem.deleteTexture(this);
		}
	}
	,__class__: h3d_mat_Texture
};
var h3d_mat_TextureArray = function(w,h,layers,flags,format) {
	this.layers = layers;
	if(flags == null) {
		flags = [];
	}
	flags.push(h3d_mat_TextureFlags.IsArray);
	h3d_mat_Texture.call(this,w,h,flags,format);
};
$hxClasses["h3d.mat.TextureArray"] = h3d_mat_TextureArray;
h3d_mat_TextureArray.__name__ = "h3d.mat.TextureArray";
h3d_mat_TextureArray.__super__ = h3d_mat_Texture;
h3d_mat_TextureArray.prototype = $extend(h3d_mat_Texture.prototype,{
	get_layerCount: function() {
		return this.layers;
	}
	,toString: function() {
		return h3d_mat_Texture.prototype.toString.call(this) + "[" + this.layers + "]";
	}
	,__class__: h3d_mat_TextureArray
});
var h3d_pass_Base = function(name) {
	this.name = name;
};
$hxClasses["h3d.pass.Base"] = h3d_pass_Base;
h3d_pass_Base.__name__ = "h3d.pass.Base";
h3d_pass_Base.prototype = {
	setContext: function(ctx) {
		this.ctx = ctx;
	}
	,draw: function(passes,sort) {
	}
	,__class__: h3d_pass_Base
};
var h3d_pass_ScreenFx = function(shader,output) {
	this.shader = shader;
	this.manager = new h3d_pass_ShaderManager(output);
	this.pass = new h3d_mat_Pass("screenfx",new hxsl_ShaderList(shader));
	this.pass.set_culling(h3d_mat_Face.None);
	this.pass.depth(false,h3d_mat_Compare.Always);
};
$hxClasses["h3d.pass.ScreenFx"] = h3d_pass_ScreenFx;
h3d_pass_ScreenFx.__name__ = "h3d.pass.ScreenFx";
h3d_pass_ScreenFx.prototype = {
	get_engine: function() {
		if(this._engine == null) {
			this._engine = h3d_Engine.CURRENT;
		}
		return this._engine;
	}
	,render: function() {
		if(this.primitive == null) {
			this.primitive = h3d_prim_Plane2D.get();
		}
		this.shader.flipY__ = this.get_engine().driver.hasFeature(h3d_impl_Feature.BottomLeftCoords) && this.get_engine().getCurrentTarget() != null ? -1 : 1;
		var shaders = this.pass.shaders;
		var rts = this.manager.compileShaders(shaders);
		this.get_engine().selectMaterial(this.pass);
		this.get_engine().selectShader(rts);
		if(this.buffers == null) {
			this.buffers = new h3d_shader_Buffers(rts);
		} else {
			var _this = this.buffers;
			_this.vertex.grow(rts.vertex);
			_this.fragment.grow(rts.fragment);
		}
		this.manager.fillGlobals(this.buffers,rts);
		this.manager.fillParams(this.buffers,rts,shaders);
		this.get_engine().uploadShaderBuffers(this.buffers,0);
		this.get_engine().uploadShaderBuffers(this.buffers,1);
		this.get_engine().uploadShaderBuffers(this.buffers,2);
		this.primitive.render(this.get_engine());
	}
	,dispose: function() {
	}
	,__class__: h3d_pass_ScreenFx
};
var h3d_pass_Blur = function(radius,gain,linear,quality) {
	if(quality == null) {
		quality = 1.;
	}
	if(linear == null) {
		linear = 0.;
	}
	if(gain == null) {
		gain = 1.;
	}
	if(radius == null) {
		radius = 1.;
	}
	this.cubeDir = [h3d_Matrix.L([0,0,-1,0,0,-1,0,0,1,0,0,0]),h3d_Matrix.L([0,0,1,0,0,-1,0,0,-1,0,0,0]),h3d_Matrix.L([1,0,0,0,0,0,1,0,0,1,0,0]),h3d_Matrix.L([1,0,0,0,0,0,-1,0,0,-1,0,0]),h3d_Matrix.L([1,0,0,0,0,-1,0,0,0,1,0,0]),h3d_Matrix.L([-1,0,0,0,0,-1,0,0,0,0,-1,0])];
	h3d_pass_ScreenFx.call(this,new h3d_shader_Blur());
	this.set_radius(radius);
	this.set_quality(quality);
	this.set_gain(gain);
	this.set_linear(linear);
};
$hxClasses["h3d.pass.Blur"] = h3d_pass_Blur;
h3d_pass_Blur.__name__ = "h3d.pass.Blur";
h3d_pass_Blur.__super__ = h3d_pass_ScreenFx;
h3d_pass_Blur.prototype = $extend(h3d_pass_ScreenFx.prototype,{
	set_radius: function(r) {
		if(this.radius == r) {
			return r;
		}
		this.values = null;
		return this.radius = r;
	}
	,set_quality: function(q) {
		if(this.quality == q) {
			return q;
		}
		this.values = null;
		return this.quality = q;
	}
	,set_gain: function(s) {
		if(this.gain == s) {
			return s;
		}
		this.values = null;
		return this.gain = s;
	}
	,set_linear: function(b) {
		if(this.linear == b) {
			return b;
		}
		this.values = null;
		return this.linear = b;
	}
	,gauss: function(x,s) {
		if(s <= 0) {
			if(x == 0) {
				return 1;
			} else {
				return 0;
			}
		}
		var sq = s * s;
		var p = Math.pow(2.718281828459,-(x * x) / (2 * sq));
		return p / Math.sqrt(2 * Math.PI * sq);
	}
	,calcValues: function() {
		this.values = [];
		this.offsets = [];
		var tot = 0.;
		var f = this.quality;
		var qadj = (f < 0. ? 0. : f > 1. ? 1. : f) * 0.7 + 0.3;
		var width;
		if(this.radius > 0) {
			var a = this.radius - 1;
			width = Math.ceil((a < 1 ? 1 : a) * qadj / 2);
		} else {
			width = 0;
		}
		var sigma = Math.sqrt(this.radius);
		var _g = 0;
		var _g1 = width + 1;
		while(_g < _g1) {
			var i = _g++;
			var i1 = i * 2;
			var i2 = i == 0 ? 0 : i * 2 - 1;
			var g1 = this.gauss(i1,sigma);
			var g2 = this.gauss(i2,sigma);
			var g = g1 + g2;
			this.values[i] = g;
			this.offsets[i] = i == 0 ? 0 : (g1 * i1 + g2 * i2) / (g * i * Math.sqrt(qadj));
			tot += g;
			if(i > 0) {
				tot += g;
			}
		}
		var minVal = this.values[0] * (0.01 / qadj);
		while(this.values.length > 2) {
			var last = this.values[this.values.length - 1];
			if(last > minVal) {
				break;
			}
			tot -= last * 2;
			this.values.pop();
		}
		tot /= this.gain;
		var _g = 0;
		var _g1 = this.values.length;
		while(_g < _g1) {
			var i = _g++;
			this.values[i] /= tot;
		}
		if(this.linear > 0) {
			var m = this.gain / (this.values.length * 2 - 1);
			var _g = 0;
			var _g1 = this.values.length;
			while(_g < _g1) {
				var i = _g++;
				var a = this.values[i];
				this.values[i] = a + this.linear * (m - a);
				var a1 = this.offsets[i];
				this.offsets[i] = a1 + this.linear * ((i == 0 ? 0 : (i * 2 - 0.5) / (i * qadj)) - a1);
			}
		}
	}
	,apply: function(ctx,src,output) {
		if(this.radius <= 0 && this.shader.fixedColor__ == null) {
			if(output != null) {
				h3d_pass_Copy.run(src,output);
			}
			return;
		}
		if(output == null) {
			output = src;
		}
		if(this.values == null) {
			this.calcValues();
		}
		var isCube = (src.flags & 1 << h3d_mat_TextureFlags.Cube._hx_index) != 0;
		var faceCount = isCube ? 6 : 1;
		var tmp = ctx.textures.allocTarget(src.name + "BlurTmp",src.width,src.height,false,src.format,isCube);
		var _this = this.shader;
		_this.constModified = true;
		_this.Quality__ = this.values.length;
		this.shader.values__ = this.values;
		this.shader.offsets__ = this.offsets;
		if(isCube) {
			this.shader.cubeTexture__ = src;
			var _this = this.shader;
			_this.constModified = true;
			_this.isCube__ = true;
		} else {
			this.shader.texture__ = src;
			var _this = this.shader;
			_this.constModified = true;
			_this.isCube__ = false;
		}
		var _this = this.shader.pixel__;
		var x = 1 / src.width;
		var y = 0;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = 0.;
		_this.w = 1.;
		var _g = 0;
		var _g1 = faceCount;
		while(_g < _g1) {
			var i = _g++;
			this.get_engine().pushTarget(tmp,i);
			if(isCube) {
				this.shader.cubeDir__ = this.cubeDir[i];
			}
			this.render();
			this.get_engine().popTarget();
		}
		if(isCube) {
			this.shader.cubeTexture__ = tmp;
		} else {
			this.shader.texture__ = tmp;
		}
		var _this = this.shader.pixel__;
		var x = 0;
		var y = 1 / src.height;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = 0.;
		_this.w = 1.;
		var outDepth = output.depthBuffer;
		output.depthBuffer = null;
		var _g = 0;
		var _g1 = faceCount;
		while(_g < _g1) {
			var i = _g++;
			this.get_engine().pushTarget(output,i);
			if(isCube) {
				this.shader.cubeDir__ = this.cubeDir[i];
			}
			this.render();
			this.get_engine().popTarget();
		}
		output.depthBuffer = outDepth;
	}
	,__class__: h3d_pass_Blur
});
var h3d_pass__$Border_BorderShader = function() {
	this.color__ = new h3d_Vector();
	h3d_shader_ScreenShader.call(this);
};
$hxClasses["h3d.pass._Border.BorderShader"] = h3d_pass__$Border_BorderShader;
h3d_pass__$Border_BorderShader.__name__ = "h3d.pass._Border.BorderShader";
h3d_pass__$Border_BorderShader.__super__ = h3d_shader_ScreenShader;
h3d_pass__$Border_BorderShader.prototype = $extend(h3d_shader_ScreenShader.prototype,{
	get_color: function() {
		return this.color__;
	}
	,set_color: function(_v) {
		return this.color__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.color__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	,__class__: h3d_pass__$Border_BorderShader
});
var h3d_pass_Border = function(width,height,size) {
	if(size == null) {
		size = 1;
	}
	h3d_pass_ScreenFx.call(this,new h3d_pass__$Border_BorderShader());
	var this1 = hxd__$FloatBuffer_Float32Expand._new(0);
	var bbuf = this1;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 0 / width * 2 - 1;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 1 - 0 / height * 2;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = width / width * 2 - 1;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 1 - 0 / height * 2;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 0 / width * 2 - 1;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 1 - size / height * 2;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = width / width * 2 - 1;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 1 - size / height * 2;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 0 / width * 2 - 1;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 1 - 0 / height * 2;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = size / width * 2 - 1;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 1 - 0 / height * 2;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 0 / width * 2 - 1;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 1 - height / height * 2;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = size / width * 2 - 1;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 1 - height / height * 2;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 0 / width * 2 - 1;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 1 - (height - size) / height * 2;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = width / width * 2 - 1;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 1 - (height - size) / height * 2;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 0 / width * 2 - 1;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 1 - height / height * 2;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = width / width * 2 - 1;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 1 - height / height * 2;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = (width - size) / width * 2 - 1;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 1 - 0 / height * 2;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = width / width * 2 - 1;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 1 - 0 / height * 2;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = (width - size) / width * 2 - 1;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 1 - height / height * 2;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = width / width * 2 - 1;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 1 - height / height * 2;
	this.primitive = new h3d_prim_RawPrimitive({ vbuf : bbuf, stride : 2, quads : true},true);
	var _this = this.shader.color__;
	var x = 1;
	var y = 1;
	var z = 1;
	var w = 1;
	if(w == null) {
		w = 1.;
	}
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	_this.x = x;
	_this.y = y;
	_this.z = z;
	_this.w = w;
};
$hxClasses["h3d.pass.Border"] = h3d_pass_Border;
h3d_pass_Border.__name__ = "h3d.pass.Border";
h3d_pass_Border.__super__ = h3d_pass_ScreenFx;
h3d_pass_Border.prototype = $extend(h3d_pass_ScreenFx.prototype,{
	dispose: function() {
		h3d_pass_ScreenFx.prototype.dispose.call(this);
		this.primitive.dispose();
	}
	,__class__: h3d_pass_Border
});
var h3d_pass_ColorMatrixShader = function() {
	this.maskChannel__ = new h3d_Vector();
	this.maskPower__ = 0;
	this.maskMatB__ = new h3d_Vector();
	this.maskMatA__ = new h3d_Vector();
	this.matrix2__ = new h3d_Matrix();
	this.matrix__ = new h3d_Matrix();
	h3d_shader_ScreenShader.call(this);
};
$hxClasses["h3d.pass.ColorMatrixShader"] = h3d_pass_ColorMatrixShader;
h3d_pass_ColorMatrixShader.__name__ = "h3d.pass.ColorMatrixShader";
h3d_pass_ColorMatrixShader.__super__ = h3d_shader_ScreenShader;
h3d_pass_ColorMatrixShader.prototype = $extend(h3d_shader_ScreenShader.prototype,{
	get_texture: function() {
		return this.texture__;
	}
	,set_texture: function(_v) {
		return this.texture__ = _v;
	}
	,get_matrix: function() {
		return this.matrix__;
	}
	,set_matrix: function(_v) {
		return this.matrix__ = _v;
	}
	,get_useAlpha: function() {
		return this.useAlpha__;
	}
	,set_useAlpha: function(_v) {
		this.constModified = true;
		return this.useAlpha__ = _v;
	}
	,get_useMask: function() {
		return this.useMask__;
	}
	,set_useMask: function(_v) {
		this.constModified = true;
		return this.useMask__ = _v;
	}
	,get_maskInvert: function() {
		return this.maskInvert__;
	}
	,set_maskInvert: function(_v) {
		this.constModified = true;
		return this.maskInvert__ = _v;
	}
	,get_hasSecondMatrix: function() {
		return this.hasSecondMatrix__;
	}
	,set_hasSecondMatrix: function(_v) {
		this.constModified = true;
		return this.hasSecondMatrix__ = _v;
	}
	,get_matrix2: function() {
		return this.matrix2__;
	}
	,set_matrix2: function(_v) {
		return this.matrix2__ = _v;
	}
	,get_mask: function() {
		return this.mask__;
	}
	,set_mask: function(_v) {
		return this.mask__ = _v;
	}
	,get_maskMatA: function() {
		return this.maskMatA__;
	}
	,set_maskMatA: function(_v) {
		return this.maskMatA__ = _v;
	}
	,get_maskMatB: function() {
		return this.maskMatB__;
	}
	,set_maskMatB: function(_v) {
		return this.maskMatB__ = _v;
	}
	,get_maskPower: function() {
		return this.maskPower__;
	}
	,set_maskPower: function(_v) {
		return this.maskPower__ = _v;
	}
	,get_maskChannel: function() {
		return this.maskChannel__;
	}
	,set_maskChannel: function(_v) {
		return this.maskChannel__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		if(this.useAlpha__) {
			this.constBits |= 1;
		}
		if(this.useMask__) {
			this.constBits |= 2;
		}
		if(this.maskInvert__) {
			this.constBits |= 4;
		}
		if(this.hasSecondMatrix__) {
			this.constBits |= 8;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.texture__;
		case 2:
			return this.matrix__;
		case 3:
			return this.useAlpha__;
		case 4:
			return this.useMask__;
		case 5:
			return this.maskInvert__;
		case 6:
			return this.hasSecondMatrix__;
		case 7:
			return this.matrix2__;
		case 8:
			return this.mask__;
		case 9:
			return this.maskMatA__;
		case 10:
			return this.maskMatB__;
		case 11:
			return this.maskPower__;
		case 12:
			return this.maskChannel__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 11:
			return this.maskPower__;
		default:
		}
		return 0.;
	}
	,__class__: h3d_pass_ColorMatrixShader
});
var h3d_pass__$Copy_ArrayCopyShader = function() {
	this.layer__ = 0;
	h3d_shader_ScreenShader.call(this);
};
$hxClasses["h3d.pass._Copy.ArrayCopyShader"] = h3d_pass__$Copy_ArrayCopyShader;
h3d_pass__$Copy_ArrayCopyShader.__name__ = "h3d.pass._Copy.ArrayCopyShader";
h3d_pass__$Copy_ArrayCopyShader.__super__ = h3d_shader_ScreenShader;
h3d_pass__$Copy_ArrayCopyShader.prototype = $extend(h3d_shader_ScreenShader.prototype,{
	get_texture: function() {
		return this.texture__;
	}
	,set_texture: function(_v) {
		return this.texture__ = _v;
	}
	,get_layer: function() {
		return this.layer__;
	}
	,set_layer: function(_v) {
		return this.layer__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.texture__;
		case 2:
			return this.layer__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	,__class__: h3d_pass__$Copy_ArrayCopyShader
});
var h3d_pass__$Copy_CopyShader = function() {
	h3d_shader_ScreenShader.call(this);
};
$hxClasses["h3d.pass._Copy.CopyShader"] = h3d_pass__$Copy_CopyShader;
h3d_pass__$Copy_CopyShader.__name__ = "h3d.pass._Copy.CopyShader";
h3d_pass__$Copy_CopyShader.__super__ = h3d_shader_ScreenShader;
h3d_pass__$Copy_CopyShader.prototype = $extend(h3d_shader_ScreenShader.prototype,{
	get_texture: function() {
		return this.texture__;
	}
	,set_texture: function(_v) {
		return this.texture__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.texture__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	,__class__: h3d_pass__$Copy_CopyShader
});
var h3d_pass_Copy = function() {
	h3d_pass_ScreenFx.call(this,new h3d_pass__$Copy_CopyShader());
};
$hxClasses["h3d.pass.Copy"] = h3d_pass_Copy;
h3d_pass_Copy.__name__ = "h3d.pass.Copy";
h3d_pass_Copy.run = function(from,to,blend,pass,layer) {
	var engine = h3d_Engine.CURRENT;
	if(to != null && from != null && (blend == null || blend == h2d_BlendMode.None) && pass == null && layer == null && engine.driver.copyTexture(from,to)) {
		return;
	}
	var inst = engine.resCache.h[h3d_pass_Copy.__id__];
	if(inst == null) {
		inst = new h3d_pass_Copy();
		engine.resCache.set(h3d_pass_Copy,inst);
	}
	inst.apply(from,to,blend,pass,layer);
};
h3d_pass_Copy.__super__ = h3d_pass_ScreenFx;
h3d_pass_Copy.prototype = $extend(h3d_pass_ScreenFx.prototype,{
	apply: function(from,to,blend,customPass,layer) {
		if(to != null) {
			this.get_engine().pushTarget(to,layer != null ? layer : 0);
		}
		this.shader.texture__ = from;
		if(customPass != null) {
			if(blend != null) {
				customPass.setBlendMode(blend);
			}
			var h = customPass.shaders;
			while(h.next != null) h = h.next;
			h.next = this.pass.shaders;
			var old = this.pass;
			this.pass = customPass;
			this.render();
			this.pass = old;
			h.next = null;
		} else {
			this.pass.setBlendMode(blend == null ? h2d_BlendMode.None : blend);
			this.render();
		}
		this.shader.texture__ = null;
		if(to != null) {
			this.get_engine().popTarget();
		}
	}
	,__class__: h3d_pass_Copy
});
var h3d_pass__$CubeCopy_CubeCopyShader = function() {
	this.mat__ = new h3d_Matrix();
	h3d_shader_ScreenShader.call(this);
};
$hxClasses["h3d.pass._CubeCopy.CubeCopyShader"] = h3d_pass__$CubeCopy_CubeCopyShader;
h3d_pass__$CubeCopy_CubeCopyShader.__name__ = "h3d.pass._CubeCopy.CubeCopyShader";
h3d_pass__$CubeCopy_CubeCopyShader.__super__ = h3d_shader_ScreenShader;
h3d_pass__$CubeCopy_CubeCopyShader.prototype = $extend(h3d_shader_ScreenShader.prototype,{
	get_texture: function() {
		return this.texture__;
	}
	,set_texture: function(_v) {
		return this.texture__ = _v;
	}
	,get_mat: function() {
		return this.mat__;
	}
	,set_mat: function(_v) {
		return this.mat__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.texture__;
		case 2:
			return this.mat__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	,__class__: h3d_pass__$CubeCopy_CubeCopyShader
});
var h3d_pass_Default = function(name) {
	this.defaultSort = ($_=new h3d_pass_SortByMaterial(),$bind($_,$_.sort));
	h3d_pass_Base.call(this,name);
	this.manager = new h3d_pass_ShaderManager(this.getOutputs());
	this.initGlobals();
};
$hxClasses["h3d.pass.Default"] = h3d_pass_Default;
h3d_pass_Default.__name__ = "h3d.pass.Default";
h3d_pass_Default.__super__ = h3d_pass_Base;
h3d_pass_Default.prototype = $extend(h3d_pass_Base.prototype,{
	getCurrentPixelSize: function() {
		var t = this.ctx.engine.getCurrentTarget();
		return new h3d_Vector(2 / (t == null ? this.ctx.engine.width : t.width),2 / (t == null ? this.ctx.engine.height : t.height));
	}
	,getOutputs: function() {
		return [hxsl_Output.Value("output.color")];
	}
	,processShaders: function(p,shaders) {
		var p = this.ctx.extraShaders;
		while(p != null) {
			shaders = this.ctx.allocShaderList(p.s,shaders);
			p = p.next;
		}
		return shaders;
	}
	,setupShaders: function(passes) {
		var lightInit = false;
		var _g_o = passes.current;
		while(_g_o != null) {
			var tmp = _g_o;
			_g_o = _g_o.next;
			var p = tmp;
			var shaders = p.pass.getShadersRec();
			shaders = this.processShaders(p,shaders);
			if(p.pass.enableLights && this.ctx.lightSystem != null) {
				if(!lightInit) {
					this.ctx.lightSystem.initGlobals(this.manager.globals);
					lightInit = true;
				}
				shaders = this.ctx.lightSystem.computeLight(p.obj,shaders);
			}
			p.shader = this.manager.compileShaders(shaders,p.pass.batchMode);
			p.shaders = shaders;
			var t = p.shader.fragment.textures;
			var tmp1;
			if(t != null) {
				var _g = t.type;
				if(_g._hx_index == 15) {
					var _g1 = _g.t;
					var _g2 = _g.size;
					tmp1 = true;
				} else {
					tmp1 = false;
				}
			} else {
				tmp1 = true;
			}
			if(tmp1) {
				p.texture = 0;
			} else {
				var _this = this.manager;
				var opt = true;
				if(opt == null) {
					opt = false;
				}
				var t1;
				if(t.perObjectGlobal != null) {
					var v = _this.globals.map.h[t.perObjectGlobal.gid];
					if(v == null) {
						throw haxe_Exception.thrown("Missing global value " + t.perObjectGlobal.path + " for shader " + _this.shaderInfo(shaders,t.perObjectGlobal.path));
					}
					var _g3 = t.type;
					var t2;
					if(_g3._hx_index == 17) {
						var _g4 = _g3.size;
						t2 = true;
					} else {
						t2 = false;
					}
					t1 = t2 ? v.texture : v;
				} else {
					var si = shaders;
					var n = t.instance;
					while(--n > 0) si = si.next;
					var v1 = si.s.getParamValue(t.index);
					if(v1 == null && !opt) {
						throw haxe_Exception.thrown("Missing param value " + Std.string(si.s) + "." + t.name);
					}
					t1 = v1;
				}
				p.texture = t1 == null ? 0 : t1.id;
			}
		}
	}
	,drawObject: function(p) {
		this.ctx.drawPass = p;
		this.ctx.engine.selectMaterial(p.pass);
		p.obj.draw(this.ctx);
	}
	,draw: function(passes,sort) {
		if(passes.current == null) {
			return;
		}
		var _g = 0;
		var _g1 = this.ctx.sharedGlobals;
		while(_g < _g1.length) {
			var g = _g1[_g];
			++_g;
			this.manager.globals.map.h[g.gid] = g.value;
		}
		this.setGlobals();
		this.setupShaders(passes);
		if(sort == null) {
			this.defaultSort(passes);
		} else {
			sort(passes);
		}
		this.ctx.currentManager = this.manager;
		var buf = this.ctx.shaderBuffers;
		var prevShader = null;
		var _g2_o = passes.current;
		while(_g2_o != null) {
			var tmp = _g2_o;
			_g2_o = _g2_o.next;
			var p = tmp;
			var v = p.obj.absPos;
			this.manager.globals.map.h[this.globalModelView_id] = v;
			if(p.shader.globals.h.hasOwnProperty(this.globalModelViewInverse_id)) {
				var v1 = p.obj.getInvPos();
				this.manager.globals.map.h[this.globalModelViewInverse_id] = v1;
			}
			if(prevShader != p.shader) {
				prevShader = p.shader;
				this.ctx.engine.selectShader(p.shader);
				if(buf == null) {
					buf = this.ctx.shaderBuffers = new h3d_shader_Buffers(p.shader);
				} else {
					var s = p.shader;
					buf.vertex.grow(s.vertex);
					buf.fragment.grow(s.fragment);
				}
				this.manager.fillGlobals(buf,p.shader);
				this.ctx.engine.uploadShaderBuffers(buf,0);
			}
			if(!p.pass.dynamicParameters) {
				this.manager.fillParams(buf,p.shader,p.shaders);
				this.ctx.engine.uploadShaderBuffers(buf,1);
				this.ctx.engine.uploadShaderBuffers(buf,2);
				this.ctx.engine.uploadShaderBuffers(buf,3);
			}
			this.drawObject(p);
		}
		var _this = this.ctx;
		_this.cachedPos = 0;
		_this.drawPass = null;
	}
	,initGlobals: function() {
		var this1 = hxsl_Globals.allocID("camera.view");
		this.cameraView_id = this1;
		var this1 = hxsl_Globals.allocID("camera.zNear");
		this.cameraNear_id = this1;
		var this1 = hxsl_Globals.allocID("camera.zFar");
		this.cameraFar_id = this1;
		var this1 = hxsl_Globals.allocID("camera.proj");
		this.cameraProj_id = this1;
		var this1 = hxsl_Globals.allocID("camera.position");
		this.cameraPos_id = this1;
		var this1 = hxsl_Globals.allocID("camera.projDiag");
		this.cameraProjDiag_id = this1;
		var this1 = hxsl_Globals.allocID("camera.projFlip");
		this.cameraProjFlip_id = this1;
		var this1 = hxsl_Globals.allocID("camera.viewProj");
		this.cameraViewProj_id = this1;
		var this1 = hxsl_Globals.allocID("camera.inverseViewProj");
		this.cameraInverseViewProj_id = this1;
		var this1 = hxsl_Globals.allocID("global.time");
		this.globalTime_id = this1;
		var this1 = hxsl_Globals.allocID("global.pixelSize");
		this.pixelSize_id = this1;
		var this1 = hxsl_Globals.allocID("global.modelView");
		this.globalModelView_id = this1;
		var this1 = hxsl_Globals.allocID("global.modelViewInverse");
		this.globalModelViewInverse_id = this1;
	}
	,setGlobals: function() {
		var v = this.ctx.camera.mcam;
		this.manager.globals.map.h[this.cameraView_id] = v;
		var v = this.ctx.camera.zNear;
		this.manager.globals.map.h[this.cameraNear_id] = v;
		var v = this.ctx.camera.zFar;
		this.manager.globals.map.h[this.cameraFar_id] = v;
		var v = this.ctx.camera.mproj;
		this.manager.globals.map.h[this.cameraProj_id] = v;
		var v = this.ctx.camera.pos;
		this.manager.globals.map.h[this.cameraPos_id] = v;
		var v = new h3d_Vector(this.ctx.camera.mproj._11,this.ctx.camera.mproj._22,this.ctx.camera.mproj._33,this.ctx.camera.mproj._44);
		this.manager.globals.map.h[this.cameraProjDiag_id] = v;
		var v = this.ctx.engine.driver.hasFeature(h3d_impl_Feature.BottomLeftCoords) && this.ctx.engine.getCurrentTarget() != null ? -1 : 1;
		this.manager.globals.map.h[this.cameraProjFlip_id] = v;
		var v = this.ctx.camera.m;
		this.manager.globals.map.h[this.cameraViewProj_id] = v;
		var v = this.ctx.camera.getInverseViewProj();
		this.manager.globals.map.h[this.cameraInverseViewProj_id] = v;
		var v = this.ctx.time;
		this.manager.globals.map.h[this.globalTime_id] = v;
		var v = this.getCurrentPixelSize();
		this.manager.globals.map.h[this.pixelSize_id] = v;
	}
	,__class__: h3d_pass_Default
});
var h3d_pass_Shadows = function(light) {
	this.pcfScale = 1.0;
	this.pcfQuality = 1;
	this.bias = 0.01;
	this.power = 30.0;
	this.samplingKind = h3d_pass_ShadowSamplingKind.None;
	this.size = 1024;
	this.mode = h3d_pass_RenderMode.None;
	this.enabled = true;
	if(this.format == null) {
		this.format = hxd_PixelFormat.R16F;
	}
	if(!h3d_Engine.CURRENT.driver.isSupportedFormat(this.format)) {
		this.format = h3d_mat_Texture.nativeFormat;
	}
	h3d_pass_Default.call(this,"shadow");
	this.light = light;
	this.blur = new h3d_pass_Blur(5);
	this.blur.set_quality(0.5);
	var _this = this.blur.shader;
	_this.constModified = true;
	_this.isDepth__ = this.format == h3d_mat_Texture.nativeFormat;
};
$hxClasses["h3d.pass.Shadows"] = h3d_pass_Shadows;
h3d_pass_Shadows.__name__ = "h3d.pass.Shadows";
h3d_pass_Shadows.__super__ = h3d_pass_Default;
h3d_pass_Shadows.prototype = $extend(h3d_pass_Default.prototype,{
	set_size: function(s) {
		if(s != this.size && this.staticTexture != null) {
			this.staticTexture.dispose();
			this.staticTexture = null;
		}
		return this.size = s;
	}
	,getShadowProj: function() {
		return this.lightCamera.m;
	}
	,isUsingWorldDist: function() {
		return false;
	}
	,getOutputs: function() {
		if(this.isUsingWorldDist()) {
			return [hxsl_Output.Swiz(hxsl_Output.Value("output.worldDist",1),[hxsl_Component.X,hxsl_Component.X,hxsl_Component.X,hxsl_Component.X])];
		}
		if(this.format == h3d_mat_Texture.nativeFormat) {
			return [hxsl_Output.PackFloat(hxsl_Output.Value("output.depth"))];
		}
		return [hxsl_Output.Swiz(hxsl_Output.Value("output.depth",1),[hxsl_Component.X,hxsl_Component.X,hxsl_Component.X,hxsl_Component.X])];
	}
	,createDefaultShadowMap: function() {
		var tex = h3d_mat_Texture.fromColor(16777215);
		tex.name = "defaultShadowMap";
		return tex;
	}
	,syncShader: function(texture) {
	}
	,filterPasses: function(passes) {
		if(!this.ctx.computingStatic) {
			switch(this.mode._hx_index) {
			case 0:
				return false;
			case 1:
				var tmp;
				if(this.staticTexture != null) {
					var _this = this.staticTexture;
					tmp = _this.t == null && _this.realloc == null;
				} else {
					tmp = true;
				}
				if(tmp) {
					this.staticTexture = this.createDefaultShadowMap();
				}
				this.syncShader(this.staticTexture);
				return false;
			case 2:
				return true;
			case 3:
				var tmp;
				if(this.staticTexture != null) {
					var _this = this.staticTexture;
					tmp = _this.t == null && _this.realloc == null;
				} else {
					tmp = true;
				}
				if(tmp) {
					this.staticTexture = this.createDefaultShadowMap();
				}
				var head = null;
				var prev = null;
				var disc = passes.discarded;
				var discQueue = passes.lastDisc;
				var cur = passes.current;
				while(cur != null) {
					if(cur.pass.isStatic == false) {
						if(head == null) {
							prev = cur;
							head = prev;
						} else {
							prev.next = cur;
							prev = cur;
						}
					} else if(disc == null) {
						discQueue = cur;
						disc = discQueue;
					} else {
						discQueue.next = cur;
						discQueue = cur;
					}
					cur = cur.next;
				}
				if(prev != null) {
					prev.next = null;
				}
				if(discQueue != null) {
					discQueue.next = null;
				}
				passes.current = head;
				passes.discarded = disc;
				passes.lastDisc = discQueue;
				return true;
			}
		} else {
			switch(this.mode._hx_index) {
			case 0:
				return false;
			case 1:
				var head = null;
				var prev = null;
				var disc = passes.discarded;
				var discQueue = passes.lastDisc;
				var cur = passes.current;
				while(cur != null) {
					if(cur.pass.isStatic == true) {
						if(head == null) {
							prev = cur;
							head = prev;
						} else {
							prev.next = cur;
							prev = cur;
						}
					} else if(disc == null) {
						discQueue = cur;
						disc = discQueue;
					} else {
						discQueue.next = cur;
						discQueue = cur;
					}
					cur = cur.next;
				}
				if(prev != null) {
					prev.next = null;
				}
				if(discQueue != null) {
					discQueue.next = null;
				}
				passes.current = head;
				passes.discarded = disc;
				passes.lastDisc = discQueue;
				return true;
			case 2:
				return false;
			case 3:
				var head = null;
				var prev = null;
				var disc = passes.discarded;
				var discQueue = passes.lastDisc;
				var cur = passes.current;
				while(cur != null) {
					if(cur.pass.isStatic == true) {
						if(head == null) {
							prev = cur;
							head = prev;
						} else {
							prev.next = cur;
							prev = cur;
						}
					} else if(disc == null) {
						discQueue = cur;
						disc = discQueue;
					} else {
						discQueue.next = cur;
						discQueue = cur;
					}
					cur = cur.next;
				}
				if(prev != null) {
					prev.next = null;
				}
				if(discQueue != null) {
					discQueue.next = null;
				}
				passes.current = head;
				passes.discarded = disc;
				passes.lastDisc = discQueue;
				return true;
			}
		}
	}
	,__class__: h3d_pass_Shadows
});
var h3d_pass_DirShadowMap = function(light) {
	this.minDist = -1.0;
	this.maxDist = -1.0;
	this.autoZPlanes = false;
	this.autoShrink = true;
	this.mergePass = new h3d_pass_ScreenFx(new h3d_shader_MinMaxShader());
	h3d_pass_Shadows.call(this,light);
	this.lightCamera = new h3d_Camera();
	this.lightCamera.orthoBounds = new h3d_col_Bounds();
	this.shader = this.dshader = new h3d_shader_DirShadow();
	this.border = new h3d_pass_Border(this.size,this.size);
	this.customDepth = h3d_Engine.CURRENT.driver.hasFeature(h3d_impl_Feature.AllocDepthBuffer);
	if(!this.customDepth) {
		this.depth = h3d_mat_DepthBuffer.getDefault();
	}
};
$hxClasses["h3d.pass.DirShadowMap"] = h3d_pass_DirShadowMap;
h3d_pass_DirShadowMap.__name__ = "h3d.pass.DirShadowMap";
h3d_pass_DirShadowMap.__super__ = h3d_pass_Shadows;
h3d_pass_DirShadowMap.prototype = $extend(h3d_pass_Shadows.prototype,{
	set_mode: function(m) {
		var _this = this.dshader;
		_this.constModified = true;
		_this.enable__ = m != h3d_pass_RenderMode.None;
		return this.mode = m;
	}
	,set_size: function(s) {
		if(this.border != null && this.size != s) {
			this.border.dispose();
			this.border = new h3d_pass_Border(s,s);
		}
		return h3d_pass_Shadows.prototype.set_size.call(this,s);
	}
	,calcShadowBounds: function(camera) {
		var _gthis = this;
		var bounds = camera.orthoBounds;
		var zMax = -1e9;
		var zMin = 1e9;
		if(this.autoShrink) {
			var mtmp = new h3d_Matrix();
			var btmp = this.autoZPlanes ? new h3d_col_Bounds() : null;
			var obj = this.boundingObject != null ? this.boundingObject : this.ctx.scene;
			obj.iterVisibleMeshes(function(m) {
				if(m.primitive == null || !m.material.castShadows) {
					return;
				}
				var b = m.primitive.getBounds();
				if(b.xMin > b.xMax) {
					return;
				}
				var absPos = ((m.primitive) instanceof h3d_prim_Instanced) ? h3d_Matrix.I() : m.getAbsPos();
				if(_gthis.autoZPlanes) {
					btmp.load(b);
					btmp.transform(absPos);
					if(btmp.zMax > zMax) {
						zMax = btmp.zMax;
					}
					if(btmp.zMin < zMin) {
						zMin = btmp.zMin;
					}
				}
				mtmp.multiply3x4(absPos,camera.mcam);
				var x = b.xMin;
				var y = b.yMin;
				var z = b.zMin;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var p_x = x;
				var p_y = y;
				var p_z = z;
				var px = p_x * mtmp._11 + p_y * mtmp._21 + p_z * mtmp._31 + mtmp._41;
				var py = p_x * mtmp._12 + p_y * mtmp._22 + p_z * mtmp._32 + mtmp._42;
				var pz = p_x * mtmp._13 + p_y * mtmp._23 + p_z * mtmp._33 + mtmp._43;
				p_x = px;
				p_y = py;
				p_z = pz;
				if(p_x < bounds.xMin) {
					bounds.xMin = p_x;
				}
				if(p_x > bounds.xMax) {
					bounds.xMax = p_x;
				}
				if(p_y < bounds.yMin) {
					bounds.yMin = p_y;
				}
				if(p_y > bounds.yMax) {
					bounds.yMax = p_y;
				}
				if(p_z < bounds.zMin) {
					bounds.zMin = p_z;
				}
				if(p_z > bounds.zMax) {
					bounds.zMax = p_z;
				}
				var x = b.xMin;
				var y = b.yMin;
				var z = b.zMax;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var p_x = x;
				var p_y = y;
				var p_z = z;
				var px = p_x * mtmp._11 + p_y * mtmp._21 + p_z * mtmp._31 + mtmp._41;
				var py = p_x * mtmp._12 + p_y * mtmp._22 + p_z * mtmp._32 + mtmp._42;
				var pz = p_x * mtmp._13 + p_y * mtmp._23 + p_z * mtmp._33 + mtmp._43;
				p_x = px;
				p_y = py;
				p_z = pz;
				if(p_x < bounds.xMin) {
					bounds.xMin = p_x;
				}
				if(p_x > bounds.xMax) {
					bounds.xMax = p_x;
				}
				if(p_y < bounds.yMin) {
					bounds.yMin = p_y;
				}
				if(p_y > bounds.yMax) {
					bounds.yMax = p_y;
				}
				if(p_z < bounds.zMin) {
					bounds.zMin = p_z;
				}
				if(p_z > bounds.zMax) {
					bounds.zMax = p_z;
				}
				var x = b.xMin;
				var y = b.yMax;
				var z = b.zMin;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var p_x = x;
				var p_y = y;
				var p_z = z;
				var px = p_x * mtmp._11 + p_y * mtmp._21 + p_z * mtmp._31 + mtmp._41;
				var py = p_x * mtmp._12 + p_y * mtmp._22 + p_z * mtmp._32 + mtmp._42;
				var pz = p_x * mtmp._13 + p_y * mtmp._23 + p_z * mtmp._33 + mtmp._43;
				p_x = px;
				p_y = py;
				p_z = pz;
				if(p_x < bounds.xMin) {
					bounds.xMin = p_x;
				}
				if(p_x > bounds.xMax) {
					bounds.xMax = p_x;
				}
				if(p_y < bounds.yMin) {
					bounds.yMin = p_y;
				}
				if(p_y > bounds.yMax) {
					bounds.yMax = p_y;
				}
				if(p_z < bounds.zMin) {
					bounds.zMin = p_z;
				}
				if(p_z > bounds.zMax) {
					bounds.zMax = p_z;
				}
				var x = b.xMin;
				var y = b.yMax;
				var z = b.zMax;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var p_x = x;
				var p_y = y;
				var p_z = z;
				var px = p_x * mtmp._11 + p_y * mtmp._21 + p_z * mtmp._31 + mtmp._41;
				var py = p_x * mtmp._12 + p_y * mtmp._22 + p_z * mtmp._32 + mtmp._42;
				var pz = p_x * mtmp._13 + p_y * mtmp._23 + p_z * mtmp._33 + mtmp._43;
				p_x = px;
				p_y = py;
				p_z = pz;
				if(p_x < bounds.xMin) {
					bounds.xMin = p_x;
				}
				if(p_x > bounds.xMax) {
					bounds.xMax = p_x;
				}
				if(p_y < bounds.yMin) {
					bounds.yMin = p_y;
				}
				if(p_y > bounds.yMax) {
					bounds.yMax = p_y;
				}
				if(p_z < bounds.zMin) {
					bounds.zMin = p_z;
				}
				if(p_z > bounds.zMax) {
					bounds.zMax = p_z;
				}
				var x = b.xMax;
				var y = b.yMin;
				var z = b.zMin;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var p_x = x;
				var p_y = y;
				var p_z = z;
				var px = p_x * mtmp._11 + p_y * mtmp._21 + p_z * mtmp._31 + mtmp._41;
				var py = p_x * mtmp._12 + p_y * mtmp._22 + p_z * mtmp._32 + mtmp._42;
				var pz = p_x * mtmp._13 + p_y * mtmp._23 + p_z * mtmp._33 + mtmp._43;
				p_x = px;
				p_y = py;
				p_z = pz;
				if(p_x < bounds.xMin) {
					bounds.xMin = p_x;
				}
				if(p_x > bounds.xMax) {
					bounds.xMax = p_x;
				}
				if(p_y < bounds.yMin) {
					bounds.yMin = p_y;
				}
				if(p_y > bounds.yMax) {
					bounds.yMax = p_y;
				}
				if(p_z < bounds.zMin) {
					bounds.zMin = p_z;
				}
				if(p_z > bounds.zMax) {
					bounds.zMax = p_z;
				}
				var x = b.xMax;
				var y = b.yMin;
				var z = b.zMax;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var p_x = x;
				var p_y = y;
				var p_z = z;
				var px = p_x * mtmp._11 + p_y * mtmp._21 + p_z * mtmp._31 + mtmp._41;
				var py = p_x * mtmp._12 + p_y * mtmp._22 + p_z * mtmp._32 + mtmp._42;
				var pz = p_x * mtmp._13 + p_y * mtmp._23 + p_z * mtmp._33 + mtmp._43;
				p_x = px;
				p_y = py;
				p_z = pz;
				if(p_x < bounds.xMin) {
					bounds.xMin = p_x;
				}
				if(p_x > bounds.xMax) {
					bounds.xMax = p_x;
				}
				if(p_y < bounds.yMin) {
					bounds.yMin = p_y;
				}
				if(p_y > bounds.yMax) {
					bounds.yMax = p_y;
				}
				if(p_z < bounds.zMin) {
					bounds.zMin = p_z;
				}
				if(p_z > bounds.zMax) {
					bounds.zMax = p_z;
				}
				var x = b.xMax;
				var y = b.yMax;
				var z = b.zMin;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var p_x = x;
				var p_y = y;
				var p_z = z;
				var px = p_x * mtmp._11 + p_y * mtmp._21 + p_z * mtmp._31 + mtmp._41;
				var py = p_x * mtmp._12 + p_y * mtmp._22 + p_z * mtmp._32 + mtmp._42;
				var pz = p_x * mtmp._13 + p_y * mtmp._23 + p_z * mtmp._33 + mtmp._43;
				p_x = px;
				p_y = py;
				p_z = pz;
				if(p_x < bounds.xMin) {
					bounds.xMin = p_x;
				}
				if(p_x > bounds.xMax) {
					bounds.xMax = p_x;
				}
				if(p_y < bounds.yMin) {
					bounds.yMin = p_y;
				}
				if(p_y > bounds.yMax) {
					bounds.yMax = p_y;
				}
				if(p_z < bounds.zMin) {
					bounds.zMin = p_z;
				}
				if(p_z > bounds.zMax) {
					bounds.zMax = p_z;
				}
				var x = b.xMax;
				var y = b.yMax;
				var z = b.zMax;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var p_x = x;
				var p_y = y;
				var p_z = z;
				var px = p_x * mtmp._11 + p_y * mtmp._21 + p_z * mtmp._31 + mtmp._41;
				var py = p_x * mtmp._12 + p_y * mtmp._22 + p_z * mtmp._32 + mtmp._42;
				var pz = p_x * mtmp._13 + p_y * mtmp._23 + p_z * mtmp._33 + mtmp._43;
				p_x = px;
				p_y = py;
				p_z = pz;
				if(p_x < bounds.xMin) {
					bounds.xMin = p_x;
				}
				if(p_x > bounds.xMax) {
					bounds.xMax = p_x;
				}
				if(p_y < bounds.yMin) {
					bounds.yMin = p_y;
				}
				if(p_y > bounds.yMax) {
					bounds.yMax = p_y;
				}
				if(p_z < bounds.zMin) {
					bounds.zMin = p_z;
				}
				if(p_z > bounds.zMax) {
					bounds.zMax = p_z;
				}
			});
		} else if(this.mode == h3d_pass_RenderMode.Dynamic) {
			bounds.xMin = -1e20;
			bounds.xMax = 1e20;
			bounds.yMin = -1e20;
			bounds.yMax = 1e20;
			bounds.zMin = -1e20;
			bounds.zMax = 1e20;
		}
		if(this.mode == h3d_pass_RenderMode.Dynamic) {
			var cameraBounds = new h3d_col_Bounds();
			var minDist = this.minDist < 0 ? this.ctx.camera.zNear : this.minDist;
			var maxDist = this.maxDist < 0 ? this.ctx.camera.zFar : this.maxDist;
			var dist = minDist;
			var _this = _gthis.ctx.camera.unproject(-1,-1,_gthis.ctx.camera.distanceToDepth(dist));
			var x = _this.x;
			var y = _this.y;
			var z = _this.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var pt_x = x;
			var pt_y = y;
			var pt_z = z;
			if(_gthis.autoShrink && _gthis.autoZPlanes) {
				var _this = _gthis.ctx.camera.pos;
				var x = _this.x;
				var y = _this.y;
				var z = _this.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var p1_x = x;
				var p1_y = y;
				var p1_z = z;
				var r = new h3d_col_Ray();
				r.px = p1_x;
				r.py = p1_y;
				r.pz = p1_z;
				r.lx = pt_x - p1_x;
				r.ly = pt_y - p1_y;
				r.lz = pt_z - p1_z;
				r.normalize();
				var r1 = r;
				var v = zMax;
				if(v == null) {
					v = 0.0;
				}
				var p_nx = 0;
				var p_ny = 0;
				var p_nz = 1;
				var p_d = v;
				var d = r1.lx * p_nx + r1.ly * p_ny + r1.lz * p_nz;
				var nd = p_d - (r1.px * p_nx + r1.py * p_ny + r1.pz * p_nz);
				var d2 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
				var k = 1;
				if(d2 > 0 && d2 * k > dist * k) {
					var x = r1.px + d2 * r1.lx;
					var y = r1.py + d2 * r1.ly;
					var z = r1.pz + d2 * r1.lz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var p_x = x;
					var p_y = y;
					var p_z = z;
					pt_x = p_x;
					pt_y = p_y;
					pt_z = p_z;
				}
			}
			var m = camera.mcam;
			var px = pt_x * m._11 + pt_y * m._21 + pt_z * m._31 + m._41;
			var py = pt_x * m._12 + pt_y * m._22 + pt_z * m._32 + m._42;
			var pz = pt_x * m._13 + pt_y * m._23 + pt_z * m._33 + m._43;
			pt_x = px;
			pt_y = py;
			pt_z = pz;
			var x = pt_x;
			var y = pt_y;
			var z = pt_z;
			if(x < cameraBounds.xMin) {
				cameraBounds.xMin = x;
			}
			if(x > cameraBounds.xMax) {
				cameraBounds.xMax = x;
			}
			if(y < cameraBounds.yMin) {
				cameraBounds.yMin = y;
			}
			if(y > cameraBounds.yMax) {
				cameraBounds.yMax = y;
			}
			if(z < cameraBounds.zMin) {
				cameraBounds.zMin = z;
			}
			if(z > cameraBounds.zMax) {
				cameraBounds.zMax = z;
			}
			var dist = minDist;
			var _this = _gthis.ctx.camera.unproject(-1,1,_gthis.ctx.camera.distanceToDepth(dist));
			var x = _this.x;
			var y = _this.y;
			var z = _this.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var pt_x = x;
			var pt_y = y;
			var pt_z = z;
			if(_gthis.autoShrink && _gthis.autoZPlanes) {
				var _this = _gthis.ctx.camera.pos;
				var x = _this.x;
				var y = _this.y;
				var z = _this.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var p1_x = x;
				var p1_y = y;
				var p1_z = z;
				var r = new h3d_col_Ray();
				r.px = p1_x;
				r.py = p1_y;
				r.pz = p1_z;
				r.lx = pt_x - p1_x;
				r.ly = pt_y - p1_y;
				r.lz = pt_z - p1_z;
				r.normalize();
				var r1 = r;
				var v = zMax;
				if(v == null) {
					v = 0.0;
				}
				var p_nx = 0;
				var p_ny = 0;
				var p_nz = 1;
				var p_d = v;
				var d = r1.lx * p_nx + r1.ly * p_ny + r1.lz * p_nz;
				var nd = p_d - (r1.px * p_nx + r1.py * p_ny + r1.pz * p_nz);
				var d2 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
				var k = 1;
				if(d2 > 0 && d2 * k > dist * k) {
					var x = r1.px + d2 * r1.lx;
					var y = r1.py + d2 * r1.ly;
					var z = r1.pz + d2 * r1.lz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var p_x = x;
					var p_y = y;
					var p_z = z;
					pt_x = p_x;
					pt_y = p_y;
					pt_z = p_z;
				}
			}
			var m = camera.mcam;
			var px = pt_x * m._11 + pt_y * m._21 + pt_z * m._31 + m._41;
			var py = pt_x * m._12 + pt_y * m._22 + pt_z * m._32 + m._42;
			var pz = pt_x * m._13 + pt_y * m._23 + pt_z * m._33 + m._43;
			pt_x = px;
			pt_y = py;
			pt_z = pz;
			var x = pt_x;
			var y = pt_y;
			var z = pt_z;
			if(x < cameraBounds.xMin) {
				cameraBounds.xMin = x;
			}
			if(x > cameraBounds.xMax) {
				cameraBounds.xMax = x;
			}
			if(y < cameraBounds.yMin) {
				cameraBounds.yMin = y;
			}
			if(y > cameraBounds.yMax) {
				cameraBounds.yMax = y;
			}
			if(z < cameraBounds.zMin) {
				cameraBounds.zMin = z;
			}
			if(z > cameraBounds.zMax) {
				cameraBounds.zMax = z;
			}
			var dist = minDist;
			var _this = _gthis.ctx.camera.unproject(1,-1,_gthis.ctx.camera.distanceToDepth(dist));
			var x = _this.x;
			var y = _this.y;
			var z = _this.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var pt_x = x;
			var pt_y = y;
			var pt_z = z;
			if(_gthis.autoShrink && _gthis.autoZPlanes) {
				var _this = _gthis.ctx.camera.pos;
				var x = _this.x;
				var y = _this.y;
				var z = _this.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var p1_x = x;
				var p1_y = y;
				var p1_z = z;
				var r = new h3d_col_Ray();
				r.px = p1_x;
				r.py = p1_y;
				r.pz = p1_z;
				r.lx = pt_x - p1_x;
				r.ly = pt_y - p1_y;
				r.lz = pt_z - p1_z;
				r.normalize();
				var r1 = r;
				var v = zMax;
				if(v == null) {
					v = 0.0;
				}
				var p_nx = 0;
				var p_ny = 0;
				var p_nz = 1;
				var p_d = v;
				var d = r1.lx * p_nx + r1.ly * p_ny + r1.lz * p_nz;
				var nd = p_d - (r1.px * p_nx + r1.py * p_ny + r1.pz * p_nz);
				var d2 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
				var k = 1;
				if(d2 > 0 && d2 * k > dist * k) {
					var x = r1.px + d2 * r1.lx;
					var y = r1.py + d2 * r1.ly;
					var z = r1.pz + d2 * r1.lz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var p_x = x;
					var p_y = y;
					var p_z = z;
					pt_x = p_x;
					pt_y = p_y;
					pt_z = p_z;
				}
			}
			var m = camera.mcam;
			var px = pt_x * m._11 + pt_y * m._21 + pt_z * m._31 + m._41;
			var py = pt_x * m._12 + pt_y * m._22 + pt_z * m._32 + m._42;
			var pz = pt_x * m._13 + pt_y * m._23 + pt_z * m._33 + m._43;
			pt_x = px;
			pt_y = py;
			pt_z = pz;
			var x = pt_x;
			var y = pt_y;
			var z = pt_z;
			if(x < cameraBounds.xMin) {
				cameraBounds.xMin = x;
			}
			if(x > cameraBounds.xMax) {
				cameraBounds.xMax = x;
			}
			if(y < cameraBounds.yMin) {
				cameraBounds.yMin = y;
			}
			if(y > cameraBounds.yMax) {
				cameraBounds.yMax = y;
			}
			if(z < cameraBounds.zMin) {
				cameraBounds.zMin = z;
			}
			if(z > cameraBounds.zMax) {
				cameraBounds.zMax = z;
			}
			var dist = minDist;
			var _this = _gthis.ctx.camera.unproject(1,1,_gthis.ctx.camera.distanceToDepth(dist));
			var x = _this.x;
			var y = _this.y;
			var z = _this.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var pt_x = x;
			var pt_y = y;
			var pt_z = z;
			if(_gthis.autoShrink && _gthis.autoZPlanes) {
				var _this = _gthis.ctx.camera.pos;
				var x = _this.x;
				var y = _this.y;
				var z = _this.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var p1_x = x;
				var p1_y = y;
				var p1_z = z;
				var r = new h3d_col_Ray();
				r.px = p1_x;
				r.py = p1_y;
				r.pz = p1_z;
				r.lx = pt_x - p1_x;
				r.ly = pt_y - p1_y;
				r.lz = pt_z - p1_z;
				r.normalize();
				var r1 = r;
				var v = zMax;
				if(v == null) {
					v = 0.0;
				}
				var p_nx = 0;
				var p_ny = 0;
				var p_nz = 1;
				var p_d = v;
				var d = r1.lx * p_nx + r1.ly * p_ny + r1.lz * p_nz;
				var nd = p_d - (r1.px * p_nx + r1.py * p_ny + r1.pz * p_nz);
				var d2 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
				var k = 1;
				if(d2 > 0 && d2 * k > dist * k) {
					var x = r1.px + d2 * r1.lx;
					var y = r1.py + d2 * r1.ly;
					var z = r1.pz + d2 * r1.lz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var p_x = x;
					var p_y = y;
					var p_z = z;
					pt_x = p_x;
					pt_y = p_y;
					pt_z = p_z;
				}
			}
			var m = camera.mcam;
			var px = pt_x * m._11 + pt_y * m._21 + pt_z * m._31 + m._41;
			var py = pt_x * m._12 + pt_y * m._22 + pt_z * m._32 + m._42;
			var pz = pt_x * m._13 + pt_y * m._23 + pt_z * m._33 + m._43;
			pt_x = px;
			pt_y = py;
			pt_z = pz;
			var x = pt_x;
			var y = pt_y;
			var z = pt_z;
			if(x < cameraBounds.xMin) {
				cameraBounds.xMin = x;
			}
			if(x > cameraBounds.xMax) {
				cameraBounds.xMax = x;
			}
			if(y < cameraBounds.yMin) {
				cameraBounds.yMin = y;
			}
			if(y > cameraBounds.yMax) {
				cameraBounds.yMax = y;
			}
			if(z < cameraBounds.zMin) {
				cameraBounds.zMin = z;
			}
			if(z > cameraBounds.zMax) {
				cameraBounds.zMax = z;
			}
			var dist = maxDist;
			var _this = _gthis.ctx.camera.unproject(-1,-1,_gthis.ctx.camera.distanceToDepth(dist));
			var x = _this.x;
			var y = _this.y;
			var z = _this.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var pt_x = x;
			var pt_y = y;
			var pt_z = z;
			if(_gthis.autoShrink && _gthis.autoZPlanes) {
				var _this = _gthis.ctx.camera.pos;
				var x = _this.x;
				var y = _this.y;
				var z = _this.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var p1_x = x;
				var p1_y = y;
				var p1_z = z;
				var r = new h3d_col_Ray();
				r.px = p1_x;
				r.py = p1_y;
				r.pz = p1_z;
				r.lx = pt_x - p1_x;
				r.ly = pt_y - p1_y;
				r.lz = pt_z - p1_z;
				r.normalize();
				var r1 = r;
				var v = zMin;
				if(v == null) {
					v = 0.0;
				}
				var p_nx = 0;
				var p_ny = 0;
				var p_nz = 1;
				var p_d = v;
				var d = r1.lx * p_nx + r1.ly * p_ny + r1.lz * p_nz;
				var nd = p_d - (r1.px * p_nx + r1.py * p_ny + r1.pz * p_nz);
				var d2 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
				var k = -1;
				if(d2 > 0 && d2 * k > dist * k) {
					var x = r1.px + d2 * r1.lx;
					var y = r1.py + d2 * r1.ly;
					var z = r1.pz + d2 * r1.lz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var p_x = x;
					var p_y = y;
					var p_z = z;
					pt_x = p_x;
					pt_y = p_y;
					pt_z = p_z;
				}
			}
			var m = camera.mcam;
			var px = pt_x * m._11 + pt_y * m._21 + pt_z * m._31 + m._41;
			var py = pt_x * m._12 + pt_y * m._22 + pt_z * m._32 + m._42;
			var pz = pt_x * m._13 + pt_y * m._23 + pt_z * m._33 + m._43;
			pt_x = px;
			pt_y = py;
			pt_z = pz;
			var x = pt_x;
			var y = pt_y;
			var z = pt_z;
			if(x < cameraBounds.xMin) {
				cameraBounds.xMin = x;
			}
			if(x > cameraBounds.xMax) {
				cameraBounds.xMax = x;
			}
			if(y < cameraBounds.yMin) {
				cameraBounds.yMin = y;
			}
			if(y > cameraBounds.yMax) {
				cameraBounds.yMax = y;
			}
			if(z < cameraBounds.zMin) {
				cameraBounds.zMin = z;
			}
			if(z > cameraBounds.zMax) {
				cameraBounds.zMax = z;
			}
			var dist = maxDist;
			var _this = _gthis.ctx.camera.unproject(-1,1,_gthis.ctx.camera.distanceToDepth(dist));
			var x = _this.x;
			var y = _this.y;
			var z = _this.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var pt_x = x;
			var pt_y = y;
			var pt_z = z;
			if(_gthis.autoShrink && _gthis.autoZPlanes) {
				var _this = _gthis.ctx.camera.pos;
				var x = _this.x;
				var y = _this.y;
				var z = _this.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var p1_x = x;
				var p1_y = y;
				var p1_z = z;
				var r = new h3d_col_Ray();
				r.px = p1_x;
				r.py = p1_y;
				r.pz = p1_z;
				r.lx = pt_x - p1_x;
				r.ly = pt_y - p1_y;
				r.lz = pt_z - p1_z;
				r.normalize();
				var r1 = r;
				var v = zMin;
				if(v == null) {
					v = 0.0;
				}
				var p_nx = 0;
				var p_ny = 0;
				var p_nz = 1;
				var p_d = v;
				var d = r1.lx * p_nx + r1.ly * p_ny + r1.lz * p_nz;
				var nd = p_d - (r1.px * p_nx + r1.py * p_ny + r1.pz * p_nz);
				var d2 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
				var k = -1;
				if(d2 > 0 && d2 * k > dist * k) {
					var x = r1.px + d2 * r1.lx;
					var y = r1.py + d2 * r1.ly;
					var z = r1.pz + d2 * r1.lz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var p_x = x;
					var p_y = y;
					var p_z = z;
					pt_x = p_x;
					pt_y = p_y;
					pt_z = p_z;
				}
			}
			var m = camera.mcam;
			var px = pt_x * m._11 + pt_y * m._21 + pt_z * m._31 + m._41;
			var py = pt_x * m._12 + pt_y * m._22 + pt_z * m._32 + m._42;
			var pz = pt_x * m._13 + pt_y * m._23 + pt_z * m._33 + m._43;
			pt_x = px;
			pt_y = py;
			pt_z = pz;
			var x = pt_x;
			var y = pt_y;
			var z = pt_z;
			if(x < cameraBounds.xMin) {
				cameraBounds.xMin = x;
			}
			if(x > cameraBounds.xMax) {
				cameraBounds.xMax = x;
			}
			if(y < cameraBounds.yMin) {
				cameraBounds.yMin = y;
			}
			if(y > cameraBounds.yMax) {
				cameraBounds.yMax = y;
			}
			if(z < cameraBounds.zMin) {
				cameraBounds.zMin = z;
			}
			if(z > cameraBounds.zMax) {
				cameraBounds.zMax = z;
			}
			var dist = maxDist;
			var _this = _gthis.ctx.camera.unproject(1,-1,_gthis.ctx.camera.distanceToDepth(dist));
			var x = _this.x;
			var y = _this.y;
			var z = _this.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var pt_x = x;
			var pt_y = y;
			var pt_z = z;
			if(_gthis.autoShrink && _gthis.autoZPlanes) {
				var _this = _gthis.ctx.camera.pos;
				var x = _this.x;
				var y = _this.y;
				var z = _this.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var p1_x = x;
				var p1_y = y;
				var p1_z = z;
				var r = new h3d_col_Ray();
				r.px = p1_x;
				r.py = p1_y;
				r.pz = p1_z;
				r.lx = pt_x - p1_x;
				r.ly = pt_y - p1_y;
				r.lz = pt_z - p1_z;
				r.normalize();
				var r1 = r;
				var v = zMin;
				if(v == null) {
					v = 0.0;
				}
				var p_nx = 0;
				var p_ny = 0;
				var p_nz = 1;
				var p_d = v;
				var d = r1.lx * p_nx + r1.ly * p_ny + r1.lz * p_nz;
				var nd = p_d - (r1.px * p_nx + r1.py * p_ny + r1.pz * p_nz);
				var d2 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
				var k = -1;
				if(d2 > 0 && d2 * k > dist * k) {
					var x = r1.px + d2 * r1.lx;
					var y = r1.py + d2 * r1.ly;
					var z = r1.pz + d2 * r1.lz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var p_x = x;
					var p_y = y;
					var p_z = z;
					pt_x = p_x;
					pt_y = p_y;
					pt_z = p_z;
				}
			}
			var m = camera.mcam;
			var px = pt_x * m._11 + pt_y * m._21 + pt_z * m._31 + m._41;
			var py = pt_x * m._12 + pt_y * m._22 + pt_z * m._32 + m._42;
			var pz = pt_x * m._13 + pt_y * m._23 + pt_z * m._33 + m._43;
			pt_x = px;
			pt_y = py;
			pt_z = pz;
			var x = pt_x;
			var y = pt_y;
			var z = pt_z;
			if(x < cameraBounds.xMin) {
				cameraBounds.xMin = x;
			}
			if(x > cameraBounds.xMax) {
				cameraBounds.xMax = x;
			}
			if(y < cameraBounds.yMin) {
				cameraBounds.yMin = y;
			}
			if(y > cameraBounds.yMax) {
				cameraBounds.yMax = y;
			}
			if(z < cameraBounds.zMin) {
				cameraBounds.zMin = z;
			}
			if(z > cameraBounds.zMax) {
				cameraBounds.zMax = z;
			}
			var dist = maxDist;
			var _this = _gthis.ctx.camera.unproject(1,1,_gthis.ctx.camera.distanceToDepth(dist));
			var x = _this.x;
			var y = _this.y;
			var z = _this.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var pt_x = x;
			var pt_y = y;
			var pt_z = z;
			if(_gthis.autoShrink && _gthis.autoZPlanes) {
				var _this = _gthis.ctx.camera.pos;
				var x = _this.x;
				var y = _this.y;
				var z = _this.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var p1_x = x;
				var p1_y = y;
				var p1_z = z;
				var r = new h3d_col_Ray();
				r.px = p1_x;
				r.py = p1_y;
				r.pz = p1_z;
				r.lx = pt_x - p1_x;
				r.ly = pt_y - p1_y;
				r.lz = pt_z - p1_z;
				r.normalize();
				var r1 = r;
				var v = zMin;
				if(v == null) {
					v = 0.0;
				}
				var p_nx = 0;
				var p_ny = 0;
				var p_nz = 1;
				var p_d = v;
				var d = r1.lx * p_nx + r1.ly * p_ny + r1.lz * p_nz;
				var nd = p_d - (r1.px * p_nx + r1.py * p_ny + r1.pz * p_nz);
				var d2 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
				var k = -1;
				if(d2 > 0 && d2 * k > dist * k) {
					var x = r1.px + d2 * r1.lx;
					var y = r1.py + d2 * r1.ly;
					var z = r1.pz + d2 * r1.lz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var p_x = x;
					var p_y = y;
					var p_z = z;
					pt_x = p_x;
					pt_y = p_y;
					pt_z = p_z;
				}
			}
			var m = camera.mcam;
			var px = pt_x * m._11 + pt_y * m._21 + pt_z * m._31 + m._41;
			var py = pt_x * m._12 + pt_y * m._22 + pt_z * m._32 + m._42;
			var pz = pt_x * m._13 + pt_y * m._23 + pt_z * m._33 + m._43;
			pt_x = px;
			pt_y = py;
			pt_z = pz;
			var x = pt_x;
			var y = pt_y;
			var z = pt_z;
			if(x < cameraBounds.xMin) {
				cameraBounds.xMin = x;
			}
			if(x > cameraBounds.xMax) {
				cameraBounds.xMax = x;
			}
			if(y < cameraBounds.yMin) {
				cameraBounds.yMin = y;
			}
			if(y > cameraBounds.yMax) {
				cameraBounds.yMax = y;
			}
			if(z < cameraBounds.zMin) {
				cameraBounds.zMin = z;
			}
			if(z > cameraBounds.zMax) {
				cameraBounds.zMax = z;
			}
			if(this.autoShrink) {
				cameraBounds.zMin = bounds.zMin;
				bounds.intersection(bounds,cameraBounds);
				if(this.autoZPlanes) {
					var _this = camera.target;
					var v = camera.pos;
					var x = _this.x - v.x;
					var y = _this.y - v.y;
					var z = _this.z - v.z;
					var w = _this.w - v.w;
					if(w == null) {
						w = 1.;
					}
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var _this_x = x;
					var _this_y = y;
					var _this_z = z;
					var _this_w = w;
					var k = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
					if(k < 1e-10) {
						k = 0;
					} else {
						k = 1. / Math.sqrt(k);
					}
					var x = _this_x * k;
					var y = _this_y * k;
					var z = _this_z * k;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var v_x = x;
					var v_y = y;
					var v_z = z;
					var v_w = 1.;
					var dMin = 1e9;
					var px = bounds.xMin;
					var py = bounds.yMin;
					var x = px;
					var y = py;
					var z = bounds.zMin;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var _this_x = x;
					var _this_y = y;
					var _this_z = z;
					var m = camera.getInverseView();
					var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31 + m._41;
					var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32 + m._42;
					var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33 + m._43;
					var x = px;
					var y = py;
					var z = pz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var r0_x = x;
					var r0_y = y;
					var r0_z = z;
					var r = new h3d_col_Ray();
					r.px = r0_x;
					r.py = r0_y;
					r.pz = r0_z;
					r.lx = v_x;
					r.ly = v_y;
					r.lz = v_z;
					r.normalize();
					var r1 = r;
					var v = zMax;
					if(v == null) {
						v = 0.0;
					}
					var p_nx = 0;
					var p_ny = 0;
					var p_nz = 1;
					var p_d = v;
					var d = r1.lx * p_nx + r1.ly * p_ny + r1.lz * p_nz;
					var nd = p_d - (r1.px * p_nx + r1.py * p_ny + r1.pz * p_nz);
					var d1 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
					if(d1 < dMin) {
						dMin = d1;
					}
					var px = bounds.xMin;
					var py = bounds.yMax;
					var x = px;
					var y = py;
					var z = bounds.zMin;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var _this_x = x;
					var _this_y = y;
					var _this_z = z;
					var m = camera.getInverseView();
					var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31 + m._41;
					var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32 + m._42;
					var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33 + m._43;
					var x = px;
					var y = py;
					var z = pz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var r0_x = x;
					var r0_y = y;
					var r0_z = z;
					var r = new h3d_col_Ray();
					r.px = r0_x;
					r.py = r0_y;
					r.pz = r0_z;
					r.lx = v_x;
					r.ly = v_y;
					r.lz = v_z;
					r.normalize();
					var r1 = r;
					var v = zMax;
					if(v == null) {
						v = 0.0;
					}
					var p_nx = 0;
					var p_ny = 0;
					var p_nz = 1;
					var p_d = v;
					var d = r1.lx * p_nx + r1.ly * p_ny + r1.lz * p_nz;
					var nd = p_d - (r1.px * p_nx + r1.py * p_ny + r1.pz * p_nz);
					var d1 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
					if(d1 < dMin) {
						dMin = d1;
					}
					var px = bounds.xMax;
					var py = bounds.yMin;
					var x = px;
					var y = py;
					var z = bounds.zMin;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var _this_x = x;
					var _this_y = y;
					var _this_z = z;
					var m = camera.getInverseView();
					var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31 + m._41;
					var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32 + m._42;
					var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33 + m._43;
					var x = px;
					var y = py;
					var z = pz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var r0_x = x;
					var r0_y = y;
					var r0_z = z;
					var r = new h3d_col_Ray();
					r.px = r0_x;
					r.py = r0_y;
					r.pz = r0_z;
					r.lx = v_x;
					r.ly = v_y;
					r.lz = v_z;
					r.normalize();
					var r1 = r;
					var v = zMax;
					if(v == null) {
						v = 0.0;
					}
					var p_nx = 0;
					var p_ny = 0;
					var p_nz = 1;
					var p_d = v;
					var d = r1.lx * p_nx + r1.ly * p_ny + r1.lz * p_nz;
					var nd = p_d - (r1.px * p_nx + r1.py * p_ny + r1.pz * p_nz);
					var d1 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
					if(d1 < dMin) {
						dMin = d1;
					}
					var px = bounds.xMax;
					var py = bounds.yMax;
					var x = px;
					var y = py;
					var z = bounds.zMin;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var _this_x = x;
					var _this_y = y;
					var _this_z = z;
					var m = camera.getInverseView();
					var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31 + m._41;
					var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32 + m._42;
					var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33 + m._43;
					var x = px;
					var y = py;
					var z = pz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var r0_x = x;
					var r0_y = y;
					var r0_z = z;
					var r = new h3d_col_Ray();
					r.px = r0_x;
					r.py = r0_y;
					r.pz = r0_z;
					r.lx = v_x;
					r.ly = v_y;
					r.lz = v_z;
					r.normalize();
					var r1 = r;
					var v = zMax;
					if(v == null) {
						v = 0.0;
					}
					var p_nx = 0;
					var p_ny = 0;
					var p_nz = 1;
					var p_d = v;
					var d = r1.lx * p_nx + r1.ly * p_ny + r1.lz * p_nz;
					var nd = p_d - (r1.px * p_nx + r1.py * p_ny + r1.pz * p_nz);
					var d1 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
					if(d1 < dMin) {
						dMin = d1;
					}
					bounds.zMin += dMin;
				}
			} else {
				bounds.load(cameraBounds);
			}
		}
		bounds.scaleCenter(1.01);
	}
	,setGlobals: function() {
		h3d_pass_Shadows.prototype.setGlobals.call(this);
		var v = this.getShadowProj();
		this.manager.globals.map.h[this.cameraViewProj_id] = v;
	}
	,syncShader: function(texture) {
		var _this = this.dshader;
		_this.constModified = true;
		_this.shadowMap__ = texture;
		var _this = this.dshader;
		_this.constModified = true;
		_this.shadowMapChannel__ = this.format == h3d_mat_Texture.nativeFormat ? hxsl_Channel.PackedFloat : hxsl_Channel.R;
		this.dshader.shadowBias__ = this.bias;
		this.dshader.shadowPower__ = this.power;
		this.dshader.shadowProj__ = this.getShadowProj();
		var _this = this.dshader;
		_this.constModified = true;
		_this.USE_ESM__ = this.samplingKind == h3d_pass_ShadowSamplingKind.ESM;
		this.dshader.shadowPower__ = this.power;
		var _this = this.dshader;
		_this.constModified = true;
		_this.USE_PCF__ = this.samplingKind == h3d_pass_ShadowSamplingKind.PCF;
		var _this = this.dshader.shadowRes__;
		var x = texture.width;
		var y = texture.height;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = 0.;
		_this.w = 1.;
		this.dshader.pcfScale__ = this.pcfScale;
		this.dshader.set_pcfQuality(this.pcfQuality);
	}
	,draw: function(passes,sort) {
		var _gthis = this;
		if(!this.enabled) {
			return;
		}
		if(!this.filterPasses(passes)) {
			return;
		}
		if(this.mode != h3d_pass_RenderMode.Mixed || this.ctx.computingStatic) {
			var _this = this.lightCamera.orthoBounds;
			_this.xMin = 1e20;
			_this.xMax = -1e20;
			_this.yMin = 1e20;
			_this.yMax = -1e20;
			_this.zMin = 1e20;
			_this.zMax = -1e20;
			if(passes.current != null) {
				this.calcShadowBounds(this.lightCamera);
			}
			this.lightCamera.update();
		}
		var f = function(col) {
			return col.inFrustum(_gthis.lightCamera.frustum);
		};
		var prevCollider = null;
		var prevResult = true;
		var head = null;
		var prev = null;
		var disc = passes.discarded;
		var discQueue = passes.lastDisc;
		var cur = passes.current;
		while(cur != null) {
			var col = cur.obj.cullingCollider;
			var tmp;
			if(col == null) {
				tmp = true;
			} else {
				if(col != prevCollider) {
					prevCollider = col;
					prevResult = f(col);
				}
				tmp = prevResult;
			}
			if(tmp) {
				if(head == null) {
					prev = cur;
					head = prev;
				} else {
					prev.next = cur;
					prev = cur;
				}
			} else if(disc == null) {
				discQueue = cur;
				disc = discQueue;
			} else {
				discQueue.next = cur;
				discQueue = cur;
			}
			cur = cur.next;
		}
		if(prev != null) {
			prev.next = null;
		}
		if(discQueue != null) {
			discQueue.next = null;
		}
		passes.current = head;
		passes.discarded = disc;
		passes.lastDisc = discQueue;
		var texture = this.ctx.textures.allocTarget("dirShadowMap",this.size,this.size,false,this.format);
		if(this.customDepth && (this.depth == null || this.depth.width != this.size || this.depth.height != this.size || this.depth.isDisposed())) {
			if(this.depth != null) {
				this.depth.dispose();
			}
			this.depth = new h3d_mat_DepthBuffer(this.size,this.size);
		}
		texture.depthBuffer = this.depth;
		if(this.mode != h3d_pass_RenderMode.Mixed || this.ctx.computingStatic) {
			var ct = this.ctx.camera.target;
			var slight = this.light == null ? this.ctx.lightSystem.shadowLight : this.light;
			var ldir = slight == null ? null : slight.getShadowDirection();
			if(ldir == null) {
				var _this = this.lightCamera.target;
				var x = 0;
				var y = 0;
				var z = -1;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				_this.x = x;
				_this.y = y;
				_this.z = z;
				_this.w = 1.;
			} else {
				var _this = this.lightCamera.target;
				var x = ldir.x;
				var y = ldir.y;
				var z = ldir.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				_this.x = x;
				_this.y = y;
				_this.z = z;
				_this.w = 1.;
				var _this = this.lightCamera.target;
				var k = _this.x * _this.x + _this.y * _this.y + _this.z * _this.z;
				if(k < 1e-10) {
					k = 0;
				} else {
					k = 1. / Math.sqrt(k);
				}
				_this.x *= k;
				_this.y *= k;
				_this.z *= k;
			}
			this.lightCamera.target.x += ct.x;
			this.lightCamera.target.y += ct.y;
			this.lightCamera.target.z += ct.z;
			var _this = this.lightCamera.pos;
			_this.x = ct.x;
			_this.y = ct.y;
			_this.z = ct.z;
			_this.w = ct.w;
			this.lightCamera.update();
		}
		this.ctx.engine.pushTarget(texture);
		this.ctx.engine.clear(16777215,1);
		h3d_pass_Shadows.prototype.draw.call(this,passes,sort);
		var doBlur = this.blur.radius > 0 && (this.mode != h3d_pass_RenderMode.Mixed || !this.ctx.computingStatic);
		if(this.border != null && !doBlur) {
			this.border.render();
		}
		this.ctx.engine.popTarget();
		if(this.mode == h3d_pass_RenderMode.Mixed && !this.ctx.computingStatic) {
			var merge = this.ctx.textures.allocTarget("mergedDirShadowMap",this.size,this.size,false,this.format);
			this.mergePass.shader.texA__ = texture;
			this.mergePass.shader.texB__ = this.staticTexture;
			this.ctx.engine.pushTarget(merge);
			this.mergePass.render();
			this.ctx.engine.popTarget();
			texture = merge;
		}
		if(doBlur) {
			this.blur.apply(this.ctx,texture);
			if(this.border != null) {
				this.ctx.engine.pushTarget(texture);
				this.border.render();
				this.ctx.engine.popTarget();
			}
		}
		this.syncShader(texture);
	}
	,__class__: h3d_pass_DirShadowMap
});
var h3d_pass_DefaultShadowMap = function(size,format) {
	if(size == null) {
		size = 1024;
	}
	if(format != null) {
		this.format = format;
	}
	h3d_pass_DirShadowMap.call(this,null);
	this.set_size(size);
	this.color = new h3d_Vector();
	this.set_mode(h3d_pass_RenderMode.Dynamic);
	this.shadowMapId = hxsl_Globals.allocID("shadow.map");
	this.shadowProjId = hxsl_Globals.allocID("shadow.proj");
	this.shadowColorId = hxsl_Globals.allocID("shadow.color");
	this.shadowPowerId = hxsl_Globals.allocID("shadow.power");
	this.shadowBiasId = hxsl_Globals.allocID("shadow.bias");
};
$hxClasses["h3d.pass.DefaultShadowMap"] = h3d_pass_DefaultShadowMap;
h3d_pass_DefaultShadowMap.__name__ = "h3d.pass.DefaultShadowMap";
h3d_pass_DefaultShadowMap.__super__ = h3d_pass_DirShadowMap;
h3d_pass_DefaultShadowMap.prototype = $extend(h3d_pass_DirShadowMap.prototype,{
	draw: function(passes,sort) {
		h3d_pass_DirShadowMap.prototype.draw.call(this,passes,sort);
		this.ctx.setGlobalID(this.shadowMapId,{ texture : this.dshader.shadowMap__, channel : this.format == h3d_mat_Texture.nativeFormat ? hxsl_Channel.PackedFloat : hxsl_Channel.R});
		this.ctx.setGlobalID(this.shadowProjId,this.getShadowProj());
		this.ctx.setGlobalID(this.shadowColorId,this.color);
		this.ctx.setGlobalID(this.shadowPowerId,this.power);
		this.ctx.setGlobalID(this.shadowBiasId,this.bias);
	}
	,__class__: h3d_pass_DefaultShadowMap
});
var h3d_pass__$HardwarePick_FixedColor = function() {
	this.viewport__ = new h3d_Vector();
	this.colorID__ = new h3d_Vector();
	hxsl_Shader.call(this);
};
$hxClasses["h3d.pass._HardwarePick.FixedColor"] = h3d_pass__$HardwarePick_FixedColor;
h3d_pass__$HardwarePick_FixedColor.__name__ = "h3d.pass._HardwarePick.FixedColor";
h3d_pass__$HardwarePick_FixedColor.__super__ = hxsl_Shader;
h3d_pass__$HardwarePick_FixedColor.prototype = $extend(hxsl_Shader.prototype,{
	get_colorID: function() {
		return this.colorID__;
	}
	,set_colorID: function(_v) {
		return this.colorID__ = _v;
	}
	,get_viewport: function() {
		return this.viewport__;
	}
	,set_viewport: function(_v) {
		return this.viewport__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.colorID__;
		case 1:
			return this.viewport__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,__class__: h3d_pass__$HardwarePick_FixedColor
});
var h3d_pass_PassList = function(current) {
	this.current = current;
	this.discarded = this.lastDisc = null;
};
$hxClasses["h3d.pass.PassList"] = h3d_pass_PassList;
h3d_pass_PassList.__name__ = "h3d.pass.PassList";
h3d_pass_PassList.prototype = {
	__class__: h3d_pass_PassList
};
var h3d_pass_PassObject = function() {
	this.texture = 0;
};
$hxClasses["h3d.pass.PassObject"] = h3d_pass_PassObject;
h3d_pass_PassObject.__name__ = "h3d.pass.PassObject";
h3d_pass_PassObject.prototype = {
	__class__: h3d_pass_PassObject
};
var h3d_pass_ShaderManager = function(output) {
	this.shaderCache = hxsl_Cache.get();
	this.globals = new hxsl_Globals();
	this.currentOutput = new hxsl_ShaderList(null);
	this.setOutput(output);
};
$hxClasses["h3d.pass.ShaderManager"] = h3d_pass_ShaderManager;
h3d_pass_ShaderManager.__name__ = "h3d.pass.ShaderManager";
h3d_pass_ShaderManager.prototype = {
	setOutput: function(output) {
		if(output == null) {
			output = [hxsl_Output.Value("output.color")];
		}
		this.currentOutput.s = this.shaderCache.getLinkShader(output);
	}
	,fillRec: function(v,type,out,pos) {
		switch(type._hx_index) {
		case 1:
			out[pos] = v;
			return 1;
		case 3:
			out[pos] = v;
			return 1;
		case 5:
			var _g = type.t;
			var n = type.size;
			var v1 = v;
			out[pos++] = v1.x;
			out[pos++] = v1.y;
			switch(n) {
			case 3:
				out[pos++] = v1.z;
				break;
			case 4:
				out[pos++] = v1.z;
				out[pos++] = v1.w;
				break;
			}
			return n;
		case 6:
			var m = v;
			out[pos++] = m._11;
			out[pos++] = m._21;
			out[pos++] = m._31;
			out[pos++] = 0;
			out[pos++] = m._12;
			out[pos++] = m._22;
			out[pos++] = m._32;
			out[pos++] = 0;
			out[pos++] = m._13;
			out[pos++] = m._23;
			out[pos++] = m._33;
			out[pos++] = 0;
			return 12;
		case 7:
			var m = v;
			out[pos++] = m._11;
			out[pos++] = m._21;
			out[pos++] = m._31;
			out[pos++] = m._41;
			out[pos++] = m._12;
			out[pos++] = m._22;
			out[pos++] = m._32;
			out[pos++] = m._42;
			out[pos++] = m._13;
			out[pos++] = m._23;
			out[pos++] = m._33;
			out[pos++] = m._43;
			out[pos++] = m._14;
			out[pos++] = m._24;
			out[pos++] = m._34;
			out[pos++] = m._44;
			return 16;
		case 8:
			var m = v;
			out[pos++] = m._11;
			out[pos++] = m._21;
			out[pos++] = m._31;
			out[pos++] = m._41;
			out[pos++] = m._12;
			out[pos++] = m._22;
			out[pos++] = m._32;
			out[pos++] = m._42;
			out[pos++] = m._13;
			out[pos++] = m._23;
			out[pos++] = m._33;
			out[pos++] = m._43;
			return 12;
		case 13:
			var vl = type.vl;
			var tot = 0;
			var _g = 0;
			while(_g < vl.length) {
				var vv = vl[_g];
				++_g;
				tot += this.fillRec(Reflect.field(v,vv.name),vv.type,out,pos + tot);
			}
			return tot;
		case 15:
			var _g = type.t;
			var _g1 = type.size;
			switch(_g._hx_index) {
			case 3:
				if(_g1._hx_index == 0) {
					var len = _g1.v;
					var v1 = v;
					var size = 0;
					var count = v1.length < len ? v1.length : len;
					var _g2 = 0;
					var _g3 = count;
					while(_g2 < _g3) {
						var i = _g2++;
						out[pos++] = v1[i];
					}
					return len;
				} else {
					throw haxe_Exception.thrown("assert " + Std.string(type));
				}
				break;
			case 5:
				if(_g.size == 4) {
					if(_g.t._hx_index == 1) {
						if(_g1._hx_index == 0) {
							var len = _g1.v;
							var v1 = v;
							var _g2 = 0;
							var _g3 = len;
							while(_g2 < _g3) {
								var i = _g2++;
								var n = v1[i];
								if(n == null) {
									break;
								}
								out[pos++] = n.x;
								out[pos++] = n.y;
								out[pos++] = n.z;
								out[pos++] = n.w;
							}
							return len * 4;
						} else {
							throw haxe_Exception.thrown("assert " + Std.string(type));
						}
					} else if(_g1._hx_index == 0) {
						var t = _g;
						var len = _g1.v;
						var v1 = v;
						var size = 0;
						var _g2 = 0;
						var _g3 = len;
						while(_g2 < _g3) {
							var i = _g2++;
							var n = v1[i];
							if(n == null) {
								break;
							}
							size = this.fillRec(n,t,out,pos);
							pos += size;
						}
						return len * size;
					} else {
						throw haxe_Exception.thrown("assert " + Std.string(type));
					}
				} else if(_g1._hx_index == 0) {
					var t = _g;
					var len = _g1.v;
					var v1 = v;
					var size = 0;
					var _g2 = 0;
					var _g3 = len;
					while(_g2 < _g3) {
						var i = _g2++;
						var n = v1[i];
						if(n == null) {
							break;
						}
						size = this.fillRec(n,t,out,pos);
						pos += size;
					}
					return len * size;
				} else {
					throw haxe_Exception.thrown("assert " + Std.string(type));
				}
				break;
			case 8:
				if(_g1._hx_index == 0) {
					var len = _g1.v;
					var v1 = v;
					var _g2 = 0;
					var _g3 = len;
					while(_g2 < _g3) {
						var i = _g2++;
						var m = v1[i];
						if(m == null) {
							break;
						}
						out[pos++] = m._11;
						out[pos++] = m._21;
						out[pos++] = m._31;
						out[pos++] = m._41;
						out[pos++] = m._12;
						out[pos++] = m._22;
						out[pos++] = m._32;
						out[pos++] = m._42;
						out[pos++] = m._13;
						out[pos++] = m._23;
						out[pos++] = m._33;
						out[pos++] = m._43;
					}
					return len * 12;
				} else {
					throw haxe_Exception.thrown("assert " + Std.string(type));
				}
				break;
			default:
				if(_g1._hx_index == 0) {
					var t = _g;
					var len = _g1.v;
					var v1 = v;
					var size = 0;
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						var n = v1[i];
						if(n == null) {
							break;
						}
						size = this.fillRec(n,t,out,pos);
						pos += size;
					}
					return len * size;
				} else {
					throw haxe_Exception.thrown("assert " + Std.string(type));
				}
			}
			break;
		default:
			throw haxe_Exception.thrown("assert " + Std.string(type));
		}
	}
	,shaderInfo: function(shaders,path) {
		var name = path.split(".").pop();
		while(shaders != null) {
			var inst = shaders.s.instance;
			var _g = 0;
			var _g1 = inst.shader.vars;
			while(_g < _g1.length) {
				var v = _g1[_g];
				++_g;
				if(v.name == name) {
					return shaders.s.toString();
				}
			}
			shaders = shaders.next;
		}
		return "(not found)";
	}
	,fillGlobals: function(buf,s) {
		var _gthis = this;
		var s1 = s.vertex;
		var g = s1.globals;
		var ptr = buf.vertex.globals;
		while(g != null) {
			var v = _gthis.globals.map.h[g.gid];
			if(v == null) {
				if(g.path == "__consts__") {
					_gthis.fillRec(s1.consts,g.type,ptr,g.pos);
					g = g.next;
					continue;
				}
				throw haxe_Exception.thrown("Missing global value " + g.path);
			}
			_gthis.fillRec(v,g.type,ptr,g.pos);
			g = g.next;
		}
		var s1 = s.fragment;
		var g = s1.globals;
		var ptr = buf.fragment.globals;
		while(g != null) {
			var v = _gthis.globals.map.h[g.gid];
			if(v == null) {
				if(g.path == "__consts__") {
					_gthis.fillRec(s1.consts,g.type,ptr,g.pos);
					g = g.next;
					continue;
				}
				throw haxe_Exception.thrown("Missing global value " + g.path);
			}
			_gthis.fillRec(v,g.type,ptr,g.pos);
			g = g.next;
		}
	}
	,fillParams: function(buf,s,shaders) {
		var _gthis = this;
		var curInstance = -1;
		var curInstanceValue = null;
		var buf1 = buf.vertex;
		var s1 = s.vertex;
		var p = s1.params;
		var ptr = buf1.params;
		while(p != null) {
			var v;
			if(p.perObjectGlobal == null) {
				if(p.type == hxsl_Type.TFloat) {
					var index = p.instance;
					var i;
					if(curInstance == index) {
						i = curInstanceValue;
					} else {
						var si = shaders;
						curInstance = index;
						while(--index > 0) si = si.next;
						curInstanceValue = si.s;
						i = curInstanceValue;
					}
					ptr[p.pos] = i.getParamFloatValue(p.index);
					p = p.next;
					continue;
				}
				var index1 = p.instance;
				var v1;
				if(curInstance == index1) {
					v1 = curInstanceValue;
				} else {
					var si1 = shaders;
					curInstance = index1;
					while(--index1 > 0) si1 = si1.next;
					curInstanceValue = si1.s;
					v1 = curInstanceValue;
				}
				v = v1.getParamValue(p.index);
				if(v == null) {
					throw haxe_Exception.thrown("Missing param value " + Std.string(curInstanceValue) + "." + p.name);
				}
			} else if(p.perObjectGlobal != null) {
				var v2 = _gthis.globals.map.h[p.perObjectGlobal.gid];
				if(v2 == null) {
					throw haxe_Exception.thrown("Missing global value " + p.perObjectGlobal.path + " for shader " + _gthis.shaderInfo(shaders,p.perObjectGlobal.path));
				}
				var _g = p.type;
				var v3;
				if(_g._hx_index == 17) {
					var _g1 = _g.size;
					v3 = true;
				} else {
					v3 = false;
				}
				v = v3 ? v2.texture : v2;
			} else {
				var index2 = p.instance;
				var v4;
				if(curInstance == index2) {
					v4 = curInstanceValue;
				} else {
					var si2 = shaders;
					curInstance = index2;
					while(--index2 > 0) si2 = si2.next;
					curInstanceValue = si2.s;
					v4 = curInstanceValue;
				}
				var v5 = v4.getParamValue(p.index);
				if(v5 == null) {
					throw haxe_Exception.thrown("Missing param value " + Std.string(shaders.s) + "." + p.name);
				}
				v = v5;
			}
			_gthis.fillRec(v,p.type,ptr,p.pos);
			p = p.next;
		}
		var tid = 0;
		var p = s1.textures;
		while(p != null) {
			var opt = !h3d_pass_ShaderManager.STRICT;
			if(opt == null) {
				opt = false;
			}
			var t;
			if(p.perObjectGlobal != null) {
				var v = _gthis.globals.map.h[p.perObjectGlobal.gid];
				if(v == null) {
					throw haxe_Exception.thrown("Missing global value " + p.perObjectGlobal.path + " for shader " + _gthis.shaderInfo(shaders,p.perObjectGlobal.path));
				}
				var _g = p.type;
				var t1;
				if(_g._hx_index == 17) {
					var _g1 = _g.size;
					t1 = true;
				} else {
					t1 = false;
				}
				t = t1 ? v.texture : v;
			} else {
				var index = p.instance;
				var v1;
				if(curInstance == index) {
					v1 = curInstanceValue;
				} else {
					var si = shaders;
					curInstance = index;
					while(--index > 0) si = si.next;
					curInstanceValue = si.s;
					v1 = curInstanceValue;
				}
				var v2 = v1.getParamValue(p.index);
				if(v2 == null && !opt) {
					throw haxe_Exception.thrown("Missing param value " + Std.string(shaders.s) + "." + p.name);
				}
				t = v2;
			}
			if(p.pos < 0) {
				var arr = t;
				var _g2 = 0;
				var _g3 = -p.pos;
				while(_g2 < _g3) {
					var i = _g2++;
					buf1.tex[tid++] = arr[i];
				}
			} else {
				buf1.tex[tid++] = t;
			}
			p = p.next;
		}
		var p = s1.buffers;
		var bid = 0;
		while(p != null) {
			var opt = !h3d_pass_ShaderManager.STRICT;
			if(opt == null) {
				opt = false;
			}
			var b;
			if(p.perObjectGlobal != null) {
				var v = _gthis.globals.map.h[p.perObjectGlobal.gid];
				if(v == null) {
					throw haxe_Exception.thrown("Missing global value " + p.perObjectGlobal.path + " for shader " + _gthis.shaderInfo(shaders,p.perObjectGlobal.path));
				}
				var _g = p.type;
				var b1;
				if(_g._hx_index == 17) {
					var _g1 = _g.size;
					b1 = true;
				} else {
					b1 = false;
				}
				b = b1 ? v.texture : v;
			} else {
				var index = p.instance;
				var v1;
				if(curInstance == index) {
					v1 = curInstanceValue;
				} else {
					var si = shaders;
					curInstance = index;
					while(--index > 0) si = si.next;
					curInstanceValue = si.s;
					v1 = curInstanceValue;
				}
				var v2 = v1.getParamValue(p.index);
				if(v2 == null && !opt) {
					throw haxe_Exception.thrown("Missing param value " + Std.string(shaders.s) + "." + p.name);
				}
				b = v2;
			}
			buf1.buffers[bid++] = b;
			p = p.next;
		}
		var buf1 = buf.fragment;
		var s1 = s.fragment;
		var p = s1.params;
		var ptr = buf1.params;
		while(p != null) {
			var v;
			if(p.perObjectGlobal == null) {
				if(p.type == hxsl_Type.TFloat) {
					var index = p.instance;
					var i;
					if(curInstance == index) {
						i = curInstanceValue;
					} else {
						var si = shaders;
						curInstance = index;
						while(--index > 0) si = si.next;
						curInstanceValue = si.s;
						i = curInstanceValue;
					}
					ptr[p.pos] = i.getParamFloatValue(p.index);
					p = p.next;
					continue;
				}
				var index1 = p.instance;
				var v1;
				if(curInstance == index1) {
					v1 = curInstanceValue;
				} else {
					var si1 = shaders;
					curInstance = index1;
					while(--index1 > 0) si1 = si1.next;
					curInstanceValue = si1.s;
					v1 = curInstanceValue;
				}
				v = v1.getParamValue(p.index);
				if(v == null) {
					throw haxe_Exception.thrown("Missing param value " + Std.string(curInstanceValue) + "." + p.name);
				}
			} else if(p.perObjectGlobal != null) {
				var v2 = _gthis.globals.map.h[p.perObjectGlobal.gid];
				if(v2 == null) {
					throw haxe_Exception.thrown("Missing global value " + p.perObjectGlobal.path + " for shader " + _gthis.shaderInfo(shaders,p.perObjectGlobal.path));
				}
				var _g = p.type;
				var v3;
				if(_g._hx_index == 17) {
					var _g1 = _g.size;
					v3 = true;
				} else {
					v3 = false;
				}
				v = v3 ? v2.texture : v2;
			} else {
				var index2 = p.instance;
				var v4;
				if(curInstance == index2) {
					v4 = curInstanceValue;
				} else {
					var si2 = shaders;
					curInstance = index2;
					while(--index2 > 0) si2 = si2.next;
					curInstanceValue = si2.s;
					v4 = curInstanceValue;
				}
				var v5 = v4.getParamValue(p.index);
				if(v5 == null) {
					throw haxe_Exception.thrown("Missing param value " + Std.string(shaders.s) + "." + p.name);
				}
				v = v5;
			}
			_gthis.fillRec(v,p.type,ptr,p.pos);
			p = p.next;
		}
		var tid = 0;
		var p = s1.textures;
		while(p != null) {
			var opt = !h3d_pass_ShaderManager.STRICT;
			if(opt == null) {
				opt = false;
			}
			var t;
			if(p.perObjectGlobal != null) {
				var v = _gthis.globals.map.h[p.perObjectGlobal.gid];
				if(v == null) {
					throw haxe_Exception.thrown("Missing global value " + p.perObjectGlobal.path + " for shader " + _gthis.shaderInfo(shaders,p.perObjectGlobal.path));
				}
				var _g = p.type;
				var t1;
				if(_g._hx_index == 17) {
					var _g1 = _g.size;
					t1 = true;
				} else {
					t1 = false;
				}
				t = t1 ? v.texture : v;
			} else {
				var index = p.instance;
				var v1;
				if(curInstance == index) {
					v1 = curInstanceValue;
				} else {
					var si = shaders;
					curInstance = index;
					while(--index > 0) si = si.next;
					curInstanceValue = si.s;
					v1 = curInstanceValue;
				}
				var v2 = v1.getParamValue(p.index);
				if(v2 == null && !opt) {
					throw haxe_Exception.thrown("Missing param value " + Std.string(shaders.s) + "." + p.name);
				}
				t = v2;
			}
			if(p.pos < 0) {
				var arr = t;
				var _g2 = 0;
				var _g3 = -p.pos;
				while(_g2 < _g3) {
					var i = _g2++;
					buf1.tex[tid++] = arr[i];
				}
			} else {
				buf1.tex[tid++] = t;
			}
			p = p.next;
		}
		var p = s1.buffers;
		var bid = 0;
		while(p != null) {
			var opt = !h3d_pass_ShaderManager.STRICT;
			if(opt == null) {
				opt = false;
			}
			var b;
			if(p.perObjectGlobal != null) {
				var v = _gthis.globals.map.h[p.perObjectGlobal.gid];
				if(v == null) {
					throw haxe_Exception.thrown("Missing global value " + p.perObjectGlobal.path + " for shader " + _gthis.shaderInfo(shaders,p.perObjectGlobal.path));
				}
				var _g = p.type;
				var b1;
				if(_g._hx_index == 17) {
					var _g1 = _g.size;
					b1 = true;
				} else {
					b1 = false;
				}
				b = b1 ? v.texture : v;
			} else {
				var index = p.instance;
				var v1;
				if(curInstance == index) {
					v1 = curInstanceValue;
				} else {
					var si = shaders;
					curInstance = index;
					while(--index > 0) si = si.next;
					curInstanceValue = si.s;
					v1 = curInstanceValue;
				}
				var v2 = v1.getParamValue(p.index);
				if(v2 == null && !opt) {
					throw haxe_Exception.thrown("Missing param value " + Std.string(shaders.s) + "." + p.name);
				}
				b = v2;
			}
			buf1.buffers[bid++] = b;
			p = p.next;
		}
	}
	,compileShaders: function(shaders,batchMode) {
		if(batchMode == null) {
			batchMode = false;
		}
		this.globals.maxChannels = 0;
		var _g_l = shaders;
		var _g_last = null;
		while(_g_l != _g_last) {
			var s = _g_l.s;
			_g_l = _g_l.next;
			var s1 = s;
			s1.updateConstants(this.globals);
		}
		this.currentOutput.next = shaders;
		var s = this.shaderCache.link(this.currentOutput,batchMode);
		this.currentOutput.next = null;
		return s;
	}
	,__class__: h3d_pass_ShaderManager
};
var h3d_pass_RenderMode = $hxEnums["h3d.pass.RenderMode"] = { __ename__:true,__constructs__:null
	,None: {_hx_name:"None",_hx_index:0,__enum__:"h3d.pass.RenderMode",toString:$estr}
	,Static: {_hx_name:"Static",_hx_index:1,__enum__:"h3d.pass.RenderMode",toString:$estr}
	,Dynamic: {_hx_name:"Dynamic",_hx_index:2,__enum__:"h3d.pass.RenderMode",toString:$estr}
	,Mixed: {_hx_name:"Mixed",_hx_index:3,__enum__:"h3d.pass.RenderMode",toString:$estr}
};
h3d_pass_RenderMode.__constructs__ = [h3d_pass_RenderMode.None,h3d_pass_RenderMode.Static,h3d_pass_RenderMode.Dynamic,h3d_pass_RenderMode.Mixed];
h3d_pass_RenderMode.__empty_constructs__ = [h3d_pass_RenderMode.None,h3d_pass_RenderMode.Static,h3d_pass_RenderMode.Dynamic,h3d_pass_RenderMode.Mixed];
var h3d_pass_ShadowSamplingKind = $hxEnums["h3d.pass.ShadowSamplingKind"] = { __ename__:true,__constructs__:null
	,None: {_hx_name:"None",_hx_index:0,__enum__:"h3d.pass.ShadowSamplingKind",toString:$estr}
	,PCF: {_hx_name:"PCF",_hx_index:1,__enum__:"h3d.pass.ShadowSamplingKind",toString:$estr}
	,ESM: {_hx_name:"ESM",_hx_index:2,__enum__:"h3d.pass.ShadowSamplingKind",toString:$estr}
};
h3d_pass_ShadowSamplingKind.__constructs__ = [h3d_pass_ShadowSamplingKind.None,h3d_pass_ShadowSamplingKind.PCF,h3d_pass_ShadowSamplingKind.ESM];
h3d_pass_ShadowSamplingKind.__empty_constructs__ = [h3d_pass_ShadowSamplingKind.None,h3d_pass_ShadowSamplingKind.PCF,h3d_pass_ShadowSamplingKind.ESM];
var h3d_pass_SortByMaterial = function() {
	this.textureCount = 1;
	this.shaderCount = 1;
	this.shaderIdMap = [];
	this.textureIdMap = [];
};
$hxClasses["h3d.pass.SortByMaterial"] = h3d_pass_SortByMaterial;
h3d_pass_SortByMaterial.__name__ = "h3d.pass.SortByMaterial";
h3d_pass_SortByMaterial.prototype = {
	sort: function(passes) {
		var _gthis = this;
		var shaderStart = this.shaderCount;
		var textureStart = this.textureCount;
		var _g_o = passes.current;
		while(_g_o != null) {
			var tmp = _g_o;
			_g_o = _g_o.next;
			var p = tmp;
			if(this.shaderIdMap[p.shader.id] < shaderStart || this.shaderIdMap[p.shader.id] == null) {
				this.shaderIdMap[p.shader.id] = this.shaderCount++;
			}
			if(this.textureIdMap[p.texture] < textureStart || this.textureIdMap[p.shader.id] == null) {
				this.textureIdMap[p.texture] = this.textureCount++;
			}
		}
		var list = passes.current;
		var tmp;
		if(list == null) {
			tmp = null;
		} else {
			var insize = 1;
			var nmerges;
			var psize = 0;
			var qsize = 0;
			var p;
			var q;
			var e;
			var tail;
			while(true) {
				p = list;
				list = null;
				tail = null;
				nmerges = 0;
				while(p != null) {
					++nmerges;
					q = p;
					psize = 0;
					var _g = 0;
					var _g1 = insize;
					while(_g < _g1) {
						var i = _g++;
						++psize;
						q = q.next;
						if(q == null) {
							break;
						}
					}
					qsize = insize;
					while(psize > 0 || qsize > 0 && q != null) {
						if(psize == 0) {
							e = q;
							q = q.next;
							--qsize;
						} else {
							var tmp1;
							if(!(qsize == 0 || q == null)) {
								var tmp2;
								if(p.pass.layer != q.pass.layer) {
									tmp2 = p.pass.layer - q.pass.layer;
								} else {
									var d = _gthis.shaderIdMap[p.shader.id] - _gthis.shaderIdMap[q.shader.id];
									tmp2 = d != 0 ? d : _gthis.textureIdMap[p.texture] - _gthis.textureIdMap[q.texture];
								}
								tmp1 = tmp2 <= 0;
							} else {
								tmp1 = true;
							}
							if(tmp1) {
								e = p;
								p = p.next;
								--psize;
							} else {
								e = q;
								q = q.next;
								--qsize;
							}
						}
						if(tail != null) {
							tail.next = e;
						} else {
							list = e;
						}
						tail = e;
					}
					p = q;
				}
				tail.next = null;
				if(nmerges <= 1) {
					break;
				}
				insize *= 2;
			}
			tmp = list;
		}
		passes.current = tmp;
	}
	,__class__: h3d_pass_SortByMaterial
};
var h3d_prim_MeshPrimitive = function() {
	h3d_prim_Primitive.call(this);
};
$hxClasses["h3d.prim.MeshPrimitive"] = h3d_prim_MeshPrimitive;
h3d_prim_MeshPrimitive.__name__ = "h3d.prim.MeshPrimitive";
h3d_prim_MeshPrimitive.__super__ = h3d_prim_Primitive;
h3d_prim_MeshPrimitive.prototype = $extend(h3d_prim_Primitive.prototype,{
	allocBuffer: function(engine,name) {
		return null;
	}
	,addBuffer: function(name,buf,offset) {
		if(offset == null) {
			offset = 0;
		}
		if(this.bufferCache == null) {
			this.bufferCache = new haxe_ds_IntMap();
		}
		var id = hxsl_Globals.allocID(name);
		var old = this.bufferCache.h[id];
		if(old != null) {
			old.dispose();
		}
		var this1 = this.bufferCache;
		var value = new h3d_BufferOffset(buf,offset);
		this1.h[id] = value;
		this.layouts = null;
	}
	,dispose: function() {
		h3d_prim_Primitive.prototype.dispose.call(this);
		if(this.bufferCache != null) {
			var b = this.bufferCache.iterator();
			while(b.hasNext()) {
				var b1 = b.next();
				b1.dispose();
			}
		}
		this.bufferCache = null;
		this.layouts = null;
	}
	,getBuffers: function(engine) {
		if(this.bufferCache == null) {
			this.bufferCache = new haxe_ds_IntMap();
		}
		if(this.layouts == null) {
			this.layouts = new haxe_ds_IntMap();
		}
		var inputs = engine.driver.getShaderInputNames();
		var buffers = this.layouts.h[inputs.id];
		if(buffers != null) {
			return buffers;
		}
		var prev = null;
		var _g = 0;
		var _g1 = inputs.names;
		while(_g < _g1.length) {
			var name = _g1[_g];
			++_g;
			var id = hxsl_Globals.allocID(name);
			var b = this.bufferCache.h[id];
			if(b == null) {
				b = this.allocBuffer(engine,name);
				if(b == null) {
					throw haxe_Exception.thrown("Buffer " + name + " is not available");
				}
				this.bufferCache.h[id] = b;
			}
			var b1 = new h3d_BufferOffset(b.buffer,b.offset);
			b = b1;
			if(prev == null) {
				prev = b;
				buffers = prev;
			} else {
				prev.next = b;
				prev = b;
			}
		}
		this.layouts.h[inputs.id] = buffers;
		return buffers;
	}
	,render: function(engine) {
		if(this.indexes == null || this.indexes.isDisposed()) {
			this.alloc(engine);
		}
		engine.renderMultiBuffers(this.getBuffers(engine),this.indexes);
	}
	,__class__: h3d_prim_MeshPrimitive
});
var h3d_prim_Instanced = function() {
	h3d_prim_MeshPrimitive.call(this);
	this.bounds = new h3d_col_Bounds();
	var _this = this.bounds;
	if(0 < _this.xMin) {
		_this.xMin = 0;
	}
	if(0 > _this.xMax) {
		_this.xMax = 0;
	}
	if(0 < _this.yMin) {
		_this.yMin = 0;
	}
	if(0 > _this.yMax) {
		_this.yMax = 0;
	}
	if(0 < _this.zMin) {
		_this.zMin = 0;
	}
	if(0 > _this.zMax) {
		_this.zMax = 0;
	}
	this.tmpBounds = new h3d_col_Bounds();
};
$hxClasses["h3d.prim.Instanced"] = h3d_prim_Instanced;
h3d_prim_Instanced.__name__ = "h3d.prim.Instanced";
h3d_prim_Instanced.__super__ = h3d_prim_MeshPrimitive;
h3d_prim_Instanced.prototype = $extend(h3d_prim_MeshPrimitive.prototype,{
	setMesh: function(m) {
		if(this.refCount > 0) {
			if(this.primitive != null) {
				this.primitive.decref();
			}
			m.incref();
		}
		this.primitive = m;
		var engine = h3d_Engine.CURRENT;
		var tmp;
		if(m.buffer != null) {
			var _this = m.buffer;
			tmp = _this.buffer == null || _this.buffer.vbuf == null;
		} else {
			tmp = true;
		}
		if(tmp) {
			m.alloc(engine);
		}
		this.buffer = m.buffer;
		this.indexes = m.indexes;
		this.baseBounds = m.getBounds();
		if(this.indexes == null) {
			this.indexes = engine.mem.triIndexes;
		}
		var bid = m.bufferCache.keys();
		while(bid.hasNext()) {
			var bid1 = bid.next();
			var b = m.bufferCache.h[bid1];
			this.addBuffer(hxsl_Globals.getIDName(bid1),b.buffer,b.offset);
		}
	}
	,dispose: function() {
	}
	,incref: function() {
		if(this.refCount == 0 && this.primitive != null) {
			this.primitive.incref();
		}
		h3d_prim_MeshPrimitive.prototype.incref.call(this);
	}
	,decref: function() {
		h3d_prim_MeshPrimitive.prototype.decref.call(this);
		if(this.refCount == 0 && this.primitive != null) {
			this.primitive.decref();
		}
	}
	,getBounds: function() {
		return this.bounds;
	}
	,addBuffer: function(name,buffer,offset) {
		if(offset == null) {
			offset = 0;
		}
		h3d_prim_MeshPrimitive.prototype.addBuffer.call(this,name,buffer,offset);
	}
	,render: function(engine) {
		var _this = this.buffer;
		if(_this.buffer == null || _this.buffer.vbuf == null) {
			this.setMesh(this.primitive);
		}
		engine.renderInstanced(this.getBuffers(engine),this.indexes,this.commands);
	}
	,__class__: h3d_prim_Instanced
});
var h3d_prim_Plane2D = function() {
	h3d_prim_Primitive.call(this);
};
$hxClasses["h3d.prim.Plane2D"] = h3d_prim_Plane2D;
h3d_prim_Plane2D.__name__ = "h3d.prim.Plane2D";
h3d_prim_Plane2D.get = function() {
	var engine = h3d_Engine.CURRENT;
	var inst = engine.resCache.h[h3d_prim_Plane2D.__id__];
	if(inst == null) {
		inst = new h3d_prim_Plane2D();
		engine.resCache.set(h3d_prim_Plane2D,inst);
	}
	return inst;
};
h3d_prim_Plane2D.__super__ = h3d_prim_Primitive;
h3d_prim_Plane2D.prototype = $extend(h3d_prim_Primitive.prototype,{
	alloc: function(engine) {
		var this1 = hxd__$FloatBuffer_Float32Expand._new(0);
		var v = this1;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = -1;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = -1;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 0;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 1;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = -1;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 1;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 0;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 0;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 1;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = -1;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 1;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 1;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 1;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 1;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 1;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 0;
		this.buffer = h3d_Buffer.ofFloats(v,4,[h3d_BufferFlag.Quads,h3d_BufferFlag.RawFormat]);
	}
	,render: function(engine) {
		var tmp;
		if(this.buffer != null) {
			var _this = this.buffer;
			tmp = _this.buffer == null || _this.buffer.vbuf == null;
		} else {
			tmp = true;
		}
		if(tmp) {
			this.alloc(engine);
		}
		engine.renderBuffer(this.buffer,engine.mem.quadIndexes,2,0,-1);
	}
	,__class__: h3d_prim_Plane2D
});
var h3d_prim_RawPrimitive = function(inf,persist) {
	if(persist == null) {
		persist = false;
	}
	h3d_prim_Primitive.call(this);
	this.onContextLost = function() {
		return inf;
	};
	this.bounds = inf.bounds;
	this.alloc(null);
	if(!persist) {
		this.onContextLost = null;
	}
};
$hxClasses["h3d.prim.RawPrimitive"] = h3d_prim_RawPrimitive;
h3d_prim_RawPrimitive.__name__ = "h3d.prim.RawPrimitive";
h3d_prim_RawPrimitive.__super__ = h3d_prim_Primitive;
h3d_prim_RawPrimitive.prototype = $extend(h3d_prim_Primitive.prototype,{
	alloc: function(engine) {
		if(this.onContextLost == null) {
			throw haxe_Exception.thrown("Cannot realloc " + Std.string(this));
		}
		var inf = this.onContextLost();
		var flags = [];
		if(inf.ibuf == null) {
			flags.push(inf.quads ? h3d_BufferFlag.Quads : h3d_BufferFlag.Triangles);
		}
		if(inf.stride < 8) {
			flags.push(h3d_BufferFlag.RawFormat);
		}
		this.buffer = h3d_Buffer.ofFloats(inf.vbuf,inf.stride,flags);
		this.vcount = this.buffer.vertices;
		this.tcount = inf.ibuf != null ? inf.ibuf.length / 3 | 0 : inf.quads ? this.vcount >> 1 : this.vcount / 3 | 0;
		if(inf.ibuf != null) {
			this.indexes = h3d_Indexes.alloc(inf.ibuf);
		} else if(this.indexes != null) {
			this.indexes.dispose();
			this.indexes = null;
		}
	}
	,getBounds: function() {
		if(this.bounds == null) {
			throw haxe_Exception.thrown("Bounds not defined for " + Std.string(this));
		}
		return this.bounds;
	}
	,__class__: h3d_prim_RawPrimitive
});
var h3d_scene_Mesh = function(primitive,material,parent) {
	h3d_scene_Object.call(this,parent);
	this.set_primitive(primitive);
	if(material == null) {
		material = h3d_mat_MaterialSetup.current.createMaterial();
		material.set_props(material.getDefaultProps());
	}
	this.material = material;
};
$hxClasses["h3d.scene.Mesh"] = h3d_scene_Mesh;
h3d_scene_Mesh.__name__ = "h3d.scene.Mesh";
h3d_scene_Mesh.__super__ = h3d_scene_Object;
h3d_scene_Mesh.prototype = $extend(h3d_scene_Object.prototype,{
	draw: function(ctx) {
		this.primitive.render(ctx.engine);
	}
	,emit: function(ctx) {
		var p = this.material.passes;
		while(p != null) {
			ctx.emitPass(p,this).index = 0;
			p = p.nextPass;
		}
	}
	,onAdd: function() {
		h3d_scene_Object.prototype.onAdd.call(this);
		if(this.primitive != null) {
			this.primitive.incref();
		}
	}
	,onRemove: function() {
		if(this.primitive != null) {
			this.primitive.decref();
		}
		h3d_scene_Object.prototype.onRemove.call(this);
	}
	,set_primitive: function(prim) {
		if(prim != this.primitive && (this.flags & 32) != 0) {
			if(this.primitive != null) {
				this.primitive.decref();
			}
			if(prim != null) {
				prim.incref();
			}
		}
		return this.primitive = prim;
	}
	,__class__: h3d_scene_Mesh
});
var h3d_scene_Interactive = function(shape,parent) {
	this.hitPoint = new h3d_Vector();
	this.lastClickFrame = -1;
	this.mouseDownButton = -1;
	this.allowMultiClick = false;
	this.enableRightButton = false;
	this.propagateEvents = false;
	this.cancelEvents = false;
	h3d_scene_Object.call(this,parent);
	this.shape = shape;
	this.set_cursor(hxd_Cursor.Button);
};
$hxClasses["h3d.scene.Interactive"] = h3d_scene_Interactive;
h3d_scene_Interactive.__name__ = "h3d.scene.Interactive";
h3d_scene_Interactive.__interfaces__ = [hxd_Interactive];
h3d_scene_Interactive.__super__ = h3d_scene_Object;
h3d_scene_Interactive.prototype = $extend(h3d_scene_Object.prototype,{
	onAdd: function() {
		this.scene = this.getScene();
		if(this.scene != null) {
			this.scene.addEventTarget(this);
		}
		h3d_scene_Object.prototype.onAdd.call(this);
	}
	,onRemove: function() {
		if(this.scene != null) {
			this.scene.removeEventTarget(this);
			this.scene = null;
		}
		h3d_scene_Object.prototype.onRemove.call(this);
	}
	,getInteractiveScene: function() {
		return this.scene;
	}
	,handleEvent: function(e) {
		if(this.propagateEvents) {
			e.propagate = true;
		}
		if(this.cancelEvents) {
			e.cancel = true;
		}
		switch(e.kind._hx_index) {
		case 0:
			if(this.enableRightButton || e.button == 0) {
				this.mouseDownButton = e.button;
				this.onPush(e);
				if(e.cancel) {
					this.mouseDownButton = -1;
				}
			}
			break;
		case 1:
			if(this.enableRightButton || e.button == 0) {
				this.onRelease(e);
				var frame = hxd_Timer.frameCount;
				if(this.mouseDownButton == e.button && (this.lastClickFrame != frame || this.allowMultiClick)) {
					this.onClick(e);
					this.lastClickFrame = frame;
				}
			}
			this.mouseDownButton = -1;
			break;
		case 2:
			this.onMove(e);
			break;
		case 3:
			this.onOver(e);
			break;
		case 4:
			this.onOut(e);
			break;
		case 5:
			this.onWheel(e);
			break;
		case 6:
			this.onFocus(e);
			break;
		case 7:
			this.onFocusLost(e);
			break;
		case 8:
			this.onKeyDown(e);
			break;
		case 9:
			this.onKeyUp(e);
			break;
		case 10:
			if(this.enableRightButton || e.button == 0) {
				this.onRelease(e);
				if(this.mouseDownButton == e.button) {
					this.onReleaseOutside(e);
				}
			}
			this.mouseDownButton = -1;
			break;
		case 11:
			this.onTextInput(e);
			break;
		case 12:
			this.onCheck(e);
			break;
		}
	}
	,set_cursor: function(c) {
		this.cursor = c;
		if(this.scene != null && this.scene.events != null) {
			this.scene.events.updateCursor(this);
		}
		return c;
	}
	,onOver: function(e) {
	}
	,onOut: function(e) {
	}
	,onPush: function(e) {
	}
	,onRelease: function(e) {
	}
	,onReleaseOutside: function(e) {
	}
	,onClick: function(e) {
	}
	,onMove: function(e) {
	}
	,onWheel: function(e) {
	}
	,onFocus: function(e) {
	}
	,onFocusLost: function(e) {
	}
	,onKeyUp: function(e) {
	}
	,onKeyDown: function(e) {
	}
	,onCheck: function(e) {
	}
	,onTextInput: function(e) {
	}
	,__class__: h3d_scene_Interactive
});
var h3d_scene_Light = function(shader,parent) {
	h3d_scene_Object.call(this,parent);
	this.shader = shader;
};
$hxClasses["h3d.scene.Light"] = h3d_scene_Light;
h3d_scene_Light.__name__ = "h3d.scene.Light";
h3d_scene_Light.__super__ = h3d_scene_Object;
h3d_scene_Light.prototype = $extend(h3d_scene_Object.prototype,{
	emit: function(ctx) {
		ctx.emitLight(this);
	}
	,getShadowDirection: function() {
		return null;
	}
	,__class__: h3d_scene_Light
});
var h3d_scene_LightSystem = function() {
};
$hxClasses["h3d.scene.LightSystem"] = h3d_scene_LightSystem;
h3d_scene_LightSystem.__name__ = "h3d.scene.LightSystem";
h3d_scene_LightSystem.prototype = {
	initGlobals: function(globals) {
	}
	,initLights: function(ctx) {
		this.ctx = ctx;
		if(this.shadowLight == null || (this.shadowLight.flags & 32) == 0) {
			var l = ctx.lights;
			while(l != null) {
				var dir = l.getShadowDirection();
				if(dir != null) {
					this.shadowLight = l;
					break;
				}
				l = l.next;
			}
		}
	}
	,computeLight: function(obj,shaders) {
		return shaders;
	}
	,__class__: h3d_scene_LightSystem
};
var h3d_scene__$RenderContext_SharedGlobal = function(gid,value) {
	this.gid = gid;
	this.value = value;
};
$hxClasses["h3d.scene._RenderContext.SharedGlobal"] = h3d_scene__$RenderContext_SharedGlobal;
h3d_scene__$RenderContext_SharedGlobal.__name__ = "h3d.scene._RenderContext.SharedGlobal";
h3d_scene__$RenderContext_SharedGlobal.prototype = {
	__class__: h3d_scene__$RenderContext_SharedGlobal
};
var h3d_scene_RenderContext = function() {
	h3d_impl_RenderContext.call(this);
	this.cachedShaderList = [];
	this.cachedPassObjects = [];
};
$hxClasses["h3d.scene.RenderContext"] = h3d_scene_RenderContext;
h3d_scene_RenderContext.__name__ = "h3d.scene.RenderContext";
h3d_scene_RenderContext.__super__ = h3d_impl_RenderContext;
h3d_scene_RenderContext.prototype = $extend(h3d_impl_RenderContext.prototype,{
	start: function() {
		this.sharedGlobals = [];
		this.lights = null;
		this.drawPass = null;
		this.passes = [];
		this.lights = null;
		this.cachedPos = 0;
		this.visibleFlag = true;
		this.time += this.elapsedTime;
		this.frame++;
	}
	,setGlobalID: function(gid,value) {
		var _g = 0;
		var _g1 = this.sharedGlobals;
		while(_g < _g1.length) {
			var g = _g1[_g];
			++_g;
			if(g.gid == gid) {
				g.value = value;
				return;
			}
		}
		this.sharedGlobals.push(new h3d_scene__$RenderContext_SharedGlobal(gid,value));
	}
	,emitPass: function(pass,obj) {
		var o = this.allocPool;
		if(o == null) {
			o = new h3d_pass_PassObject();
			o.nextAlloc = this.allocFirst;
			this.allocFirst = o;
		} else {
			this.allocPool = o.nextAlloc;
		}
		o.pass = pass;
		o.obj = obj;
		if(this.passes.length <= pass.passId) {
			this.passes.length = pass.passId;
		}
		o.next = this.passes[pass.passId];
		this.passes[pass.passId] = o;
		return o;
	}
	,allocShaderList: function(s,next) {
		var sl = this.cachedShaderList[this.cachedPos++];
		if(sl == null) {
			sl = new hxsl_ShaderList(null);
			this.cachedShaderList[this.cachedPos - 1] = sl;
		}
		sl.s = s;
		sl.next = next;
		return sl;
	}
	,emitLight: function(l) {
		l.next = this.lights;
		this.lights = l;
	}
	,done: function() {
		this.drawPass = null;
		var p = this.allocFirst;
		while(p != null && p != this.allocPool) {
			p.obj = null;
			p.pass = null;
			p.shader = null;
			p.shaders = null;
			p.next = null;
			p.index = 0;
			p.texture = 0;
			p = p.nextAlloc;
		}
		if(this.allocPool != null) {
			this.allocFirst = this.allocFirst.nextAlloc;
		}
		this.allocPool = this.allocFirst;
		var _g = 0;
		var _g1 = this.cachedShaderList;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			c.s = null;
			c.next = null;
		}
		this.passes = [];
		this.lights = null;
	}
	,__class__: h3d_scene_RenderContext
});
var h3d_scene_PassObjects = function() {
	this.passes = new h3d_pass_PassList();
};
$hxClasses["h3d.scene.PassObjects"] = h3d_scene_PassObjects;
h3d_scene_PassObjects.__name__ = "h3d.scene.PassObjects";
h3d_scene_PassObjects.prototype = {
	__class__: h3d_scene_PassObjects
};
var h3d_scene_Renderer = function() {
	this.hasSetTarget = false;
	this.emptyPasses = new h3d_pass_PassList();
	this.allPasses = [];
	this.passObjects = new haxe_ds_StringMap();
	this.set_props(this.getDefaultProps());
	var _g = $bind(this,this.depthSort);
	var frontToBack = true;
	this.frontToBack = function(passes) {
		_g(frontToBack,passes);
	};
	var _g1 = $bind(this,this.depthSort);
	var frontToBack1 = false;
	this.backToFront = function(passes) {
		_g1(frontToBack1,passes);
	};
};
$hxClasses["h3d.scene.Renderer"] = h3d_scene_Renderer;
h3d_scene_Renderer.__name__ = "h3d.scene.Renderer";
h3d_scene_Renderer.__super__ = hxd_impl_AnyProps;
h3d_scene_Renderer.prototype = $extend(hxd_impl_AnyProps.prototype,{
	depthSort: function(frontToBack,passes) {
		var cam = this.ctx.camera.m;
		var _g_o = passes.current;
		while(_g_o != null) {
			var tmp = _g_o;
			_g_o = _g_o.next;
			var p = tmp;
			var z = p.obj.absPos._41 * cam._13 + p.obj.absPos._42 * cam._23 + p.obj.absPos._43 * cam._33 + cam._43;
			var w = p.obj.absPos._41 * cam._14 + p.obj.absPos._42 * cam._24 + p.obj.absPos._43 * cam._34 + cam._44;
			p.depth = z / w;
		}
		if(frontToBack) {
			var list = passes.current;
			var tmp;
			if(list == null) {
				tmp = null;
			} else {
				var insize = 1;
				var nmerges;
				var psize = 0;
				var qsize = 0;
				var p;
				var q;
				var e;
				var tail;
				while(true) {
					p = list;
					list = null;
					tail = null;
					nmerges = 0;
					while(p != null) {
						++nmerges;
						q = p;
						psize = 0;
						var _g = 0;
						var _g1 = insize;
						while(_g < _g1) {
							var i = _g++;
							++psize;
							q = q.next;
							if(q == null) {
								break;
							}
						}
						qsize = insize;
						while(psize > 0 || qsize > 0 && q != null) {
							if(psize == 0) {
								e = q;
								q = q.next;
								--qsize;
							} else if(qsize == 0 || q == null || (p.pass.layer == q.pass.layer ? p.depth > q.depth ? 1 : -1 : p.pass.layer - q.pass.layer) <= 0) {
								e = p;
								p = p.next;
								--psize;
							} else {
								e = q;
								q = q.next;
								--qsize;
							}
							if(tail != null) {
								tail.next = e;
							} else {
								list = e;
							}
							tail = e;
						}
						p = q;
					}
					tail.next = null;
					if(nmerges <= 1) {
						break;
					}
					insize *= 2;
				}
				tmp = list;
			}
			passes.current = tmp;
		} else {
			var list = passes.current;
			var tmp;
			if(list == null) {
				tmp = null;
			} else {
				var insize = 1;
				var nmerges;
				var psize = 0;
				var qsize = 0;
				var p;
				var q;
				var e;
				var tail;
				while(true) {
					p = list;
					list = null;
					tail = null;
					nmerges = 0;
					while(p != null) {
						++nmerges;
						q = p;
						psize = 0;
						var _g = 0;
						var _g1 = insize;
						while(_g < _g1) {
							var i = _g++;
							++psize;
							q = q.next;
							if(q == null) {
								break;
							}
						}
						qsize = insize;
						while(psize > 0 || qsize > 0 && q != null) {
							if(psize == 0) {
								e = q;
								q = q.next;
								--qsize;
							} else if(qsize == 0 || q == null || (p.pass.layer == q.pass.layer ? p.depth > q.depth ? -1 : 1 : p.pass.layer - q.pass.layer) <= 0) {
								e = p;
								p = p.next;
								--psize;
							} else {
								e = q;
								q = q.next;
								--qsize;
							}
							if(tail != null) {
								tail.next = e;
							} else {
								list = e;
							}
							tail = e;
						}
						p = q;
					}
					tail.next = null;
					if(nmerges <= 1) {
						break;
					}
					insize *= 2;
				}
				tmp = list;
			}
			passes.current = tmp;
		}
	}
	,resetTarget: function() {
		if(this.hasSetTarget) {
			this.ctx.engine.popTarget();
			this.hasSetTarget = false;
		}
	}
	,has: function(name) {
		return this.passObjects.h[name] != null;
	}
	,get: function(name) {
		var p = this.passObjects.h[name];
		if(p == null) {
			return this.emptyPasses;
		}
		p.rendered = true;
		return p.passes;
	}
	,render: function() {
		throw haxe_Exception.thrown("Not implemented");
	}
	,computeStatic: function() {
		throw haxe_Exception.thrown("Not implemented");
	}
	,start: function() {
	}
	,process: function(passes) {
		this.hasSetTarget = false;
		var _g = 0;
		var _g1 = this.allPasses;
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			p.setContext(this.ctx);
		}
		var _g = 0;
		while(_g < passes.length) {
			var p = passes[_g];
			++_g;
			this.passObjects.h[p.name] = p;
		}
		this.ctx.textures.begin();
		if(this.ctx.computingStatic) {
			this.computeStatic();
		} else {
			this.render();
		}
		this.resetTarget();
		var _g = 0;
		while(_g < passes.length) {
			var p = passes[_g];
			++_g;
			this.passObjects.h[p.name] = null;
		}
	}
	,__class__: h3d_scene_Renderer
});
var h3d_scene_Scene = function(createRenderer,createLightSystem) {
	if(createLightSystem == null) {
		createLightSystem = true;
	}
	if(createRenderer == null) {
		createRenderer = true;
	}
	h3d_scene_Object.call(this,null);
	this.window = hxd_Window.getInstance();
	this.eventListeners = [];
	this.hitInteractives = [];
	this.interactives = [];
	this.camera = new h3d_Camera();
	var engine = h3d_Engine.CURRENT;
	if(engine != null) {
		this.camera.screenRatio = engine.width / engine.height;
	}
	this.ctx = new h3d_scene_RenderContext();
	if(createRenderer) {
		this.set_renderer(h3d_mat_MaterialSetup.current.createRenderer());
	}
	if(createLightSystem) {
		this.lightSystem = h3d_mat_MaterialSetup.current.createLightSystem();
	}
};
$hxClasses["h3d.scene.Scene"] = h3d_scene_Scene;
h3d_scene_Scene.__name__ = "h3d.scene.Scene";
h3d_scene_Scene.__interfaces__ = [hxd_InteractiveScene,h3d_IDrawable];
h3d_scene_Scene.__super__ = h3d_scene_Object;
h3d_scene_Scene.prototype = $extend(h3d_scene_Object.prototype,{
	setEvents: function(events) {
		this.events = events;
	}
	,dispatchListeners: function(event) {
		var _g = 0;
		var _g1 = this.eventListeners;
		while(_g < _g1.length) {
			var l = _g1[_g];
			++_g;
			l(event);
			if(!event.propagate) {
				break;
			}
		}
	}
	,set_renderer: function(r) {
		this.renderer = r;
		if(r != null) {
			r.ctx = this.ctx;
		}
		return r;
	}
	,sortHitPointByCameraDistance: function(i1,i2) {
		var z1 = i1.hitPoint.w;
		var z2 = i2.hitPoint.w;
		if(z1 > z2) {
			return -1;
		}
		return 1;
	}
	,dispatchEvent: function(event,to) {
		var i = to;
		i.handleEvent(event);
	}
	,isInteractiveVisible: function(i) {
		var o = i;
		while(o != this) {
			if(o == null || (o.flags & 2) == 0) {
				return false;
			}
			o = o.parent;
		}
		return true;
	}
	,handleEvent: function(event,last) {
		if(this.interactives.length == 0) {
			return null;
		}
		if(this.hitInteractives.length == 0) {
			var screenX = (event.relX / this.window.get_width() - 0.5) * 2;
			var screenY = -(event.relY / this.window.get_height() - 0.5) * 2;
			var p0 = this.camera.unproject(screenX,screenY,0);
			var p1 = this.camera.unproject(screenX,screenY,1);
			var x = p0.x;
			var y = p0.y;
			var z = p0.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var p1_x = x;
			var p1_y = y;
			var p1_z = z;
			var x = p1.x;
			var y = p1.y;
			var z = p1.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var p2_x = x;
			var p2_y = y;
			var p2_z = z;
			var r = new h3d_col_Ray();
			r.px = p1_x;
			r.py = p1_y;
			r.pz = p1_z;
			r.lx = p2_x - p1_x;
			r.ly = p2_y - p1_y;
			r.lz = p2_z - p1_z;
			r.normalize();
			var r1 = r;
			var saveR_px = r1.px;
			var saveR_py = r1.py;
			var saveR_pz = r1.pz;
			var saveR_lx = r1.lx;
			var saveR_ly = r1.ly;
			var saveR_lz = r1.lz;
			var priority = -2147483648;
			var _g = 0;
			var _g1 = this.interactives;
			while(_g < _g1.length) {
				var i = _g1[_g];
				++_g;
				if(i.priority < priority) {
					continue;
				}
				var p = i;
				while(p != null && (p.flags & 2) != 0) p = p.parent;
				if(p != null) {
					continue;
				}
				var minv = i.getInvPos();
				var x = r1.px;
				var y = r1.py;
				var z = r1.pz;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var p_x = x;
				var p_y = y;
				var p_z = z;
				var p_w = 1.;
				var px = p_x * minv._11 + p_y * minv._21 + p_z * minv._31 + p_w * minv._41;
				var py = p_x * minv._12 + p_y * minv._22 + p_z * minv._32 + p_w * minv._42;
				var pz = p_x * minv._13 + p_y * minv._23 + p_z * minv._33 + p_w * minv._43;
				p_x = px;
				p_y = py;
				p_z = pz;
				r1.px = p_x;
				r1.py = p_y;
				r1.pz = p_z;
				var x1 = r1.lx;
				var y1 = r1.ly;
				var z1 = r1.lz;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				var l_x = x1;
				var l_y = y1;
				var l_z = z1;
				var l_w = 1.;
				var px1 = l_x * minv._11 + l_y * minv._21 + l_z * minv._31;
				var py1 = l_x * minv._12 + l_y * minv._22 + l_z * minv._32;
				var pz1 = l_x * minv._13 + l_y * minv._23 + l_z * minv._33;
				l_x = px1;
				l_y = py1;
				l_z = pz1;
				r1.lx = l_x;
				r1.ly = l_y;
				r1.lz = l_z;
				r1.normalize();
				if(r1.lx != r1.lx) {
					r1.px = saveR_px;
					r1.py = saveR_py;
					r1.pz = saveR_pz;
					r1.lx = saveR_lx;
					r1.ly = saveR_ly;
					r1.lz = saveR_lz;
					continue;
				}
				var hit = i.shape.rayIntersection(r1,i.bestMatch);
				if(hit < 0) {
					r1.px = saveR_px;
					r1.py = saveR_py;
					r1.pz = saveR_pz;
					r1.lx = saveR_lx;
					r1.ly = saveR_ly;
					r1.lz = saveR_lz;
					continue;
				}
				var x2 = r1.px + hit * r1.lx;
				var y2 = r1.py + hit * r1.ly;
				var z2 = r1.pz + hit * r1.lz;
				if(z2 == null) {
					z2 = 0.;
				}
				if(y2 == null) {
					y2 = 0.;
				}
				if(x2 == null) {
					x2 = 0.;
				}
				var hitPoint_x = x2;
				var hitPoint_y = y2;
				var hitPoint_z = z2;
				r1.px = saveR_px;
				r1.py = saveR_py;
				r1.pz = saveR_pz;
				r1.lx = saveR_lx;
				r1.ly = saveR_ly;
				r1.lz = saveR_lz;
				i.hitPoint.x = hitPoint_x;
				i.hitPoint.y = hitPoint_y;
				i.hitPoint.z = hitPoint_z;
				if(i.priority > priority) {
					while(this.hitInteractives.length > 0) this.hitInteractives.pop();
					priority = i.priority;
				}
				this.hitInteractives.push(i);
			}
			if(this.hitInteractives.length == 0) {
				return null;
			}
			if(this.hitInteractives.length > 1) {
				var _g = 0;
				var _g1 = this.hitInteractives;
				while(_g < _g1.length) {
					var i = _g1[_g];
					++_g;
					var m = i.invPos;
					var wfactor = 0.;
					if(i.preciseShape != null) {
						var x = r1.px;
						var y = r1.py;
						var z = r1.pz;
						if(z == null) {
							z = 0.;
						}
						if(y == null) {
							y = 0.;
						}
						if(x == null) {
							x = 0.;
						}
						var p_x = x;
						var p_y = y;
						var p_z = z;
						var p_w = 1.;
						var px = p_x * m._11 + p_y * m._21 + p_z * m._31 + p_w * m._41;
						var py = p_x * m._12 + p_y * m._22 + p_z * m._32 + p_w * m._42;
						var pz = p_x * m._13 + p_y * m._23 + p_z * m._33 + p_w * m._43;
						p_x = px;
						p_y = py;
						p_z = pz;
						r1.px = p_x;
						r1.py = p_y;
						r1.pz = p_z;
						var x1 = r1.lx;
						var y1 = r1.ly;
						var z1 = r1.lz;
						if(z1 == null) {
							z1 = 0.;
						}
						if(y1 == null) {
							y1 = 0.;
						}
						if(x1 == null) {
							x1 = 0.;
						}
						var l_x = x1;
						var l_y = y1;
						var l_z = z1;
						var l_w = 1.;
						var px1 = l_x * m._11 + l_y * m._21 + l_z * m._31;
						var py1 = l_x * m._12 + l_y * m._22 + l_z * m._32;
						var pz1 = l_x * m._13 + l_y * m._23 + l_z * m._33;
						l_x = px1;
						l_y = py1;
						l_z = pz1;
						r1.lx = l_x;
						r1.ly = l_y;
						r1.lz = l_z;
						r1.normalize();
						var hit = i.preciseShape.rayIntersection(r1,i.bestMatch);
						if(hit > 0) {
							var x2 = r1.px + hit * r1.lx;
							var y2 = r1.py + hit * r1.ly;
							var z2 = r1.pz + hit * r1.lz;
							if(z2 == null) {
								z2 = 0.;
							}
							if(y2 == null) {
								y2 = 0.;
							}
							if(x2 == null) {
								x2 = 0.;
							}
							var hitPoint_x = x2;
							var hitPoint_y = y2;
							var hitPoint_z = z2;
							i.hitPoint.x = hitPoint_x;
							i.hitPoint.y = hitPoint_y;
							i.hitPoint.z = hitPoint_z;
						} else {
							wfactor = 1.;
						}
						r1.px = saveR_px;
						r1.py = saveR_py;
						r1.pz = saveR_pz;
						r1.lx = saveR_lx;
						r1.ly = saveR_ly;
						r1.lz = saveR_lz;
					}
					var _this = i.hitPoint;
					var x3 = _this.x;
					var y3 = _this.y;
					var z3 = _this.z;
					var w = _this.w;
					if(w == null) {
						w = 1.;
					}
					if(z3 == null) {
						z3 = 0.;
					}
					if(y3 == null) {
						y3 = 0.;
					}
					if(x3 == null) {
						x3 = 0.;
					}
					var p_x1 = x3;
					var p_y1 = y3;
					var p_z1 = z3;
					var p_w1 = w;
					p_w1 = 1;
					var m1 = i.absPos;
					var px2 = p_x1 * m1._11 + p_y1 * m1._21 + p_z1 * m1._31 + p_w1 * m1._41;
					var py2 = p_x1 * m1._12 + p_y1 * m1._22 + p_z1 * m1._32 + p_w1 * m1._42;
					var pz2 = p_x1 * m1._13 + p_y1 * m1._23 + p_z1 * m1._33 + p_w1 * m1._43;
					p_x1 = px2;
					p_y1 = py2;
					p_z1 = pz2;
					var m2 = this.camera.m;
					var px3 = p_x1 * m2._11 + p_y1 * m2._21 + p_z1 * m2._31 + p_w1 * m2._41;
					var py3 = p_x1 * m2._12 + p_y1 * m2._22 + p_z1 * m2._32 + p_w1 * m2._42;
					var pz3 = p_x1 * m2._13 + p_y1 * m2._23 + p_z1 * m2._33 + p_w1 * m2._43;
					var iw = 1 / (p_x1 * m2._14 + p_y1 * m2._24 + p_z1 * m2._34 + p_w1 * m2._44);
					p_x1 = px3 * iw;
					p_y1 = py3 * iw;
					p_z1 = pz3 * iw;
					p_w1 = 1;
					i.hitPoint.w = p_z1 + wfactor;
				}
				this.hitInteractives.sort($bind(this,this.sortHitPointByCameraDistance));
			}
			this.hitInteractives.unshift(null);
		}
		while(this.hitInteractives.length > 0) {
			var i = this.hitInteractives.pop();
			if(i == null) {
				return null;
			}
			event.relX = i.hitPoint.x;
			event.relY = i.hitPoint.y;
			event.relZ = i.hitPoint.z;
			i.handleEvent(event);
			if(event.cancel) {
				event.cancel = false;
				event.propagate = false;
				continue;
			}
			if(!event.propagate) {
				while(this.hitInteractives.length > 0) this.hitInteractives.pop();
			}
			return i;
		}
		return null;
	}
	,addEventTarget: function(i) {
		if(this.interactives.indexOf(i) >= 0) {
			throw haxe_Exception.thrown("assert");
		}
		this.interactives.push(i);
	}
	,removeEventTarget: function(i) {
		if(HxOverrides.remove(this.interactives,i)) {
			if(this.events != null) {
				this.events.onRemove(i);
			}
			HxOverrides.remove(this.hitInteractives,i);
		}
	}
	,setElapsedTime: function(elapsedTime) {
		this.ctx.elapsedTime = elapsedTime;
	}
	,onContextLost: function() {
		this.ctx.wasContextLost = true;
	}
	,render: function(engine) {
		if((this.flags & 32) == 0) {
			this.onAdd();
		}
		var t = engine.getCurrentTarget();
		if(t == null) {
			this.camera.screenRatio = engine.width / engine.height;
		} else {
			this.camera.screenRatio = t.width / t.height;
		}
		this.camera.update();
		if(this.camera.rightHanded) {
			engine.driver.setRenderFlag(h3d_impl_RenderFlag.CameraHandness,1);
		}
		this.ctx.camera = this.camera;
		this.ctx.engine = engine;
		this.ctx.scene = this;
		this.ctx.start();
		this.renderer.start();
		this.syncRec(this.ctx);
		this.emitRec(this.ctx);
		var passes = [];
		var passIndex = -1;
		var _g = 0;
		var _g1 = this.ctx.passes.length;
		while(_g < _g1) {
			var passId = _g++;
			var curPass = this.ctx.passes[passId];
			if(curPass == null) {
				continue;
			}
			var pobjs = this.ctx.cachedPassObjects[++passIndex];
			if(pobjs == null) {
				pobjs = new h3d_scene_PassObjects();
				this.ctx.cachedPassObjects[passIndex] = pobjs;
			}
			pobjs.name = curPass.pass.name;
			var _this = pobjs.passes;
			_this.current = curPass;
			_this.discarded = _this.lastDisc = null;
			passes.push(pobjs);
		}
		if(this.lightSystem != null) {
			this.ctx.lightSystem = this.lightSystem;
			this.lightSystem.initLights(this.ctx);
		}
		this.renderer.process(passes);
		if(this.camera.rightHanded) {
			engine.driver.setRenderFlag(h3d_impl_RenderFlag.CameraHandness,0);
		}
		this.ctx.done();
		this.ctx.wasContextLost = false;
		this.ctx.scene = null;
		this.ctx.camera = null;
		this.ctx.engine = null;
		var _g = 0;
		var _g1 = passIndex;
		while(_g < _g1) {
			var i = _g++;
			var p = this.ctx.cachedPassObjects[i];
			p.name = null;
			var _this = p.passes;
			_this.current = null;
			_this.discarded = _this.lastDisc = null;
		}
	}
	,__class__: h3d_scene_Scene
});
var h3d_scene_fwd_Light = function(shader,parent) {
	this.priority = 0;
	this.cullingDistance = -1;
	h3d_scene_Light.call(this,shader,parent);
};
$hxClasses["h3d.scene.fwd.Light"] = h3d_scene_fwd_Light;
h3d_scene_fwd_Light.__name__ = "h3d.scene.fwd.Light";
h3d_scene_fwd_Light.__super__ = h3d_scene_Light;
h3d_scene_fwd_Light.prototype = $extend(h3d_scene_Light.prototype,{
	__class__: h3d_scene_fwd_Light
});
var h3d_scene_fwd_LightSystem = function() {
	this.perPixelLighting = true;
	this.maxLightsPerObject = 6;
	h3d_scene_LightSystem.call(this);
	this.ambientLight = new h3d_Vector(0.5,0.5,0.5);
	this.ambientShader = new h3d_shader_AmbientLight();
	this.set_additiveLighting(true);
};
$hxClasses["h3d.scene.fwd.LightSystem"] = h3d_scene_fwd_LightSystem;
h3d_scene_fwd_LightSystem.__name__ = "h3d.scene.fwd.LightSystem";
h3d_scene_fwd_LightSystem.__super__ = h3d_scene_LightSystem;
h3d_scene_fwd_LightSystem.prototype = $extend(h3d_scene_LightSystem.prototype,{
	set_additiveLighting: function(b) {
		var value = this.ambientShader;
		var _this = ((value) instanceof h3d_shader_AmbientLight) ? value : null;
		_this.constModified = true;
		return _this.additive__ = b;
	}
	,initLights: function(ctx) {
		this.lightCount = 0;
		this.ctx = ctx;
		this.cullLights();
		h3d_scene_LightSystem.prototype.initLights.call(this,ctx);
		if(this.lightCount <= this.maxLightsPerObject) {
			var list = ctx.lights;
			var cmp = $bind(this,this.sortLight);
			var tmp;
			if(list == null) {
				tmp = null;
			} else {
				var insize = 1;
				var nmerges;
				var psize = 0;
				var qsize = 0;
				var p;
				var q;
				var e;
				var tail;
				while(true) {
					p = list;
					list = null;
					tail = null;
					nmerges = 0;
					while(p != null) {
						++nmerges;
						q = p;
						psize = 0;
						var _g = 0;
						var _g1 = insize;
						while(_g < _g1) {
							var i = _g++;
							++psize;
							q = q.next;
							if(q == null) {
								break;
							}
						}
						qsize = insize;
						while(psize > 0 || qsize > 0 && q != null) {
							if(psize == 0) {
								e = q;
								q = q.next;
								--qsize;
							} else if(qsize == 0 || q == null || cmp(p,q) <= 0) {
								e = p;
								p = p.next;
								--psize;
							} else {
								e = q;
								q = q.next;
								--qsize;
							}
							if(tail != null) {
								tail.next = e;
							} else {
								list = e;
							}
							tail = e;
						}
						p = q;
					}
					tail.next = null;
					if(nmerges <= 1) {
						break;
					}
					insize *= 2;
				}
				tmp = list;
			}
			ctx.lights = tmp;
		}
	}
	,initGlobals: function(globals) {
		globals.set("global.ambientLight",this.ambientLight);
		globals.set("global.perPixelLighting",this.perPixelLighting);
	}
	,cullLights: function() {
		var ll = this.ctx.lights;
		var prev = null;
		var s = new h3d_col_Sphere();
		while(ll != null) {
			var l = ((ll) instanceof h3d_scene_fwd_Light) ? ll : null;
			if(l != null) {
				s.x = l.absPos._41;
				s.y = l.absPos._42;
				s.z = l.absPos._43;
				s.r = l.cullingDistance;
			}
			if(l == null || l.cullingDistance > 0 && !this.ctx.computingStatic && !this.ctx.camera.frustum.hasSphere(s)) {
				if(prev == null) {
					this.ctx.lights = ll.next;
				} else {
					prev.next = ll.next;
				}
				ll = ll.next;
				continue;
			}
			this.lightCount++;
			l.objectDistance = 0.;
			prev = ll;
			ll = ll.next;
		}
	}
	,sortLight: function(l1,l2) {
		var p = l1.priority - l2.priority;
		if(p != 0) {
			return -p;
		}
		if(l1.objectDistance < l2.objectDistance) {
			return -1;
		} else {
			return 1;
		}
	}
	,computeLight: function(obj,shaders) {
		var _gthis = this;
		if(this.lightCount > this.maxLightsPerObject) {
			var ll = this.ctx.lights;
			while(ll != null) {
				var l = ((ll) instanceof h3d_scene_fwd_Light) ? ll : null;
				if((obj.flags & 16) != 0) {
					var dx = l.absPos._41 - this.ctx.camera.target.x;
					var dy = l.absPos._42 - this.ctx.camera.target.y;
					var dz = l.absPos._43 - this.ctx.camera.target.z;
					if(dz == null) {
						dz = 0.;
					}
					l.objectDistance = dx * dx + dy * dy + dz * dz;
				} else {
					var dx1 = l.absPos._41 - obj.absPos._41;
					var dy1 = l.absPos._42 - obj.absPos._42;
					var dz1 = l.absPos._43 - obj.absPos._43;
					if(dz1 == null) {
						dz1 = 0.;
					}
					l.objectDistance = dx1 * dx1 + dy1 * dy1 + dz1 * dz1;
				}
				ll = ll.next;
			}
			var list = this.ctx.lights;
			var cmp = $bind(this,this.sortLight);
			var tmp;
			if(list == null) {
				tmp = null;
			} else {
				var insize = 1;
				var nmerges;
				var psize = 0;
				var qsize = 0;
				var p;
				var q;
				var e;
				var tail;
				while(true) {
					p = list;
					list = null;
					tail = null;
					nmerges = 0;
					while(p != null) {
						++nmerges;
						q = p;
						psize = 0;
						var _g = 0;
						var _g1 = insize;
						while(_g < _g1) {
							var i = _g++;
							++psize;
							q = q.next;
							if(q == null) {
								break;
							}
						}
						qsize = insize;
						while(psize > 0 || qsize > 0 && q != null) {
							if(psize == 0) {
								e = q;
								q = q.next;
								--qsize;
							} else if(qsize == 0 || q == null || cmp(p,q) <= 0) {
								e = p;
								p = p.next;
								--psize;
							} else {
								e = q;
								q = q.next;
								--qsize;
							}
							if(tail != null) {
								tail.next = e;
							} else {
								list = e;
							}
							tail = e;
						}
						p = q;
					}
					tail.next = null;
					if(nmerges <= 1) {
						break;
					}
					insize *= 2;
				}
				tmp = list;
			}
			this.ctx.lights = tmp;
		}
		shaders = _gthis.ctx.allocShaderList(this.ambientShader,shaders);
		var l = this.ctx.lights;
		var i = 0;
		while(l != null) {
			if(i++ == this.maxLightsPerObject) {
				break;
			}
			shaders = _gthis.ctx.allocShaderList(l.shader,shaders);
			l = l.next;
		}
		return shaders;
	}
	,__class__: h3d_scene_fwd_LightSystem
});
var h3d_scene_fwd_DepthPass = function() {
	this.enableSky = false;
	h3d_pass_Default.call(this,"depth");
	this.depthMapId = hxsl_Globals.allocID("depthMap");
};
$hxClasses["h3d.scene.fwd.DepthPass"] = h3d_scene_fwd_DepthPass;
h3d_scene_fwd_DepthPass.__name__ = "h3d.scene.fwd.DepthPass";
h3d_scene_fwd_DepthPass.__super__ = h3d_pass_Default;
h3d_scene_fwd_DepthPass.prototype = $extend(h3d_pass_Default.prototype,{
	getOutputs: function() {
		return [hxsl_Output.PackFloat(hxsl_Output.Value("output.depth"))];
	}
	,draw: function(passes,sort) {
		var texture = this.ctx.textures.allocTarget("depthMap",this.ctx.engine.width,this.ctx.engine.height,true);
		this.ctx.engine.pushTarget(texture);
		this.ctx.engine.clear(this.enableSky ? 0 : 16711680,1);
		h3d_pass_Default.prototype.draw.call(this,passes,sort);
		this.ctx.engine.popTarget();
		this.ctx.setGlobalID(this.depthMapId,{ texture : texture});
	}
	,__class__: h3d_scene_fwd_DepthPass
});
var h3d_scene_fwd_NormalPass = function() {
	h3d_pass_Default.call(this,"normal");
	this.normalMapId = hxsl_Globals.allocID("normalMap");
};
$hxClasses["h3d.scene.fwd.NormalPass"] = h3d_scene_fwd_NormalPass;
h3d_scene_fwd_NormalPass.__name__ = "h3d.scene.fwd.NormalPass";
h3d_scene_fwd_NormalPass.__super__ = h3d_pass_Default;
h3d_scene_fwd_NormalPass.prototype = $extend(h3d_pass_Default.prototype,{
	getOutputs: function() {
		return [hxsl_Output.PackNormal(hxsl_Output.Value("output.normal"))];
	}
	,draw: function(passes,sort) {
		var texture = this.ctx.textures.allocTarget("normalMap",this.ctx.engine.width,this.ctx.engine.height);
		this.ctx.engine.pushTarget(texture);
		this.ctx.engine.clear(8421504,1);
		h3d_pass_Default.prototype.draw.call(this,passes,sort);
		this.ctx.engine.popTarget();
		this.ctx.setGlobalID(this.normalMapId,texture);
	}
	,__class__: h3d_scene_fwd_NormalPass
});
var h3d_scene_fwd_Renderer = function() {
	this.shadow = new h3d_pass_DefaultShadowMap(1024);
	this.normal = new h3d_scene_fwd_NormalPass();
	this.depth = new h3d_scene_fwd_DepthPass();
	h3d_scene_Renderer.call(this);
	this.defaultPass = new h3d_pass_Default("default");
	this.allPasses = [this.defaultPass,this.depth,this.normal,this.shadow];
};
$hxClasses["h3d.scene.fwd.Renderer"] = h3d_scene_fwd_Renderer;
h3d_scene_fwd_Renderer.__name__ = "h3d.scene.fwd.Renderer";
h3d_scene_fwd_Renderer.__super__ = h3d_scene_Renderer;
h3d_scene_fwd_Renderer.prototype = $extend(h3d_scene_Renderer.prototype,{
	renderPass: function(p,passes,sort) {
		p.draw(passes,sort);
	}
	,render: function() {
		if(this.has("shadow")) {
			this.renderPass(this.shadow,this.get("shadow"));
		}
		if(this.has("depth")) {
			this.renderPass(this.depth,this.get("depth"));
		}
		if(this.has("normal")) {
			this.renderPass(this.normal,this.get("normal"));
		}
		this.renderPass(this.defaultPass,this.get("default"));
		this.renderPass(this.defaultPass,this.get("alpha"),this.backToFront);
		this.renderPass(this.defaultPass,this.get("additive"));
	}
	,__class__: h3d_scene_fwd_Renderer
});
var h3d_shader_AmbientLight = function() {
	hxsl_Shader.call(this);
};
$hxClasses["h3d.shader.AmbientLight"] = h3d_shader_AmbientLight;
h3d_shader_AmbientLight.__name__ = "h3d.shader.AmbientLight";
h3d_shader_AmbientLight.__super__ = hxsl_Shader;
h3d_shader_AmbientLight.prototype = $extend(hxsl_Shader.prototype,{
	get_additive: function() {
		return this.additive__;
	}
	,set_additive: function(_v) {
		this.constModified = true;
		return this.additive__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		if(this.additive__) {
			this.constBits |= 2;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		if(index == 0) {
			return this.additive__;
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,__class__: h3d_shader_AmbientLight
});
var h3d_shader_Base2d = function() {
	this.viewportB__ = new h3d_Vector();
	this.viewportA__ = new h3d_Vector();
	this.halfPixelInverse__ = new h3d_Vector();
	this.uvPos__ = new h3d_Vector();
	this.filterMatrixB__ = new h3d_Vector();
	this.filterMatrixA__ = new h3d_Vector();
	this.absoluteMatrixB__ = new h3d_Vector();
	this.absoluteMatrixA__ = new h3d_Vector();
	this.color__ = new h3d_Vector();
	this.zValue__ = 0;
	hxsl_Shader.call(this);
};
$hxClasses["h3d.shader.Base2d"] = h3d_shader_Base2d;
h3d_shader_Base2d.__name__ = "h3d.shader.Base2d";
h3d_shader_Base2d.__super__ = hxsl_Shader;
h3d_shader_Base2d.prototype = $extend(hxsl_Shader.prototype,{
	get_zValue: function() {
		return this.zValue__;
	}
	,set_zValue: function(_v) {
		return this.zValue__ = _v;
	}
	,get_texture: function() {
		return this.texture__;
	}
	,set_texture: function(_v) {
		return this.texture__ = _v;
	}
	,get_isRelative: function() {
		return this.isRelative__;
	}
	,set_isRelative: function(_v) {
		this.constModified = true;
		return this.isRelative__ = _v;
	}
	,get_color: function() {
		return this.color__;
	}
	,set_color: function(_v) {
		return this.color__ = _v;
	}
	,get_absoluteMatrixA: function() {
		return this.absoluteMatrixA__;
	}
	,set_absoluteMatrixA: function(_v) {
		return this.absoluteMatrixA__ = _v;
	}
	,get_absoluteMatrixB: function() {
		return this.absoluteMatrixB__;
	}
	,set_absoluteMatrixB: function(_v) {
		return this.absoluteMatrixB__ = _v;
	}
	,get_filterMatrixA: function() {
		return this.filterMatrixA__;
	}
	,set_filterMatrixA: function(_v) {
		return this.filterMatrixA__ = _v;
	}
	,get_filterMatrixB: function() {
		return this.filterMatrixB__;
	}
	,set_filterMatrixB: function(_v) {
		return this.filterMatrixB__ = _v;
	}
	,get_hasUVPos: function() {
		return this.hasUVPos__;
	}
	,set_hasUVPos: function(_v) {
		this.constModified = true;
		return this.hasUVPos__ = _v;
	}
	,get_uvPos: function() {
		return this.uvPos__;
	}
	,set_uvPos: function(_v) {
		return this.uvPos__ = _v;
	}
	,get_killAlpha: function() {
		return this.killAlpha__;
	}
	,set_killAlpha: function(_v) {
		this.constModified = true;
		return this.killAlpha__ = _v;
	}
	,get_pixelAlign: function() {
		return this.pixelAlign__;
	}
	,set_pixelAlign: function(_v) {
		this.constModified = true;
		return this.pixelAlign__ = _v;
	}
	,get_halfPixelInverse: function() {
		return this.halfPixelInverse__;
	}
	,set_halfPixelInverse: function(_v) {
		return this.halfPixelInverse__ = _v;
	}
	,get_viewportA: function() {
		return this.viewportA__;
	}
	,set_viewportA: function(_v) {
		return this.viewportA__ = _v;
	}
	,get_viewportB: function() {
		return this.viewportB__;
	}
	,set_viewportB: function(_v) {
		return this.viewportB__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		if(this.isRelative__) {
			this.constBits |= 1;
		}
		if(this.hasUVPos__) {
			this.constBits |= 2;
		}
		if(this.killAlpha__) {
			this.constBits |= 4;
		}
		if(this.pixelAlign__) {
			this.constBits |= 8;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.zValue__;
		case 1:
			return this.texture__;
		case 2:
			return this.isRelative__;
		case 3:
			return this.color__;
		case 4:
			return this.absoluteMatrixA__;
		case 5:
			return this.absoluteMatrixB__;
		case 6:
			return this.filterMatrixA__;
		case 7:
			return this.filterMatrixB__;
		case 8:
			return this.hasUVPos__;
		case 9:
			return this.uvPos__;
		case 10:
			return this.killAlpha__;
		case 11:
			return this.pixelAlign__;
		case 12:
			return this.halfPixelInverse__;
		case 13:
			return this.viewportA__;
		case 14:
			return this.viewportB__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		if(index == 0) {
			return this.zValue__;
		}
		return 0.;
	}
	,__class__: h3d_shader_Base2d
});
var h3d_shader_BaseMesh = function() {
	this.specularColor__ = new h3d_Vector();
	this.specularAmount__ = 0;
	this.specularPower__ = 0;
	this.color__ = new h3d_Vector();
	hxsl_Shader.call(this);
	var _this = this.color__;
	var x = 1;
	var y = 1;
	var z = 1;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	_this.x = x;
	_this.y = y;
	_this.z = z;
	_this.w = 1.;
	var _this = this.specularColor__;
	var x = 1;
	var y = 1;
	var z = 1;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	_this.x = x;
	_this.y = y;
	_this.z = z;
	_this.w = 1.;
	this.specularPower__ = 50;
	this.specularAmount__ = 1;
};
$hxClasses["h3d.shader.BaseMesh"] = h3d_shader_BaseMesh;
h3d_shader_BaseMesh.__name__ = "h3d.shader.BaseMesh";
h3d_shader_BaseMesh.__super__ = hxsl_Shader;
h3d_shader_BaseMesh.prototype = $extend(hxsl_Shader.prototype,{
	get_color: function() {
		return this.color__;
	}
	,set_color: function(_v) {
		return this.color__ = _v;
	}
	,get_specularPower: function() {
		return this.specularPower__;
	}
	,set_specularPower: function(_v) {
		return this.specularPower__ = _v;
	}
	,get_specularAmount: function() {
		return this.specularAmount__;
	}
	,set_specularAmount: function(_v) {
		return this.specularAmount__ = _v;
	}
	,get_specularColor: function() {
		return this.specularColor__;
	}
	,set_specularColor: function(_v) {
		return this.specularColor__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.color__;
		case 1:
			return this.specularPower__;
		case 2:
			return this.specularAmount__;
		case 3:
			return this.specularColor__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		switch(index) {
		case 1:
			return this.specularPower__;
		case 2:
			return this.specularAmount__;
		default:
		}
		return 0.;
	}
	,__class__: h3d_shader_BaseMesh
});
var h3d_shader_Blur = function() {
	this.cubeDir__ = new h3d_Matrix();
	this.fixedColor__ = new h3d_Vector();
	this.pixel__ = new h3d_Vector();
	this.offsets__ = [];
	this.values__ = [];
	this.Quality__ = 0;
	this.cameraInverseViewProj__ = new h3d_Matrix();
	h3d_shader_ScreenShader.call(this);
};
$hxClasses["h3d.shader.Blur"] = h3d_shader_Blur;
h3d_shader_Blur.__name__ = "h3d.shader.Blur";
h3d_shader_Blur.__super__ = h3d_shader_ScreenShader;
h3d_shader_Blur.prototype = $extend(h3d_shader_ScreenShader.prototype,{
	get_cameraInverseViewProj: function() {
		return this.cameraInverseViewProj__;
	}
	,set_cameraInverseViewProj: function(_v) {
		return this.cameraInverseViewProj__ = _v;
	}
	,get_texture: function() {
		return this.texture__;
	}
	,set_texture: function(_v) {
		return this.texture__ = _v;
	}
	,get_depthTexture: function() {
		return this.depthTexture__;
	}
	,set_depthTexture: function(_v) {
		return this.depthTexture__ = _v;
	}
	,get_Quality: function() {
		return this.Quality__;
	}
	,set_Quality: function(_v) {
		this.constModified = true;
		return this.Quality__ = _v;
	}
	,get_isDepth: function() {
		return this.isDepth__;
	}
	,set_isDepth: function(_v) {
		this.constModified = true;
		return this.isDepth__ = _v;
	}
	,get_values: function() {
		return this.values__;
	}
	,set_values: function(_v) {
		return this.values__ = _v;
	}
	,get_offsets: function() {
		return this.offsets__;
	}
	,set_offsets: function(_v) {
		return this.offsets__ = _v;
	}
	,get_pixel: function() {
		return this.pixel__;
	}
	,set_pixel: function(_v) {
		return this.pixel__ = _v;
	}
	,get_hasFixedColor: function() {
		return this.hasFixedColor__;
	}
	,set_hasFixedColor: function(_v) {
		this.constModified = true;
		return this.hasFixedColor__ = _v;
	}
	,get_smoothFixedColor: function() {
		return this.smoothFixedColor__;
	}
	,set_smoothFixedColor: function(_v) {
		this.constModified = true;
		return this.smoothFixedColor__ = _v;
	}
	,get_fixedColor: function() {
		return this.fixedColor__;
	}
	,set_fixedColor: function(_v) {
		return this.fixedColor__ = _v;
	}
	,get_isDepthDependant: function() {
		return this.isDepthDependant__;
	}
	,set_isDepthDependant: function(_v) {
		this.constModified = true;
		return this.isDepthDependant__ = _v;
	}
	,get_hasNormal: function() {
		return this.hasNormal__;
	}
	,set_hasNormal: function(_v) {
		this.constModified = true;
		return this.hasNormal__ = _v;
	}
	,get_normalTexture: function() {
		return this.normalTexture__;
	}
	,set_normalTexture: function(_v) {
		return this.normalTexture__ = _v;
	}
	,get_isCube: function() {
		return this.isCube__;
	}
	,set_isCube: function(_v) {
		this.constModified = true;
		return this.isCube__ = _v;
	}
	,get_cubeTexture: function() {
		return this.cubeTexture__;
	}
	,set_cubeTexture: function(_v) {
		return this.cubeTexture__ = _v;
	}
	,get_cubeDir: function() {
		return this.cubeDir__;
	}
	,set_cubeDir: function(_v) {
		return this.cubeDir__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		var v = this.Quality__;
		if(v >>> 8 != 0) {
			throw haxe_Exception.thrown("Quality" + " is out of range " + v + ">" + 255);
		}
		this.constBits |= v;
		if(this.isDepth__) {
			this.constBits |= 256;
		}
		if(this.hasFixedColor__) {
			this.constBits |= 512;
		}
		if(this.smoothFixedColor__) {
			this.constBits |= 1024;
		}
		if(this.isDepthDependant__) {
			this.constBits |= 2048;
		}
		if(this.hasNormal__) {
			this.constBits |= 4096;
		}
		if(this.isCube__) {
			this.constBits |= 8192;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.cameraInverseViewProj__;
		case 2:
			return this.texture__;
		case 3:
			return this.depthTexture__;
		case 4:
			return this.Quality__;
		case 5:
			return this.isDepth__;
		case 6:
			return this.values__;
		case 7:
			return this.offsets__;
		case 8:
			return this.pixel__;
		case 9:
			return this.hasFixedColor__;
		case 10:
			return this.smoothFixedColor__;
		case 11:
			return this.fixedColor__;
		case 12:
			return this.isDepthDependant__;
		case 13:
			return this.hasNormal__;
		case 14:
			return this.normalTexture__;
		case 15:
			return this.isCube__;
		case 16:
			return this.cubeTexture__;
		case 17:
			return this.cubeDir__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	,__class__: h3d_shader_Blur
});
var h3d_shader_ShaderBuffers = function(s) {
	this.globals = new Float32Array(s.globalsSize << 2);
	this.params = new Float32Array(s.paramsSize << 2);
	var this1 = new Array(s.texturesCount);
	this.tex = this1;
	var tmp;
	if(s.bufferCount > 0) {
		var this1 = new Array(s.bufferCount);
		tmp = this1;
	} else {
		tmp = null;
	}
	this.buffers = tmp;
};
$hxClasses["h3d.shader.ShaderBuffers"] = h3d_shader_ShaderBuffers;
h3d_shader_ShaderBuffers.__name__ = "h3d.shader.ShaderBuffers";
h3d_shader_ShaderBuffers.prototype = {
	grow: function(s) {
		var ng = s.globalsSize << 2;
		var np = s.paramsSize << 2;
		var nt = s.texturesCount;
		var nb = s.bufferCount;
		if(this.globals.length < ng) {
			this.globals = new Float32Array(ng);
		}
		if(this.params.length < np) {
			this.params = new Float32Array(np);
		}
		if(this.tex.length < nt) {
			var this1 = new Array(nt);
			this.tex = this1;
		}
		if(nb > 0 && (this.buffers == null || this.buffers.length < nb)) {
			var this1 = new Array(nb);
			this.buffers = this1;
		}
	}
	,__class__: h3d_shader_ShaderBuffers
};
var h3d_shader_Buffers = function(s) {
	this.vertex = new h3d_shader_ShaderBuffers(s.vertex);
	this.fragment = new h3d_shader_ShaderBuffers(s.fragment);
};
$hxClasses["h3d.shader.Buffers"] = h3d_shader_Buffers;
h3d_shader_Buffers.__name__ = "h3d.shader.Buffers";
h3d_shader_Buffers.prototype = {
	__class__: h3d_shader_Buffers
};
var h3d_shader_ColorAdd = function(color) {
	if(color == null) {
		color = 0;
	}
	this.color__ = new h3d_Vector();
	hxsl_Shader.call(this);
	var _this = this.color__;
	_this.x = (color >> 16 & 255) / 255;
	_this.y = (color >> 8 & 255) / 255;
	_this.z = (color & 255) / 255;
	_this.w = (color >>> 24) / 255;
};
$hxClasses["h3d.shader.ColorAdd"] = h3d_shader_ColorAdd;
h3d_shader_ColorAdd.__name__ = "h3d.shader.ColorAdd";
h3d_shader_ColorAdd.__super__ = hxsl_Shader;
h3d_shader_ColorAdd.prototype = $extend(hxsl_Shader.prototype,{
	get_color: function() {
		return this.color__;
	}
	,set_color: function(_v) {
		return this.color__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		if(index == 0) {
			return this.color__;
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,__class__: h3d_shader_ColorAdd
});
var h3d_shader_ColorKey = function(v) {
	if(v == null) {
		v = 0;
	}
	this.colorKey__ = new h3d_Vector();
	hxsl_Shader.call(this);
	var _this = this.colorKey__;
	_this.x = (v >> 16 & 255) / 255;
	_this.y = (v >> 8 & 255) / 255;
	_this.z = (v & 255) / 255;
	_this.w = (v >>> 24) / 255;
};
$hxClasses["h3d.shader.ColorKey"] = h3d_shader_ColorKey;
h3d_shader_ColorKey.__name__ = "h3d.shader.ColorKey";
h3d_shader_ColorKey.__super__ = hxsl_Shader;
h3d_shader_ColorKey.prototype = $extend(hxsl_Shader.prototype,{
	get_colorKey: function() {
		return this.colorKey__;
	}
	,set_colorKey: function(_v) {
		return this.colorKey__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		if(index == 0) {
			return this.colorKey__;
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,__class__: h3d_shader_ColorKey
});
var h3d_shader_ColorMatrix = function(m) {
	this.matrix__ = new h3d_Matrix();
	hxsl_Shader.call(this);
	if(m != null) {
		this.matrix__.loadValues(m);
	} else {
		this.matrix__.identity();
	}
};
$hxClasses["h3d.shader.ColorMatrix"] = h3d_shader_ColorMatrix;
h3d_shader_ColorMatrix.__name__ = "h3d.shader.ColorMatrix";
h3d_shader_ColorMatrix.__super__ = hxsl_Shader;
h3d_shader_ColorMatrix.prototype = $extend(hxsl_Shader.prototype,{
	get_matrix: function() {
		return this.matrix__;
	}
	,set_matrix: function(_v) {
		return this.matrix__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		if(index == 0) {
			return this.matrix__;
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,__class__: h3d_shader_ColorMatrix
});
var h3d_shader_DirShadow = function() {
	this.poissonDisk__ = [];
	this.shadowBias__ = 0;
	this.shadowProj__ = new h3d_Matrix();
	this.shadowMapChannel__ = hxsl_Channel.Unknown;
	this.shadowRes__ = new h3d_Vector();
	this.pcfScale__ = 0;
	this.PCF_SAMPLES__ = 0;
	this.shadowPower__ = 0;
	hxsl_Shader.call(this);
	this.set_pcfQuality(1);
};
$hxClasses["h3d.shader.DirShadow"] = h3d_shader_DirShadow;
h3d_shader_DirShadow.__name__ = "h3d.shader.DirShadow";
h3d_shader_DirShadow.__super__ = hxsl_Shader;
h3d_shader_DirShadow.prototype = $extend(hxsl_Shader.prototype,{
	set_pcfQuality: function(q) {
		var _v;
		switch(q) {
		case 2:
			_v = [new h3d_Vector(-0.326,-0.406),new h3d_Vector(-0.840,-0.074),new h3d_Vector(-0.696,0.457),new h3d_Vector(-0.203,0.621),new h3d_Vector(0.962,-0.195),new h3d_Vector(0.473,-0.480),new h3d_Vector(0.519,0.767),new h3d_Vector(0.185,-0.893),new h3d_Vector(0.507,0.064),new h3d_Vector(0.896,0.412),new h3d_Vector(-0.322,-0.933),new h3d_Vector(-0.792,-0.598)];
			break;
		case 3:
			_v = [new h3d_Vector(-0.613392,0.617481),new h3d_Vector(0.170019,-0.040254),new h3d_Vector(-0.299417,0.791925),new h3d_Vector(0.645680,0.493210),new h3d_Vector(-0.651784,0.717887),new h3d_Vector(0.421003,0.027070),new h3d_Vector(-0.817194,-0.271096),new h3d_Vector(-0.705374,-0.668203),new h3d_Vector(0.977050,-0.108615),new h3d_Vector(0.063326,0.142369),new h3d_Vector(0.203528,0.214331),new h3d_Vector(-0.667531,0.326090),new h3d_Vector(-0.098422,-0.295755),new h3d_Vector(-0.885922,0.215369),new h3d_Vector(0.566637,0.605213),new h3d_Vector(0.039766,-0.396100),new h3d_Vector(0.751946,0.453352),new h3d_Vector(0.078707,-0.715323),new h3d_Vector(-0.075838,-0.529344),new h3d_Vector(0.724479,-0.580798),new h3d_Vector(0.222999,-0.215125),new h3d_Vector(-0.467574,-0.405438),new h3d_Vector(-0.248268,-0.814753),new h3d_Vector(0.354411,-0.887570),new h3d_Vector(0.175817,0.382366),new h3d_Vector(0.487472,-0.063082),new h3d_Vector(-0.084078,0.898312),new h3d_Vector(0.488876,-0.783441),new h3d_Vector(0.470016,0.217933),new h3d_Vector(-0.696890,-0.549791),new h3d_Vector(-0.149693,0.605762),new h3d_Vector(0.034211,0.979980),new h3d_Vector(0.503098,-0.308878),new h3d_Vector(-0.016205,-0.872921),new h3d_Vector(0.385784,-0.393902),new h3d_Vector(-0.146886,-0.859249),new h3d_Vector(0.643361,0.164098),new h3d_Vector(0.634388,-0.049471),new h3d_Vector(-0.688894,0.007843),new h3d_Vector(0.464034,-0.188818),new h3d_Vector(-0.440840,0.137486),new h3d_Vector(0.364483,0.511704),new h3d_Vector(0.034028,0.325968),new h3d_Vector(0.099094,-0.308023),new h3d_Vector(0.693960,-0.366253),new h3d_Vector(0.678884,-0.204688),new h3d_Vector(0.001801,0.780328),new h3d_Vector(0.145177,-0.898984),new h3d_Vector(0.062655,-0.611866),new h3d_Vector(0.315226,-0.604297),new h3d_Vector(-0.780145,0.486251),new h3d_Vector(-0.371868,0.882138),new h3d_Vector(0.200476,0.494430),new h3d_Vector(-0.494552,-0.711051),new h3d_Vector(0.612476,0.705252),new h3d_Vector(-0.578845,-0.768792),new h3d_Vector(-0.772454,-0.090976),new h3d_Vector(0.504440,0.372295),new h3d_Vector(0.155736,0.065157),new h3d_Vector(0.391522,0.849605),new h3d_Vector(-0.620106,-0.328104),new h3d_Vector(0.789239,-0.419965),new h3d_Vector(-0.545396,0.538133),new h3d_Vector(-0.178564,-0.596057)];
			break;
		default:
			_v = [new h3d_Vector(-0.942,-0.399),new h3d_Vector(0.945,-0.768),new h3d_Vector(-0.094,-0.929),new h3d_Vector(0.344,0.293)];
		}
		this.poissonDisk__ = _v;
		this.constModified = true;
		this.PCF_SAMPLES__ = this.poissonDisk__.length;
		return q;
	}
	,get_enable: function() {
		return this.enable__;
	}
	,set_enable: function(_v) {
		this.constModified = true;
		return this.enable__ = _v;
	}
	,get_USE_ESM: function() {
		return this.USE_ESM__;
	}
	,set_USE_ESM: function(_v) {
		this.constModified = true;
		return this.USE_ESM__ = _v;
	}
	,get_shadowPower: function() {
		return this.shadowPower__;
	}
	,set_shadowPower: function(_v) {
		return this.shadowPower__ = _v;
	}
	,get_USE_PCF: function() {
		return this.USE_PCF__;
	}
	,set_USE_PCF: function(_v) {
		this.constModified = true;
		return this.USE_PCF__ = _v;
	}
	,get_PCF_SAMPLES: function() {
		return this.PCF_SAMPLES__;
	}
	,set_PCF_SAMPLES: function(_v) {
		this.constModified = true;
		return this.PCF_SAMPLES__ = _v;
	}
	,get_pcfScale: function() {
		return this.pcfScale__;
	}
	,set_pcfScale: function(_v) {
		return this.pcfScale__ = _v;
	}
	,get_shadowRes: function() {
		return this.shadowRes__;
	}
	,set_shadowRes: function(_v) {
		return this.shadowRes__ = _v;
	}
	,get_shadowMap: function() {
		return this.shadowMap__;
	}
	,set_shadowMap: function(_v) {
		this.constModified = true;
		return this.shadowMap__ = _v;
	}
	,get_shadowProj: function() {
		return this.shadowProj__;
	}
	,set_shadowProj: function(_v) {
		return this.shadowProj__ = _v;
	}
	,get_shadowBias: function() {
		return this.shadowBias__;
	}
	,set_shadowBias: function(_v) {
		return this.shadowBias__ = _v;
	}
	,get_poissonDisk: function() {
		return this.poissonDisk__;
	}
	,set_poissonDisk: function(_v) {
		return this.poissonDisk__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		if(this.enable__) {
			this.constBits |= 1;
		}
		if(this.USE_ESM__) {
			this.constBits |= 2;
		}
		if(this.USE_PCF__) {
			this.constBits |= 4;
		}
		var v = this.PCF_SAMPLES__;
		if(v >>> 8 != 0) {
			throw haxe_Exception.thrown("PCF_SAMPLES" + " is out of range " + v + ">" + 255);
		}
		this.constBits |= v << 3;
		if(this.shadowMap__ == null) {
			this.shadowMapChannel__ = hxsl_Channel.Unknown;
		} else if(this.shadowMapChannel__ == hxsl_Channel.Unknown) {
			if(this.shadowMap__.format == h3d_mat_Texture.nativeFormat) {
				this.shadowMapChannel__ = hxsl_Channel.PackedFloat;
			} else {
				throw haxe_Exception.thrown("shadowMap" + "Channel is not set");
			}
		}
		this.constBits |= (globals.allocChannelID(this.shadowMap__) << 3 | this.shadowMapChannel__._hx_index) << 11;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.enable__;
		case 1:
			return this.USE_ESM__;
		case 2:
			return this.shadowPower__;
		case 3:
			return this.USE_PCF__;
		case 4:
			return this.PCF_SAMPLES__;
		case 5:
			return this.pcfScale__;
		case 6:
			return this.shadowRes__;
		case 7:
			return this.shadowMap__;
		case 8:
			return this.shadowProj__;
		case 9:
			return this.shadowBias__;
		case 10:
			return this.poissonDisk__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		switch(index) {
		case 2:
			return this.shadowPower__;
		case 5:
			return this.pcfScale__;
		case 9:
			return this.shadowBias__;
		default:
		}
		return 0.;
	}
	,__class__: h3d_shader_DirShadow
});
var h3d_shader_GenTexture = function() {
	this.color__ = new h3d_Vector();
	this.mode__ = 0;
	h3d_shader_ScreenShader.call(this);
};
$hxClasses["h3d.shader.GenTexture"] = h3d_shader_GenTexture;
h3d_shader_GenTexture.__name__ = "h3d.shader.GenTexture";
h3d_shader_GenTexture.__super__ = h3d_shader_ScreenShader;
h3d_shader_GenTexture.prototype = $extend(h3d_shader_ScreenShader.prototype,{
	get_mode: function() {
		return this.mode__;
	}
	,set_mode: function(_v) {
		this.constModified = true;
		return this.mode__ = _v;
	}
	,get_color: function() {
		return this.color__;
	}
	,set_color: function(_v) {
		return this.color__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		var v = this.mode__;
		if(v >>> 8 != 0) {
			throw haxe_Exception.thrown("mode" + " is out of range " + v + ">" + 255);
		}
		this.constBits |= v;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.mode__;
		case 2:
			return this.color__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	,__class__: h3d_shader_GenTexture
});
var h3d_shader_LineShader = function(width,lengthScale) {
	if(lengthScale == null) {
		lengthScale = 1.;
	}
	if(width == null) {
		width = 1.5;
	}
	this.width__ = 0;
	this.lengthScale__ = 0;
	hxsl_Shader.call(this);
	this.width__ = width;
	this.lengthScale__ = lengthScale;
};
$hxClasses["h3d.shader.LineShader"] = h3d_shader_LineShader;
h3d_shader_LineShader.__name__ = "h3d.shader.LineShader";
h3d_shader_LineShader.__super__ = hxsl_Shader;
h3d_shader_LineShader.prototype = $extend(hxsl_Shader.prototype,{
	get_lengthScale: function() {
		return this.lengthScale__;
	}
	,set_lengthScale: function(_v) {
		return this.lengthScale__ = _v;
	}
	,get_width: function() {
		return this.width__;
	}
	,set_width: function(_v) {
		return this.width__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.lengthScale__;
		case 1:
			return this.width__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		switch(index) {
		case 0:
			return this.lengthScale__;
		case 1:
			return this.width__;
		default:
		}
		return 0.;
	}
	,__class__: h3d_shader_LineShader
});
var h3d_shader_MinMaxShader = function() {
	h3d_shader_ScreenShader.call(this);
};
$hxClasses["h3d.shader.MinMaxShader"] = h3d_shader_MinMaxShader;
h3d_shader_MinMaxShader.__name__ = "h3d.shader.MinMaxShader";
h3d_shader_MinMaxShader.__super__ = h3d_shader_ScreenShader;
h3d_shader_MinMaxShader.prototype = $extend(h3d_shader_ScreenShader.prototype,{
	get_texA: function() {
		return this.texA__;
	}
	,set_texA: function(_v) {
		return this.texA__ = _v;
	}
	,get_texB: function() {
		return this.texB__;
	}
	,set_texB: function(_v) {
		return this.texB__ = _v;
	}
	,get_isMax: function() {
		return this.isMax__;
	}
	,set_isMax: function(_v) {
		this.constModified = true;
		return this.isMax__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		if(this.isMax__) {
			this.constBits |= 1;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.texA__;
		case 2:
			return this.texB__;
		case 3:
			return this.isMax__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	,__class__: h3d_shader_MinMaxShader
});
var h3d_shader_CubeMinMaxShader = function() {
	this.mat__ = new h3d_Matrix();
	h3d_shader_ScreenShader.call(this);
};
$hxClasses["h3d.shader.CubeMinMaxShader"] = h3d_shader_CubeMinMaxShader;
h3d_shader_CubeMinMaxShader.__name__ = "h3d.shader.CubeMinMaxShader";
h3d_shader_CubeMinMaxShader.__super__ = h3d_shader_ScreenShader;
h3d_shader_CubeMinMaxShader.prototype = $extend(h3d_shader_ScreenShader.prototype,{
	get_texA: function() {
		return this.texA__;
	}
	,set_texA: function(_v) {
		return this.texA__ = _v;
	}
	,get_texB: function() {
		return this.texB__;
	}
	,set_texB: function(_v) {
		return this.texB__ = _v;
	}
	,get_isMax: function() {
		return this.isMax__;
	}
	,set_isMax: function(_v) {
		this.constModified = true;
		return this.isMax__ = _v;
	}
	,get_mat: function() {
		return this.mat__;
	}
	,set_mat: function(_v) {
		return this.mat__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		if(this.isMax__) {
			this.constBits |= 1;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.texA__;
		case 2:
			return this.texB__;
		case 3:
			return this.isMax__;
		case 4:
			return this.mat__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	,__class__: h3d_shader_CubeMinMaxShader
});
var h3d_shader_NormalMap = function(texture) {
	hxsl_Shader.call(this);
	this.texture__ = texture;
};
$hxClasses["h3d.shader.NormalMap"] = h3d_shader_NormalMap;
h3d_shader_NormalMap.__name__ = "h3d.shader.NormalMap";
h3d_shader_NormalMap.__super__ = hxsl_Shader;
h3d_shader_NormalMap.prototype = $extend(hxsl_Shader.prototype,{
	get_texture: function() {
		return this.texture__;
	}
	,set_texture: function(_v) {
		return this.texture__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		if(index == 0) {
			return this.texture__;
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,__class__: h3d_shader_NormalMap
});
var h3d_shader_Shadow = function() {
	hxsl_Shader.call(this);
};
$hxClasses["h3d.shader.Shadow"] = h3d_shader_Shadow;
h3d_shader_Shadow.__name__ = "h3d.shader.Shadow";
h3d_shader_Shadow.__super__ = hxsl_Shader;
h3d_shader_Shadow.prototype = $extend(hxsl_Shader.prototype,{
	updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,__class__: h3d_shader_Shadow
});
var h3d_shader_SignedDistanceField = function() {
	this.smoothing__ = 0.041666666666666664;
	this.alphaCutoff__ = 0.5;
	this.autoSmoothing__ = false;
	this.channel__ = 0;
	hxsl_Shader.call(this);
};
$hxClasses["h3d.shader.SignedDistanceField"] = h3d_shader_SignedDistanceField;
h3d_shader_SignedDistanceField.__name__ = "h3d.shader.SignedDistanceField";
h3d_shader_SignedDistanceField.__super__ = hxsl_Shader;
h3d_shader_SignedDistanceField.prototype = $extend(hxsl_Shader.prototype,{
	get_channel: function() {
		return this.channel__;
	}
	,set_channel: function(_v) {
		this.constModified = true;
		return this.channel__ = _v;
	}
	,get_autoSmoothing: function() {
		return this.autoSmoothing__;
	}
	,set_autoSmoothing: function(_v) {
		this.constModified = true;
		return this.autoSmoothing__ = _v;
	}
	,get_alphaCutoff: function() {
		return this.alphaCutoff__;
	}
	,set_alphaCutoff: function(_v) {
		return this.alphaCutoff__ = _v;
	}
	,get_smoothing: function() {
		return this.smoothing__;
	}
	,set_smoothing: function(_v) {
		return this.smoothing__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		var v = this.channel__;
		if(v >>> 8 != 0) {
			throw haxe_Exception.thrown("channel" + " is out of range " + v + ">" + 255);
		}
		this.constBits |= v;
		if(this.autoSmoothing__) {
			this.constBits |= 256;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.channel__;
		case 1:
			return this.autoSmoothing__;
		case 2:
			return this.alphaCutoff__;
		case 3:
			return this.smoothing__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		switch(index) {
		case 2:
			return this.alphaCutoff__;
		case 3:
			return this.smoothing__;
		default:
		}
		return 0.;
	}
	,__class__: h3d_shader_SignedDistanceField
});
var h3d_shader_SkinBase = function() {
	this.bonesMatrixes__ = [];
	this.fourBonesByVertex__ = false;
	this.MaxBones__ = 0;
	hxsl_Shader.call(this);
	this.constModified = true;
	this.MaxBones__ = 34;
};
$hxClasses["h3d.shader.SkinBase"] = h3d_shader_SkinBase;
h3d_shader_SkinBase.__name__ = "h3d.shader.SkinBase";
h3d_shader_SkinBase.__super__ = hxsl_Shader;
h3d_shader_SkinBase.prototype = $extend(hxsl_Shader.prototype,{
	get_MaxBones: function() {
		return this.MaxBones__;
	}
	,set_MaxBones: function(_v) {
		this.constModified = true;
		return this.MaxBones__ = _v;
	}
	,get_fourBonesByVertex: function() {
		return this.fourBonesByVertex__;
	}
	,set_fourBonesByVertex: function(_v) {
		this.constModified = true;
		return this.fourBonesByVertex__ = _v;
	}
	,get_bonesMatrixes: function() {
		return this.bonesMatrixes__;
	}
	,set_bonesMatrixes: function(_v) {
		return this.bonesMatrixes__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		var v = this.MaxBones__;
		if(v >>> 8 != 0) {
			throw haxe_Exception.thrown("MaxBones" + " is out of range " + v + ">" + 255);
		}
		this.constBits |= v;
		if(this.fourBonesByVertex__) {
			this.constBits |= 256;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.MaxBones__;
		case 1:
			return this.fourBonesByVertex__;
		case 2:
			return this.bonesMatrixes__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,__class__: h3d_shader_SkinBase
});
var h3d_shader_Skin = function() {
	h3d_shader_SkinBase.call(this);
};
$hxClasses["h3d.shader.Skin"] = h3d_shader_Skin;
h3d_shader_Skin.__name__ = "h3d.shader.Skin";
h3d_shader_Skin.__super__ = h3d_shader_SkinBase;
h3d_shader_Skin.prototype = $extend(h3d_shader_SkinBase.prototype,{
	updateConstants: function(globals) {
		this.constBits = 0;
		var v = this.MaxBones__;
		if(v >>> 8 != 0) {
			throw haxe_Exception.thrown("MaxBones" + " is out of range " + v + ">" + 255);
		}
		this.constBits |= v;
		if(this.fourBonesByVertex__) {
			this.constBits |= 256;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.MaxBones__;
		case 1:
			return this.fourBonesByVertex__;
		case 2:
			return this.bonesMatrixes__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,__class__: h3d_shader_Skin
});
var h3d_shader_SkinTangent = function() {
	h3d_shader_SkinBase.call(this);
};
$hxClasses["h3d.shader.SkinTangent"] = h3d_shader_SkinTangent;
h3d_shader_SkinTangent.__name__ = "h3d.shader.SkinTangent";
h3d_shader_SkinTangent.__super__ = h3d_shader_SkinBase;
h3d_shader_SkinTangent.prototype = $extend(h3d_shader_SkinBase.prototype,{
	updateConstants: function(globals) {
		this.constBits = 0;
		var v = this.MaxBones__;
		if(v >>> 8 != 0) {
			throw haxe_Exception.thrown("MaxBones" + " is out of range " + v + ">" + 255);
		}
		this.constBits |= v;
		if(this.fourBonesByVertex__) {
			this.constBits |= 256;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.MaxBones__;
		case 1:
			return this.fourBonesByVertex__;
		case 2:
			return this.bonesMatrixes__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,__class__: h3d_shader_SkinTangent
});
var h3d_shader_SpecularTexture = function(tex) {
	hxsl_Shader.call(this);
	this.texture__ = tex;
};
$hxClasses["h3d.shader.SpecularTexture"] = h3d_shader_SpecularTexture;
h3d_shader_SpecularTexture.__name__ = "h3d.shader.SpecularTexture";
h3d_shader_SpecularTexture.__super__ = hxsl_Shader;
h3d_shader_SpecularTexture.prototype = $extend(hxsl_Shader.prototype,{
	get_texture: function() {
		return this.texture__;
	}
	,set_texture: function(_v) {
		return this.texture__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		if(index == 0) {
			return this.texture__;
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,__class__: h3d_shader_SpecularTexture
});
var h3d_shader_Texture = function(tex) {
	this.killAlphaThreshold__ = 0;
	hxsl_Shader.call(this);
	this.texture__ = tex;
	this.killAlphaThreshold__ = h3d_mat_Defaults.defaultKillAlphaThreshold;
};
$hxClasses["h3d.shader.Texture"] = h3d_shader_Texture;
h3d_shader_Texture.__name__ = "h3d.shader.Texture";
h3d_shader_Texture.__super__ = hxsl_Shader;
h3d_shader_Texture.prototype = $extend(hxsl_Shader.prototype,{
	get_additive: function() {
		return this.additive__;
	}
	,set_additive: function(_v) {
		this.constModified = true;
		return this.additive__ = _v;
	}
	,get_killAlpha: function() {
		return this.killAlpha__;
	}
	,set_killAlpha: function(_v) {
		this.constModified = true;
		return this.killAlpha__ = _v;
	}
	,get_specularAlpha: function() {
		return this.specularAlpha__;
	}
	,set_specularAlpha: function(_v) {
		this.constModified = true;
		return this.specularAlpha__ = _v;
	}
	,get_killAlphaThreshold: function() {
		return this.killAlphaThreshold__;
	}
	,set_killAlphaThreshold: function(_v) {
		return this.killAlphaThreshold__ = _v;
	}
	,get_texture: function() {
		return this.texture__;
	}
	,set_texture: function(_v) {
		return this.texture__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		if(this.additive__) {
			this.constBits |= 1;
		}
		if(this.killAlpha__) {
			this.constBits |= 2;
		}
		if(this.specularAlpha__) {
			this.constBits |= 4;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.additive__;
		case 1:
			return this.killAlpha__;
		case 2:
			return this.specularAlpha__;
		case 3:
			return this.killAlphaThreshold__;
		case 4:
			return this.texture__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		if(index == 3) {
			return this.killAlphaThreshold__;
		}
		return 0.;
	}
	,__class__: h3d_shader_Texture
});
var h3d_shader_UVDelta = function(dx,dy,sx,sy) {
	if(sy == null) {
		sy = 1.;
	}
	if(sx == null) {
		sx = 1.;
	}
	if(dy == null) {
		dy = 0.;
	}
	if(dx == null) {
		dx = 0.;
	}
	this.uvScale__ = new h3d_Vector();
	this.uvDelta__ = new h3d_Vector();
	hxsl_Shader.call(this);
	var _this = this.uvDelta__;
	var x = dx;
	var y = dy;
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	_this.x = x;
	_this.y = y;
	_this.z = 0.;
	_this.w = 1.;
	var _this = this.uvScale__;
	var x = sx;
	var y = sy;
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	_this.x = x;
	_this.y = y;
	_this.z = 0.;
	_this.w = 1.;
};
$hxClasses["h3d.shader.UVDelta"] = h3d_shader_UVDelta;
h3d_shader_UVDelta.__name__ = "h3d.shader.UVDelta";
h3d_shader_UVDelta.__super__ = hxsl_Shader;
h3d_shader_UVDelta.prototype = $extend(hxsl_Shader.prototype,{
	get_uvDelta: function() {
		return this.uvDelta__;
	}
	,set_uvDelta: function(_v) {
		return this.uvDelta__ = _v;
	}
	,get_uvScale: function() {
		return this.uvScale__;
	}
	,set_uvScale: function(_v) {
		return this.uvScale__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.uvDelta__;
		case 1:
			return this.uvScale__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,__class__: h3d_shader_UVDelta
});
var h3d_shader_VertexColorAlpha = function() {
	hxsl_Shader.call(this);
};
$hxClasses["h3d.shader.VertexColorAlpha"] = h3d_shader_VertexColorAlpha;
h3d_shader_VertexColorAlpha.__name__ = "h3d.shader.VertexColorAlpha";
h3d_shader_VertexColorAlpha.__super__ = hxsl_Shader;
h3d_shader_VertexColorAlpha.prototype = $extend(hxsl_Shader.prototype,{
	get_additive: function() {
		return this.additive__;
	}
	,set_additive: function(_v) {
		this.constModified = true;
		return this.additive__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		if(this.additive__) {
			this.constBits |= 1;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		if(index == 0) {
			return this.additive__;
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,__class__: h3d_shader_VertexColorAlpha
});
var h3d_shader_VolumeDecal = function(objectWidth,objectHeight) {
	this.isCentered__ = true;
	this.tangent__ = new h3d_Vector();
	this.normal__ = new h3d_Vector();
	this.scale__ = new h3d_Vector();
	hxsl_Shader.call(this);
	var _this = this.normal__;
	var x = 0;
	var y = 0;
	var z = 1;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	_this.x = x;
	_this.y = y;
	_this.z = z;
	_this.w = 1.;
	var _this = this.tangent__;
	var x = 1;
	var y = 0;
	var z = 0;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	_this.x = x;
	_this.y = y;
	_this.z = z;
	_this.w = 1.;
	var _this = this.scale__;
	var x = 1 / objectWidth;
	var y = 1 / objectHeight;
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	_this.x = x;
	_this.y = y;
	_this.z = 0.;
	_this.w = 1.;
};
$hxClasses["h3d.shader.VolumeDecal"] = h3d_shader_VolumeDecal;
h3d_shader_VolumeDecal.__name__ = "h3d.shader.VolumeDecal";
h3d_shader_VolumeDecal.__super__ = hxsl_Shader;
h3d_shader_VolumeDecal.prototype = $extend(hxsl_Shader.prototype,{
	get_scale: function() {
		return this.scale__;
	}
	,set_scale: function(_v) {
		return this.scale__ = _v;
	}
	,get_normal: function() {
		return this.normal__;
	}
	,set_normal: function(_v) {
		return this.normal__ = _v;
	}
	,get_tangent: function() {
		return this.tangent__;
	}
	,set_tangent: function(_v) {
		return this.tangent__ = _v;
	}
	,get_isCentered: function() {
		return this.isCentered__;
	}
	,set_isCentered: function(_v) {
		this.constModified = true;
		return this.isCentered__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		if(this.isCentered__) {
			this.constBits |= 64;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.scale__;
		case 1:
			return this.normal__;
		case 2:
			return this.tangent__;
		case 3:
			return this.isCentered__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,__class__: h3d_shader_VolumeDecal
});
var haxe_IMap = function() { };
$hxClasses["haxe.IMap"] = haxe_IMap;
haxe_IMap.__name__ = "haxe.IMap";
haxe_IMap.__isInterface__ = true;
var haxe_EntryPoint = function() { };
$hxClasses["haxe.EntryPoint"] = haxe_EntryPoint;
haxe_EntryPoint.__name__ = "haxe.EntryPoint";
haxe_EntryPoint.processEvents = function() {
	while(true) {
		var f = haxe_EntryPoint.pending.shift();
		if(f == null) {
			break;
		}
		f();
	}
	var time = haxe_MainLoop.tick();
	if(!haxe_MainLoop.hasEvents() && haxe_EntryPoint.threadCount == 0) {
		return -1;
	}
	return time;
};
haxe_EntryPoint.run = function() {
	var nextTick = haxe_EntryPoint.processEvents();
	if(typeof(window) != "undefined") {
		var $window = window;
		var rqf = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame || $window.mozRequestAnimationFrame;
		if(rqf != null) {
			rqf(haxe_EntryPoint.run);
		} else if(nextTick >= 0) {
			setTimeout(haxe_EntryPoint.run,nextTick * 1000);
		}
	} else if(nextTick >= 0) {
		setTimeout(haxe_EntryPoint.run,nextTick * 1000);
	}
};
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
};
$hxClasses["haxe.Exception"] = haxe_Exception;
haxe_Exception.__name__ = "haxe.Exception";
haxe_Exception.caught = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value;
	} else if(((value) instanceof Error)) {
		return new haxe_Exception(value.message,null,value);
	} else {
		return new haxe_ValueException(value,null,value);
	}
};
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	unwrap: function() {
		return this.__nativeException;
	}
	,toString: function() {
		return this.get_message();
	}
	,get_message: function() {
		return this.message;
	}
	,get_native: function() {
		return this.__nativeException;
	}
	,__class__: haxe_Exception
});
var haxe_Log = function() { };
$hxClasses["haxe.Log"] = haxe_Log;
haxe_Log.__name__ = "haxe.Log";
haxe_Log.formatOutput = function(v,infos) {
	var str = Std.string(v);
	if(infos == null) {
		return str;
	}
	var pstr = infos.fileName + ":" + infos.lineNumber;
	if(infos.customParams != null) {
		var _g = 0;
		var _g1 = infos.customParams;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			str += ", " + Std.string(v);
		}
	}
	return pstr + ": " + str;
};
haxe_Log.trace = function(v,infos) {
	var str = haxe_Log.formatOutput(v,infos);
	if(typeof(console) != "undefined" && console.log != null) {
		console.log(str);
	}
};
var haxe_MainEvent = function(f,p) {
	this.isBlocking = true;
	this.f = f;
	this.priority = p;
	this.nextRun = -Infinity;
};
$hxClasses["haxe.MainEvent"] = haxe_MainEvent;
haxe_MainEvent.__name__ = "haxe.MainEvent";
haxe_MainEvent.prototype = {
	__class__: haxe_MainEvent
};
var haxe_MainLoop = function() { };
$hxClasses["haxe.MainLoop"] = haxe_MainLoop;
haxe_MainLoop.__name__ = "haxe.MainLoop";
haxe_MainLoop.hasEvents = function() {
	var p = haxe_MainLoop.pending;
	while(p != null) {
		if(p.isBlocking) {
			return true;
		}
		p = p.next;
	}
	return false;
};
haxe_MainLoop.add = function(f,priority) {
	if(priority == null) {
		priority = 0;
	}
	if(f == null) {
		throw haxe_Exception.thrown("Event function is null");
	}
	var e = new haxe_MainEvent(f,priority);
	var head = haxe_MainLoop.pending;
	if(head != null) {
		head.prev = e;
	}
	e.next = head;
	haxe_MainLoop.pending = e;
	haxe_MainLoop.injectIntoEventLoop(0);
	return e;
};
haxe_MainLoop.injectIntoEventLoop = function(waitMs) {
};
haxe_MainLoop.sortEvents = function() {
	var list = haxe_MainLoop.pending;
	if(list == null) {
		return;
	}
	var insize = 1;
	var nmerges;
	var psize = 0;
	var qsize = 0;
	var p;
	var q;
	var e;
	var tail;
	while(true) {
		p = list;
		list = null;
		tail = null;
		nmerges = 0;
		while(p != null) {
			++nmerges;
			q = p;
			psize = 0;
			var _g = 0;
			var _g1 = insize;
			while(_g < _g1) {
				var i = _g++;
				++psize;
				q = q.next;
				if(q == null) {
					break;
				}
			}
			qsize = insize;
			while(psize > 0 || qsize > 0 && q != null) {
				if(psize == 0) {
					e = q;
					q = q.next;
					--qsize;
				} else if(qsize == 0 || q == null || (p.priority > q.priority || p.priority == q.priority && p.nextRun <= q.nextRun)) {
					e = p;
					p = p.next;
					--psize;
				} else {
					e = q;
					q = q.next;
					--qsize;
				}
				if(tail != null) {
					tail.next = e;
				} else {
					list = e;
				}
				e.prev = tail;
				tail = e;
			}
			p = q;
		}
		tail.next = null;
		if(nmerges <= 1) {
			break;
		}
		insize *= 2;
	}
	list.prev = null;
	haxe_MainLoop.pending = list;
};
haxe_MainLoop.tick = function() {
	haxe_MainLoop.sortEvents();
	var e = haxe_MainLoop.pending;
	var now = HxOverrides.now() / 1000;
	var wait = 1e9;
	while(e != null) {
		var next = e.next;
		var wt = e.nextRun - now;
		if(wt <= 0) {
			wait = 0;
			if(e.f != null) {
				e.f();
			}
		} else if(wait > wt) {
			wait = wt;
		}
		e = next;
	}
	return wait;
};
var haxe_Resource = function() { };
$hxClasses["haxe.Resource"] = haxe_Resource;
haxe_Resource.__name__ = "haxe.Resource";
haxe_Resource.getBytes = function(name) {
	var _g = 0;
	var _g1 = haxe_Resource.content;
	while(_g < _g1.length) {
		var x = _g1[_g];
		++_g;
		if(x.name == name) {
			if(x.str != null) {
				return haxe_io_Bytes.ofString(x.str);
			}
			return haxe_crypto_Base64.decode(x.data);
		}
	}
	return null;
};
var haxe_Timer = function(time_ms) {
	var me = this;
	this.id = setInterval(function() {
		me.run();
	},time_ms);
};
$hxClasses["haxe.Timer"] = haxe_Timer;
haxe_Timer.__name__ = "haxe.Timer";
haxe_Timer.delay = function(f,time_ms) {
	var t = new haxe_Timer(time_ms);
	t.run = function() {
		t.stop();
		f();
	};
	return t;
};
haxe_Timer.prototype = {
	stop: function() {
		if(this.id == null) {
			return;
		}
		clearInterval(this.id);
		this.id = null;
	}
	,run: function() {
	}
	,__class__: haxe_Timer
};
var haxe__$Unserializer_DefaultResolver = function() {
};
$hxClasses["haxe._Unserializer.DefaultResolver"] = haxe__$Unserializer_DefaultResolver;
haxe__$Unserializer_DefaultResolver.__name__ = "haxe._Unserializer.DefaultResolver";
haxe__$Unserializer_DefaultResolver.prototype = {
	resolveClass: function(name) {
		return $hxClasses[name];
	}
	,resolveEnum: function(name) {
		return $hxEnums[name];
	}
	,__class__: haxe__$Unserializer_DefaultResolver
};
var haxe_Unserializer = function(buf) {
	this.buf = buf;
	this.length = this.buf.length;
	this.pos = 0;
	this.scache = [];
	this.cache = [];
	var r = haxe_Unserializer.DEFAULT_RESOLVER;
	if(r == null) {
		r = new haxe__$Unserializer_DefaultResolver();
		haxe_Unserializer.DEFAULT_RESOLVER = r;
	}
	this.resolver = r;
};
$hxClasses["haxe.Unserializer"] = haxe_Unserializer;
haxe_Unserializer.__name__ = "haxe.Unserializer";
haxe_Unserializer.initCodes = function() {
	var codes = [];
	var _g = 0;
	var _g1 = haxe_Unserializer.BASE64.length;
	while(_g < _g1) {
		var i = _g++;
		codes[haxe_Unserializer.BASE64.charCodeAt(i)] = i;
	}
	return codes;
};
haxe_Unserializer.run = function(v) {
	return new haxe_Unserializer(v).unserialize();
};
haxe_Unserializer.prototype = {
	readDigits: function() {
		var k = 0;
		var s = false;
		var fpos = this.pos;
		while(true) {
			var c = this.buf.charCodeAt(this.pos);
			if(c != c) {
				break;
			}
			if(c == 45) {
				if(this.pos != fpos) {
					break;
				}
				s = true;
				this.pos++;
				continue;
			}
			if(c < 48 || c > 57) {
				break;
			}
			k = k * 10 + (c - 48);
			this.pos++;
		}
		if(s) {
			k *= -1;
		}
		return k;
	}
	,readFloat: function() {
		var p1 = this.pos;
		while(true) {
			var c = this.buf.charCodeAt(this.pos);
			if(c != c) {
				break;
			}
			if(c >= 43 && c < 58 || c == 101 || c == 69) {
				this.pos++;
			} else {
				break;
			}
		}
		return parseFloat(HxOverrides.substr(this.buf,p1,this.pos - p1));
	}
	,unserializeObject: function(o) {
		while(true) {
			if(this.pos >= this.length) {
				throw haxe_Exception.thrown("Invalid object");
			}
			if(this.buf.charCodeAt(this.pos) == 103) {
				break;
			}
			var k = this.unserialize();
			if(typeof(k) != "string") {
				throw haxe_Exception.thrown("Invalid object key");
			}
			var v = this.unserialize();
			o[k] = v;
		}
		this.pos++;
	}
	,unserializeEnum: function(edecl,tag) {
		if(this.buf.charCodeAt(this.pos++) != 58) {
			throw haxe_Exception.thrown("Invalid enum format");
		}
		var nargs = this.readDigits();
		if(nargs == 0) {
			return Type.createEnum(edecl,tag);
		}
		var args = [];
		while(nargs-- > 0) args.push(this.unserialize());
		return Type.createEnum(edecl,tag,args);
	}
	,unserialize: function() {
		switch(this.buf.charCodeAt(this.pos++)) {
		case 65:
			var name = this.unserialize();
			var cl = this.resolver.resolveClass(name);
			if(cl == null) {
				throw haxe_Exception.thrown("Class not found " + name);
			}
			return cl;
		case 66:
			var name = this.unserialize();
			var e = this.resolver.resolveEnum(name);
			if(e == null) {
				throw haxe_Exception.thrown("Enum not found " + name);
			}
			return e;
		case 67:
			var name = this.unserialize();
			var cl = this.resolver.resolveClass(name);
			if(cl == null) {
				throw haxe_Exception.thrown("Class not found " + name);
			}
			var o = Object.create(cl.prototype);
			this.cache.push(o);
			o.hxUnserialize(this);
			if(this.buf.charCodeAt(this.pos++) != 103) {
				throw haxe_Exception.thrown("Invalid custom data");
			}
			return o;
		case 77:
			var h = new haxe_ds_ObjectMap();
			this.cache.push(h);
			var buf = this.buf;
			while(this.buf.charCodeAt(this.pos) != 104) {
				var s = this.unserialize();
				h.set(s,this.unserialize());
			}
			this.pos++;
			return h;
		case 82:
			var n = this.readDigits();
			if(n < 0 || n >= this.scache.length) {
				throw haxe_Exception.thrown("Invalid string reference");
			}
			return this.scache[n];
		case 97:
			var buf = this.buf;
			var a = [];
			this.cache.push(a);
			while(true) {
				var c = this.buf.charCodeAt(this.pos);
				if(c == 104) {
					this.pos++;
					break;
				}
				if(c == 117) {
					this.pos++;
					var n = this.readDigits();
					a[a.length + n - 1] = null;
				} else {
					a.push(this.unserialize());
				}
			}
			return a;
		case 98:
			var h = new haxe_ds_StringMap();
			this.cache.push(h);
			var buf = this.buf;
			while(this.buf.charCodeAt(this.pos) != 104) {
				var s = this.unserialize();
				var value = this.unserialize();
				h.h[s] = value;
			}
			this.pos++;
			return h;
		case 99:
			var name = this.unserialize();
			var cl = this.resolver.resolveClass(name);
			if(cl == null) {
				throw haxe_Exception.thrown("Class not found " + name);
			}
			var o = Object.create(cl.prototype);
			this.cache.push(o);
			this.unserializeObject(o);
			return o;
		case 100:
			return this.readFloat();
		case 102:
			return false;
		case 105:
			return this.readDigits();
		case 106:
			var name = this.unserialize();
			var edecl = this.resolver.resolveEnum(name);
			if(edecl == null) {
				throw haxe_Exception.thrown("Enum not found " + name);
			}
			this.pos++;
			var index = this.readDigits();
			var _this = edecl.__constructs__;
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = _this[i]._hx_name;
			}
			var tag = result[index];
			if(tag == null) {
				throw haxe_Exception.thrown("Unknown enum index " + name + "@" + index);
			}
			var e = this.unserializeEnum(edecl,tag);
			this.cache.push(e);
			return e;
		case 107:
			return NaN;
		case 108:
			var l = new haxe_ds_List();
			this.cache.push(l);
			var buf = this.buf;
			while(this.buf.charCodeAt(this.pos) != 104) l.add(this.unserialize());
			this.pos++;
			return l;
		case 109:
			return -Infinity;
		case 110:
			return null;
		case 111:
			var o = { };
			this.cache.push(o);
			this.unserializeObject(o);
			return o;
		case 112:
			return Infinity;
		case 113:
			var h = new haxe_ds_IntMap();
			this.cache.push(h);
			var buf = this.buf;
			var c = this.buf.charCodeAt(this.pos++);
			while(c == 58) {
				var i = this.readDigits();
				var value = this.unserialize();
				h.h[i] = value;
				c = this.buf.charCodeAt(this.pos++);
			}
			if(c != 104) {
				throw haxe_Exception.thrown("Invalid IntMap format");
			}
			return h;
		case 114:
			var n = this.readDigits();
			if(n < 0 || n >= this.cache.length) {
				throw haxe_Exception.thrown("Invalid reference");
			}
			return this.cache[n];
		case 115:
			var len = this.readDigits();
			var buf = this.buf;
			if(this.buf.charCodeAt(this.pos++) != 58 || this.length - this.pos < len) {
				throw haxe_Exception.thrown("Invalid bytes length");
			}
			var codes = haxe_Unserializer.CODES;
			if(codes == null) {
				codes = haxe_Unserializer.initCodes();
				haxe_Unserializer.CODES = codes;
			}
			var i = this.pos;
			var rest = len & 3;
			var size = (len >> 2) * 3 + (rest >= 2 ? rest - 1 : 0);
			var max = i + (len - rest);
			var bytes = new haxe_io_Bytes(new ArrayBuffer(size));
			var bpos = 0;
			while(i < max) {
				var c1 = codes[buf.charCodeAt(i++)];
				var c2 = codes[buf.charCodeAt(i++)];
				bytes.b[bpos++] = c1 << 2 | c2 >> 4;
				var c3 = codes[buf.charCodeAt(i++)];
				bytes.b[bpos++] = c2 << 4 | c3 >> 2;
				var c4 = codes[buf.charCodeAt(i++)];
				bytes.b[bpos++] = c3 << 6 | c4;
			}
			if(rest >= 2) {
				var c1 = codes[buf.charCodeAt(i++)];
				var c2 = codes[buf.charCodeAt(i++)];
				bytes.b[bpos++] = c1 << 2 | c2 >> 4;
				if(rest == 3) {
					var c3 = codes[buf.charCodeAt(i++)];
					bytes.b[bpos++] = c2 << 4 | c3 >> 2;
				}
			}
			this.pos += len;
			this.cache.push(bytes);
			return bytes;
		case 116:
			return true;
		case 118:
			var d;
			if(this.buf.charCodeAt(this.pos) >= 48 && this.buf.charCodeAt(this.pos) <= 57 && this.buf.charCodeAt(this.pos + 1) >= 48 && this.buf.charCodeAt(this.pos + 1) <= 57 && this.buf.charCodeAt(this.pos + 2) >= 48 && this.buf.charCodeAt(this.pos + 2) <= 57 && this.buf.charCodeAt(this.pos + 3) >= 48 && this.buf.charCodeAt(this.pos + 3) <= 57 && this.buf.charCodeAt(this.pos + 4) == 45) {
				d = HxOverrides.strDate(HxOverrides.substr(this.buf,this.pos,19));
				this.pos += 19;
			} else {
				d = new Date(this.readFloat());
			}
			this.cache.push(d);
			return d;
		case 119:
			var name = this.unserialize();
			var edecl = this.resolver.resolveEnum(name);
			if(edecl == null) {
				throw haxe_Exception.thrown("Enum not found " + name);
			}
			var e = this.unserializeEnum(edecl,this.unserialize());
			this.cache.push(e);
			return e;
		case 120:
			throw haxe_Exception.thrown(this.unserialize());
		case 121:
			var len = this.readDigits();
			if(this.buf.charCodeAt(this.pos++) != 58 || this.length - this.pos < len) {
				throw haxe_Exception.thrown("Invalid string length");
			}
			var s = HxOverrides.substr(this.buf,this.pos,len);
			this.pos += len;
			s = decodeURIComponent(s.split("+").join(" "));
			this.scache.push(s);
			return s;
		case 122:
			return 0;
		default:
		}
		this.pos--;
		throw haxe_Exception.thrown("Invalid char " + this.buf.charAt(this.pos) + " at position " + this.pos);
	}
	,__class__: haxe_Unserializer
};
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
};
$hxClasses["haxe.ValueException"] = haxe_ValueException;
haxe_ValueException.__name__ = "haxe.ValueException";
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
	unwrap: function() {
		return this.value;
	}
	,__class__: haxe_ValueException
});
var haxe_crypto_Adler32 = function() {
	this.a1 = 1;
	this.a2 = 0;
};
$hxClasses["haxe.crypto.Adler32"] = haxe_crypto_Adler32;
haxe_crypto_Adler32.__name__ = "haxe.crypto.Adler32";
haxe_crypto_Adler32.read = function(i) {
	var a = new haxe_crypto_Adler32();
	var a2a = i.readByte();
	var a2b = i.readByte();
	var a1a = i.readByte();
	var a1b = i.readByte();
	a.a1 = a1a << 8 | a1b;
	a.a2 = a2a << 8 | a2b;
	return a;
};
haxe_crypto_Adler32.prototype = {
	update: function(b,pos,len) {
		var a1 = this.a1;
		var a2 = this.a2;
		var _g = pos;
		var _g1 = pos + len;
		while(_g < _g1) {
			var p = _g++;
			var c = b.b[p];
			a1 = (a1 + c) % 65521;
			a2 = (a2 + a1) % 65521;
		}
		this.a1 = a1;
		this.a2 = a2;
	}
	,equals: function(a) {
		if(a.a1 == this.a1) {
			return a.a2 == this.a2;
		} else {
			return false;
		}
	}
	,__class__: haxe_crypto_Adler32
};
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
$hxClasses["haxe.io.Bytes"] = haxe_io_Bytes;
haxe_io_Bytes.__name__ = "haxe.io.Bytes";
haxe_io_Bytes.ofString = function(s,encoding) {
	if(encoding == haxe_io_Encoding.RawNative) {
		var buf = new Uint8Array(s.length << 1);
		var _g = 0;
		var _g1 = s.length;
		while(_g < _g1) {
			var i = _g++;
			var c = s.charCodeAt(i);
			buf[i << 1] = c & 255;
			buf[i << 1 | 1] = c >> 8;
		}
		return new haxe_io_Bytes(buf.buffer);
	}
	var a = [];
	var i = 0;
	while(i < s.length) {
		var c = s.charCodeAt(i++);
		if(55296 <= c && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(i++) & 1023;
		}
		if(c <= 127) {
			a.push(c);
		} else if(c <= 2047) {
			a.push(192 | c >> 6);
			a.push(128 | c & 63);
		} else if(c <= 65535) {
			a.push(224 | c >> 12);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		} else {
			a.push(240 | c >> 18);
			a.push(128 | c >> 12 & 63);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		}
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.ofData = function(b) {
	var hb = b.hxBytes;
	if(hb != null) {
		return hb;
	}
	return new haxe_io_Bytes(b);
};
haxe_io_Bytes.prototype = {
	blit: function(pos,src,srcpos,len) {
		if(pos < 0 || srcpos < 0 || len < 0 || pos + len > this.length || srcpos + len > src.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(srcpos == 0 && len == src.b.byteLength) {
			this.b.set(src.b,pos);
		} else {
			this.b.set(src.b.subarray(srcpos,srcpos + len),pos);
		}
	}
	,fill: function(pos,len,value) {
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			this.b[pos++] = value;
		}
	}
	,getFloat: function(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getFloat32(pos,true);
	}
	,setFloat: function(pos,v) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		this.data.setFloat32(pos,v,true);
	}
	,getUInt16: function(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getUint16(pos,true);
	}
	,setUInt16: function(pos,v) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		this.data.setUint16(pos,v,true);
	}
	,getInt32: function(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getInt32(pos,true);
	}
	,setInt32: function(pos,v) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		this.data.setInt32(pos,v,true);
	}
	,getString: function(pos,len,encoding) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(encoding == null) {
			encoding = haxe_io_Encoding.UTF8;
		}
		var s = "";
		var b = this.b;
		var i = pos;
		var max = pos + len;
		switch(encoding._hx_index) {
		case 0:
			var debug = pos > 0;
			while(i < max) {
				var c = b[i++];
				if(c < 128) {
					if(c == 0) {
						break;
					}
					s += String.fromCodePoint(c);
				} else if(c < 224) {
					var code = (c & 63) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else if(c < 240) {
					var c2 = b[i++];
					var code1 = (c & 31) << 12 | (c2 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code1);
				} else {
					var c21 = b[i++];
					var c3 = b[i++];
					var u = (c & 15) << 18 | (c21 & 127) << 12 | (c3 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(u);
				}
			}
			break;
		case 1:
			while(i < max) {
				var c = b[i++] | b[i++] << 8;
				s += String.fromCodePoint(c);
			}
			break;
		}
		return s;
	}
	,toString: function() {
		return this.getString(0,this.length);
	}
	,__class__: haxe_io_Bytes
};
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__:true,__constructs__:null
	,UTF8: {_hx_name:"UTF8",_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_name:"RawNative",_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
haxe_io_Encoding.__constructs__ = [haxe_io_Encoding.UTF8,haxe_io_Encoding.RawNative];
haxe_io_Encoding.__empty_constructs__ = [haxe_io_Encoding.UTF8,haxe_io_Encoding.RawNative];
var haxe_crypto_Base64 = function() { };
$hxClasses["haxe.crypto.Base64"] = haxe_crypto_Base64;
haxe_crypto_Base64.__name__ = "haxe.crypto.Base64";
haxe_crypto_Base64.decode = function(str,complement) {
	if(complement == null) {
		complement = true;
	}
	if(complement) {
		while(HxOverrides.cca(str,str.length - 1) == 61) str = HxOverrides.substr(str,0,-1);
	}
	return new haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).decodeBytes(haxe_io_Bytes.ofString(str));
};
var haxe_crypto_BaseCode = function(base) {
	var len = base.length;
	var nbits = 1;
	while(len > 1 << nbits) ++nbits;
	if(nbits > 8 || len != 1 << nbits) {
		throw haxe_Exception.thrown("BaseCode : base length must be a power of two.");
	}
	this.base = base;
	this.nbits = nbits;
};
$hxClasses["haxe.crypto.BaseCode"] = haxe_crypto_BaseCode;
haxe_crypto_BaseCode.__name__ = "haxe.crypto.BaseCode";
haxe_crypto_BaseCode.prototype = {
	initTable: function() {
		var tbl = [];
		var _g = 0;
		while(_g < 256) {
			var i = _g++;
			tbl[i] = -1;
		}
		var _g = 0;
		var _g1 = this.base.length;
		while(_g < _g1) {
			var i = _g++;
			tbl[this.base.b[i]] = i;
		}
		this.tbl = tbl;
	}
	,decodeBytes: function(b) {
		var nbits = this.nbits;
		var base = this.base;
		if(this.tbl == null) {
			this.initTable();
		}
		var tbl = this.tbl;
		var size = b.length * nbits >> 3;
		var out = new haxe_io_Bytes(new ArrayBuffer(size));
		var buf = 0;
		var curbits = 0;
		var pin = 0;
		var pout = 0;
		while(pout < size) {
			while(curbits < 8) {
				curbits += nbits;
				buf <<= nbits;
				var i = tbl[b.b[pin++]];
				if(i == -1) {
					throw haxe_Exception.thrown("BaseCode : invalid encoded char");
				}
				buf |= i;
			}
			curbits -= 8;
			out.b[pout++] = buf >> curbits & 255;
		}
		return out;
	}
	,__class__: haxe_crypto_BaseCode
};
var haxe_crypto_Md5 = function() {
};
$hxClasses["haxe.crypto.Md5"] = haxe_crypto_Md5;
haxe_crypto_Md5.__name__ = "haxe.crypto.Md5";
haxe_crypto_Md5.encode = function(s) {
	var m = new haxe_crypto_Md5();
	var h = m.doEncode(haxe_crypto_Md5.str2blks(s));
	return m.hex(h);
};
haxe_crypto_Md5.str2blks = function(str) {
	var str1 = haxe_io_Bytes.ofString(str);
	var nblk = (str1.length + 8 >> 6) + 1;
	var blks = [];
	var blksSize = nblk * 16;
	var _g = 0;
	var _g1 = blksSize;
	while(_g < _g1) {
		var i = _g++;
		blks[i] = 0;
	}
	var i = 0;
	var max = str1.length;
	var l = max * 8;
	while(i < max) {
		blks[i >> 2] |= str1.b[i] << (l + i) % 4 * 8;
		++i;
	}
	blks[i >> 2] |= 128 << (l + i) % 4 * 8;
	var k = nblk * 16 - 2;
	blks[k] = l & 255;
	blks[k] |= (l >>> 8 & 255) << 8;
	blks[k] |= (l >>> 16 & 255) << 16;
	blks[k] |= (l >>> 24 & 255) << 24;
	return blks;
};
haxe_crypto_Md5.prototype = {
	bitOR: function(a,b) {
		var lsb = a & 1 | b & 1;
		var msb31 = a >>> 1 | b >>> 1;
		return msb31 << 1 | lsb;
	}
	,bitXOR: function(a,b) {
		var lsb = a & 1 ^ b & 1;
		var msb31 = a >>> 1 ^ b >>> 1;
		return msb31 << 1 | lsb;
	}
	,bitAND: function(a,b) {
		var lsb = a & 1 & (b & 1);
		var msb31 = a >>> 1 & b >>> 1;
		return msb31 << 1 | lsb;
	}
	,addme: function(x,y) {
		var lsw = (x & 65535) + (y & 65535);
		var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
		return msw << 16 | lsw & 65535;
	}
	,hex: function(a) {
		var str = "";
		var hex_chr = "0123456789abcdef";
		var _g = 0;
		while(_g < a.length) {
			var num = a[_g];
			++_g;
			str += hex_chr.charAt(num >> 4 & 15) + hex_chr.charAt(num & 15);
			str += hex_chr.charAt(num >> 12 & 15) + hex_chr.charAt(num >> 8 & 15);
			str += hex_chr.charAt(num >> 20 & 15) + hex_chr.charAt(num >> 16 & 15);
			str += hex_chr.charAt(num >> 28 & 15) + hex_chr.charAt(num >> 24 & 15);
		}
		return str;
	}
	,rol: function(num,cnt) {
		return num << cnt | num >>> 32 - cnt;
	}
	,cmn: function(q,a,b,x,s,t) {
		return this.addme(this.rol(this.addme(this.addme(a,q),this.addme(x,t)),s),b);
	}
	,ff: function(a,b,c,d,x,s,t) {
		return this.cmn(this.bitOR(this.bitAND(b,c),this.bitAND(~b,d)),a,b,x,s,t);
	}
	,gg: function(a,b,c,d,x,s,t) {
		return this.cmn(this.bitOR(this.bitAND(b,d),this.bitAND(c,~d)),a,b,x,s,t);
	}
	,hh: function(a,b,c,d,x,s,t) {
		return this.cmn(this.bitXOR(this.bitXOR(b,c),d),a,b,x,s,t);
	}
	,ii: function(a,b,c,d,x,s,t) {
		return this.cmn(this.bitXOR(c,this.bitOR(b,~d)),a,b,x,s,t);
	}
	,doEncode: function(x) {
		var a = 1732584193;
		var b = -271733879;
		var c = -1732584194;
		var d = 271733878;
		var step;
		var i = 0;
		while(i < x.length) {
			var olda = a;
			var oldb = b;
			var oldc = c;
			var oldd = d;
			step = 0;
			a = this.ff(a,b,c,d,x[i],7,-680876936);
			d = this.ff(d,a,b,c,x[i + 1],12,-389564586);
			c = this.ff(c,d,a,b,x[i + 2],17,606105819);
			b = this.ff(b,c,d,a,x[i + 3],22,-1044525330);
			a = this.ff(a,b,c,d,x[i + 4],7,-176418897);
			d = this.ff(d,a,b,c,x[i + 5],12,1200080426);
			c = this.ff(c,d,a,b,x[i + 6],17,-1473231341);
			b = this.ff(b,c,d,a,x[i + 7],22,-45705983);
			a = this.ff(a,b,c,d,x[i + 8],7,1770035416);
			d = this.ff(d,a,b,c,x[i + 9],12,-1958414417);
			c = this.ff(c,d,a,b,x[i + 10],17,-42063);
			b = this.ff(b,c,d,a,x[i + 11],22,-1990404162);
			a = this.ff(a,b,c,d,x[i + 12],7,1804603682);
			d = this.ff(d,a,b,c,x[i + 13],12,-40341101);
			c = this.ff(c,d,a,b,x[i + 14],17,-1502002290);
			b = this.ff(b,c,d,a,x[i + 15],22,1236535329);
			a = this.gg(a,b,c,d,x[i + 1],5,-165796510);
			d = this.gg(d,a,b,c,x[i + 6],9,-1069501632);
			c = this.gg(c,d,a,b,x[i + 11],14,643717713);
			b = this.gg(b,c,d,a,x[i],20,-373897302);
			a = this.gg(a,b,c,d,x[i + 5],5,-701558691);
			d = this.gg(d,a,b,c,x[i + 10],9,38016083);
			c = this.gg(c,d,a,b,x[i + 15],14,-660478335);
			b = this.gg(b,c,d,a,x[i + 4],20,-405537848);
			a = this.gg(a,b,c,d,x[i + 9],5,568446438);
			d = this.gg(d,a,b,c,x[i + 14],9,-1019803690);
			c = this.gg(c,d,a,b,x[i + 3],14,-187363961);
			b = this.gg(b,c,d,a,x[i + 8],20,1163531501);
			a = this.gg(a,b,c,d,x[i + 13],5,-1444681467);
			d = this.gg(d,a,b,c,x[i + 2],9,-51403784);
			c = this.gg(c,d,a,b,x[i + 7],14,1735328473);
			b = this.gg(b,c,d,a,x[i + 12],20,-1926607734);
			a = this.hh(a,b,c,d,x[i + 5],4,-378558);
			d = this.hh(d,a,b,c,x[i + 8],11,-2022574463);
			c = this.hh(c,d,a,b,x[i + 11],16,1839030562);
			b = this.hh(b,c,d,a,x[i + 14],23,-35309556);
			a = this.hh(a,b,c,d,x[i + 1],4,-1530992060);
			d = this.hh(d,a,b,c,x[i + 4],11,1272893353);
			c = this.hh(c,d,a,b,x[i + 7],16,-155497632);
			b = this.hh(b,c,d,a,x[i + 10],23,-1094730640);
			a = this.hh(a,b,c,d,x[i + 13],4,681279174);
			d = this.hh(d,a,b,c,x[i],11,-358537222);
			c = this.hh(c,d,a,b,x[i + 3],16,-722521979);
			b = this.hh(b,c,d,a,x[i + 6],23,76029189);
			a = this.hh(a,b,c,d,x[i + 9],4,-640364487);
			d = this.hh(d,a,b,c,x[i + 12],11,-421815835);
			c = this.hh(c,d,a,b,x[i + 15],16,530742520);
			b = this.hh(b,c,d,a,x[i + 2],23,-995338651);
			a = this.ii(a,b,c,d,x[i],6,-198630844);
			d = this.ii(d,a,b,c,x[i + 7],10,1126891415);
			c = this.ii(c,d,a,b,x[i + 14],15,-1416354905);
			b = this.ii(b,c,d,a,x[i + 5],21,-57434055);
			a = this.ii(a,b,c,d,x[i + 12],6,1700485571);
			d = this.ii(d,a,b,c,x[i + 3],10,-1894986606);
			c = this.ii(c,d,a,b,x[i + 10],15,-1051523);
			b = this.ii(b,c,d,a,x[i + 1],21,-2054922799);
			a = this.ii(a,b,c,d,x[i + 8],6,1873313359);
			d = this.ii(d,a,b,c,x[i + 15],10,-30611744);
			c = this.ii(c,d,a,b,x[i + 6],15,-1560198380);
			b = this.ii(b,c,d,a,x[i + 13],21,1309151649);
			a = this.ii(a,b,c,d,x[i + 4],6,-145523070);
			d = this.ii(d,a,b,c,x[i + 11],10,-1120210379);
			c = this.ii(c,d,a,b,x[i + 2],15,718787259);
			b = this.ii(b,c,d,a,x[i + 9],21,-343485551);
			a = this.addme(a,olda);
			b = this.addme(b,oldb);
			c = this.addme(c,oldc);
			d = this.addme(d,oldd);
			i += 16;
		}
		return [a,b,c,d];
	}
	,__class__: haxe_crypto_Md5
};
var haxe_ds_ArraySort = function() { };
$hxClasses["haxe.ds.ArraySort"] = haxe_ds_ArraySort;
haxe_ds_ArraySort.__name__ = "haxe.ds.ArraySort";
haxe_ds_ArraySort.sort = function(a,cmp) {
	haxe_ds_ArraySort.rec(a,cmp,0,a.length);
};
haxe_ds_ArraySort.rec = function(a,cmp,from,to) {
	var middle = from + to >> 1;
	if(to - from < 12) {
		if(to <= from) {
			return;
		}
		var _g = from + 1;
		var _g1 = to;
		while(_g < _g1) {
			var i = _g++;
			var j = i;
			while(j > from) {
				if(cmp(a[j],a[j - 1]) < 0) {
					haxe_ds_ArraySort.swap(a,j - 1,j);
				} else {
					break;
				}
				--j;
			}
		}
		return;
	}
	haxe_ds_ArraySort.rec(a,cmp,from,middle);
	haxe_ds_ArraySort.rec(a,cmp,middle,to);
	haxe_ds_ArraySort.doMerge(a,cmp,from,middle,to,middle - from,to - middle);
};
haxe_ds_ArraySort.doMerge = function(a,cmp,from,pivot,to,len1,len2) {
	var first_cut;
	var second_cut;
	var len11;
	var len22;
	if(len1 == 0 || len2 == 0) {
		return;
	}
	if(len1 + len2 == 2) {
		if(cmp(a[pivot],a[from]) < 0) {
			haxe_ds_ArraySort.swap(a,pivot,from);
		}
		return;
	}
	if(len1 > len2) {
		len11 = len1 >> 1;
		first_cut = from + len11;
		second_cut = haxe_ds_ArraySort.lower(a,cmp,pivot,to,first_cut);
		len22 = second_cut - pivot;
	} else {
		len22 = len2 >> 1;
		second_cut = pivot + len22;
		first_cut = haxe_ds_ArraySort.upper(a,cmp,from,pivot,second_cut);
		len11 = first_cut - from;
	}
	haxe_ds_ArraySort.rotate(a,cmp,first_cut,pivot,second_cut);
	var new_mid = first_cut + len22;
	haxe_ds_ArraySort.doMerge(a,cmp,from,first_cut,new_mid,len11,len22);
	haxe_ds_ArraySort.doMerge(a,cmp,new_mid,second_cut,to,len1 - len11,len2 - len22);
};
haxe_ds_ArraySort.rotate = function(a,cmp,from,mid,to) {
	if(from == mid || mid == to) {
		return;
	}
	var n = haxe_ds_ArraySort.gcd(to - from,mid - from);
	while(n-- != 0) {
		var val = a[from + n];
		var shift = mid - from;
		var p1 = from + n;
		var p2 = from + n + shift;
		while(p2 != from + n) {
			a[p1] = a[p2];
			p1 = p2;
			if(to - p2 > shift) {
				p2 += shift;
			} else {
				p2 = from + (shift - (to - p2));
			}
		}
		a[p1] = val;
	}
};
haxe_ds_ArraySort.gcd = function(m,n) {
	while(n != 0) {
		var t = m % n;
		m = n;
		n = t;
	}
	return m;
};
haxe_ds_ArraySort.upper = function(a,cmp,from,to,val) {
	var len = to - from;
	var half;
	var mid;
	while(len > 0) {
		half = len >> 1;
		mid = from + half;
		if(cmp(a[val],a[mid]) < 0) {
			len = half;
		} else {
			from = mid + 1;
			len = len - half - 1;
		}
	}
	return from;
};
haxe_ds_ArraySort.lower = function(a,cmp,from,to,val) {
	var len = to - from;
	var half;
	var mid;
	while(len > 0) {
		half = len >> 1;
		mid = from + half;
		if(cmp(a[mid],a[val]) < 0) {
			from = mid + 1;
			len = len - half - 1;
		} else {
			len = half;
		}
	}
	return from;
};
haxe_ds_ArraySort.swap = function(a,i,j) {
	var tmp = a[i];
	a[i] = a[j];
	a[j] = tmp;
};
var haxe_ds_BalancedTree = function() {
};
$hxClasses["haxe.ds.BalancedTree"] = haxe_ds_BalancedTree;
haxe_ds_BalancedTree.__name__ = "haxe.ds.BalancedTree";
haxe_ds_BalancedTree.__interfaces__ = [haxe_IMap];
haxe_ds_BalancedTree.prototype = {
	set: function(key,value) {
		this.root = this.setLoop(key,value,this.root);
	}
	,get: function(key) {
		var node = this.root;
		while(node != null) {
			var c = this.compare(key,node.key);
			if(c == 0) {
				return node.value;
			}
			if(c < 0) {
				node = node.left;
			} else {
				node = node.right;
			}
		}
		return null;
	}
	,setLoop: function(k,v,node) {
		if(node == null) {
			return new haxe_ds_TreeNode(null,k,v,null);
		}
		var c = this.compare(k,node.key);
		if(c == 0) {
			return new haxe_ds_TreeNode(node.left,k,v,node.right,node == null ? 0 : node._height);
		} else if(c < 0) {
			var nl = this.setLoop(k,v,node.left);
			return this.balance(nl,node.key,node.value,node.right);
		} else {
			var nr = this.setLoop(k,v,node.right);
			return this.balance(node.left,node.key,node.value,nr);
		}
	}
	,balance: function(l,k,v,r) {
		var hl = l == null ? 0 : l._height;
		var hr = r == null ? 0 : r._height;
		if(hl > hr + 2) {
			var _this = l.left;
			var _this1 = l.right;
			if((_this == null ? 0 : _this._height) >= (_this1 == null ? 0 : _this1._height)) {
				return new haxe_ds_TreeNode(l.left,l.key,l.value,new haxe_ds_TreeNode(l.right,k,v,r));
			} else {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l.left,l.key,l.value,l.right.left),l.right.key,l.right.value,new haxe_ds_TreeNode(l.right.right,k,v,r));
			}
		} else if(hr > hl + 2) {
			var _this = r.right;
			var _this1 = r.left;
			if((_this == null ? 0 : _this._height) > (_this1 == null ? 0 : _this1._height)) {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l,k,v,r.left),r.key,r.value,r.right);
			} else {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l,k,v,r.left.left),r.left.key,r.left.value,new haxe_ds_TreeNode(r.left.right,r.key,r.value,r.right));
			}
		} else {
			return new haxe_ds_TreeNode(l,k,v,r,(hl > hr ? hl : hr) + 1);
		}
	}
	,compare: function(k1,k2) {
		return Reflect.compare(k1,k2);
	}
	,__class__: haxe_ds_BalancedTree
};
var haxe_ds_TreeNode = function(l,k,v,r,h) {
	if(h == null) {
		h = -1;
	}
	this.left = l;
	this.key = k;
	this.value = v;
	this.right = r;
	if(h == -1) {
		var tmp;
		var _this = this.left;
		var _this1 = this.right;
		if((_this == null ? 0 : _this._height) > (_this1 == null ? 0 : _this1._height)) {
			var _this = this.left;
			tmp = _this == null ? 0 : _this._height;
		} else {
			var _this = this.right;
			tmp = _this == null ? 0 : _this._height;
		}
		this._height = tmp + 1;
	} else {
		this._height = h;
	}
};
$hxClasses["haxe.ds.TreeNode"] = haxe_ds_TreeNode;
haxe_ds_TreeNode.__name__ = "haxe.ds.TreeNode";
haxe_ds_TreeNode.prototype = {
	__class__: haxe_ds_TreeNode
};
var haxe_ds_EnumValueMap = function() {
	haxe_ds_BalancedTree.call(this);
};
$hxClasses["haxe.ds.EnumValueMap"] = haxe_ds_EnumValueMap;
haxe_ds_EnumValueMap.__name__ = "haxe.ds.EnumValueMap";
haxe_ds_EnumValueMap.__interfaces__ = [haxe_IMap];
haxe_ds_EnumValueMap.__super__ = haxe_ds_BalancedTree;
haxe_ds_EnumValueMap.prototype = $extend(haxe_ds_BalancedTree.prototype,{
	compare: function(k1,k2) {
		var d = k1._hx_index - k2._hx_index;
		if(d != 0) {
			return d;
		}
		var p1 = Type.enumParameters(k1);
		var p2 = Type.enumParameters(k2);
		if(p1.length == 0 && p2.length == 0) {
			return 0;
		}
		return this.compareArgs(p1,p2);
	}
	,compareArgs: function(a1,a2) {
		var ld = a1.length - a2.length;
		if(ld != 0) {
			return ld;
		}
		var _g = 0;
		var _g1 = a1.length;
		while(_g < _g1) {
			var i = _g++;
			var d = this.compareArg(a1[i],a2[i]);
			if(d != 0) {
				return d;
			}
		}
		return 0;
	}
	,compareArg: function(v1,v2) {
		if(Reflect.isEnumValue(v1) && Reflect.isEnumValue(v2)) {
			return this.compare(v1,v2);
		} else if(((v1) instanceof Array) && ((v2) instanceof Array)) {
			return this.compareArgs(v1,v2);
		} else {
			return Reflect.compare(v1,v2);
		}
	}
	,__class__: haxe_ds_EnumValueMap
});
var haxe_ds_IntMap = function() {
	this.h = { };
};
$hxClasses["haxe.ds.IntMap"] = haxe_ds_IntMap;
haxe_ds_IntMap.__name__ = "haxe.ds.IntMap";
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
haxe_ds_IntMap.prototype = {
	remove: function(key) {
		if(!this.h.hasOwnProperty(key)) {
			return false;
		}
		delete(this.h[key]);
		return true;
	}
	,keys: function() {
		var a = [];
		for( var key in this.h ) if(this.h.hasOwnProperty(key)) a.push(+key);
		return new haxe_iterators_ArrayIterator(a);
	}
	,iterator: function() {
		return { ref : this.h, it : this.keys(), hasNext : function() {
			return this.it.hasNext();
		}, next : function() {
			var i = this.it.next();
			return this.ref[i];
		}};
	}
	,__class__: haxe_ds_IntMap
};
var haxe_ds_List = function() {
	this.length = 0;
};
$hxClasses["haxe.ds.List"] = haxe_ds_List;
haxe_ds_List.__name__ = "haxe.ds.List";
haxe_ds_List.prototype = {
	add: function(item) {
		var x = new haxe_ds__$List_ListNode(item,null);
		if(this.h == null) {
			this.h = x;
		} else {
			this.q.next = x;
		}
		this.q = x;
		this.length++;
	}
	,push: function(item) {
		var x = new haxe_ds__$List_ListNode(item,this.h);
		this.h = x;
		if(this.q == null) {
			this.q = x;
		}
		this.length++;
	}
	,pop: function() {
		if(this.h == null) {
			return null;
		}
		var x = this.h.item;
		this.h = this.h.next;
		if(this.h == null) {
			this.q = null;
		}
		this.length--;
		return x;
	}
	,remove: function(v) {
		var prev = null;
		var l = this.h;
		while(l != null) {
			if(l.item == v) {
				if(prev == null) {
					this.h = l.next;
				} else {
					prev.next = l.next;
				}
				if(this.q == l) {
					this.q = prev;
				}
				this.length--;
				return true;
			}
			prev = l;
			l = l.next;
		}
		return false;
	}
	,__class__: haxe_ds_List
};
var haxe_ds__$List_ListNode = function(item,next) {
	this.item = item;
	this.next = next;
};
$hxClasses["haxe.ds._List.ListNode"] = haxe_ds__$List_ListNode;
haxe_ds__$List_ListNode.__name__ = "haxe.ds._List.ListNode";
haxe_ds__$List_ListNode.prototype = {
	__class__: haxe_ds__$List_ListNode
};
var haxe_ds_ObjectMap = function() {
	this.h = { __keys__ : { }};
};
$hxClasses["haxe.ds.ObjectMap"] = haxe_ds_ObjectMap;
haxe_ds_ObjectMap.__name__ = "haxe.ds.ObjectMap";
haxe_ds_ObjectMap.__interfaces__ = [haxe_IMap];
haxe_ds_ObjectMap.prototype = {
	set: function(key,value) {
		var id = key.__id__;
		if(id == null) {
			id = (key.__id__ = $global.$haxeUID++);
		}
		this.h[id] = value;
		this.h.__keys__[id] = key;
	}
	,remove: function(key) {
		var id = key.__id__;
		if(this.h.__keys__[id] == null) {
			return false;
		}
		delete(this.h[id]);
		delete(this.h.__keys__[id]);
		return true;
	}
	,keys: function() {
		var a = [];
		for( var key in this.h.__keys__ ) {
		if(this.h.hasOwnProperty(key)) {
			a.push(this.h.__keys__[key]);
		}
		}
		return new haxe_iterators_ArrayIterator(a);
	}
	,__class__: haxe_ds_ObjectMap
};
var haxe_ds_StringMap = function() {
	this.h = Object.create(null);
};
$hxClasses["haxe.ds.StringMap"] = haxe_ds_StringMap;
haxe_ds_StringMap.__name__ = "haxe.ds.StringMap";
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	iterator: function() {
		return new haxe_ds__$StringMap_StringMapValueIterator(this.h);
	}
	,__class__: haxe_ds_StringMap
};
var haxe_ds__$StringMap_StringMapKeyIterator = function(h) {
	this.h = h;
	this.keys = Object.keys(h);
	this.length = this.keys.length;
	this.current = 0;
};
$hxClasses["haxe.ds._StringMap.StringMapKeyIterator"] = haxe_ds__$StringMap_StringMapKeyIterator;
haxe_ds__$StringMap_StringMapKeyIterator.__name__ = "haxe.ds._StringMap.StringMapKeyIterator";
haxe_ds__$StringMap_StringMapKeyIterator.prototype = {
	hasNext: function() {
		return this.current < this.length;
	}
	,next: function() {
		return this.keys[this.current++];
	}
	,__class__: haxe_ds__$StringMap_StringMapKeyIterator
};
var haxe_ds__$StringMap_StringMapValueIterator = function(h) {
	this.h = h;
	this.keys = Object.keys(h);
	this.length = this.keys.length;
	this.current = 0;
};
$hxClasses["haxe.ds._StringMap.StringMapValueIterator"] = haxe_ds__$StringMap_StringMapValueIterator;
haxe_ds__$StringMap_StringMapValueIterator.__name__ = "haxe.ds._StringMap.StringMapValueIterator";
haxe_ds__$StringMap_StringMapValueIterator.prototype = {
	hasNext: function() {
		return this.current < this.length;
	}
	,next: function() {
		return this.h[this.keys[this.current++]];
	}
	,__class__: haxe_ds__$StringMap_StringMapValueIterator
};
var haxe_exceptions_PosException = function(message,previous,pos) {
	haxe_Exception.call(this,message,previous);
	if(pos == null) {
		this.posInfos = { fileName : "(unknown)", lineNumber : 0, className : "(unknown)", methodName : "(unknown)"};
	} else {
		this.posInfos = pos;
	}
};
$hxClasses["haxe.exceptions.PosException"] = haxe_exceptions_PosException;
haxe_exceptions_PosException.__name__ = "haxe.exceptions.PosException";
haxe_exceptions_PosException.__super__ = haxe_Exception;
haxe_exceptions_PosException.prototype = $extend(haxe_Exception.prototype,{
	toString: function() {
		return "" + haxe_Exception.prototype.toString.call(this) + " in " + this.posInfos.className + "." + this.posInfos.methodName + " at " + this.posInfos.fileName + ":" + this.posInfos.lineNumber;
	}
	,__class__: haxe_exceptions_PosException
});
var haxe_exceptions_NotImplementedException = function(message,previous,pos) {
	if(message == null) {
		message = "Not implemented";
	}
	haxe_exceptions_PosException.call(this,message,previous,pos);
};
$hxClasses["haxe.exceptions.NotImplementedException"] = haxe_exceptions_NotImplementedException;
haxe_exceptions_NotImplementedException.__name__ = "haxe.exceptions.NotImplementedException";
haxe_exceptions_NotImplementedException.__super__ = haxe_exceptions_PosException;
haxe_exceptions_NotImplementedException.prototype = $extend(haxe_exceptions_PosException.prototype,{
	__class__: haxe_exceptions_NotImplementedException
});
var haxe_io_BytesBuffer = function() {
	this.pos = 0;
	this.size = 0;
};
$hxClasses["haxe.io.BytesBuffer"] = haxe_io_BytesBuffer;
haxe_io_BytesBuffer.__name__ = "haxe.io.BytesBuffer";
haxe_io_BytesBuffer.prototype = {
	addByte: function(byte) {
		if(this.pos == this.size) {
			this.grow(1);
		}
		this.view.setUint8(this.pos++,byte);
	}
	,add: function(src) {
		if(this.pos + src.length > this.size) {
			this.grow(src.length);
		}
		if(this.size == 0) {
			return;
		}
		var sub = new Uint8Array(src.b.buffer,src.b.byteOffset,src.length);
		this.u8.set(sub,this.pos);
		this.pos += src.length;
	}
	,addBytes: function(src,pos,len) {
		if(pos < 0 || len < 0 || pos + len > src.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(this.pos + len > this.size) {
			this.grow(len);
		}
		if(this.size == 0) {
			return;
		}
		var sub = new Uint8Array(src.b.buffer,src.b.byteOffset + pos,len);
		this.u8.set(sub,this.pos);
		this.pos += len;
	}
	,grow: function(delta) {
		var req = this.pos + delta;
		var nsize = this.size == 0 ? 16 : this.size;
		while(nsize < req) nsize = nsize * 3 >> 1;
		var nbuf = new ArrayBuffer(nsize);
		var nu8 = new Uint8Array(nbuf);
		if(this.size > 0) {
			nu8.set(this.u8);
		}
		this.size = nsize;
		this.buffer = nbuf;
		this.u8 = nu8;
		this.view = new DataView(this.buffer);
	}
	,getBytes: function() {
		if(this.size == 0) {
			return new haxe_io_Bytes(new ArrayBuffer(0));
		}
		var b = new haxe_io_Bytes(this.buffer);
		b.length = this.pos;
		return b;
	}
	,__class__: haxe_io_BytesBuffer
};
var haxe_io_Input = function() { };
$hxClasses["haxe.io.Input"] = haxe_io_Input;
haxe_io_Input.__name__ = "haxe.io.Input";
haxe_io_Input.prototype = {
	readByte: function() {
		throw new haxe_exceptions_NotImplementedException(null,null,{ fileName : "haxe/io/Input.hx", lineNumber : 53, className : "haxe.io.Input", methodName : "readByte"});
	}
	,readBytes: function(s,pos,len) {
		var k = len;
		var b = s.b;
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		try {
			while(k > 0) {
				b[pos] = this.readByte();
				++pos;
				--k;
			}
		} catch( _g ) {
			if(!((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
				throw _g;
			}
		}
		return len - k;
	}
	,set_bigEndian: function(b) {
		this.bigEndian = b;
		return b;
	}
	,readFullBytes: function(s,pos,len) {
		while(len > 0) {
			var k = this.readBytes(s,pos,len);
			if(k == 0) {
				throw haxe_Exception.thrown(haxe_io_Error.Blocked);
			}
			pos += k;
			len -= k;
		}
	}
	,read: function(nbytes) {
		var s = new haxe_io_Bytes(new ArrayBuffer(nbytes));
		var p = 0;
		while(nbytes > 0) {
			var k = this.readBytes(s,p,nbytes);
			if(k == 0) {
				throw haxe_Exception.thrown(haxe_io_Error.Blocked);
			}
			p += k;
			nbytes -= k;
		}
		return s;
	}
	,readUntil: function(end) {
		var buf = new haxe_io_BytesBuffer();
		var last;
		while(true) {
			last = this.readByte();
			if(!(last != end)) {
				break;
			}
			buf.addByte(last);
		}
		return buf.getBytes().toString();
	}
	,readLine: function() {
		var buf = new haxe_io_BytesBuffer();
		var last;
		var s;
		try {
			while(true) {
				last = this.readByte();
				if(!(last != 10)) {
					break;
				}
				buf.addByte(last);
			}
			s = buf.getBytes().toString();
			if(HxOverrides.cca(s,s.length - 1) == 13) {
				s = HxOverrides.substr(s,0,-1);
			}
		} catch( _g ) {
			var _g1 = haxe_Exception.caught(_g).unwrap();
			if(((_g1) instanceof haxe_io_Eof)) {
				var e = _g1;
				s = buf.getBytes().toString();
				if(s.length == 0) {
					throw haxe_Exception.thrown(e);
				}
			} else {
				throw _g;
			}
		}
		return s;
	}
	,readDouble: function() {
		var i1 = this.readInt32();
		var i2 = this.readInt32();
		if(this.bigEndian) {
			return haxe_io_FPHelper.i64ToDouble(i2,i1);
		} else {
			return haxe_io_FPHelper.i64ToDouble(i1,i2);
		}
	}
	,readInt16: function() {
		var ch1 = this.readByte();
		var ch2 = this.readByte();
		var n = this.bigEndian ? ch2 | ch1 << 8 : ch1 | ch2 << 8;
		if((n & 32768) != 0) {
			return n - 65536;
		}
		return n;
	}
	,readUInt16: function() {
		var ch1 = this.readByte();
		var ch2 = this.readByte();
		if(this.bigEndian) {
			return ch2 | ch1 << 8;
		} else {
			return ch1 | ch2 << 8;
		}
	}
	,readUInt24: function() {
		var ch1 = this.readByte();
		var ch2 = this.readByte();
		var ch3 = this.readByte();
		if(this.bigEndian) {
			return ch3 | ch2 << 8 | ch1 << 16;
		} else {
			return ch1 | ch2 << 8 | ch3 << 16;
		}
	}
	,readInt32: function() {
		var ch1 = this.readByte();
		var ch2 = this.readByte();
		var ch3 = this.readByte();
		var ch4 = this.readByte();
		if(this.bigEndian) {
			return ch4 | ch3 << 8 | ch2 << 16 | ch1 << 24;
		} else {
			return ch1 | ch2 << 8 | ch3 << 16 | ch4 << 24;
		}
	}
	,readString: function(len,encoding) {
		var b = new haxe_io_Bytes(new ArrayBuffer(len));
		this.readFullBytes(b,0,len);
		return b.getString(0,len,encoding);
	}
	,__class__: haxe_io_Input
};
var haxe_io_BytesInput = function(b,pos,len) {
	if(pos == null) {
		pos = 0;
	}
	if(len == null) {
		len = b.length - pos;
	}
	if(pos < 0 || len < 0 || pos + len > b.length) {
		throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
	}
	this.b = b.b;
	this.pos = pos;
	this.len = len;
	this.totlen = len;
};
$hxClasses["haxe.io.BytesInput"] = haxe_io_BytesInput;
haxe_io_BytesInput.__name__ = "haxe.io.BytesInput";
haxe_io_BytesInput.__super__ = haxe_io_Input;
haxe_io_BytesInput.prototype = $extend(haxe_io_Input.prototype,{
	set_position: function(p) {
		if(p < 0) {
			p = 0;
		} else if(p > this.totlen) {
			p = this.totlen;
		}
		this.len = this.totlen - p;
		return this.pos = p;
	}
	,readByte: function() {
		if(this.len == 0) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
		this.len--;
		return this.b[this.pos++];
	}
	,readBytes: function(buf,pos,len) {
		if(pos < 0 || len < 0 || pos + len > buf.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(this.len == 0 && len > 0) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
		if(this.len < len) {
			len = this.len;
		}
		var b1 = this.b;
		var b2 = buf.b;
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			b2[pos + i] = b1[this.pos + i];
		}
		this.pos += len;
		this.len -= len;
		return len;
	}
	,__class__: haxe_io_BytesInput
});
var haxe_io_Output = function() { };
$hxClasses["haxe.io.Output"] = haxe_io_Output;
haxe_io_Output.__name__ = "haxe.io.Output";
haxe_io_Output.prototype = {
	writeByte: function(c) {
		throw new haxe_exceptions_NotImplementedException(null,null,{ fileName : "haxe/io/Output.hx", lineNumber : 47, className : "haxe.io.Output", methodName : "writeByte"});
	}
	,writeBytes: function(s,pos,len) {
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		var b = s.b;
		var k = len;
		while(k > 0) {
			this.writeByte(b[pos]);
			++pos;
			--k;
		}
		return len;
	}
	,flush: function() {
	}
	,close: function() {
	}
	,write: function(s) {
		var l = s.length;
		var p = 0;
		while(l > 0) {
			var k = this.writeBytes(s,p,l);
			if(k == 0) {
				throw haxe_Exception.thrown(haxe_io_Error.Blocked);
			}
			p += k;
			l -= k;
		}
	}
	,writeFloat: function(x) {
		this.writeInt32(haxe_io_FPHelper.floatToI32(x));
	}
	,writeInt16: function(x) {
		if(x < -32768 || x >= 32768) {
			throw haxe_Exception.thrown(haxe_io_Error.Overflow);
		}
		this.writeUInt16(x & 65535);
	}
	,writeUInt16: function(x) {
		if(x < 0 || x >= 65536) {
			throw haxe_Exception.thrown(haxe_io_Error.Overflow);
		}
		if(this.bigEndian) {
			this.writeByte(x >> 8);
			this.writeByte(x & 255);
		} else {
			this.writeByte(x & 255);
			this.writeByte(x >> 8);
		}
	}
	,writeInt32: function(x) {
		if(this.bigEndian) {
			this.writeByte(x >>> 24);
			this.writeByte(x >> 16 & 255);
			this.writeByte(x >> 8 & 255);
			this.writeByte(x & 255);
		} else {
			this.writeByte(x & 255);
			this.writeByte(x >> 8 & 255);
			this.writeByte(x >> 16 & 255);
			this.writeByte(x >>> 24);
		}
	}
	,__class__: haxe_io_Output
};
var haxe_io_BytesOutput = function() {
	this.b = new haxe_io_BytesBuffer();
};
$hxClasses["haxe.io.BytesOutput"] = haxe_io_BytesOutput;
haxe_io_BytesOutput.__name__ = "haxe.io.BytesOutput";
haxe_io_BytesOutput.__super__ = haxe_io_Output;
haxe_io_BytesOutput.prototype = $extend(haxe_io_Output.prototype,{
	writeByte: function(c) {
		this.b.addByte(c);
	}
	,writeBytes: function(buf,pos,len) {
		this.b.addBytes(buf,pos,len);
		return len;
	}
	,getBytes: function() {
		return this.b.getBytes();
	}
	,__class__: haxe_io_BytesOutput
});
var haxe_io_Eof = function() {
};
$hxClasses["haxe.io.Eof"] = haxe_io_Eof;
haxe_io_Eof.__name__ = "haxe.io.Eof";
haxe_io_Eof.prototype = {
	toString: function() {
		return "Eof";
	}
	,__class__: haxe_io_Eof
};
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__:true,__constructs__:null
	,Blocked: {_hx_name:"Blocked",_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_name:"Overflow",_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_name:"OutsideBounds",_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_._hx_name="Custom",$_.__params__ = ["e"],$_)
};
haxe_io_Error.__constructs__ = [haxe_io_Error.Blocked,haxe_io_Error.Overflow,haxe_io_Error.OutsideBounds,haxe_io_Error.Custom];
haxe_io_Error.__empty_constructs__ = [haxe_io_Error.Blocked,haxe_io_Error.Overflow,haxe_io_Error.OutsideBounds];
var haxe_io_FPHelper = function() { };
$hxClasses["haxe.io.FPHelper"] = haxe_io_FPHelper;
haxe_io_FPHelper.__name__ = "haxe.io.FPHelper";
haxe_io_FPHelper.floatToI32 = function(f) {
	haxe_io_FPHelper.helper.setFloat32(0,f,true);
	return haxe_io_FPHelper.helper.getInt32(0,true);
};
haxe_io_FPHelper.i64ToDouble = function(low,high) {
	haxe_io_FPHelper.helper.setInt32(0,low,true);
	haxe_io_FPHelper.helper.setInt32(4,high,true);
	return haxe_io_FPHelper.helper.getFloat64(0,true);
};
var haxe_io_Path = function(path) {
	switch(path) {
	case ".":case "..":
		this.dir = path;
		this.file = "";
		return;
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		this.dir = HxOverrides.substr(path,0,c2);
		path = HxOverrides.substr(path,c2 + 1,null);
		this.backslash = true;
	} else if(c2 < c1) {
		this.dir = HxOverrides.substr(path,0,c1);
		path = HxOverrides.substr(path,c1 + 1,null);
	} else {
		this.dir = null;
	}
	var cp = path.lastIndexOf(".");
	if(cp != -1) {
		this.ext = HxOverrides.substr(path,cp + 1,null);
		this.file = HxOverrides.substr(path,0,cp);
	} else {
		this.ext = null;
		this.file = path;
	}
};
$hxClasses["haxe.io.Path"] = haxe_io_Path;
haxe_io_Path.__name__ = "haxe.io.Path";
haxe_io_Path.directory = function(path) {
	var s = new haxe_io_Path(path);
	if(s.dir == null) {
		return "";
	}
	return s.dir;
};
haxe_io_Path.withExtension = function(path,ext) {
	var s = new haxe_io_Path(path);
	s.ext = ext;
	return s.toString();
};
haxe_io_Path.join = function(paths) {
	var _g = [];
	var _g1 = 0;
	var _g2 = paths;
	while(_g1 < _g2.length) {
		var v = _g2[_g1];
		++_g1;
		if(v != null && v != "") {
			_g.push(v);
		}
	}
	var paths = _g;
	if(paths.length == 0) {
		return "";
	}
	var path = paths[0];
	var _g = 1;
	var _g1 = paths.length;
	while(_g < _g1) {
		var i = _g++;
		path = haxe_io_Path.addTrailingSlash(path);
		path += paths[i];
	}
	return haxe_io_Path.normalize(path);
};
haxe_io_Path.normalize = function(path) {
	var slash = "/";
	path = path.split("\\").join(slash);
	if(path == slash) {
		return slash;
	}
	var target = [];
	var _g = 0;
	var _g1 = path.split(slash);
	while(_g < _g1.length) {
		var token = _g1[_g];
		++_g;
		if(token == ".." && target.length > 0 && target[target.length - 1] != "..") {
			target.pop();
		} else if(token == "") {
			if(target.length > 0 || HxOverrides.cca(path,0) == 47) {
				target.push(token);
			}
		} else if(token != ".") {
			target.push(token);
		}
	}
	var tmp = target.join(slash);
	var acc_b = "";
	var colon = false;
	var slashes = false;
	var _g2_offset = 0;
	var _g2_s = tmp;
	while(_g2_offset < _g2_s.length) {
		var s = _g2_s;
		var index = _g2_offset++;
		var c = s.charCodeAt(index);
		if(c >= 55296 && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
		}
		var c1 = c;
		if(c1 >= 65536) {
			++_g2_offset;
		}
		var c2 = c1;
		switch(c2) {
		case 47:
			if(!colon) {
				slashes = true;
			} else {
				var i = c2;
				colon = false;
				if(slashes) {
					acc_b += "/";
					slashes = false;
				}
				acc_b += String.fromCodePoint(i);
			}
			break;
		case 58:
			acc_b += ":";
			colon = true;
			break;
		default:
			var i1 = c2;
			colon = false;
			if(slashes) {
				acc_b += "/";
				slashes = false;
			}
			acc_b += String.fromCodePoint(i1);
		}
	}
	return acc_b;
};
haxe_io_Path.addTrailingSlash = function(path) {
	if(path.length == 0) {
		return "/";
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		if(c2 != path.length - 1) {
			return path + "\\";
		} else {
			return path;
		}
	} else if(c1 != path.length - 1) {
		return path + "/";
	} else {
		return path;
	}
};
haxe_io_Path.prototype = {
	toString: function() {
		return (this.dir == null ? "" : this.dir + (this.backslash ? "\\" : "/")) + this.file + (this.ext == null ? "" : "." + this.ext);
	}
	,__class__: haxe_io_Path
};
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
$hxClasses["haxe.iterators.ArrayIterator"] = haxe_iterators_ArrayIterator;
haxe_iterators_ArrayIterator.__name__ = "haxe.iterators.ArrayIterator";
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
	,__class__: haxe_iterators_ArrayIterator
};
var haxe_macro_Binop = $hxEnums["haxe.macro.Binop"] = { __ename__:true,__constructs__:null
	,OpAdd: {_hx_name:"OpAdd",_hx_index:0,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpMult: {_hx_name:"OpMult",_hx_index:1,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpDiv: {_hx_name:"OpDiv",_hx_index:2,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpSub: {_hx_name:"OpSub",_hx_index:3,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAssign: {_hx_name:"OpAssign",_hx_index:4,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpEq: {_hx_name:"OpEq",_hx_index:5,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpNotEq: {_hx_name:"OpNotEq",_hx_index:6,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpGt: {_hx_name:"OpGt",_hx_index:7,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpGte: {_hx_name:"OpGte",_hx_index:8,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpLt: {_hx_name:"OpLt",_hx_index:9,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpLte: {_hx_name:"OpLte",_hx_index:10,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAnd: {_hx_name:"OpAnd",_hx_index:11,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpOr: {_hx_name:"OpOr",_hx_index:12,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpXor: {_hx_name:"OpXor",_hx_index:13,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpBoolAnd: {_hx_name:"OpBoolAnd",_hx_index:14,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpBoolOr: {_hx_name:"OpBoolOr",_hx_index:15,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpShl: {_hx_name:"OpShl",_hx_index:16,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpShr: {_hx_name:"OpShr",_hx_index:17,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpUShr: {_hx_name:"OpUShr",_hx_index:18,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpMod: {_hx_name:"OpMod",_hx_index:19,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAssignOp: ($_=function(op) { return {_hx_index:20,op:op,__enum__:"haxe.macro.Binop",toString:$estr}; },$_._hx_name="OpAssignOp",$_.__params__ = ["op"],$_)
	,OpInterval: {_hx_name:"OpInterval",_hx_index:21,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpArrow: {_hx_name:"OpArrow",_hx_index:22,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpIn: {_hx_name:"OpIn",_hx_index:23,__enum__:"haxe.macro.Binop",toString:$estr}
};
haxe_macro_Binop.__constructs__ = [haxe_macro_Binop.OpAdd,haxe_macro_Binop.OpMult,haxe_macro_Binop.OpDiv,haxe_macro_Binop.OpSub,haxe_macro_Binop.OpAssign,haxe_macro_Binop.OpEq,haxe_macro_Binop.OpNotEq,haxe_macro_Binop.OpGt,haxe_macro_Binop.OpGte,haxe_macro_Binop.OpLt,haxe_macro_Binop.OpLte,haxe_macro_Binop.OpAnd,haxe_macro_Binop.OpOr,haxe_macro_Binop.OpXor,haxe_macro_Binop.OpBoolAnd,haxe_macro_Binop.OpBoolOr,haxe_macro_Binop.OpShl,haxe_macro_Binop.OpShr,haxe_macro_Binop.OpUShr,haxe_macro_Binop.OpMod,haxe_macro_Binop.OpAssignOp,haxe_macro_Binop.OpInterval,haxe_macro_Binop.OpArrow,haxe_macro_Binop.OpIn];
haxe_macro_Binop.__empty_constructs__ = [haxe_macro_Binop.OpAdd,haxe_macro_Binop.OpMult,haxe_macro_Binop.OpDiv,haxe_macro_Binop.OpSub,haxe_macro_Binop.OpAssign,haxe_macro_Binop.OpEq,haxe_macro_Binop.OpNotEq,haxe_macro_Binop.OpGt,haxe_macro_Binop.OpGte,haxe_macro_Binop.OpLt,haxe_macro_Binop.OpLte,haxe_macro_Binop.OpAnd,haxe_macro_Binop.OpOr,haxe_macro_Binop.OpXor,haxe_macro_Binop.OpBoolAnd,haxe_macro_Binop.OpBoolOr,haxe_macro_Binop.OpShl,haxe_macro_Binop.OpShr,haxe_macro_Binop.OpUShr,haxe_macro_Binop.OpMod,haxe_macro_Binop.OpInterval,haxe_macro_Binop.OpArrow,haxe_macro_Binop.OpIn];
var haxe_macro_Unop = $hxEnums["haxe.macro.Unop"] = { __ename__:true,__constructs__:null
	,OpIncrement: {_hx_name:"OpIncrement",_hx_index:0,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpDecrement: {_hx_name:"OpDecrement",_hx_index:1,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNot: {_hx_name:"OpNot",_hx_index:2,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNeg: {_hx_name:"OpNeg",_hx_index:3,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNegBits: {_hx_name:"OpNegBits",_hx_index:4,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpSpread: {_hx_name:"OpSpread",_hx_index:5,__enum__:"haxe.macro.Unop",toString:$estr}
};
haxe_macro_Unop.__constructs__ = [haxe_macro_Unop.OpIncrement,haxe_macro_Unop.OpDecrement,haxe_macro_Unop.OpNot,haxe_macro_Unop.OpNeg,haxe_macro_Unop.OpNegBits,haxe_macro_Unop.OpSpread];
haxe_macro_Unop.__empty_constructs__ = [haxe_macro_Unop.OpIncrement,haxe_macro_Unop.OpDecrement,haxe_macro_Unop.OpNot,haxe_macro_Unop.OpNeg,haxe_macro_Unop.OpNegBits,haxe_macro_Unop.OpSpread];
var haxe_rtti_Meta = function() { };
$hxClasses["haxe.rtti.Meta"] = haxe_rtti_Meta;
haxe_rtti_Meta.__name__ = "haxe.rtti.Meta";
haxe_rtti_Meta.getType = function(t) {
	var meta = haxe_rtti_Meta.getMeta(t);
	if(meta == null || meta.obj == null) {
		return { };
	} else {
		return meta.obj;
	}
};
haxe_rtti_Meta.getMeta = function(t) {
	return t.__meta__;
};
var haxe_xml__$Access_NodeAccess = {};
haxe_xml__$Access_NodeAccess.resolve = function(this1,name) {
	var x = this1.elementsNamed(name).next();
	if(x == null) {
		var xname;
		if(this1.nodeType == Xml.Document) {
			xname = "Document";
		} else {
			if(this1.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this1.nodeType == null ? "null" : XmlType.toString(this1.nodeType)));
			}
			xname = this1.nodeName;
		}
		throw haxe_Exception.thrown(xname + " is missing element " + name);
	}
	if(x.nodeType != Xml.Document && x.nodeType != Xml.Element) {
		throw haxe_Exception.thrown("Invalid nodeType " + (x.nodeType == null ? "null" : XmlType.toString(x.nodeType)));
	}
	var this1 = x;
	return this1;
};
var haxe_xml__$Access_AttribAccess = {};
haxe_xml__$Access_AttribAccess.resolve = function(this1,name) {
	if(this1.nodeType == Xml.Document) {
		throw haxe_Exception.thrown("Cannot access document attribute " + name);
	}
	var v = this1.get(name);
	if(v == null) {
		if(this1.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this1.nodeType == null ? "null" : XmlType.toString(this1.nodeType)));
		}
		throw haxe_Exception.thrown(this1.nodeName + " is missing attribute " + name);
	}
	return v;
};
var haxe_xml__$Access_HasNodeAccess = {};
haxe_xml__$Access_HasNodeAccess.resolve = function(this1,name) {
	return this1.elementsNamed(name).hasNext();
};
var haxe_xml_XmlParserException = function(message,xml,position) {
	this.xml = xml;
	this.message = message;
	this.position = position;
	this.lineNumber = 1;
	this.positionAtLine = 0;
	var _g = 0;
	var _g1 = position;
	while(_g < _g1) {
		var i = _g++;
		var c = xml.charCodeAt(i);
		if(c == 10) {
			this.lineNumber++;
			this.positionAtLine = 0;
		} else if(c != 13) {
			this.positionAtLine++;
		}
	}
};
$hxClasses["haxe.xml.XmlParserException"] = haxe_xml_XmlParserException;
haxe_xml_XmlParserException.__name__ = "haxe.xml.XmlParserException";
haxe_xml_XmlParserException.prototype = {
	toString: function() {
		var c = js_Boot.getClass(this);
		return c.__name__ + ": " + this.message + " at line " + this.lineNumber + " char " + this.positionAtLine;
	}
	,__class__: haxe_xml_XmlParserException
};
var haxe_xml_Parser = function() { };
$hxClasses["haxe.xml.Parser"] = haxe_xml_Parser;
haxe_xml_Parser.__name__ = "haxe.xml.Parser";
haxe_xml_Parser.parse = function(str,strict) {
	if(strict == null) {
		strict = false;
	}
	var doc = Xml.createDocument();
	haxe_xml_Parser.doParse(str,strict,0,doc);
	return doc;
};
haxe_xml_Parser.doParse = function(str,strict,p,parent) {
	if(p == null) {
		p = 0;
	}
	var xml = null;
	var state = 1;
	var next = 1;
	var aname = null;
	var start = 0;
	var nsubs = 0;
	var nbrackets = 0;
	var buf = new StringBuf();
	var escapeNext = 1;
	var attrValQuote = -1;
	while(p < str.length) {
		var c = str.charCodeAt(p);
		switch(state) {
		case 0:
			switch(c) {
			case 9:case 10:case 13:case 32:
				break;
			default:
				state = next;
				continue;
			}
			break;
		case 1:
			if(c == 60) {
				state = 0;
				next = 2;
			} else {
				start = p;
				state = 13;
				continue;
			}
			break;
		case 2:
			switch(c) {
			case 33:
				if(str.charCodeAt(p + 1) == 91) {
					p += 2;
					if(HxOverrides.substr(str,p,6).toUpperCase() != "CDATA[") {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected <![CDATA[",str,p));
					}
					p += 5;
					state = 17;
					start = p + 1;
				} else if(str.charCodeAt(p + 1) == 68 || str.charCodeAt(p + 1) == 100) {
					if(HxOverrides.substr(str,p + 2,6).toUpperCase() != "OCTYPE") {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected <!DOCTYPE",str,p));
					}
					p += 8;
					state = 16;
					start = p + 1;
				} else if(str.charCodeAt(p + 1) != 45 || str.charCodeAt(p + 2) != 45) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected <!--",str,p));
				} else {
					p += 2;
					state = 15;
					start = p + 1;
				}
				break;
			case 47:
				if(parent == null) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected node name",str,p));
				}
				start = p + 1;
				state = 0;
				next = 10;
				break;
			case 63:
				state = 14;
				start = p;
				break;
			default:
				state = 3;
				start = p;
				continue;
			}
			break;
		case 3:
			if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45)) {
				if(p == start) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected node name",str,p));
				}
				xml = Xml.createElement(HxOverrides.substr(str,start,p - start));
				parent.addChild(xml);
				++nsubs;
				state = 0;
				next = 4;
				continue;
			}
			break;
		case 4:
			switch(c) {
			case 47:
				state = 11;
				break;
			case 62:
				state = 9;
				break;
			default:
				state = 5;
				start = p;
				continue;
			}
			break;
		case 5:
			if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45)) {
				if(start == p) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected attribute name",str,p));
				}
				var tmp = HxOverrides.substr(str,start,p - start);
				aname = tmp;
				if(xml.exists(aname)) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Duplicate attribute [" + aname + "]",str,p));
				}
				state = 0;
				next = 6;
				continue;
			}
			break;
		case 6:
			if(c == 61) {
				state = 0;
				next = 7;
			} else {
				throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected =",str,p));
			}
			break;
		case 7:
			switch(c) {
			case 34:case 39:
				buf = new StringBuf();
				state = 8;
				start = p + 1;
				attrValQuote = c;
				break;
			default:
				throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected \"",str,p));
			}
			break;
		case 8:
			switch(c) {
			case 38:
				var len = p - start;
				buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
				state = 18;
				escapeNext = 8;
				start = p + 1;
				break;
			case 60:case 62:
				if(strict) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Invalid unescaped " + String.fromCodePoint(c) + " in attribute value",str,p));
				} else if(c == attrValQuote) {
					var len1 = p - start;
					buf.b += len1 == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len1);
					var val = buf.b;
					buf = new StringBuf();
					xml.set(aname,val);
					state = 0;
					next = 4;
				}
				break;
			default:
				if(c == attrValQuote) {
					var len2 = p - start;
					buf.b += len2 == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len2);
					var val1 = buf.b;
					buf = new StringBuf();
					xml.set(aname,val1);
					state = 0;
					next = 4;
				}
			}
			break;
		case 9:
			p = haxe_xml_Parser.doParse(str,strict,p,xml);
			start = p;
			state = 1;
			break;
		case 10:
			if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45)) {
				if(start == p) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected node name",str,p));
				}
				var v = HxOverrides.substr(str,start,p - start);
				if(parent == null || parent.nodeType != 0) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Unexpected </" + v + ">, tag is not open",str,p));
				}
				if(parent.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (parent.nodeType == null ? "null" : XmlType.toString(parent.nodeType)));
				}
				if(v != parent.nodeName) {
					if(parent.nodeType != Xml.Element) {
						throw haxe_Exception.thrown("Bad node type, expected Element but found " + (parent.nodeType == null ? "null" : XmlType.toString(parent.nodeType)));
					}
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected </" + parent.nodeName + ">",str,p));
				}
				state = 0;
				next = 12;
				continue;
			}
			break;
		case 11:
			if(c == 62) {
				state = 1;
			} else {
				throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected >",str,p));
			}
			break;
		case 12:
			if(c == 62) {
				if(nsubs == 0) {
					parent.addChild(Xml.createPCData(""));
				}
				return p;
			} else {
				throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected >",str,p));
			}
			break;
		case 13:
			if(c == 60) {
				var len3 = p - start;
				buf.b += len3 == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len3);
				var child = Xml.createPCData(buf.b);
				buf = new StringBuf();
				parent.addChild(child);
				++nsubs;
				state = 0;
				next = 2;
			} else if(c == 38) {
				var len4 = p - start;
				buf.b += len4 == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len4);
				state = 18;
				escapeNext = 13;
				start = p + 1;
			}
			break;
		case 14:
			if(c == 63 && str.charCodeAt(p + 1) == 62) {
				++p;
				var str1 = HxOverrides.substr(str,start + 1,p - start - 2);
				parent.addChild(Xml.createProcessingInstruction(str1));
				++nsubs;
				state = 1;
			}
			break;
		case 15:
			if(c == 45 && str.charCodeAt(p + 1) == 45 && str.charCodeAt(p + 2) == 62) {
				parent.addChild(Xml.createComment(HxOverrides.substr(str,start,p - start)));
				++nsubs;
				p += 2;
				state = 1;
			}
			break;
		case 16:
			if(c == 91) {
				++nbrackets;
			} else if(c == 93) {
				--nbrackets;
			} else if(c == 62 && nbrackets == 0) {
				parent.addChild(Xml.createDocType(HxOverrides.substr(str,start,p - start)));
				++nsubs;
				state = 1;
			}
			break;
		case 17:
			if(c == 93 && str.charCodeAt(p + 1) == 93 && str.charCodeAt(p + 2) == 62) {
				var child1 = Xml.createCData(HxOverrides.substr(str,start,p - start));
				parent.addChild(child1);
				++nsubs;
				p += 2;
				state = 1;
			}
			break;
		case 18:
			if(c == 59) {
				var s = HxOverrides.substr(str,start,p - start);
				if(s.charCodeAt(0) == 35) {
					var c1 = s.charCodeAt(1) == 120 ? Std.parseInt("0" + HxOverrides.substr(s,1,s.length - 1)) : Std.parseInt(HxOverrides.substr(s,1,s.length - 1));
					buf.b += String.fromCodePoint(c1);
				} else if(!Object.prototype.hasOwnProperty.call(haxe_xml_Parser.escapes.h,s)) {
					if(strict) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Undefined entity: " + s,str,p));
					}
					buf.b += Std.string("&" + s + ";");
				} else {
					buf.b += Std.string(haxe_xml_Parser.escapes.h[s]);
				}
				start = p + 1;
				state = escapeNext;
			} else if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45) && c != 35) {
				if(strict) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Invalid character in entity: " + String.fromCodePoint(c),str,p));
				}
				buf.b += String.fromCodePoint(38);
				var len5 = p - start;
				buf.b += len5 == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len5);
				--p;
				start = p + 1;
				state = escapeNext;
			}
			break;
		}
		++p;
	}
	if(state == 1) {
		start = p;
		state = 13;
	}
	if(state == 13) {
		if(parent.nodeType == 0) {
			if(parent.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (parent.nodeType == null ? "null" : XmlType.toString(parent.nodeType)));
			}
			throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Unclosed node <" + parent.nodeName + ">",str,p));
		}
		if(p != start || nsubs == 0) {
			var len = p - start;
			buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
			parent.addChild(Xml.createPCData(buf.b));
			++nsubs;
		}
		return p;
	}
	if(!strict && state == 18 && escapeNext == 13) {
		buf.b += String.fromCodePoint(38);
		var len = p - start;
		buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
		parent.addChild(Xml.createPCData(buf.b));
		++nsubs;
		return p;
	}
	throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Unexpected end",str,p));
};
var haxe_xml_Printer = function(pretty) {
	this.output = new StringBuf();
	this.pretty = pretty;
};
$hxClasses["haxe.xml.Printer"] = haxe_xml_Printer;
haxe_xml_Printer.__name__ = "haxe.xml.Printer";
haxe_xml_Printer.print = function(xml,pretty) {
	if(pretty == null) {
		pretty = false;
	}
	var printer = new haxe_xml_Printer(pretty);
	printer.writeNode(xml,"");
	return printer.output.b;
};
haxe_xml_Printer.prototype = {
	writeNode: function(value,tabs) {
		switch(value.nodeType) {
		case 0:
			this.output.b += Std.string(tabs + "<");
			if(value.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string(value.nodeName);
			var attribute = value.attributes();
			while(attribute.hasNext()) {
				var attribute1 = attribute.next();
				this.output.b += Std.string(" " + attribute1 + "=\"");
				var input = StringTools.htmlEscape(value.get(attribute1),true);
				this.output.b += Std.string(input);
				this.output.b += "\"";
			}
			if(this.hasChildren(value)) {
				this.output.b += ">";
				if(this.pretty) {
					this.output.b += "\n";
				}
				if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
				}
				var _g_current = 0;
				var _g_array = value.children;
				while(_g_current < _g_array.length) {
					var child = _g_array[_g_current++];
					this.writeNode(child,this.pretty ? tabs + "\t" : tabs);
				}
				this.output.b += Std.string(tabs + "</");
				if(value.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
				}
				this.output.b += Std.string(value.nodeName);
				this.output.b += ">";
				if(this.pretty) {
					this.output.b += "\n";
				}
			} else {
				this.output.b += "/>";
				if(this.pretty) {
					this.output.b += "\n";
				}
			}
			break;
		case 1:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			var nodeValue = value.nodeValue;
			if(nodeValue.length != 0) {
				var input = tabs + StringTools.htmlEscape(nodeValue);
				this.output.b += Std.string(input);
				if(this.pretty) {
					this.output.b += "\n";
				}
			}
			break;
		case 2:
			this.output.b += Std.string(tabs + "<![CDATA[");
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string(value.nodeValue);
			this.output.b += "]]>";
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 3:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			var commentContent = value.nodeValue;
			var _this_r = new RegExp("[\n\r\t]+","g".split("u").join(""));
			commentContent = commentContent.replace(_this_r,"");
			commentContent = "<!--" + commentContent + "-->";
			this.output.b += tabs == null ? "null" : "" + tabs;
			var input = StringTools.trim(commentContent);
			this.output.b += Std.string(input);
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 4:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string("<!DOCTYPE " + value.nodeValue + ">");
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 5:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string("<?" + value.nodeValue + "?>");
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 6:
			if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			var _g_current = 0;
			var _g_array = value.children;
			while(_g_current < _g_array.length) {
				var child = _g_array[_g_current++];
				this.writeNode(child,tabs);
			}
			break;
		}
	}
	,hasChildren: function(value) {
		if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
		}
		var _g_current = 0;
		var _g_array = value.children;
		while(_g_current < _g_array.length) {
			var child = _g_array[_g_current++];
			switch(child.nodeType) {
			case 0:case 1:
				return true;
			case 2:case 3:
				if(child.nodeType == Xml.Document || child.nodeType == Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, unexpected " + (child.nodeType == null ? "null" : XmlType.toString(child.nodeType)));
				}
				if(StringTools.ltrim(child.nodeValue).length != 0) {
					return true;
				}
				break;
			default:
			}
		}
		return false;
	}
	,__class__: haxe_xml_Printer
};
var haxe_zip_Huffman = $hxEnums["haxe.zip.Huffman"] = { __ename__:true,__constructs__:null
	,Found: ($_=function(i) { return {_hx_index:0,i:i,__enum__:"haxe.zip.Huffman",toString:$estr}; },$_._hx_name="Found",$_.__params__ = ["i"],$_)
	,NeedBit: ($_=function(left,right) { return {_hx_index:1,left:left,right:right,__enum__:"haxe.zip.Huffman",toString:$estr}; },$_._hx_name="NeedBit",$_.__params__ = ["left","right"],$_)
	,NeedBits: ($_=function(n,table) { return {_hx_index:2,n:n,table:table,__enum__:"haxe.zip.Huffman",toString:$estr}; },$_._hx_name="NeedBits",$_.__params__ = ["n","table"],$_)
};
haxe_zip_Huffman.__constructs__ = [haxe_zip_Huffman.Found,haxe_zip_Huffman.NeedBit,haxe_zip_Huffman.NeedBits];
haxe_zip_Huffman.__empty_constructs__ = [];
var haxe_zip_HuffTools = function() {
};
$hxClasses["haxe.zip.HuffTools"] = haxe_zip_HuffTools;
haxe_zip_HuffTools.__name__ = "haxe.zip.HuffTools";
haxe_zip_HuffTools.prototype = {
	treeDepth: function(t) {
		switch(t._hx_index) {
		case 0:
			var _g = t.i;
			return 0;
		case 1:
			var a = t.left;
			var b = t.right;
			var da = this.treeDepth(a);
			var db = this.treeDepth(b);
			return 1 + (da < db ? da : db);
		case 2:
			var _g = t.n;
			var _g = t.table;
			throw haxe_Exception.thrown("assert");
		}
	}
	,treeCompress: function(t) {
		var d = this.treeDepth(t);
		if(d == 0) {
			return t;
		}
		if(d == 1) {
			if(t._hx_index == 1) {
				var a = t.left;
				var b = t.right;
				return haxe_zip_Huffman.NeedBit(this.treeCompress(a),this.treeCompress(b));
			} else {
				throw haxe_Exception.thrown("assert");
			}
		}
		var size = 1 << d;
		var table = [];
		var _g = 0;
		var _g1 = size;
		while(_g < _g1) {
			var i = _g++;
			table.push(haxe_zip_Huffman.Found(-1));
		}
		this.treeWalk(table,0,0,d,t);
		return haxe_zip_Huffman.NeedBits(d,table);
	}
	,treeWalk: function(table,p,cd,d,t) {
		if(t._hx_index == 1) {
			var a = t.left;
			var b = t.right;
			if(d > 0) {
				this.treeWalk(table,p,cd + 1,d - 1,a);
				this.treeWalk(table,p | 1 << cd,cd + 1,d - 1,b);
			} else {
				table[p] = this.treeCompress(t);
			}
		} else {
			table[p] = this.treeCompress(t);
		}
	}
	,treeMake: function(bits,maxbits,v,len) {
		if(len > maxbits) {
			throw haxe_Exception.thrown("Invalid huffman");
		}
		var idx = v << 5 | len;
		if(bits.h.hasOwnProperty(idx)) {
			return haxe_zip_Huffman.Found(bits.h[idx]);
		}
		v <<= 1;
		++len;
		return haxe_zip_Huffman.NeedBit(this.treeMake(bits,maxbits,v,len),this.treeMake(bits,maxbits,v | 1,len));
	}
	,make: function(lengths,pos,nlengths,maxbits) {
		if(nlengths == 1) {
			return haxe_zip_Huffman.NeedBit(haxe_zip_Huffman.Found(0),haxe_zip_Huffman.Found(0));
		}
		var counts = [];
		var tmp = [];
		if(maxbits > 32) {
			throw haxe_Exception.thrown("Invalid huffman");
		}
		var _g = 0;
		var _g1 = maxbits;
		while(_g < _g1) {
			var i = _g++;
			counts.push(0);
			tmp.push(0);
		}
		var _g = 0;
		var _g1 = nlengths;
		while(_g < _g1) {
			var i = _g++;
			var p = lengths[i + pos];
			if(p >= maxbits) {
				throw haxe_Exception.thrown("Invalid huffman");
			}
			counts[p]++;
		}
		var code = 0;
		var _g = 1;
		var _g1 = maxbits - 1;
		while(_g < _g1) {
			var i = _g++;
			code = code + counts[i] << 1;
			tmp[i] = code;
		}
		var bits = new haxe_ds_IntMap();
		var _g = 0;
		var _g1 = nlengths;
		while(_g < _g1) {
			var i = _g++;
			var l = lengths[i + pos];
			if(l != 0) {
				var n = tmp[l - 1];
				tmp[l - 1] = n + 1;
				bits.h[n << 5 | l] = i;
			}
		}
		return this.treeCompress(haxe_zip_Huffman.NeedBit(this.treeMake(bits,maxbits,0,1),this.treeMake(bits,maxbits,1,1)));
	}
	,__class__: haxe_zip_HuffTools
};
var haxe_zip__$InflateImpl_Window = function(hasCrc) {
	this.buffer = new haxe_io_Bytes(new ArrayBuffer(65536));
	this.pos = 0;
	if(hasCrc) {
		this.crc = new haxe_crypto_Adler32();
	}
};
$hxClasses["haxe.zip._InflateImpl.Window"] = haxe_zip__$InflateImpl_Window;
haxe_zip__$InflateImpl_Window.__name__ = "haxe.zip._InflateImpl.Window";
haxe_zip__$InflateImpl_Window.prototype = {
	slide: function() {
		if(this.crc != null) {
			this.crc.update(this.buffer,0,32768);
		}
		var b = new haxe_io_Bytes(new ArrayBuffer(65536));
		this.pos -= 32768;
		b.blit(0,this.buffer,32768,this.pos);
		this.buffer = b;
	}
	,addBytes: function(b,p,len) {
		if(this.pos + len > 65536) {
			this.slide();
		}
		this.buffer.blit(this.pos,b,p,len);
		this.pos += len;
	}
	,addByte: function(c) {
		if(this.pos == 65536) {
			this.slide();
		}
		this.buffer.b[this.pos] = c;
		this.pos++;
	}
	,getLastChar: function() {
		return this.buffer.b[this.pos - 1];
	}
	,available: function() {
		return this.pos;
	}
	,checksum: function() {
		if(this.crc != null) {
			this.crc.update(this.buffer,0,this.pos);
		}
		return this.crc;
	}
	,__class__: haxe_zip__$InflateImpl_Window
};
var haxe_zip__$InflateImpl_State = $hxEnums["haxe.zip._InflateImpl.State"] = { __ename__:true,__constructs__:null
	,Head: {_hx_name:"Head",_hx_index:0,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,Block: {_hx_name:"Block",_hx_index:1,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,CData: {_hx_name:"CData",_hx_index:2,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,Flat: {_hx_name:"Flat",_hx_index:3,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,Crc: {_hx_name:"Crc",_hx_index:4,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,Dist: {_hx_name:"Dist",_hx_index:5,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,DistOne: {_hx_name:"DistOne",_hx_index:6,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,Done: {_hx_name:"Done",_hx_index:7,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
};
haxe_zip__$InflateImpl_State.__constructs__ = [haxe_zip__$InflateImpl_State.Head,haxe_zip__$InflateImpl_State.Block,haxe_zip__$InflateImpl_State.CData,haxe_zip__$InflateImpl_State.Flat,haxe_zip__$InflateImpl_State.Crc,haxe_zip__$InflateImpl_State.Dist,haxe_zip__$InflateImpl_State.DistOne,haxe_zip__$InflateImpl_State.Done];
haxe_zip__$InflateImpl_State.__empty_constructs__ = [haxe_zip__$InflateImpl_State.Head,haxe_zip__$InflateImpl_State.Block,haxe_zip__$InflateImpl_State.CData,haxe_zip__$InflateImpl_State.Flat,haxe_zip__$InflateImpl_State.Crc,haxe_zip__$InflateImpl_State.Dist,haxe_zip__$InflateImpl_State.DistOne,haxe_zip__$InflateImpl_State.Done];
var haxe_zip_InflateImpl = function(i,header,crc) {
	if(crc == null) {
		crc = true;
	}
	if(header == null) {
		header = true;
	}
	this.isFinal = false;
	this.htools = new haxe_zip_HuffTools();
	this.huffman = this.buildFixedHuffman();
	this.huffdist = null;
	this.len = 0;
	this.dist = 0;
	this.state = header ? haxe_zip__$InflateImpl_State.Head : haxe_zip__$InflateImpl_State.Block;
	this.input = i;
	this.bits = 0;
	this.nbits = 0;
	this.needed = 0;
	this.output = null;
	this.outpos = 0;
	this.lengths = [];
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.window = new haxe_zip__$InflateImpl_Window(crc);
};
$hxClasses["haxe.zip.InflateImpl"] = haxe_zip_InflateImpl;
haxe_zip_InflateImpl.__name__ = "haxe.zip.InflateImpl";
haxe_zip_InflateImpl.run = function(i,bufsize) {
	if(bufsize == null) {
		bufsize = 65536;
	}
	var buf = new haxe_io_Bytes(new ArrayBuffer(bufsize));
	var output = new haxe_io_BytesBuffer();
	var inflate = new haxe_zip_InflateImpl(i);
	while(true) {
		var len = inflate.readBytes(buf,0,bufsize);
		output.addBytes(buf,0,len);
		if(len < bufsize) {
			break;
		}
	}
	return output.getBytes();
};
haxe_zip_InflateImpl.prototype = {
	buildFixedHuffman: function() {
		if(haxe_zip_InflateImpl.FIXED_HUFFMAN != null) {
			return haxe_zip_InflateImpl.FIXED_HUFFMAN;
		}
		var a = [];
		var _g = 0;
		while(_g < 288) {
			var n = _g++;
			a.push(n <= 143 ? 8 : n <= 255 ? 9 : n <= 279 ? 7 : 8);
		}
		haxe_zip_InflateImpl.FIXED_HUFFMAN = this.htools.make(a,0,288,10);
		return haxe_zip_InflateImpl.FIXED_HUFFMAN;
	}
	,readBytes: function(b,pos,len) {
		this.needed = len;
		this.outpos = pos;
		this.output = b;
		if(len > 0) {
			while(this.inflateLoop()) {
			}
		}
		return len - this.needed;
	}
	,getBits: function(n) {
		while(this.nbits < n) {
			this.bits |= this.input.readByte() << this.nbits;
			this.nbits += 8;
		}
		var b = this.bits & (1 << n) - 1;
		this.nbits -= n;
		this.bits >>= n;
		return b;
	}
	,getBit: function() {
		if(this.nbits == 0) {
			this.nbits = 8;
			this.bits = this.input.readByte();
		}
		var b = (this.bits & 1) == 1;
		this.nbits--;
		this.bits >>= 1;
		return b;
	}
	,getRevBits: function(n) {
		if(n == 0) {
			return 0;
		} else if(this.getBit()) {
			return 1 << n - 1 | this.getRevBits(n - 1);
		} else {
			return this.getRevBits(n - 1);
		}
	}
	,resetBits: function() {
		this.bits = 0;
		this.nbits = 0;
	}
	,addBytes: function(b,p,len) {
		this.window.addBytes(b,p,len);
		this.output.blit(this.outpos,b,p,len);
		this.needed -= len;
		this.outpos += len;
	}
	,addByte: function(b) {
		this.window.addByte(b);
		this.output.b[this.outpos] = b;
		this.needed--;
		this.outpos++;
	}
	,addDistOne: function(n) {
		var c = this.window.getLastChar();
		var _g = 0;
		var _g1 = n;
		while(_g < _g1) {
			var i = _g++;
			this.addByte(c);
		}
	}
	,addDist: function(d,len) {
		this.addBytes(this.window.buffer,this.window.pos - d,len);
	}
	,applyHuffman: function(h) {
		switch(h._hx_index) {
		case 0:
			var n = h.i;
			return n;
		case 1:
			var a = h.left;
			var b = h.right;
			return this.applyHuffman(this.getBit() ? b : a);
		case 2:
			var n = h.n;
			var tbl = h.table;
			return this.applyHuffman(tbl[this.getBits(n)]);
		}
	}
	,inflateLengths: function(a,max) {
		var i = 0;
		var prev = 0;
		while(i < max) {
			var n = this.applyHuffman(this.huffman);
			switch(n) {
			case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:case 11:case 12:case 13:case 14:case 15:
				prev = n;
				a[i] = n;
				++i;
				break;
			case 16:
				var end = i + 3 + this.getBits(2);
				if(end > max) {
					throw haxe_Exception.thrown("Invalid data");
				}
				while(i < end) {
					a[i] = prev;
					++i;
				}
				break;
			case 17:
				i += 3 + this.getBits(3);
				if(i > max) {
					throw haxe_Exception.thrown("Invalid data");
				}
				break;
			case 18:
				i += 11 + this.getBits(7);
				if(i > max) {
					throw haxe_Exception.thrown("Invalid data");
				}
				break;
			default:
				throw haxe_Exception.thrown("Invalid data");
			}
		}
	}
	,inflateLoop: function() {
		switch(this.state._hx_index) {
		case 0:
			var cmf = this.input.readByte();
			var cm = cmf & 15;
			var cinfo = cmf >> 4;
			if(cm != 8) {
				throw haxe_Exception.thrown("Invalid data");
			}
			var flg = this.input.readByte();
			var fdict = (flg & 32) != 0;
			if(((cmf << 8) + flg) % 31 != 0) {
				throw haxe_Exception.thrown("Invalid data");
			}
			if(fdict) {
				throw haxe_Exception.thrown("Unsupported dictionary");
			}
			this.state = haxe_zip__$InflateImpl_State.Block;
			return true;
		case 1:
			this.isFinal = this.getBit();
			switch(this.getBits(2)) {
			case 0:
				this.len = this.input.readUInt16();
				var nlen = this.input.readUInt16();
				if(nlen != 65535 - this.len) {
					throw haxe_Exception.thrown("Invalid data");
				}
				this.state = haxe_zip__$InflateImpl_State.Flat;
				var r = this.inflateLoop();
				this.resetBits();
				return r;
			case 1:
				this.huffman = this.buildFixedHuffman();
				this.huffdist = null;
				this.state = haxe_zip__$InflateImpl_State.CData;
				return true;
			case 2:
				var hlit = this.getBits(5) + 257;
				var hdist = this.getBits(5) + 1;
				var hclen = this.getBits(4) + 4;
				var _g = 0;
				var _g1 = hclen;
				while(_g < _g1) {
					var i = _g++;
					this.lengths[haxe_zip_InflateImpl.CODE_LENGTHS_POS[i]] = this.getBits(3);
				}
				var _g = hclen;
				var _g1 = 19;
				while(_g < _g1) {
					var i = _g++;
					this.lengths[haxe_zip_InflateImpl.CODE_LENGTHS_POS[i]] = 0;
				}
				this.huffman = this.htools.make(this.lengths,0,19,8);
				var lengths = [];
				var _g = 0;
				var _g1 = hlit + hdist;
				while(_g < _g1) {
					var i = _g++;
					lengths.push(0);
				}
				this.inflateLengths(lengths,hlit + hdist);
				this.huffdist = this.htools.make(lengths,hlit,hdist,16);
				this.huffman = this.htools.make(lengths,0,hlit,16);
				this.state = haxe_zip__$InflateImpl_State.CData;
				return true;
			default:
				throw haxe_Exception.thrown("Invalid data");
			}
			break;
		case 2:
			var n = this.applyHuffman(this.huffman);
			if(n < 256) {
				this.addByte(n);
				return this.needed > 0;
			} else if(n == 256) {
				this.state = this.isFinal ? haxe_zip__$InflateImpl_State.Crc : haxe_zip__$InflateImpl_State.Block;
				return true;
			} else {
				n -= 257;
				var extra_bits = haxe_zip_InflateImpl.LEN_EXTRA_BITS_TBL[n];
				if(extra_bits == -1) {
					throw haxe_Exception.thrown("Invalid data");
				}
				this.len = haxe_zip_InflateImpl.LEN_BASE_VAL_TBL[n] + this.getBits(extra_bits);
				var dist_code = this.huffdist == null ? this.getRevBits(5) : this.applyHuffman(this.huffdist);
				extra_bits = haxe_zip_InflateImpl.DIST_EXTRA_BITS_TBL[dist_code];
				if(extra_bits == -1) {
					throw haxe_Exception.thrown("Invalid data");
				}
				this.dist = haxe_zip_InflateImpl.DIST_BASE_VAL_TBL[dist_code] + this.getBits(extra_bits);
				if(this.dist > this.window.available()) {
					throw haxe_Exception.thrown("Invalid data");
				}
				this.state = this.dist == 1 ? haxe_zip__$InflateImpl_State.DistOne : haxe_zip__$InflateImpl_State.Dist;
				return true;
			}
			break;
		case 3:
			var rlen = this.len < this.needed ? this.len : this.needed;
			var bytes = this.input.read(rlen);
			this.len -= rlen;
			this.addBytes(bytes,0,rlen);
			if(this.len == 0) {
				this.state = this.isFinal ? haxe_zip__$InflateImpl_State.Crc : haxe_zip__$InflateImpl_State.Block;
			}
			return this.needed > 0;
		case 4:
			var calc = this.window.checksum();
			if(calc == null) {
				this.state = haxe_zip__$InflateImpl_State.Done;
				return true;
			}
			var crc = haxe_crypto_Adler32.read(this.input);
			if(!calc.equals(crc)) {
				throw haxe_Exception.thrown("Invalid CRC");
			}
			this.state = haxe_zip__$InflateImpl_State.Done;
			return true;
		case 5:
			while(this.len > 0 && this.needed > 0) {
				var rdist = this.len < this.dist ? this.len : this.dist;
				var rlen = this.needed < rdist ? this.needed : rdist;
				this.addDist(this.dist,rlen);
				this.len -= rlen;
			}
			if(this.len == 0) {
				this.state = haxe_zip__$InflateImpl_State.CData;
			}
			return this.needed > 0;
		case 6:
			var rlen = this.len < this.needed ? this.len : this.needed;
			this.addDistOne(rlen);
			this.len -= rlen;
			if(this.len == 0) {
				this.state = haxe_zip__$InflateImpl_State.CData;
			}
			return this.needed > 0;
		case 7:
			return false;
		}
	}
	,__class__: haxe_zip_InflateImpl
};
var haxe_zip_Uncompress = function() { };
$hxClasses["haxe.zip.Uncompress"] = haxe_zip_Uncompress;
haxe_zip_Uncompress.__name__ = "haxe.zip.Uncompress";
haxe_zip_Uncompress.run = function(src,bufsize) {
	return haxe_zip_InflateImpl.run(new haxe_io_BytesInput(src),bufsize);
};
var hxd_BitmapData = function(width,height) {
	if(!(width == -101 && height == -102)) {
		var canvas = window.document.createElement("canvas");
		canvas.width = width;
		canvas.height = height;
		this.ctx = canvas.getContext("2d",null);
	}
};
$hxClasses["hxd.BitmapData"] = hxd_BitmapData;
hxd_BitmapData.__name__ = "hxd.BitmapData";
hxd_BitmapData.prototype = {
	clear: function(color) {
		this.fill(0,0,this.ctx.canvas.width,this.ctx.canvas.height,color);
	}
	,fill: function(x,y,width,height,color) {
		this.ctx.fillStyle = "rgba(" + (color >> 16 & 255) + ", " + (color >> 8 & 255) + ", " + (color & 255) + ", " + (color >>> 24) / 255 + ")";
		this.ctx.fillRect(x,y,width,height);
	}
	,setPixel: function(x,y,c) {
		var i = this.lockImage;
		if(i != null) {
			var a = x + y * i.width << 2;
			i.data[a] = c >> 16 & 255;
			i.data[a | 1] = c >> 8 & 255;
			i.data[a | 2] = c & 255;
			i.data[a | 3] = c >>> 24 & 255;
			return;
		}
		var i = this.pixel;
		if(i == null) {
			i = this.ctx.createImageData(1,1);
			this.pixel = i;
		}
		i.data[0] = c >> 16 & 255;
		i.data[1] = c >> 8 & 255;
		i.data[2] = c & 255;
		i.data[3] = c >>> 24 & 255;
		this.ctx.putImageData(i,x,y);
	}
	,getPixels: function() {
		var w = this.ctx.canvas.width;
		var h = this.ctx.canvas.height;
		var data = this.ctx.getImageData(0,0,w,h).data;
		var pixels = data.buffer;
		return new hxd_Pixels(w,h,haxe_io_Bytes.ofData(pixels),hxd_PixelFormat.RGBA);
	}
	,__class__: hxd_BitmapData
};
var hxd_Charset = function() {
	var _gthis = this;
	this.map = new haxe_ds_IntMap();
	var _g = 0;
	while(_g < 94) {
		var i = _g++;
		_gthis.map.h[65281 + i] = 33 + i;
	}
	var _g = 192;
	var _g1 = 199;
	while(_g < _g1) {
		var i = _g++;
		_gthis.map.h[i] = 65;
	}
	var _g = 224;
	var _g1 = 231;
	while(_g < _g1) {
		var i = _g++;
		_gthis.map.h[i] = 97;
	}
	var _g = 200;
	var _g1 = 204;
	while(_g < _g1) {
		var i = _g++;
		_gthis.map.h[i] = 69;
	}
	var _g = 232;
	var _g1 = 236;
	while(_g < _g1) {
		var i = _g++;
		_gthis.map.h[i] = 101;
	}
	var _g = 204;
	var _g1 = 208;
	while(_g < _g1) {
		var i = _g++;
		_gthis.map.h[i] = 73;
	}
	var _g = 236;
	var _g1 = 240;
	while(_g < _g1) {
		var i = _g++;
		_gthis.map.h[i] = 105;
	}
	var _g = 210;
	var _g1 = 215;
	while(_g < _g1) {
		var i = _g++;
		_gthis.map.h[i] = 79;
	}
	var _g = 242;
	var _g1 = 247;
	while(_g < _g1) {
		var i = _g++;
		_gthis.map.h[i] = 111;
	}
	var _g = 217;
	var _g1 = 221;
	while(_g < _g1) {
		var i = _g++;
		_gthis.map.h[i] = 85;
	}
	var _g = 249;
	var _g1 = 253;
	while(_g < _g1) {
		var i = _g++;
		_gthis.map.h[i] = 117;
	}
	_gthis.map.h[199] = 67;
	_gthis.map.h[231] = 67;
	_gthis.map.h[208] = 68;
	_gthis.map.h[222] = 100;
	_gthis.map.h[209] = 78;
	_gthis.map.h[241] = 110;
	_gthis.map.h[221] = 89;
	_gthis.map.h[253] = 121;
	_gthis.map.h[255] = 121;
	_gthis.map.h[8364] = 69;
	_gthis.map.h[12288] = 32;
	_gthis.map.h[160] = 32;
	_gthis.map.h[171] = 34;
	_gthis.map.h[187] = 34;
	_gthis.map.h[8220] = 34;
	_gthis.map.h[8221] = 34;
	_gthis.map.h[8222] = 34;
	_gthis.map.h[8216] = 39;
	_gthis.map.h[8217] = 39;
	_gthis.map.h[180] = 39;
	_gthis.map.h[8216] = 39;
	_gthis.map.h[8249] = 60;
	_gthis.map.h[8250] = 62;
	_gthis.map.h[8211] = 45;
};
$hxClasses["hxd.Charset"] = hxd_Charset;
hxd_Charset.__name__ = "hxd.Charset";
hxd_Charset.getDefault = function() {
	if(hxd_Charset.inst == null) {
		hxd_Charset.inst = new hxd_Charset();
	}
	return hxd_Charset.inst;
};
hxd_Charset.prototype = {
	resolveChar: function(code,glyphs) {
		var c = code;
		while(c != null) {
			var g = glyphs.h[c];
			if(g != null) {
				return g;
			}
			c = this.map.h[c];
		}
		return null;
	}
	,isCJK: function(code) {
		if(!(code >= 11904 && code <= 42191 || code >= 63744 && code <= 64255)) {
			if(code >= 131072) {
				return code <= 262141;
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	,isSpace: function(code) {
		if(code != 32) {
			return code == 12288;
		} else {
			return true;
		}
	}
	,isBreakChar: function(code) {
		if(!this.isSpace(code)) {
			return this.isCJK(code);
		} else {
			return true;
		}
	}
	,isComplementChar: function(code) {
		return hxd_Charset.complementChars.h.hasOwnProperty(code);
	}
	,__class__: hxd_Charset
};
var hxd_Cursor = $hxEnums["hxd.Cursor"] = { __ename__:true,__constructs__:null
	,Default: {_hx_name:"Default",_hx_index:0,__enum__:"hxd.Cursor",toString:$estr}
	,Button: {_hx_name:"Button",_hx_index:1,__enum__:"hxd.Cursor",toString:$estr}
	,Move: {_hx_name:"Move",_hx_index:2,__enum__:"hxd.Cursor",toString:$estr}
	,TextInput: {_hx_name:"TextInput",_hx_index:3,__enum__:"hxd.Cursor",toString:$estr}
	,Hide: {_hx_name:"Hide",_hx_index:4,__enum__:"hxd.Cursor",toString:$estr}
	,Custom: ($_=function(custom) { return {_hx_index:5,custom:custom,__enum__:"hxd.Cursor",toString:$estr}; },$_._hx_name="Custom",$_.__params__ = ["custom"],$_)
	,Callback: ($_=function(f) { return {_hx_index:6,f:f,__enum__:"hxd.Cursor",toString:$estr}; },$_._hx_name="Callback",$_.__params__ = ["f"],$_)
};
hxd_Cursor.__constructs__ = [hxd_Cursor.Default,hxd_Cursor.Button,hxd_Cursor.Move,hxd_Cursor.TextInput,hxd_Cursor.Hide,hxd_Cursor.Custom,hxd_Cursor.Callback];
hxd_Cursor.__empty_constructs__ = [hxd_Cursor.Default,hxd_Cursor.Button,hxd_Cursor.Move,hxd_Cursor.TextInput,hxd_Cursor.Hide];
var hxd_CustomCursor = function(frames,speed,offsetX,offsetY) {
	this.frames = frames;
	this.speed = speed;
	this.offsetX = offsetX;
	this.offsetY = offsetY;
	this.frameDelay = 1 / speed;
	this.frameTime = 0;
	this.frameIndex = 0;
};
$hxClasses["hxd.CustomCursor"] = hxd_CustomCursor;
hxd_CustomCursor.__name__ = "hxd.CustomCursor";
hxd_CustomCursor.prototype = {
	reset: function() {
		this.frameTime = 0;
		this.frameIndex = 0;
	}
	,update: function(dt) {
		var newTime = this.frameTime + dt;
		var delay = this.frameDelay;
		var index = this.frameIndex;
		while(newTime >= delay) {
			newTime -= delay;
			++index;
		}
		this.frameTime = newTime;
		if(index >= this.frames.length) {
			index %= this.frames.length;
		}
		if(index != this.frameIndex) {
			this.frameIndex = index;
			return index;
		}
		return -1;
	}
	,__class__: hxd_CustomCursor
};
var hxd_EventKind = $hxEnums["hxd.EventKind"] = { __ename__:true,__constructs__:null
	,EPush: {_hx_name:"EPush",_hx_index:0,__enum__:"hxd.EventKind",toString:$estr}
	,ERelease: {_hx_name:"ERelease",_hx_index:1,__enum__:"hxd.EventKind",toString:$estr}
	,EMove: {_hx_name:"EMove",_hx_index:2,__enum__:"hxd.EventKind",toString:$estr}
	,EOver: {_hx_name:"EOver",_hx_index:3,__enum__:"hxd.EventKind",toString:$estr}
	,EOut: {_hx_name:"EOut",_hx_index:4,__enum__:"hxd.EventKind",toString:$estr}
	,EWheel: {_hx_name:"EWheel",_hx_index:5,__enum__:"hxd.EventKind",toString:$estr}
	,EFocus: {_hx_name:"EFocus",_hx_index:6,__enum__:"hxd.EventKind",toString:$estr}
	,EFocusLost: {_hx_name:"EFocusLost",_hx_index:7,__enum__:"hxd.EventKind",toString:$estr}
	,EKeyDown: {_hx_name:"EKeyDown",_hx_index:8,__enum__:"hxd.EventKind",toString:$estr}
	,EKeyUp: {_hx_name:"EKeyUp",_hx_index:9,__enum__:"hxd.EventKind",toString:$estr}
	,EReleaseOutside: {_hx_name:"EReleaseOutside",_hx_index:10,__enum__:"hxd.EventKind",toString:$estr}
	,ETextInput: {_hx_name:"ETextInput",_hx_index:11,__enum__:"hxd.EventKind",toString:$estr}
	,ECheck: {_hx_name:"ECheck",_hx_index:12,__enum__:"hxd.EventKind",toString:$estr}
};
hxd_EventKind.__constructs__ = [hxd_EventKind.EPush,hxd_EventKind.ERelease,hxd_EventKind.EMove,hxd_EventKind.EOver,hxd_EventKind.EOut,hxd_EventKind.EWheel,hxd_EventKind.EFocus,hxd_EventKind.EFocusLost,hxd_EventKind.EKeyDown,hxd_EventKind.EKeyUp,hxd_EventKind.EReleaseOutside,hxd_EventKind.ETextInput,hxd_EventKind.ECheck];
hxd_EventKind.__empty_constructs__ = [hxd_EventKind.EPush,hxd_EventKind.ERelease,hxd_EventKind.EMove,hxd_EventKind.EOver,hxd_EventKind.EOut,hxd_EventKind.EWheel,hxd_EventKind.EFocus,hxd_EventKind.EFocusLost,hxd_EventKind.EKeyDown,hxd_EventKind.EKeyUp,hxd_EventKind.EReleaseOutside,hxd_EventKind.ETextInput,hxd_EventKind.ECheck];
var hxd_Event = function(k,x,y) {
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.button = 0;
	this.kind = k;
	this.relX = x;
	this.relY = y;
};
$hxClasses["hxd.Event"] = hxd_Event;
hxd_Event.__name__ = "hxd.Event";
hxd_Event.prototype = {
	__class__: hxd_Event
};
var hxd__$FloatBuffer_Float32Expand = {};
hxd__$FloatBuffer_Float32Expand._new = function(length) {
	var this1 = { pos : length, array : new Float32Array(new ArrayBuffer(length << 2))};
	return this1;
};
var hxd_Key = function() { };
$hxClasses["hxd.Key"] = hxd_Key;
hxd_Key.__name__ = "hxd.Key";
hxd_Key.isDown = function(code) {
	return hxd_Key.keyPressed[code] > 0;
};
hxd_Key.isPressed = function(code) {
	return hxd_Key.keyPressed[code] == hxd_Timer.frameCount + 2 - 1;
};
hxd_Key.initialize = function() {
	if(hxd_Key.initDone) {
		hxd_Key.dispose();
	}
	hxd_Key.initDone = true;
	hxd_Key.keyPressed = [];
	hxd_Window.getInstance().addEventTarget(hxd_Key.onEvent);
};
hxd_Key.dispose = function() {
	if(hxd_Key.initDone) {
		hxd_Window.getInstance().removeEventTarget(hxd_Key.onEvent);
		hxd_Key.initDone = false;
		hxd_Key.keyPressed = [];
	}
};
hxd_Key.onEvent = function(e) {
	switch(e.kind._hx_index) {
	case 0:
		if(e.button < 5) {
			hxd_Key.keyPressed[e.button] = hxd_Timer.frameCount + 2;
		}
		break;
	case 1:
		if(e.button < 5) {
			hxd_Key.keyPressed[e.button] = -(hxd_Timer.frameCount + 2);
		}
		break;
	case 5:
		hxd_Key.keyPressed[e.wheelDelta > 0 ? 6 : 5] = hxd_Timer.frameCount + 2;
		break;
	case 8:
		if(!hxd_Key.ALLOW_KEY_REPEAT && hxd_Key.keyPressed[e.keyCode] > 0) {
			return;
		}
		hxd_Key.keyPressed[e.keyCode] = hxd_Timer.frameCount + 2;
		break;
	case 9:
		hxd_Key.keyPressed[e.keyCode] = -(hxd_Timer.frameCount + 2);
		break;
	case 10:
		hxd_Key.keyPressed = [];
		break;
	default:
	}
};
var hxd_Flags = $hxEnums["hxd.Flags"] = { __ename__:true,__constructs__:null
	,ReadOnly: {_hx_name:"ReadOnly",_hx_index:0,__enum__:"hxd.Flags",toString:$estr}
	,AlphaPremultiplied: {_hx_name:"AlphaPremultiplied",_hx_index:1,__enum__:"hxd.Flags",toString:$estr}
	,FlipY: {_hx_name:"FlipY",_hx_index:2,__enum__:"hxd.Flags",toString:$estr}
};
hxd_Flags.__constructs__ = [hxd_Flags.ReadOnly,hxd_Flags.AlphaPremultiplied,hxd_Flags.FlipY];
hxd_Flags.__empty_constructs__ = [hxd_Flags.ReadOnly,hxd_Flags.AlphaPremultiplied,hxd_Flags.FlipY];
var hxd_PixelsARGB = {};
hxd_PixelsARGB.fromPixels = function(p) {
	p.convert(hxd_PixelFormat.ARGB);
	p.setFlip(false);
	return p;
};
var hxd_Pixels = function(width,height,bytes,format,offset) {
	if(offset == null) {
		offset = 0;
	}
	this.width = width;
	this.height = height;
	this.bytes = bytes;
	this.set_innerFormat(format);
	this.offset = offset;
	var i = 0;
	if(i == null) {
		i = 0;
	}
	var this1 = i;
	this.flags = this1;
};
$hxClasses["hxd.Pixels"] = hxd_Pixels;
hxd_Pixels.__name__ = "hxd.Pixels";
hxd_Pixels.calcDataSize = function(width,height,format) {
	if(format._hx_index == 21) {
		var _g = format.v;
		return (height + 3 >> 2 << 2) * hxd_Pixels.calcStride(width,format);
	} else {
		return height * hxd_Pixels.calcStride(width,format);
	}
};
hxd_Pixels.calcStride = function(width,format) {
	var tmp;
	switch(format._hx_index) {
	case 3:case 20:
		tmp = 8;
		break;
	case 4:
		tmp = 16;
		break;
	case 5:
		tmp = 1;
		break;
	case 7:
		tmp = 4;
		break;
	case 8:
		tmp = 2;
		break;
	case 9:
		tmp = 4;
		break;
	case 10:
		tmp = 8;
		break;
	case 11:
		tmp = 3;
		break;
	case 12:case 19:
		tmp = 6;
		break;
	case 13:
		tmp = 12;
		break;
	case 0:case 1:case 2:case 14:case 15:
		tmp = 4;
		break;
	case 16:
		tmp = 4;
		break;
	case 17:
		tmp = 4;
		break;
	case 6:case 18:
		tmp = 2;
		break;
	case 21:
		var n = format.v;
		var blocks = width + 3 >> 2;
		if(n == 1 || n == 4) {
			return blocks << 1;
		}
		return blocks << 2;
	}
	return width * tmp;
};
hxd_Pixels.alloc = function(width,height,format) {
	return new hxd_Pixels(width,height,new haxe_io_Bytes(new ArrayBuffer(hxd_Pixels.calcDataSize(width,height,format))),format);
};
hxd_Pixels.prototype = {
	set_innerFormat: function(fmt) {
		this.innerFormat = fmt;
		this.stride = hxd_Pixels.calcStride(this.width,fmt);
		this.dataSize = hxd_Pixels.calcDataSize(this.width,this.height,fmt);
		this.bytesPerPixel = hxd_Pixels.calcStride(1,fmt);
		return fmt;
	}
	,invalidFormat: function() {
		throw haxe_Exception.thrown("Unsupported format for this operation : " + Std.string(this.innerFormat));
	}
	,copyInner: function() {
		var old = this.bytes;
		this.bytes = new haxe_io_Bytes(new ArrayBuffer(this.dataSize));
		this.bytes.blit(0,old,this.offset,this.dataSize);
		this.offset = 0;
		this.flags &= -1 - (1 << hxd_Flags.ReadOnly._hx_index);
	}
	,setFlip: function(b) {
		if(b == null) {
			b = false;
		}
		if((this.flags & 1 << hxd_Flags.FlipY._hx_index) != 0 == b) {
			return;
		}
		if((this.flags & 1 << hxd_Flags.ReadOnly._hx_index) != 0) {
			this.copyInner();
		}
		if(b) {
			this.flags |= 1 << hxd_Flags.FlipY._hx_index;
		} else {
			this.flags &= -1 - (1 << hxd_Flags.FlipY._hx_index);
		}
		if(this.stride % 4 != 0) {
			this.invalidFormat();
		}
		var _g = 0;
		var _g1 = this.height >> 1;
		while(_g < _g1) {
			var y = _g++;
			var p1 = y * this.stride + this.offset;
			var p2 = (this.height - 1 - y) * this.stride + this.offset;
			var _g2 = 0;
			var _g3 = this.stride >> 2;
			while(_g2 < _g3) {
				var x = _g2++;
				var a = this.bytes.getInt32(p1);
				var b = this.bytes.getInt32(p2);
				this.bytes.setInt32(p1,b);
				this.bytes.setInt32(p2,a);
				p1 += 4;
				p2 += 4;
			}
		}
	}
	,convert: function(target) {
		if(this.innerFormat == target || Type.enumEq(this.innerFormat,target)) {
			return;
		}
		if((this.flags & 1 << hxd_Flags.ReadOnly._hx_index) != 0) {
			this.copyInner();
		}
		var this1 = this.bytes.b;
		var bytes = this1;
		var _g = this.innerFormat;
		switch(_g._hx_index) {
		case 0:
			switch(target._hx_index) {
			case 1:
				var _g1 = 0;
				var _g2 = this.width * this.height;
				while(_g1 < _g2) {
					var i = _g1++;
					var p = (i << 2) + this.offset;
					var a = bytes[p];
					var r = bytes[p + 1];
					var g = bytes[p + 2];
					var b = bytes[p + 3];
					bytes[p++] = b;
					bytes[p++] = g;
					bytes[p++] = r;
					bytes[p] = a;
				}
				break;
			case 2:
				var _g1 = 0;
				var _g2 = this.width * this.height;
				while(_g1 < _g2) {
					var i = _g1++;
					var p = (i << 2) + this.offset;
					var a = bytes[p];
					var v = bytes[p + 1];
					bytes[p] = v;
					var v1 = bytes[p + 2];
					bytes[p + 1] = v1;
					var v2 = bytes[p + 3];
					bytes[p + 2] = v2;
					bytes[p + 3] = a;
				}
				break;
			default:
				throw haxe_Exception.thrown("Cannot convert from " + Std.string(this.innerFormat) + " to " + Std.string(target));
			}
			break;
		case 1:
			switch(target._hx_index) {
			case 0:
				var _g1 = 0;
				var _g2 = this.width * this.height;
				while(_g1 < _g2) {
					var i = _g1++;
					var p = (i << 2) + this.offset;
					var a = bytes[p];
					var r = bytes[p + 1];
					var g = bytes[p + 2];
					var b = bytes[p + 3];
					bytes[p++] = b;
					bytes[p++] = g;
					bytes[p++] = r;
					bytes[p] = a;
				}
				break;
			case 2:
				var _g1 = 0;
				var _g2 = this.width * this.height;
				while(_g1 < _g2) {
					var i = _g1++;
					var p = (i << 2) + this.offset;
					var b = bytes[p];
					var r = bytes[p + 2];
					bytes[p] = r;
					bytes[p + 2] = b;
				}
				break;
			default:
				throw haxe_Exception.thrown("Cannot convert from " + Std.string(this.innerFormat) + " to " + Std.string(target));
			}
			break;
		case 2:
			switch(target._hx_index) {
			case 0:
				var _g1 = 0;
				var _g2 = this.width * this.height;
				while(_g1 < _g2) {
					var i = _g1++;
					var p = (i << 2) + this.offset;
					var a = bytes[p + 3];
					var v = bytes[p + 2];
					bytes[p + 3] = v;
					var v1 = bytes[p + 1];
					bytes[p + 2] = v1;
					var v2 = bytes[p];
					bytes[p + 1] = v2;
					bytes[p] = a;
				}
				break;
			case 1:
				var _g1 = 0;
				var _g2 = this.width * this.height;
				while(_g1 < _g2) {
					var i = _g1++;
					var p = (i << 2) + this.offset;
					var b = bytes[p];
					var r = bytes[p + 2];
					bytes[p] = r;
					bytes[p + 2] = b;
				}
				break;
			case 5:
				var nbytes = new haxe_io_Bytes(new ArrayBuffer(this.width * this.height));
				var this1 = nbytes.b;
				var out = this1;
				var _g1 = 0;
				var _g2 = this.width * this.height;
				while(_g1 < _g2) {
					var i = _g1++;
					var v = bytes[i << 2];
					out[i] = v;
				}
				this.bytes = nbytes;
				break;
			default:
				throw haxe_Exception.thrown("Cannot convert from " + Std.string(this.innerFormat) + " to " + Std.string(target));
			}
			break;
		case 4:
			if(target._hx_index == 7) {
				var nbytes = new haxe_io_Bytes(new ArrayBuffer(this.height * this.width * 4));
				var this1 = nbytes.b;
				var out = this1;
				var _g1 = 0;
				var _g2 = this.width * this.height;
				while(_g1 < _g2) {
					var i = _g1++;
					nbytes.setFloat(i << 2,this.bytes.getFloat(i << 4));
				}
				this.bytes = nbytes;
			} else {
				throw haxe_Exception.thrown("Cannot convert from " + Std.string(this.innerFormat) + " to " + Std.string(target));
			}
			break;
		case 7:
			switch(target._hx_index) {
			case 1:case 2:
				var fbytes = this.bytes;
				var p = 0;
				var _g1 = 0;
				var _g2 = this.width * this.height;
				while(_g1 < _g2) {
					var i = _g1++;
					var v = fbytes.getFloat(p) * 255 | 0;
					if(v < 0) {
						v = 0;
					} else if(v > 255) {
						v = 255;
					}
					bytes[p++] = v;
					bytes[p++] = v;
					bytes[p++] = v;
					bytes[p++] = 255;
				}
				break;
			default:
				throw haxe_Exception.thrown("Cannot convert from " + Std.string(this.innerFormat) + " to " + Std.string(target));
			}
			break;
		case 18:
			if(target._hx_index == 7) {
				var nbytes = new haxe_io_Bytes(new ArrayBuffer(this.width * this.height * 4));
				var fbytes = this.bytes;
				var _g1 = 0;
				var _g2 = this.width * this.height;
				while(_g1 < _g2) {
					var i = _g1++;
					var nv = fbytes.getUInt16(i << 1);
					nbytes.setFloat(i << 2,nv / 65535.0);
				}
				this.bytes = nbytes;
			} else {
				throw haxe_Exception.thrown("Cannot convert from " + Std.string(this.innerFormat) + " to " + Std.string(target));
			}
			break;
		case 21:
			if(target._hx_index == 21) {
				var b = target.v;
				var a = _g.v;
				if(a != b) {
					throw haxe_Exception.thrown("Cannot convert from " + Std.string(this.innerFormat) + " to " + Std.string(target));
				}
			} else {
				throw haxe_Exception.thrown("Cannot convert from " + Std.string(this.innerFormat) + " to " + Std.string(target));
			}
			break;
		default:
			throw haxe_Exception.thrown("Cannot convert from " + Std.string(this.innerFormat) + " to " + Std.string(target));
		}
		this.set_innerFormat(target);
	}
	,dispose: function() {
		this.bytes = null;
	}
	,toString: function() {
		return "Pixels(" + this.width + "x" + this.height + " " + Std.string(this.innerFormat) + ")";
	}
	,__class__: hxd_Pixels
};
var hxd_SceneEvents = function($window) {
	this.defaultCursor = hxd_Cursor.Default;
	this.mouseCheckMove = true;
	this.enablePhysicalMouse = true;
	this.isOut = false;
	this.onOver = new hxd_Event(hxd_EventKind.EOver);
	this.onOut = new hxd_Event(hxd_EventKind.EOut);
	this.checkPos = new hxd_Event(hxd_EventKind.ECheck);
	this.focusLost = new hxd_Event(hxd_EventKind.EFocusLost);
	this.lastTouch = 0;
	this.mouseY = -1.;
	this.mouseX = -1.;
	this.overIndex = -1;
	this.scenes = [];
	this.pendingEvents = [];
	this.pushList = [];
	this.overList = [];
	this.overCandidates = [];
	if($window == null) {
		$window = hxd_Window.getInstance();
	}
	this.window = $window;
	$window.addEventTarget($bind(this,this.onEvent));
};
$hxClasses["hxd.SceneEvents"] = hxd_SceneEvents;
hxd_SceneEvents.__name__ = "hxd.SceneEvents";
hxd_SceneEvents.prototype = {
	onRemove: function(i) {
		if(i == this.currentFocus) {
			this.currentFocus = null;
		}
		if(this.overIndex >= 0) {
			var index = this.overList.indexOf(i);
			if(index >= 0) {
				HxOverrides.remove(this.overList,i);
				if(index < this.overIndex) {
					this.overIndex--;
				}
			}
		} else {
			HxOverrides.remove(this.overList,i);
			this.selectCursor();
		}
		HxOverrides.remove(this.pushList,i);
	}
	,addScene: function(s,index) {
		s.setEvents(this);
		if(index == null) {
			this.scenes.push(s);
		} else {
			this.scenes.splice(index,0,s);
		}
	}
	,blur: function() {
		if(this.currentFocus == null) {
			return;
		}
		this.focusLost.cancel = false;
		this.currentFocus.handleEvent(this.focusLost);
		if(!this.focusLost.cancel) {
			this.currentFocus = null;
		}
	}
	,checkFocus: function() {
		if(this.currentFocus == null) {
			return;
		}
		var s = this.currentFocus.getInteractiveScene();
		if(s == null) {
			this.currentFocus = null;
			return;
		}
		if(!s.isInteractiveVisible(this.currentFocus)) {
			this.blur();
		}
	}
	,emitEvent: function(event) {
		var oldX = event.relX;
		var oldY = event.relY;
		var overCandidateCount = 0;
		var handled = false;
		var checkOver = false;
		var fillOver = false;
		var checkPush = false;
		var cancelFocus = false;
		var updateCursor = false;
		this.overIndex = 0;
		switch(event.kind._hx_index) {
		case 0:
			cancelFocus = true;
			checkPush = true;
			break;
		case 1:
			checkPush = true;
			break;
		case 2:case 12:
			checkOver = true;
			fillOver = true;
			break;
		case 5:case 8:case 9:case 11:
			if(this.currentFocus != null) {
				event.relX = event.relY = 0;
				this.currentFocus.handleEvent(event);
				event.relX = oldX;
				event.relY = oldY;
				if(!event.propagate) {
					return;
				}
			}
			break;
		default:
		}
		var _g = 0;
		var _g1 = this.scenes;
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			var last = null;
			while(true) {
				var i = s.handleEvent(event,last);
				if(i == null) {
					event.relX = oldX;
					event.relY = oldY;
					break;
				}
				if(checkOver) {
					if(fillOver) {
						var idx = this.overList.indexOf(i);
						if(idx == -1) {
							if(this.overCandidates.length == overCandidateCount) {
								this.overCandidates[overCandidateCount] = { i : i, s : s, x : event.relX, y : event.relY, z : event.relZ};
							} else {
								var info = this.overCandidates[overCandidateCount];
								info.i = i;
								info.s = s;
								info.x = event.relX;
								info.y = event.relY;
								info.z = event.relZ;
							}
							++overCandidateCount;
							this.overList.splice(this.overIndex++,0,i);
							updateCursor = true;
						} else {
							if(idx < this.overIndex) {
								while(true) {
									this.overList[idx] = this.overList[idx + 1];
									++idx;
									if(!(idx < this.overIndex)) {
										break;
									}
								}
								this.overList[this.overIndex] = i;
								updateCursor = true;
							} else if(idx > this.overIndex) {
								while(true) {
									this.overList[idx] = this.overList[idx - 1];
									--idx;
									if(!(idx > this.overIndex)) {
										break;
									}
								}
								this.overList[this.overIndex] = i;
								updateCursor = true;
							}
							this.overIndex++;
						}
						fillOver = event.propagate;
					}
				} else {
					if(checkPush) {
						if(event.kind == hxd_EventKind.EPush) {
							this.pushList.push(i);
						} else {
							HxOverrides.remove(this.pushList,i);
						}
					}
					if(cancelFocus && i == this.currentFocus) {
						cancelFocus = false;
					}
				}
				event.relX = oldX;
				event.relY = oldY;
				if(!event.propagate) {
					handled = true;
					break;
				}
				last = i;
				event.propagate = false;
			}
			if(handled) {
				break;
			}
		}
		if(cancelFocus && this.currentFocus != null) {
			this.blur();
		}
		if(checkOver) {
			if(this.overIndex < this.overList.length) {
				while(this.overIndex < this.overList.length) {
					var e = this.overList.pop();
					e.handleEvent(this.onOut);
				}
				updateCursor = true;
			}
			if(overCandidateCount != 0) {
				var i = 0;
				var ev = this.onOver;
				while(true) {
					var info = this.overCandidates[i++];
					ev.relX = info.x;
					ev.relY = info.y;
					ev.relZ = info.z;
					if(info.s.isInteractiveVisible(info.i)) {
						info.i.handleEvent(ev);
					} else {
						HxOverrides.remove(this.overList,info.i);
					}
					info.i = null;
					info.s = null;
					if(!(i < overCandidateCount)) {
						break;
					}
				}
			}
		}
		this.overIndex = -1;
		if(updateCursor) {
			this.selectCursor();
		}
		if(!handled && event != this.checkPos) {
			if(event.kind == hxd_EventKind.EPush) {
				this.pushList.push(null);
			} else if(event.kind == hxd_EventKind.ERelease) {
				HxOverrides.remove(this.pushList,null);
			}
			this.dispatchListeners(event);
		}
		if(event.kind == hxd_EventKind.ERelease && this.pushList.length > 0) {
			var _g = 0;
			var _g1 = this.pushList;
			while(_g < _g1.length) {
				var i = _g1[_g];
				++_g;
				if(i == null) {
					event.kind = hxd_EventKind.EReleaseOutside;
					this.dispatchListeners(event);
					event.kind = hxd_EventKind.ERelease;
				} else {
					var s = i.getInteractiveScene();
					if(s == null) {
						continue;
					}
					event.kind = hxd_EventKind.EReleaseOutside;
					s.dispatchEvent(event,i);
					event.kind = hxd_EventKind.ERelease;
					event.relX = oldX;
					event.relY = oldY;
				}
			}
			this.pushList = [];
		}
	}
	,checkEvents: function() {
		var old = this.pendingEvents;
		var checkMoved = !this.mouseCheckMove;
		var checkFocused = this.currentFocus == null;
		if(old.length > 0) {
			this.pendingEvents = [];
			var _g = 0;
			while(_g < old.length) {
				var e = old[_g];
				++_g;
				var ox = e.relX;
				var oy = e.relY;
				switch(e.kind._hx_index) {
				case 0:case 1:
					this.mouseX = e.relX;
					this.mouseY = e.relY;
					this.lastTouch = e.touchId;
					break;
				case 2:
					checkMoved = true;
					this.mouseX = e.relX;
					this.mouseY = e.relY;
					this.lastTouch = e.touchId;
					break;
				case 3:
					this.isOut = false;
					this.selectCursor();
					continue;
				case 4:
					this.isOut = true;
					if(this.overList.length > 0) {
						var i = this.overList.length - 1;
						while(i >= 0) {
							this.onOut.cancel = false;
							this.overList[i].handleEvent(this.onOut);
							HxOverrides.remove(this.overList,this.overList[i]);
							--i;
						}
						this.selectCursor();
					}
					continue;
				case 5:case 8:case 9:case 11:
					if(!checkFocused) {
						checkFocused = true;
						this.checkFocus();
					}
					break;
				default:
				}
				if(this.currentDrag != null && (this.currentDrag.ref == null || this.currentDrag.ref == e.touchId)) {
					e.propagate = true;
					e.cancel = false;
					this.currentDrag.f(e);
					e.relX = ox;
					e.relY = oy;
					if(!e.propagate) {
						continue;
					}
				}
				this.emitEvent(e);
			}
		}
		if(!checkFocused) {
			this.checkFocus();
		}
		if(!checkMoved && !this.isOut && this.currentDrag == null) {
			this.checkPos.relX = this.mouseX;
			this.checkPos.relY = this.mouseY;
			this.checkPos.touchId = this.lastTouch;
			this.checkPos.cancel = false;
			this.checkPos.propagate = false;
			this.emitEvent(this.checkPos);
		}
	}
	,updateCursor: function(i) {
		if(this.overList.indexOf(i) != -1) {
			this.selectCursor();
		}
	}
	,selectCursor: function() {
		var cur = this.defaultCursor;
		var _g = 0;
		var _g1 = this.overList;
		while(_g < _g1.length) {
			var o = _g1[_g];
			++_g;
			if(o.cursor != null) {
				cur = o.cursor;
				break;
			}
		}
		if(cur._hx_index == 6) {
			var f = cur.f;
			f();
		} else {
			hxd_System.setCursor(cur);
		}
	}
	,onEvent: function(e) {
		if(!this.enablePhysicalMouse && e.kind == hxd_EventKind.EMove) {
			return;
		}
		this.pendingEvents.push(e);
	}
	,dispatchListeners: function(event) {
		var ox = event.relX;
		var oy = event.relY;
		event.propagate = true;
		var _g = 0;
		var _g1 = this.scenes;
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			event.cancel = false;
			s.dispatchListeners(event);
			event.relX = ox;
			event.relY = oy;
			if(!event.propagate) {
				break;
			}
		}
	}
	,__class__: hxd_SceneEvents
};
var hxd_Platform = $hxEnums["hxd.Platform"] = { __ename__:true,__constructs__:null
	,IOS: {_hx_name:"IOS",_hx_index:0,__enum__:"hxd.Platform",toString:$estr}
	,Android: {_hx_name:"Android",_hx_index:1,__enum__:"hxd.Platform",toString:$estr}
	,WebGL: {_hx_name:"WebGL",_hx_index:2,__enum__:"hxd.Platform",toString:$estr}
	,PC: {_hx_name:"PC",_hx_index:3,__enum__:"hxd.Platform",toString:$estr}
	,Console: {_hx_name:"Console",_hx_index:4,__enum__:"hxd.Platform",toString:$estr}
	,FlashPlayer: {_hx_name:"FlashPlayer",_hx_index:5,__enum__:"hxd.Platform",toString:$estr}
};
hxd_Platform.__constructs__ = [hxd_Platform.IOS,hxd_Platform.Android,hxd_Platform.WebGL,hxd_Platform.PC,hxd_Platform.Console,hxd_Platform.FlashPlayer];
hxd_Platform.__empty_constructs__ = [hxd_Platform.IOS,hxd_Platform.Android,hxd_Platform.WebGL,hxd_Platform.PC,hxd_Platform.Console,hxd_Platform.FlashPlayer];
var hxd_SystemValue = $hxEnums["hxd.SystemValue"] = { __ename__:true,__constructs__:null
	,IsTouch: {_hx_name:"IsTouch",_hx_index:0,__enum__:"hxd.SystemValue",toString:$estr}
	,IsWindowed: {_hx_name:"IsWindowed",_hx_index:1,__enum__:"hxd.SystemValue",toString:$estr}
	,IsMobile: {_hx_name:"IsMobile",_hx_index:2,__enum__:"hxd.SystemValue",toString:$estr}
};
hxd_SystemValue.__constructs__ = [hxd_SystemValue.IsTouch,hxd_SystemValue.IsWindowed,hxd_SystemValue.IsMobile];
hxd_SystemValue.__empty_constructs__ = [hxd_SystemValue.IsTouch,hxd_SystemValue.IsWindowed,hxd_SystemValue.IsMobile];
var hxd_Timer = function() { };
$hxClasses["hxd.Timer"] = hxd_Timer;
hxd_Timer.__name__ = "hxd.Timer";
hxd_Timer.update = function() {
	hxd_Timer.frameCount++;
	var newTime = HxOverrides.now() / 1000;
	hxd_Timer.elapsedTime = newTime - hxd_Timer.lastTimeStamp;
	hxd_Timer.lastTimeStamp = newTime;
	if(hxd_Timer.elapsedTime < hxd_Timer.maxDeltaTime) {
		var a = hxd_Timer.elapsedTime;
		hxd_Timer.currentDT = a + hxd_Timer.smoothFactor * (hxd_Timer.currentDT - a);
	} else {
		hxd_Timer.elapsedTime = 1 / hxd_Timer.wantedFPS;
	}
	hxd_Timer.dt = hxd_Timer.currentDT;
};
hxd_Timer.skip = function() {
	hxd_Timer.lastTimeStamp = HxOverrides.now() / 1000;
};
var hxd_Window = function(canvas,globalEvents) {
	this.useScreenPixels = js_Browser.get_supported();
	this._mouseLock = false;
	this.curMouseY = 0.;
	this.curMouseX = 0.;
	var _gthis = this;
	var customCanvas = canvas != null;
	this.eventTargets = new haxe_ds_List();
	this.resizeEvents = new haxe_ds_List();
	if(!js_Browser.get_supported()) {
		this.canvasPos = { "width" : 0, "top" : 0, "left" : 0, "height" : 0};
		return;
	}
	if(canvas == null) {
		canvas = window.document.getElementById("webgl");
		if(canvas == null) {
			throw haxe_Exception.thrown("Missing canvas #webgl");
		}
		if(canvas.getAttribute("globalEvents") == "1") {
			globalEvents = true;
		}
	}
	this.canvas = canvas;
	this.propagateKeyEvents = globalEvents;
	var propagate = canvas.getAttribute("propagateKeyEvents");
	if(propagate != null) {
		this.propagateKeyEvents = propagate != "0" && propagate != "false";
	}
	this.focused = globalEvents;
	this.element = globalEvents ? window : canvas;
	this.canvasPos = canvas.getBoundingClientRect();
	if(customCanvas) {
		canvas.addEventListener("mousemove",$bind(this,this.onMouseMove));
	} else {
		window.addEventListener("mousemove",$bind(this,this.onMouseMove));
	}
	this.element.addEventListener("mousedown",$bind(this,this.onMouseDown));
	this.element.addEventListener("mouseup",$bind(this,this.onMouseUp));
	this.element.addEventListener("mouseenter",$bind(this,this.onMouseEnter));
	this.element.addEventListener("mouseleave",$bind(this,this.onMouseLeave));
	this.element.addEventListener("wheel",$bind(this,this.onMouseWheel));
	this.element.addEventListener("touchstart",$bind(this,this.onTouchStart));
	this.element.addEventListener("touchmove",$bind(this,this.onTouchMove));
	this.element.addEventListener("touchend",$bind(this,this.onTouchEnd));
	this.element.addEventListener("keydown",$bind(this,this.onKeyDown));
	this.element.addEventListener("keyup",$bind(this,this.onKeyUp));
	this.element.addEventListener("keypress",$bind(this,this.onKeyPress));
	var _g = $bind(this,this.onFocus);
	var b = false;
	var tmp = function() {
		_g(b);
	};
	this.element.addEventListener("blur",tmp);
	var _g1 = $bind(this,this.onFocus);
	var b1 = true;
	var tmp = function() {
		_g1(b1);
	};
	this.element.addEventListener("focus",tmp);
	if(window.ResizeObserver != null) {
		this.observer = new ResizeObserver(function(e) {
			_gthis.checkResize();
		});
		this.observer.observe(canvas);
	} else {
		window.addEventListener("resize",$bind(this,this.checkResize));
	}
	canvas.addEventListener("contextmenu",function(e) {
		e.stopPropagation();
		if(e.button == 2) {
			e.preventDefault();
		}
		return false;
	});
	if(globalEvents) {
		canvas.addEventListener("mousedown",function(e) {
			_gthis.onMouseDown(e);
			e.stopPropagation();
			e.preventDefault();
		});
		this.element.addEventListener("contextmenu",function(e) {
			e.stopPropagation();
			e.preventDefault();
			return false;
		});
	} else {
		if(canvas.getAttribute("tabindex") == null) {
			canvas.setAttribute("tabindex","1");
		}
		canvas.style.outline = "none";
	}
	this.curW = this.get_width();
	this.curH = this.get_height();
};
$hxClasses["hxd.Window"] = hxd_Window;
hxd_Window.__name__ = "hxd.Window";
hxd_Window.getInstance = function() {
	if(hxd_Window.inst == null) {
		hxd_Window.inst = new hxd_Window();
	}
	return hxd_Window.inst;
};
hxd_Window.prototype = {
	checkResize: function() {
		this.canvasPos = this.canvas.getBoundingClientRect();
		var cw = this.get_width();
		var ch = this.get_height();
		if(this.curW != cw || this.curH != ch) {
			this.curW = cw;
			this.curH = ch;
			this.onResize(null);
		}
	}
	,event: function(e) {
		var _g_head = this.eventTargets.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var et = val;
			et(e);
		}
	}
	,addEventTarget: function(et) {
		this.eventTargets.add(et);
	}
	,removeEventTarget: function(et) {
		var _g_head = this.eventTargets.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var e = val;
			if(Reflect.compareMethods(e,et)) {
				this.eventTargets.remove(e);
				break;
			}
		}
	}
	,addResizeEvent: function(f) {
		this.resizeEvents.push(f);
	}
	,removeResizeEvent: function(f) {
		var _g_head = this.resizeEvents.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var e = val;
			if(Reflect.compareMethods(e,f)) {
				this.resizeEvents.remove(f);
				break;
			}
		}
	}
	,onResize: function(e) {
		var _g_head = this.resizeEvents.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var r = val;
			r();
		}
	}
	,getPixelRatio: function() {
		if(this.useScreenPixels) {
			return window.devicePixelRatio;
		} else {
			return 1;
		}
	}
	,get_width: function() {
		return Math.round(this.canvasPos.width * this.getPixelRatio());
	}
	,get_height: function() {
		return Math.round(this.canvasPos.height * this.getPixelRatio());
	}
	,get_mouseX: function() {
		return Math.round((this.curMouseX - this.canvasPos.left) * this.getPixelRatio());
	}
	,get_mouseY: function() {
		return Math.round((this.curMouseY - this.canvasPos.top) * this.getPixelRatio());
	}
	,get_mouseLock: function() {
		return this._mouseLock;
	}
	,onMouseDown: function(e) {
		if(this.get_mouseLock()) {
			if(e.movementX != 0 || e.movementY != 0) {
				this.onMouseMove(e);
			}
		} else if(e.clientX != this.curMouseX || e.clientY != this.curMouseY) {
			this.onMouseMove(e);
		}
		var ev = new hxd_Event(hxd_EventKind.EPush,this.get_mouseX(),this.get_mouseY());
		var _g = e.button;
		var tmp;
		switch(_g) {
		case 1:
			tmp = 2;
			break;
		case 2:
			tmp = 1;
			break;
		default:
			var x = _g;
			tmp = x;
		}
		ev.button = tmp;
		this.event(ev);
	}
	,onMouseUp: function(e) {
		if(this.get_mouseLock()) {
			if(e.movementX != 0 || e.movementY != 0) {
				this.onMouseMove(e);
			}
		} else if(e.clientX != this.curMouseX || e.clientY != this.curMouseY) {
			this.onMouseMove(e);
		}
		var ev = new hxd_Event(hxd_EventKind.ERelease,this.get_mouseX(),this.get_mouseY());
		var _g = e.button;
		var tmp;
		switch(_g) {
		case 1:
			tmp = 2;
			break;
		case 2:
			tmp = 1;
			break;
		default:
			var x = _g;
			tmp = x;
		}
		ev.button = tmp;
		this.event(ev);
	}
	,onMouseEnter: function(e) {
		var ev = new hxd_Event(hxd_EventKind.EOver,this.get_mouseX(),this.get_mouseY());
		this.event(ev);
	}
	,onMouseLeave: function(e) {
		var ev = new hxd_Event(hxd_EventKind.EOut,this.get_mouseX(),this.get_mouseY());
		this.event(ev);
	}
	,onMouseMove: function(e) {
		if(this.get_mouseLock()) {
			this.curMouseX += e.movementX;
			this.curMouseY += e.movementY;
		} else {
			this.curMouseX = e.clientX;
			this.curMouseY = e.clientY;
		}
		this.event(new hxd_Event(hxd_EventKind.EMove,this.get_mouseX(),this.get_mouseY()));
	}
	,onMouseWheel: function(e) {
		e.preventDefault();
		var ev = new hxd_Event(hxd_EventKind.EWheel,this.get_mouseX(),this.get_mouseY());
		ev.wheelDelta = e.deltaY / 120;
		this.event(ev);
	}
	,onTouchStart: function(e) {
		e.preventDefault();
		var x;
		var y;
		var ev;
		var _g = 0;
		var _g1 = e.changedTouches;
		while(_g < _g1.length) {
			var touch = _g1[_g];
			++_g;
			x = Math.round((touch.clientX - this.canvasPos.left) * this.getPixelRatio());
			y = Math.round((touch.clientY - this.canvasPos.top) * this.getPixelRatio());
			ev = new hxd_Event(hxd_EventKind.EPush,x,y);
			ev.touchId = touch.identifier;
			this.event(ev);
		}
	}
	,onTouchMove: function(e) {
		e.preventDefault();
		var x;
		var y;
		var ev;
		var _g = 0;
		var _g1 = e.changedTouches;
		while(_g < _g1.length) {
			var touch = _g1[_g];
			++_g;
			x = Math.round((touch.clientX - this.canvasPos.left) * this.getPixelRatio());
			y = Math.round((touch.clientY - this.canvasPos.top) * this.getPixelRatio());
			ev = new hxd_Event(hxd_EventKind.EMove,x,y);
			ev.touchId = touch.identifier;
			this.event(ev);
		}
	}
	,onTouchEnd: function(e) {
		e.preventDefault();
		var x;
		var y;
		var ev;
		var _g = 0;
		var _g1 = e.changedTouches;
		while(_g < _g1.length) {
			var touch = _g1[_g];
			++_g;
			x = Math.round((touch.clientX - this.canvasPos.left) * this.getPixelRatio());
			y = Math.round((touch.clientY - this.canvasPos.top) * this.getPixelRatio());
			ev = new hxd_Event(hxd_EventKind.ERelease,x,y);
			ev.touchId = touch.identifier;
			this.event(ev);
		}
	}
	,onKeyUp: function(e) {
		var ev = new hxd_Event(hxd_EventKind.EKeyUp,this.get_mouseX(),this.get_mouseY());
		ev.keyCode = e.keyCode;
		this.event(ev);
		if(!this.propagateKeyEvents) {
			e.preventDefault();
			e.stopPropagation();
		}
	}
	,onKeyDown: function(e) {
		var ev = new hxd_Event(hxd_EventKind.EKeyDown,this.get_mouseX(),this.get_mouseY());
		ev.keyCode = e.keyCode;
		this.event(ev);
		if(!this.propagateKeyEvents) {
			switch(ev.keyCode) {
			case 8:case 9:case 16:case 17:case 33:case 34:case 35:case 36:case 37:case 38:case 39:case 40:
				e.preventDefault();
				break;
			default:
			}
			e.stopPropagation();
		}
	}
	,onKeyPress: function(e) {
		var ev = new hxd_Event(hxd_EventKind.ETextInput,this.get_mouseX(),this.get_mouseY());
		ev.charCode = e.charCode;
		this.event(ev);
		if(!this.propagateKeyEvents) {
			e.preventDefault();
			e.stopPropagation();
		}
	}
	,onFocus: function(b) {
		this.event(new hxd_Event(b ? hxd_EventKind.EFocus : hxd_EventKind.EFocusLost));
		this.focused = b;
	}
	,set_displayMode: function(m) {
		if(!js_Browser.get_supported()) {
			return m;
		}
		var doc = window.document;
		var elt = doc.documentElement;
		var fullscreen = m != hxd_DisplayMode.Windowed;
		if(doc.fullscreenElement == elt == fullscreen) {
			return hxd_DisplayMode.Windowed;
		}
		if(m != hxd_DisplayMode.Windowed) {
			elt.requestFullscreen();
		} else {
			doc.exitFullscreen();
		}
		return m;
	}
	,__class__: hxd_Window
};
var js_Browser = function() { };
$hxClasses["js.Browser"] = js_Browser;
js_Browser.__name__ = "js.Browser";
js_Browser.get_supported = function() {
	if(typeof(window) != "undefined" && typeof(window.location) != "undefined") {
		return typeof(window.location.protocol) == "string";
	} else {
		return false;
	}
};
var hxd_System = function() { };
$hxClasses["hxd.System"] = hxd_System;
hxd_System.__name__ = "hxd.System";
hxd_System.setLoop = function(f) {
	if(!hxd_System.loopInit) {
		hxd_System.loopInit = true;
		hxd_System.browserLoop();
	}
	hxd_System.loopFunc = f;
};
hxd_System.browserLoop = function() {
	if(js_Browser.get_supported()) {
		var $window = window;
		var rqf = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame || $window.mozRequestAnimationFrame;
		if(hxd_System.fpsLimit > 0) {
			window.setTimeout(function() {
				return rqf(hxd_System.browserLoop);
			},1000 / hxd_System.fpsLimit);
		} else {
			rqf(hxd_System.browserLoop);
		}
	} else {
		throw haxe_Exception.thrown("Cannot use browserLoop without Browser support nor defining nodejs + hxnodejs");
	}
	if(hxd_System.loopFunc != null) {
		hxd_System.loopFunc();
	}
};
hxd_System.start = function(callb) {
	callb();
};
hxd_System.setNativeCursor = function(c) {
	if(hxd_System.currentNativeCursor != null && Type.enumEq(c,hxd_System.currentNativeCursor)) {
		return;
	}
	hxd_System.currentNativeCursor = c;
	hxd_System.currentCustomCursor = null;
	var canvas = hxd_Window.getInstance().canvas;
	if(canvas != null) {
		var tmp;
		switch(c._hx_index) {
		case 0:
			tmp = "default";
			break;
		case 1:
			tmp = "pointer";
			break;
		case 2:
			tmp = "move";
			break;
		case 3:
			tmp = "text";
			break;
		case 4:
			tmp = "none";
			break;
		case 5:
			var cur = c.custom;
			if(cur.alloc == null) {
				cur.alloc = [];
				var _g = 0;
				var _g1 = cur.frames;
				while(_g < _g1.length) {
					var frame = _g1[_g];
					++_g;
					cur.alloc.push("url(\"" + frame.ctx.canvas.toDataURL("image/png") + "\") " + cur.offsetX + " " + cur.offsetY + ", default");
				}
			}
			if(cur.frames.length > 1) {
				hxd_System.currentCustomCursor = cur;
				cur.reset();
			}
			tmp = cur.alloc[cur.frameIndex];
			break;
		case 6:
			var _g = c.f;
			throw haxe_Exception.thrown("assert");
		}
		canvas.style.cursor = tmp;
	}
};
hxd_System.getDefaultFrameRate = function() {
	return 60.;
};
hxd_System.getValue = function(s) {
	switch(s._hx_index) {
	case 0:
		if(hxd_System.get_platform() != hxd_Platform.Android) {
			return hxd_System.get_platform() == hxd_Platform.IOS;
		} else {
			return true;
		}
		break;
	case 1:
		return true;
	case 2:
		if(hxd_System.get_platform() != hxd_Platform.Android) {
			return hxd_System.get_platform() == hxd_Platform.IOS;
		} else {
			return true;
		}
		break;
	}
};
hxd_System.updateCursor = function() {
	if(hxd_System.currentCustomCursor != null) {
		var change = hxd_System.currentCustomCursor.update(hxd_Timer.elapsedTime);
		if(change != -1) {
			var canvas = hxd_Window.getInstance().canvas;
			if(canvas != null) {
				canvas.style.cursor = hxd_System.currentCustomCursor.alloc[change];
			}
		}
	}
};
hxd_System.get_platform = function() {
	var ua = $global.navigator.userAgent.toLowerCase();
	if(ua.indexOf("android") >= 0) {
		return hxd_Platform.Android;
	} else if(ua.indexOf("ipad") >= 0 || ua.indexOf("iphone") >= 0 || ua.indexOf("ipod") >= 0) {
		return hxd_Platform.IOS;
	} else {
		return hxd_Platform.PC;
	}
};
var hxd_DisplayMode = $hxEnums["hxd.DisplayMode"] = { __ename__:true,__constructs__:null
	,Windowed: {_hx_name:"Windowed",_hx_index:0,__enum__:"hxd.DisplayMode",toString:$estr}
	,Borderless: {_hx_name:"Borderless",_hx_index:1,__enum__:"hxd.DisplayMode",toString:$estr}
	,Fullscreen: {_hx_name:"Fullscreen",_hx_index:2,__enum__:"hxd.DisplayMode",toString:$estr}
	,FullscreenResize: {_hx_name:"FullscreenResize",_hx_index:3,__enum__:"hxd.DisplayMode",toString:$estr}
};
hxd_DisplayMode.__constructs__ = [hxd_DisplayMode.Windowed,hxd_DisplayMode.Borderless,hxd_DisplayMode.Fullscreen,hxd_DisplayMode.FullscreenResize];
hxd_DisplayMode.__empty_constructs__ = [hxd_DisplayMode.Windowed,hxd_DisplayMode.Borderless,hxd_DisplayMode.Fullscreen,hxd_DisplayMode.FullscreenResize];
var hxd_res_Embed = function() { };
$hxClasses["hxd.res.Embed"] = hxd_res_Embed;
hxd_res_Embed.__name__ = "hxd.res.Embed";
var hxd__$res_R_$fonts_$04B_$03_$TTF = function() { };
$hxClasses["hxd._res.R_fonts_04B_03_TTF"] = hxd__$res_R_$fonts_$04B_$03_$TTF;
hxd__$res_R_$fonts_$04B_$03_$TTF.__name__ = "hxd._res.R_fonts_04B_03_TTF";
hxd__$res_R_$fonts_$04B_$03_$TTF.__super__ = hxd_res_Embed;
hxd__$res_R_$fonts_$04B_$03_$TTF.prototype = $extend(hxd_res_Embed.prototype,{
	__class__: hxd__$res_R_$fonts_$04B_$03_$TTF
});
var hxd_earcut_EarNode = function() {
};
$hxClasses["hxd.earcut.EarNode"] = hxd_earcut_EarNode;
hxd_earcut_EarNode.__name__ = "hxd.earcut.EarNode";
hxd_earcut_EarNode.prototype = {
	__class__: hxd_earcut_EarNode
};
var hxd_earcut_Earcut = function() {
};
$hxClasses["hxd.earcut.Earcut"] = hxd_earcut_Earcut;
hxd_earcut_Earcut.__name__ = "hxd.earcut.Earcut";
hxd_earcut_Earcut.prototype = {
	triangulate_h2d_GPoint: function(points,holes) {
		var hasHoles = holes != null && holes.length > 0;
		var outerLen = hasHoles ? holes[0] : points.length;
		if(outerLen < 3) {
			return [];
		}
		var root = this.setLinkedList_triangulate_T(points,0,outerLen,true);
		if(holes != null) {
			root = this.eliminateHoles_triangulate_T(points,holes,root);
		}
		return this.triangulateNode(root,points.length > 80);
	}
	,eliminateHoles_triangulate_T: function(points,holes,root) {
		var queue = [];
		var _g = 0;
		var _g1 = holes.length;
		while(_g < _g1) {
			var i = _g++;
			var s = holes[i];
			var e = i == holes.length - 1 ? points.length : holes[i + 1];
			var node = this.setLinkedList_eliminateHoles_T(points,s,e,false);
			if(node == node.next) {
				node.steiner = true;
			}
			queue.push(this.getLeftmost(node));
		}
		queue.sort($bind(this,this.compareX));
		var _g = 0;
		while(_g < queue.length) {
			var q = queue[_g];
			++_g;
			this.eliminateHole(q,root);
			root = this.filterPoints(root,root.next);
		}
		return root;
	}
	,setLinkedList_eliminateHoles_T: function(points,start,end,clockwise) {
		var sum = 0.;
		var j = end - 1;
		var _g = start;
		var _g1 = end;
		while(_g < _g1) {
			var i = _g++;
			sum += (points[j].x - points[i].x) * (points[i].y + points[j].y);
			j = i;
		}
		var last = null;
		var n = this.cache;
		if(n == null) {
			n = new hxd_earcut_EarNode();
			n.allocNext = this.allocated;
			this.allocated = n;
		} else {
			this.cache = n.next;
		}
		n.i = -1;
		n.z = -1;
		n.x = 0;
		n.y = 0;
		n.next = null;
		n.prev = last;
		n.steiner = false;
		n.prevZ = null;
		n.nextZ = null;
		if(last != null) {
			last.next = n;
		}
		var node = n;
		var first = node;
		if(clockwise == sum > 0) {
			var _g = start;
			var _g1 = end;
			while(_g < _g1) {
				var i = _g++;
				var p = points[i];
				var x = p.x;
				var y = p.y;
				var n = this.cache;
				if(n == null) {
					n = new hxd_earcut_EarNode();
					n.allocNext = this.allocated;
					this.allocated = n;
				} else {
					this.cache = n.next;
				}
				n.i = i;
				n.z = -1;
				n.x = x;
				n.y = y;
				n.next = null;
				n.prev = node;
				n.steiner = false;
				n.prevZ = null;
				n.nextZ = null;
				if(node != null) {
					node.next = n;
				}
				node = n;
			}
		} else {
			var i = end - 1;
			while(i >= start) {
				var p = points[i];
				var x = p.x;
				var y = p.y;
				var n = this.cache;
				if(n == null) {
					n = new hxd_earcut_EarNode();
					n.allocNext = this.allocated;
					this.allocated = n;
				} else {
					this.cache = n.next;
				}
				n.i = i;
				n.z = -1;
				n.x = x;
				n.y = y;
				n.next = null;
				n.prev = node;
				n.steiner = false;
				n.prevZ = null;
				n.nextZ = null;
				if(node != null) {
					node.next = n;
				}
				node = n;
				--i;
			}
		}
		node.next = first.next;
		node.next.prev = node;
		return node;
	}
	,setLinkedList_triangulate_T: function(points,start,end,clockwise) {
		var sum = 0.;
		var j = end - 1;
		var _g = start;
		var _g1 = end;
		while(_g < _g1) {
			var i = _g++;
			sum += (points[j].x - points[i].x) * (points[i].y + points[j].y);
			j = i;
		}
		var last = null;
		var n = this.cache;
		if(n == null) {
			n = new hxd_earcut_EarNode();
			n.allocNext = this.allocated;
			this.allocated = n;
		} else {
			this.cache = n.next;
		}
		n.i = -1;
		n.z = -1;
		n.x = 0;
		n.y = 0;
		n.next = null;
		n.prev = last;
		n.steiner = false;
		n.prevZ = null;
		n.nextZ = null;
		if(last != null) {
			last.next = n;
		}
		var node = n;
		var first = node;
		if(clockwise == sum > 0) {
			var _g = start;
			var _g1 = end;
			while(_g < _g1) {
				var i = _g++;
				var p = points[i];
				var x = p.x;
				var y = p.y;
				var n = this.cache;
				if(n == null) {
					n = new hxd_earcut_EarNode();
					n.allocNext = this.allocated;
					this.allocated = n;
				} else {
					this.cache = n.next;
				}
				n.i = i;
				n.z = -1;
				n.x = x;
				n.y = y;
				n.next = null;
				n.prev = node;
				n.steiner = false;
				n.prevZ = null;
				n.nextZ = null;
				if(node != null) {
					node.next = n;
				}
				node = n;
			}
		} else {
			var i = end - 1;
			while(i >= start) {
				var p = points[i];
				var x = p.x;
				var y = p.y;
				var n = this.cache;
				if(n == null) {
					n = new hxd_earcut_EarNode();
					n.allocNext = this.allocated;
					this.allocated = n;
				} else {
					this.cache = n.next;
				}
				n.i = i;
				n.z = -1;
				n.x = x;
				n.y = y;
				n.next = null;
				n.prev = node;
				n.steiner = false;
				n.prevZ = null;
				n.nextZ = null;
				if(node != null) {
					node.next = n;
				}
				node = n;
				--i;
			}
		}
		node.next = first.next;
		node.next.prev = node;
		return node;
	}
	,triangulateNode: function(root,useZOrder) {
		this.triangles = [];
		root = this.filterPoints(root);
		if(useZOrder && root != null) {
			var maxX = root.x;
			this.minX = maxX;
			var maxY = root.y;
			this.minY = maxY;
			var p = root.next;
			while(p != root) {
				var x = p.x;
				var y = p.y;
				if(x < this.minX) {
					this.minX = x;
				}
				if(y < this.minY) {
					this.minY = y;
				}
				if(x > maxX) {
					maxX = x;
				}
				if(y > maxY) {
					maxY = y;
				}
				p = p.next;
			}
			var a = maxX - this.minX;
			var b = maxY - this.minY;
			this.size = a < b ? b : a;
			this.hasSize = true;
		} else {
			this.hasSize = false;
		}
		this.earcutLinked(root);
		var result = this.triangles;
		this.triangles = null;
		var n = this.allocated;
		if(this.cache != null) {
			while(n != this.cache) n = n.allocNext;
			n = n.allocNext;
		}
		while(n != null) {
			n.next = this.cache;
			this.cache = n;
			n = n.allocNext;
		}
		return result;
	}
	,eliminateHole: function(hole,root) {
		root = this.findHoleBridge(hole,root);
		if(root != null) {
			var b = this.splitPolygon(root,hole);
			this.filterPoints(b,b.next);
		}
	}
	,findHoleBridge: function(hole,root) {
		var p = root;
		var hx = hole.x;
		var hy = hole.y;
		var qx = -Infinity;
		var m = null;
		while(true) {
			if(hy <= p.y && hy >= p.next.y) {
				var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
				if(x <= hx && x > qx) {
					qx = x;
					m = p.x < p.next.x ? p : p.next;
				}
			}
			p = p.next;
			if(!(p != root)) {
				break;
			}
		}
		if(m == null) {
			return null;
		}
		var stop = m;
		var tanMin = Infinity;
		var tan;
		p = m.next;
		while(p != stop) {
			var tmp;
			if(hx >= p.x && p.x >= m.x) {
				var ax = hy < m.y ? hx : qx;
				var bx = m.x;
				var by = m.y;
				var cx = hy < m.y ? qx : hx;
				var px = p.x;
				var py = p.y;
				tmp = (cx - px) * (hy - py) - (ax - px) * (hy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (hy - py) >= 0 && (bx - px) * (hy - py) - (cx - px) * (by - py) >= 0;
			} else {
				tmp = false;
			}
			if(tmp) {
				var f = hy - p.y;
				tan = (f < 0 ? -f : f) / (hx - p.x);
				var tmp1;
				if(tan < tanMin || tan == tanMin && p.x > m.x) {
					var p1 = p.prev;
					var r = p.next;
					if((p.y - p1.y) * (r.x - p.x) - (p.x - p1.x) * (r.y - p.y) < 0) {
						var r1 = p.next;
						if((hole.y - p.y) * (r1.x - hole.x) - (hole.x - p.x) * (r1.y - hole.y) >= 0) {
							var q = p.prev;
							tmp1 = (q.y - p.y) * (hole.x - q.x) - (q.x - p.x) * (hole.y - q.y) >= 0;
						} else {
							tmp1 = false;
						}
					} else {
						var r2 = p.prev;
						if(!((hole.y - p.y) * (r2.x - hole.x) - (hole.x - p.x) * (r2.y - hole.y) < 0)) {
							var q1 = p.next;
							tmp1 = (q1.y - p.y) * (hole.x - q1.x) - (q1.x - p.x) * (hole.y - q1.y) < 0;
						} else {
							tmp1 = true;
						}
					}
				} else {
					tmp1 = false;
				}
				if(tmp1) {
					m = p;
					tanMin = tan;
				}
			}
			p = p.next;
		}
		return m;
	}
	,getLeftmost: function(node) {
		var p = node;
		var leftmost = node;
		while(true) {
			if(p.x < leftmost.x) {
				leftmost = p;
			}
			p = p.next;
			if(!(p != node)) {
				break;
			}
		}
		return leftmost;
	}
	,compareX: function(a,b) {
		if(a.x - b.x > 0) {
			return 1;
		} else {
			return -1;
		}
	}
	,filterPoints: function(start,end) {
		if(start == null) {
			return start;
		}
		if(end == null) {
			end = start;
		}
		var p = start;
		var again;
		while(true) {
			again = false;
			var tmp;
			if(!p.steiner) {
				var p2 = p.next;
				if(!(p.x == p2.x && p.y == p2.y)) {
					var p1 = p.prev;
					var r = p.next;
					tmp = (p.y - p1.y) * (r.x - p.x) - (p.x - p1.x) * (r.y - p.y) == 0;
				} else {
					tmp = true;
				}
			} else {
				tmp = false;
			}
			if(tmp) {
				p.next.prev = p.prev;
				p.prev.next = p.next;
				if(p.prevZ != null) {
					p.prevZ.nextZ = p.nextZ;
				}
				if(p.nextZ != null) {
					p.nextZ.prevZ = p.prevZ;
				}
				end = p.prev;
				p = end;
				if(p == p.next) {
					return null;
				}
				again = true;
			} else {
				p = p.next;
			}
			if(!(again || p != end)) {
				break;
			}
		}
		return end;
	}
	,earcutLinked: function(ear,pass) {
		if(pass == null) {
			pass = 0;
		}
		if(ear == null) {
			return;
		}
		if(pass == 0 && this.hasSize) {
			this.indexCurve(ear);
		}
		var stop = ear;
		var prev;
		var next;
		while(ear.prev != ear.next) {
			prev = ear.prev;
			next = ear.next;
			if(this.hasSize ? this.isEarHashed(ear) : this.isEar(ear)) {
				this.triangles.push(prev.i);
				this.triangles.push(ear.i);
				this.triangles.push(next.i);
				ear.next.prev = ear.prev;
				ear.prev.next = ear.next;
				if(ear.prevZ != null) {
					ear.prevZ.nextZ = ear.nextZ;
				}
				if(ear.nextZ != null) {
					ear.nextZ.prevZ = ear.prevZ;
				}
				ear = next.next;
				stop = next.next;
				continue;
			}
			ear = next;
			if(ear == stop) {
				switch(pass) {
				case 0:
					this.earcutLinked(this.filterPoints(ear),1);
					break;
				case 1:
					ear = this.cureLocalIntersections(ear);
					this.earcutLinked(ear,2);
					break;
				case 2:
					this.splitEarcut(ear);
					break;
				}
				break;
			}
		}
	}
	,isEar: function(ear) {
		var a = ear.prev;
		var b = ear;
		var c = ear.next;
		if((b.y - a.y) * (c.x - b.x) - (b.x - a.x) * (c.y - b.y) >= 0) {
			return false;
		}
		var p = ear.next.next;
		while(p != ear.prev) {
			var tmp;
			var ax = a.x;
			var ay = a.y;
			var bx = b.x;
			var by = b.y;
			var cx = c.x;
			var cy = c.y;
			var px = p.x;
			var py = p.y;
			if((cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0) {
				var p1 = p.prev;
				var r = p.next;
				tmp = (p.y - p1.y) * (r.x - p.x) - (p.x - p1.x) * (r.y - p.y) >= 0;
			} else {
				tmp = false;
			}
			if(tmp) {
				return false;
			}
			p = p.next;
		}
		return true;
	}
	,isEarHashed: function(ear) {
		var a = ear.prev;
		var b = ear;
		var c = ear.next;
		if((b.y - a.y) * (c.x - b.x) - (b.x - a.x) * (c.y - b.y) >= 0) {
			return false;
		}
		var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x;
		var minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y;
		var maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x;
		var maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
		var x = 32767 * (minTX - this.minX) / this.size | 0;
		var y = 32767 * (minTY - this.minY) / this.size | 0;
		x = (x | x << 8) & 16711935;
		x = (x | x << 4) & 252645135;
		x = (x | x << 2) & 858993459;
		x = (x | x << 1) & 1431655765;
		y = (y | y << 8) & 16711935;
		y = (y | y << 4) & 252645135;
		y = (y | y << 2) & 858993459;
		y = (y | y << 1) & 1431655765;
		var minZ = x | y << 1;
		var x = 32767 * (maxTX - this.minX) / this.size | 0;
		var y = 32767 * (maxTY - this.minY) / this.size | 0;
		x = (x | x << 8) & 16711935;
		x = (x | x << 4) & 252645135;
		x = (x | x << 2) & 858993459;
		x = (x | x << 1) & 1431655765;
		y = (y | y << 8) & 16711935;
		y = (y | y << 4) & 252645135;
		y = (y | y << 2) & 858993459;
		y = (y | y << 1) & 1431655765;
		var maxZ = x | y << 1;
		var p = ear.nextZ;
		while(p != null && p.z <= maxZ) {
			var tmp;
			var tmp1;
			if(p != ear.prev && p != ear.next) {
				var ax = a.x;
				var ay = a.y;
				var bx = b.x;
				var by = b.y;
				var cx = c.x;
				var cy = c.y;
				var px = p.x;
				var py = p.y;
				tmp1 = (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
			} else {
				tmp1 = false;
			}
			if(tmp1) {
				var p1 = p.prev;
				var r = p.next;
				tmp = (p.y - p1.y) * (r.x - p.x) - (p.x - p1.x) * (r.y - p.y) >= 0;
			} else {
				tmp = false;
			}
			if(tmp) {
				return false;
			}
			p = p.nextZ;
		}
		p = ear.prevZ;
		while(p != null && p.z >= minZ) {
			var tmp;
			var tmp1;
			if(p != ear.prev && p != ear.next) {
				var ax = a.x;
				var ay = a.y;
				var bx = b.x;
				var by = b.y;
				var cx = c.x;
				var cy = c.y;
				var px = p.x;
				var py = p.y;
				tmp1 = (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
			} else {
				tmp1 = false;
			}
			if(tmp1) {
				var p1 = p.prev;
				var r = p.next;
				tmp = (p.y - p1.y) * (r.x - p.x) - (p.x - p1.x) * (r.y - p.y) >= 0;
			} else {
				tmp = false;
			}
			if(tmp) {
				return false;
			}
			p = p.prevZ;
		}
		return true;
	}
	,cureLocalIntersections: function(start) {
		var p = start;
		while(true) {
			var a = p.prev;
			var b = p.next.next;
			var tmp;
			var tmp1;
			var p2 = p.next;
			if((p.y - a.y) * (p2.x - p.x) - (p.x - a.x) * (p2.y - p.y) > 0 != (p.y - a.y) * (b.x - p.x) - (p.x - a.x) * (b.y - p.y) > 0 && (b.y - p2.y) * (a.x - b.x) - (b.x - p2.x) * (a.y - b.y) > 0 != (b.y - p2.y) * (p.x - b.x) - (b.x - p2.x) * (p.y - b.y) > 0) {
				var p1 = a.prev;
				var r = a.next;
				if((a.y - p1.y) * (r.x - a.x) - (a.x - p1.x) * (r.y - a.y) < 0) {
					var r1 = a.next;
					if((b.y - a.y) * (r1.x - b.x) - (b.x - a.x) * (r1.y - b.y) >= 0) {
						var q = a.prev;
						tmp1 = (q.y - a.y) * (b.x - q.x) - (q.x - a.x) * (b.y - q.y) >= 0;
					} else {
						tmp1 = false;
					}
				} else {
					var r2 = a.prev;
					if(!((b.y - a.y) * (r2.x - b.x) - (b.x - a.x) * (r2.y - b.y) < 0)) {
						var q1 = a.next;
						tmp1 = (q1.y - a.y) * (b.x - q1.x) - (q1.x - a.x) * (b.y - q1.y) < 0;
					} else {
						tmp1 = true;
					}
				}
			} else {
				tmp1 = false;
			}
			if(tmp1) {
				var p3 = b.prev;
				var r3 = b.next;
				if((b.y - p3.y) * (r3.x - b.x) - (b.x - p3.x) * (r3.y - b.y) < 0) {
					var r4 = b.next;
					if((a.y - b.y) * (r4.x - a.x) - (a.x - b.x) * (r4.y - a.y) >= 0) {
						var q2 = b.prev;
						tmp = (q2.y - b.y) * (a.x - q2.x) - (q2.x - b.x) * (a.y - q2.y) >= 0;
					} else {
						tmp = false;
					}
				} else {
					var r5 = b.prev;
					if(!((a.y - b.y) * (r5.x - a.x) - (a.x - b.x) * (r5.y - a.y) < 0)) {
						var q3 = b.next;
						tmp = (q3.y - b.y) * (a.x - q3.x) - (q3.x - b.x) * (a.y - q3.y) < 0;
					} else {
						tmp = true;
					}
				}
			} else {
				tmp = false;
			}
			if(tmp) {
				this.triangles.push(a.i);
				this.triangles.push(p.i);
				this.triangles.push(b.i);
				p.next.prev = p.prev;
				p.prev.next = p.next;
				if(p.prevZ != null) {
					p.prevZ.nextZ = p.nextZ;
				}
				if(p.nextZ != null) {
					p.nextZ.prevZ = p.prevZ;
				}
				var p4 = p.next;
				p4.next.prev = p4.prev;
				p4.prev.next = p4.next;
				if(p4.prevZ != null) {
					p4.prevZ.nextZ = p4.nextZ;
				}
				if(p4.nextZ != null) {
					p4.nextZ.prevZ = p4.prevZ;
				}
				start = b;
				p = start;
			}
			p = p.next;
			if(!(p != start)) {
				break;
			}
		}
		return p;
	}
	,splitEarcut: function(start) {
		var a = start;
		while(true) {
			var b = a.next.next;
			while(b != a.prev) {
				if(a.i != b.i && this.isValidDiagonal(a,b)) {
					var c = this.splitPolygon(a,b);
					a = this.filterPoints(a,a.next);
					c = this.filterPoints(c,c.next);
					this.earcutLinked(a);
					this.earcutLinked(c);
					return;
				}
				b = b.next;
			}
			a = a.next;
			if(!(a != start)) {
				break;
			}
		}
	}
	,splitPolygon: function(a,b) {
		var i = a.i;
		var x = a.x;
		var y = a.y;
		var last = null;
		var n = this.cache;
		if(n == null) {
			n = new hxd_earcut_EarNode();
			n.allocNext = this.allocated;
			this.allocated = n;
		} else {
			this.cache = n.next;
		}
		n.i = i;
		n.z = -1;
		n.x = x;
		n.y = y;
		n.next = null;
		n.prev = last;
		n.steiner = false;
		n.prevZ = null;
		n.nextZ = null;
		if(last != null) {
			last.next = n;
		}
		var a2 = n;
		var i = b.i;
		var x = b.x;
		var y = b.y;
		var last = null;
		var n = this.cache;
		if(n == null) {
			n = new hxd_earcut_EarNode();
			n.allocNext = this.allocated;
			this.allocated = n;
		} else {
			this.cache = n.next;
		}
		n.i = i;
		n.z = -1;
		n.x = x;
		n.y = y;
		n.next = null;
		n.prev = last;
		n.steiner = false;
		n.prevZ = null;
		n.nextZ = null;
		if(last != null) {
			last.next = n;
		}
		var b2 = n;
		var an = a.next;
		var bp = b.prev;
		a.next = b;
		b.prev = a;
		a2.next = an;
		an.prev = a2;
		b2.next = a2;
		a2.prev = b2;
		bp.next = b2;
		b2.prev = bp;
		return b2;
	}
	,isValidDiagonal: function(a,b) {
		if(!(a.x == b.x && a.y == b.y)) {
			var tmp;
			var tmp1;
			if(a.next.i != b.i && a.prev.i != b.i && !this.intersectsPolygon(a,b)) {
				var p = a.prev;
				var r = a.next;
				if((a.y - p.y) * (r.x - a.x) - (a.x - p.x) * (r.y - a.y) < 0) {
					var r = a.next;
					if((b.y - a.y) * (r.x - b.x) - (b.x - a.x) * (r.y - b.y) >= 0) {
						var q = a.prev;
						tmp1 = (q.y - a.y) * (b.x - q.x) - (q.x - a.x) * (b.y - q.y) >= 0;
					} else {
						tmp1 = false;
					}
				} else {
					var r = a.prev;
					if(!((b.y - a.y) * (r.x - b.x) - (b.x - a.x) * (r.y - b.y) < 0)) {
						var q = a.next;
						tmp1 = (q.y - a.y) * (b.x - q.x) - (q.x - a.x) * (b.y - q.y) < 0;
					} else {
						tmp1 = true;
					}
				}
			} else {
				tmp1 = false;
			}
			if(tmp1) {
				var p = b.prev;
				var r = b.next;
				if((b.y - p.y) * (r.x - b.x) - (b.x - p.x) * (r.y - b.y) < 0) {
					var r = b.next;
					if((a.y - b.y) * (r.x - a.x) - (a.x - b.x) * (r.y - a.y) >= 0) {
						var q = b.prev;
						tmp = (q.y - b.y) * (a.x - q.x) - (q.x - b.x) * (a.y - q.y) >= 0;
					} else {
						tmp = false;
					}
				} else {
					var r = b.prev;
					if(!((a.y - b.y) * (r.x - a.x) - (a.x - b.x) * (r.y - a.y) < 0)) {
						var q = b.next;
						tmp = (q.y - b.y) * (a.x - q.x) - (q.x - b.x) * (a.y - q.y) < 0;
					} else {
						tmp = true;
					}
				}
			} else {
				tmp = false;
			}
			if(tmp) {
				return this.middleInside(a,b);
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	,middleInside: function(a,b) {
		var p = a;
		var inside = false;
		var px = (a.x + b.x) / 2;
		var py = (a.y + b.y) / 2;
		while(true) {
			if(p.y > py != p.next.y > py && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) {
				inside = !inside;
			}
			p = p.next;
			if(!(p != a)) {
				break;
			}
		}
		return inside;
	}
	,intersectsPolygon: function(a,b) {
		var p = a;
		while(true) {
			var tmp;
			if(p.i != a.i && p.next.i != a.i && p.i != b.i && p.next.i != b.i) {
				var q1 = p.next;
				tmp = (q1.y - p.y) * (a.x - q1.x) - (q1.x - p.x) * (a.y - q1.y) > 0 != (q1.y - p.y) * (b.x - q1.x) - (q1.x - p.x) * (b.y - q1.y) > 0 && (b.y - a.y) * (p.x - b.x) - (b.x - a.x) * (p.y - b.y) > 0 != (b.y - a.y) * (q1.x - b.x) - (b.x - a.x) * (q1.y - b.y) > 0;
			} else {
				tmp = false;
			}
			if(tmp) {
				return true;
			}
			p = p.next;
			if(!(p != a)) {
				break;
			}
		}
		return false;
	}
	,indexCurve: function(start) {
		var p = start;
		while(true) {
			if(p.z < 0) {
				var x = 32767 * (p.x - this.minX) / this.size | 0;
				var y = 32767 * (p.y - this.minY) / this.size | 0;
				x = (x | x << 8) & 16711935;
				x = (x | x << 4) & 252645135;
				x = (x | x << 2) & 858993459;
				x = (x | x << 1) & 1431655765;
				y = (y | y << 8) & 16711935;
				y = (y | y << 4) & 252645135;
				y = (y | y << 2) & 858993459;
				y = (y | y << 1) & 1431655765;
				p.z = x | y << 1;
			}
			p.prevZ = p.prev;
			p.nextZ = p.next;
			p = p.next;
			if(!(p != start)) {
				break;
			}
		}
		p.prevZ.nextZ = null;
		p.prevZ = null;
		this.sortLinked(p);
	}
	,sortLinked: function(list) {
		var p;
		var q;
		var e;
		var tail;
		var numMerges;
		var pSize;
		var qSize;
		var inSize = 1;
		while(true) {
			p = list;
			list = null;
			tail = null;
			numMerges = 0;
			while(p != null) {
				++numMerges;
				q = p;
				pSize = 0;
				var _g = 0;
				var _g1 = inSize;
				while(_g < _g1) {
					var i = _g++;
					++pSize;
					q = q.nextZ;
					if(q == null) {
						break;
					}
				}
				qSize = inSize;
				while(pSize > 0 || qSize > 0 && q != null) {
					if(pSize == 0) {
						e = q;
						q = q.nextZ;
						--qSize;
					} else if(qSize == 0 || q == null) {
						e = p;
						p = p.nextZ;
						--pSize;
					} else if(p.z <= q.z) {
						e = p;
						p = p.nextZ;
						--pSize;
					} else {
						e = q;
						q = q.nextZ;
						--qSize;
					}
					if(tail != null) {
						tail.nextZ = e;
					} else {
						list = e;
					}
					e.prevZ = tail;
					tail = e;
				}
				p = q;
			}
			tail.nextZ = null;
			inSize *= 2;
			if(!(numMerges > 1)) {
				break;
			}
		}
		return list;
	}
	,__class__: hxd_earcut_Earcut
};
var hxd_fmt_bfnt_FontParser = function() { };
$hxClasses["hxd.fmt.bfnt.FontParser"] = hxd_fmt_bfnt_FontParser;
hxd_fmt_bfnt_FontParser.__name__ = "hxd.fmt.bfnt.FontParser";
hxd_fmt_bfnt_FontParser.parse = function(bytes,path,resolveTile) {
	var tile = null;
	var font = new h2d_Font(null,0);
	var glyphs = font.glyphs;
	font.baseLine = 0;
	var _g = bytes.getInt32(0);
	switch(_g) {
	case 54938946:
		var bytes1 = new haxe_io_BytesInput(bytes);
		bytes1.set_position(bytes1.pos + 4);
		var pageCount = 0;
		while(bytes1.pos < bytes1.totlen) {
			var id = bytes1.readByte();
			var length = bytes1.readInt32();
			var pos = bytes1.pos;
			switch(id) {
			case 1:
				font.size = font.initSize = bytes1.readInt16();
				bytes1.set_position(bytes1.pos + 12);
				font.name = bytes1.readUntil(0);
				break;
			case 2:
				font.lineHeight = bytes1.readUInt16();
				font.baseLine = bytes1.readUInt16();
				bytes1.set_position(bytes1.pos + 4);
				pageCount = bytes1.readUInt16();
				if(pageCount != 1) {
					haxe_Log.trace("Warning: BMF format only supports one page at the moment.",{ fileName : "hxd/fmt/bfnt/FontParser.hx", lineNumber : 224, className : "hxd.fmt.bfnt.FontParser", methodName : "parse"});
				}
				break;
			case 3:
				var name = bytes1.readUntil(0);
				try {
					font.tilePath = name;
					tile = resolveTile(haxe_io_Path.join([haxe_io_Path.directory(path),name]));
				} catch( _g1 ) {
					haxe_Log.trace("Warning: Could not find referenced font texture at \"" + name + "\", trying to resolve same name as fnt!",{ fileName : "hxd/fmt/bfnt/FontParser.hx", lineNumber : 30, className : "hxd.fmt.bfnt.FontParser", methodName : "parse"});
					font.tilePath = new haxe_io_Path(path).file + ".png";
					tile = resolveTile(haxe_io_Path.withExtension(path,"png"));
				}
				break;
			case 4:
				var count = length / 20 | 0;
				while(count > 0) {
					var cid = bytes1.readInt32();
					var t = tile.sub(bytes1.readUInt16(),bytes1.readUInt16(),bytes1.readUInt16(),bytes1.readUInt16(),bytes1.readInt16(),bytes1.readInt16());
					var fc = new h2d_FontChar(t,bytes1.readInt16());
					glyphs.h[cid] = fc;
					bytes1.set_position(bytes1.pos + 2);
					--count;
				}
				break;
			case 5:
				var count1 = length / 10 | 0;
				while(count1 > 0) {
					var first = bytes1.readInt32();
					var key = bytes1.readInt32();
					var fc1 = glyphs.h[key];
					if(fc1 != null) {
						fc1.addKerning(first,bytes1.readInt16());
					} else {
						bytes1.set_position(bytes1.pos + 2);
					}
					--count1;
				}
				break;
			}
			bytes1.set_position(pos + length);
		}
		break;
	case 1414415938:
		return new hxd_fmt_bfnt_Reader(new haxe_io_BytesInput(bytes)).read(function(tp) {
			try {
				font.tilePath = tp;
				tile = resolveTile(haxe_io_Path.join([haxe_io_Path.directory(path),tp]));
			} catch( _g ) {
				haxe_Log.trace("Warning: Could not find referenced font texture at \"" + tp + "\", trying to resolve same name as fnt!",{ fileName : "hxd/fmt/bfnt/FontParser.hx", lineNumber : 30, className : "hxd.fmt.bfnt.FontParser", methodName : "parse"});
				font.tilePath = new haxe_io_Path(path).file + ".png";
				tile = resolveTile(haxe_io_Path.withExtension(path,"png"));
			}
			return tile;
		});
	case 1836597052:case 1852794428:
		var xml = Xml.parse(bytes.toString());
		var x = xml.firstElement();
		if(x.nodeType != Xml.Document && x.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Invalid nodeType " + (x.nodeType == null ? "null" : XmlType.toString(x.nodeType)));
		}
		var this1 = x;
		var xml = this1;
		if(haxe_xml__$Access_HasNodeAccess.resolve(xml,"info")) {
			var tmp = haxe_xml__$Access_NodeAccess.resolve(xml,"info");
			font.name = haxe_xml__$Access_AttribAccess.resolve(tmp,"face");
			var tmp = haxe_xml__$Access_AttribAccess.resolve(haxe_xml__$Access_NodeAccess.resolve(xml,"info"),"size");
			font.size = font.initSize = Std.parseInt(tmp);
			var tmp = haxe_xml__$Access_AttribAccess.resolve(haxe_xml__$Access_NodeAccess.resolve(xml,"common"),"lineHeight");
			font.lineHeight = Std.parseInt(tmp);
			var tmp = haxe_xml__$Access_AttribAccess.resolve(haxe_xml__$Access_NodeAccess.resolve(xml,"common"),"base");
			font.baseLine = Std.parseInt(tmp);
			var p = haxe_xml__$Access_NodeAccess.resolve(xml,"pages").elements();
			while(p.hasNext()) {
				var p1 = p.next();
				if(haxe_xml__$Access_AttribAccess.resolve(p1,"id") == "0") {
					var tilePath = haxe_xml__$Access_AttribAccess.resolve(p1,"file");
					try {
						font.tilePath = tilePath;
						tile = resolveTile(haxe_io_Path.join([haxe_io_Path.directory(path),tilePath]));
					} catch( _g1 ) {
						haxe_Log.trace("Warning: Could not find referenced font texture at \"" + tilePath + "\", trying to resolve same name as fnt!",{ fileName : "hxd/fmt/bfnt/FontParser.hx", lineNumber : 30, className : "hxd.fmt.bfnt.FontParser", methodName : "parse"});
						font.tilePath = new haxe_io_Path(path).file + ".png";
						tile = resolveTile(haxe_io_Path.withExtension(path,"png"));
					}
				} else {
					haxe_Log.trace("Warning: BMF format only supports one page at the moment.",{ fileName : "hxd/fmt/bfnt/FontParser.hx", lineNumber : 66, className : "hxd.fmt.bfnt.FontParser", methodName : "parse"});
				}
			}
			var chars = haxe_xml__$Access_NodeAccess.resolve(xml,"chars").elements();
			var c = chars;
			while(c.hasNext()) {
				var c1 = c.next();
				var t = tile.sub(Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(c1,"x")),Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(c1,"y")),Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(c1,"width")),Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(c1,"height")),Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(c1,"xoffset")),Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(c1,"yoffset")));
				var fc = new h2d_FontChar(t,Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(c1,"xadvance")));
				var kerns = haxe_xml__$Access_NodeAccess.resolve(xml,"kernings").elements();
				var k = kerns;
				while(k.hasNext()) {
					var k1 = k.next();
					if(haxe_xml__$Access_AttribAccess.resolve(k1,"second") == haxe_xml__$Access_AttribAccess.resolve(c1,"id")) {
						fc.addKerning(Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(k1,"first")),Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(k1,"amount")));
					}
				}
				var key = Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(c1,"id"));
				glyphs.h[key] = fc;
			}
		} else {
			font.tilePath = new haxe_io_Path(path).file + ".png";
			tile = resolveTile(haxe_io_Path.withExtension(path,"png"));
			font.name = haxe_xml__$Access_AttribAccess.resolve(xml,"family");
			var tmp = haxe_xml__$Access_AttribAccess.resolve(xml,"size");
			font.size = font.initSize = Std.parseInt(tmp);
			var tmp = haxe_xml__$Access_AttribAccess.resolve(xml,"height");
			font.lineHeight = Std.parseInt(tmp);
			var kernings = [];
			var c = xml.elements();
			while(c.hasNext()) {
				var c1 = c.next();
				var r = haxe_xml__$Access_AttribAccess.resolve(c1,"rect").split(" ");
				var o = haxe_xml__$Access_AttribAccess.resolve(c1,"offset").split(" ");
				var t = tile.sub(Std.parseInt(r[0]),Std.parseInt(r[1]),Std.parseInt(r[2]),Std.parseInt(r[3]),Std.parseInt(o[0]),Std.parseInt(o[1]));
				var fc = new h2d_FontChar(t,Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(c1,"width")));
				var code = haxe_xml__$Access_AttribAccess.resolve(c1,"code");
				var code1 = StringTools.startsWith(code,"&#") ? Std.parseInt(HxOverrides.substr(code,2,code.length - 3)) : HxOverrides.cca(code,0);
				var k = c1.elements();
				while(k.hasNext()) {
					var k1 = k.next();
					var code2 = haxe_xml__$Access_AttribAccess.resolve(k1,"id");
					var next = StringTools.startsWith(code2,"&#") ? Std.parseInt(HxOverrides.substr(code2,2,code2.length - 3)) : HxOverrides.cca(code2,0);
					var adv = Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(k1,"advance"));
					if(glyphs.h.hasOwnProperty(next)) {
						glyphs.h[next].addKerning(code1,adv);
					} else {
						kernings.push({ prev : code1, next : next, adv : adv});
					}
				}
				glyphs.h[code1] = fc;
			}
			var _g1 = 0;
			while(_g1 < kernings.length) {
				var k = kernings[_g1];
				++_g1;
				var g = glyphs.h[k.next];
				if(g == null) {
					continue;
				}
				g.addKerning(k.prev,k.adv);
			}
		}
		break;
	case 1868983913:
		var lines = bytes.toString().split("\n");
		var reg = new EReg(" *?([0-9a-zA-Z]+)=(\"[^\"]+\"|.+?)(?:[ \r]|$)","");
		var idx;
		var pageCount = 0;
		var _g1 = 0;
		while(_g1 < lines.length) {
			var line = lines[_g1];
			++_g1;
			idx = line.indexOf(" ");
			switch(HxOverrides.substr(line,0,idx)) {
			case "char":
				var id = 0;
				var x = 0;
				var y = 0;
				var width = 0;
				var height = 0;
				var xoffset = 0;
				var yoffset = 0;
				var xadvance = 0;
				while(idx < line.length && reg.matchSub(line,idx)) {
					switch(reg.matched(1)) {
					case "height":
						var v = reg.matched(2);
						height = Std.parseInt(HxOverrides.cca(v,0) == 34 ? v.substring(1,v.length - 1) : v);
						break;
					case "id":
						var v1 = reg.matched(2);
						id = Std.parseInt(HxOverrides.cca(v1,0) == 34 ? v1.substring(1,v1.length - 1) : v1);
						break;
					case "width":
						var v2 = reg.matched(2);
						width = Std.parseInt(HxOverrides.cca(v2,0) == 34 ? v2.substring(1,v2.length - 1) : v2);
						break;
					case "x":
						var v3 = reg.matched(2);
						x = Std.parseInt(HxOverrides.cca(v3,0) == 34 ? v3.substring(1,v3.length - 1) : v3);
						break;
					case "xadvance":
						var v4 = reg.matched(2);
						xadvance = Std.parseInt(HxOverrides.cca(v4,0) == 34 ? v4.substring(1,v4.length - 1) : v4);
						break;
					case "xoffset":
						var v5 = reg.matched(2);
						xoffset = Std.parseInt(HxOverrides.cca(v5,0) == 34 ? v5.substring(1,v5.length - 1) : v5);
						break;
					case "y":
						var v6 = reg.matched(2);
						y = Std.parseInt(HxOverrides.cca(v6,0) == 34 ? v6.substring(1,v6.length - 1) : v6);
						break;
					case "yoffset":
						var v7 = reg.matched(2);
						yoffset = Std.parseInt(HxOverrides.cca(v7,0) == 34 ? v7.substring(1,v7.length - 1) : v7);
						break;
					}
					var pos = reg.matchedPos();
					idx = pos.pos + pos.len;
				}
				var t = tile.sub(x,y,width,height,xoffset,yoffset);
				var fc = new h2d_FontChar(t,xadvance);
				glyphs.h[id] = fc;
				break;
			case "common":
				while(idx < line.length && reg.matchSub(line,idx)) {
					switch(reg.matched(1)) {
					case "base":
						var v8 = reg.matched(2);
						font.baseLine = Std.parseInt(HxOverrides.cca(v8,0) == 34 ? v8.substring(1,v8.length - 1) : v8);
						break;
					case "lineHeight":
						var v9 = reg.matched(2);
						font.lineHeight = Std.parseInt(HxOverrides.cca(v9,0) == 34 ? v9.substring(1,v9.length - 1) : v9);
						break;
					case "pages":
						var v10 = reg.matched(2);
						pageCount = Std.parseInt(HxOverrides.cca(v10,0) == 34 ? v10.substring(1,v10.length - 1) : v10);
						if(pageCount != 1) {
							haxe_Log.trace("Warning: BMF format only supports one page at the moment.",{ fileName : "hxd/fmt/bfnt/FontParser.hx", lineNumber : 157, className : "hxd.fmt.bfnt.FontParser", methodName : "parse"});
						}
						break;
					}
					var pos1 = reg.matchedPos();
					idx = pos1.pos + pos1.len;
				}
				break;
			case "info":
				while(idx < line.length && reg.matchSub(line,idx)) {
					switch(reg.matched(1)) {
					case "face":
						var v11 = reg.matched(2);
						font.name = HxOverrides.cca(v11,0) == 34 ? v11.substring(1,v11.length - 1) : v11;
						break;
					case "size":
						var v12 = reg.matched(2);
						font.size = font.initSize = Std.parseInt(HxOverrides.cca(v12,0) == 34 ? v12.substring(1,v12.length - 1) : v12);
						break;
					}
					var pos2 = reg.matchedPos();
					idx = pos2.pos + pos2.len;
				}
				break;
			case "kerning":
				var first = 0;
				var second = 0;
				var advance = 0;
				while(idx < line.length && reg.matchSub(line,idx)) {
					switch(reg.matched(1)) {
					case "amount":
						var v13 = reg.matched(2);
						advance = Std.parseInt(HxOverrides.cca(v13,0) == 34 ? v13.substring(1,v13.length - 1) : v13);
						break;
					case "first":
						var v14 = reg.matched(2);
						first = Std.parseInt(HxOverrides.cca(v14,0) == 34 ? v14.substring(1,v14.length - 1) : v14);
						break;
					case "second":
						var v15 = reg.matched(2);
						second = Std.parseInt(HxOverrides.cca(v15,0) == 34 ? v15.substring(1,v15.length - 1) : v15);
						break;
					}
					var pos3 = reg.matchedPos();
					idx = pos3.pos + pos3.len;
				}
				var fc1 = glyphs.h[second];
				if(fc1 != null) {
					fc1.addKerning(first,advance);
				}
				break;
			case "page":
				while(idx < line.length && reg.matchSub(line,idx)) {
					if(reg.matched(1) == "file") {
						var v16 = reg.matched(2);
						var tilePath = HxOverrides.cca(v16,0) == 34 ? v16.substring(1,v16.length - 1) : v16;
						try {
							font.tilePath = tilePath;
							tile = resolveTile(haxe_io_Path.join([haxe_io_Path.directory(path),tilePath]));
						} catch( _g2 ) {
							haxe_Log.trace("Warning: Could not find referenced font texture at \"" + tilePath + "\", trying to resolve same name as fnt!",{ fileName : "hxd/fmt/bfnt/FontParser.hx", lineNumber : 30, className : "hxd.fmt.bfnt.FontParser", methodName : "parse"});
							font.tilePath = new haxe_io_Path(path).file + ".png";
							tile = resolveTile(haxe_io_Path.withExtension(path,"png"));
						}
					}
					var pos4 = reg.matchedPos();
					idx = pos4.pos + pos4.len;
				}
				break;
			}
		}
		break;
	default:
		var sign = _g;
		throw haxe_Exception.thrown("Unknown font signature " + StringTools.hex(sign,8));
	}
	if(glyphs.h[32] == null) {
		var value = new h2d_FontChar(tile.sub(0,0,0,0),font.size >> 1);
		glyphs.h[32] = value;
	}
	font.tile = tile;
	if(font.baseLine == 0) {
		var padding = 0;
		var space = glyphs.h[32];
		if(space != null) {
			padding = space.t.height * .5;
		}
		var a = glyphs.h[65];
		if(a == null) {
			a = glyphs.h[97];
		}
		if(a == null) {
			a = glyphs.h[48];
		}
		if(a == null) {
			font.baseLine = font.lineHeight - 2 - padding;
		} else {
			font.baseLine = a.t.dy + a.t.height - padding;
		}
	}
	var fallback = glyphs.h[65533];
	if(fallback == null) {
		fallback = glyphs.h[9633];
	}
	if(fallback == null) {
		fallback = glyphs.h[63];
	}
	if(fallback != null) {
		font.defaultChar = fallback;
	}
	return font;
};
var hxd_fmt_bfnt_Reader = function(i) {
	this.i = i;
};
$hxClasses["hxd.fmt.bfnt.Reader"] = hxd_fmt_bfnt_Reader;
hxd_fmt_bfnt_Reader.__name__ = "hxd.fmt.bfnt.Reader";
hxd_fmt_bfnt_Reader.prototype = {
	read: function(resolveTile) {
		if(this.i.readString(4) != "BFNT" || this.i.readByte() != 0) {
			throw haxe_Exception.thrown("Not a BFNT file!");
		}
		var font = null;
		var _g = this.i.readByte();
		if(_g == 1) {
			font = new h2d_Font(this.i.readString(this.i.readUInt16()),this.i.readInt16());
			font.tilePath = this.i.readString(this.i.readUInt16());
			var tile = font.tile = resolveTile(font.tilePath);
			font.lineHeight = this.i.readInt16();
			font.baseLine = this.i.readInt16();
			var defaultChar = this.i.readInt32();
			var id;
			while(true) {
				id = this.i.readInt32();
				if(!(id != 0)) {
					break;
				}
				var t = tile.sub(this.i.readUInt16(),this.i.readUInt16(),this.i.readUInt16(),this.i.readUInt16(),this.i.readInt16(),this.i.readInt16());
				var glyph = new h2d_FontChar(t,this.i.readInt16());
				font.glyphs.h[id] = glyph;
				if(id == defaultChar) {
					font.defaultChar = glyph;
				}
				var prevChar;
				while(true) {
					prevChar = this.i.readInt32();
					if(!(prevChar != 0)) {
						break;
					}
					glyph.addKerning(prevChar,this.i.readInt16());
				}
			}
		} else {
			var ver = _g;
			throw haxe_Exception.thrown("Unknown BFNT version: " + ver);
		}
		return font;
	}
	,__class__: hxd_fmt_bfnt_Reader
};
var hxd_fmt_hdr_Reader = function() { };
$hxClasses["hxd.fmt.hdr.Reader"] = hxd_fmt_hdr_Reader;
hxd_fmt_hdr_Reader.__name__ = "hxd.fmt.hdr.Reader";
hxd_fmt_hdr_Reader.decode = function(bytes,sRGB) {
	var f = new haxe_io_BytesInput(bytes);
	var width = 0;
	var height = 0;
	var keys_h = Object.create(null);
	while(true) {
		var line = f.readLine();
		if(line == "") {
			break;
		}
		if(HxOverrides.cca(line,0) == 35) {
			continue;
		}
		var nameValue = line.split("=");
		if(nameValue.length > 1) {
			keys_h[nameValue.shift()] = nameValue.join("=");
		}
	}
	var parts = f.readLine().split(" ");
	height = Std.parseInt(parts[1]);
	width = Std.parseInt(parts[3]);
	var gamma = keys_h["GAMMA"] == "1";
	var data = new haxe_io_Bytes(new ArrayBuffer(width * height * 4 * 4));
	var exposure = 1.0;
	var exp = keys_h["EXPOSURE"];
	if(exp != null) {
		var exp1 = parseFloat(exp);
		if(exp1 < 1e-12 || exp1 < 1e12) {
			exposure = exp1;
		}
	}
	var gammaCorrect = sRGB ? 1 : 0.45454545454545453;
	var _g = [];
	var _g1 = 0;
	while(_g1 < 256) {
		var e = _g1++;
		_g.push(Math.pow(e,gammaCorrect));
	}
	var gammaVals = _g;
	var _g = [];
	var _g1 = 0;
	while(_g1 < 256) {
		var e = _g1++;
		_g.push(Math.pow(Math.pow(2,e - 128) / (256 * exposure),gammaCorrect));
	}
	var exps = _g;
	var _g = keys_h["FORMAT"];
	if(_g == null) {
		var fmt = _g;
		throw haxe_Exception.thrown("Unsupported HDR format " + fmt);
	} else if(_g == "32-bit_rle_rgbe") {
		var dataPos = f.pos;
		var scanLen = width * 4;
		var scanLine = new haxe_io_Bytes(new ArrayBuffer(scanLen));
		var widthBE = width >> 8 | (width & 255) << 8;
		var _g1 = 0;
		var _g2 = height;
		while(_g1 < _g2) {
			var y = _g1++;
			var h = bytes.getInt32(dataPos);
			if((h & 65535) != 514 || h >>> 16 != widthBE) {
				scanLine.blit(0,bytes,dataPos,width * 4);
				dataPos += width * 4;
			} else {
				dataPos += 4;
				var p = 0;
				var end = width * 4;
				while(p < end) {
					var len = bytes.b[dataPos++];
					if(len > 128) {
						len -= 128;
						scanLine.fill(p,len,bytes.b[dataPos++]);
					} else {
						scanLine.blit(p,bytes,dataPos,len);
						dataPos += len;
					}
					p += len;
				}
			}
			var pos = y * width * 16;
			var _g3 = 0;
			var _g4 = width;
			while(_g3 < _g4) {
				var x = _g3++;
				var e = exps[scanLine.b[x + width * 3]];
				data.setFloat(pos,gammaVals[scanLine.b[x]] * e);
				pos += 4;
				data.setFloat(pos,gammaVals[scanLine.b[x + width]] * e);
				pos += 4;
				data.setFloat(pos,gammaVals[scanLine.b[x + (width << 1)]] * e);
				pos += 4;
				data.setFloat(pos,1.0);
				pos += 4;
			}
		}
	} else {
		var fmt = _g;
		throw haxe_Exception.thrown("Unsupported HDR format " + fmt);
	}
	return { width : width, height : height, bytes : data, gamma : gamma};
};
var hxd_fs_FileEntry = function() { };
$hxClasses["hxd.fs.FileEntry"] = hxd_fs_FileEntry;
hxd_fs_FileEntry.__name__ = "hxd.fs.FileEntry";
hxd_fs_FileEntry.prototype = {
	getBytes: function() {
		return null;
	}
	,readBytes: function(out,outPos,pos,len) {
		throw haxe_Exception.thrown("readBytes() not implemented");
	}
	,fetchBytes: function(pos,len) {
		var bytes = hxd_fs_FileEntry.TMP_BYTES;
		if(bytes == null || bytes.length < len) {
			var allocSize = len + 65535 & -65536;
			bytes = new haxe_io_Bytes(new ArrayBuffer(allocSize));
			hxd_fs_FileEntry.TMP_BYTES = bytes;
		}
		this.readFull(bytes,pos,len);
		return bytes;
	}
	,readFull: function(bytes,pos,len) {
		if(this.readBytes(bytes,0,pos,len) < len) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
	}
	,open: function() {
		return new hxd_fs_FileInput(this);
	}
	,load: function(onReady) {
		if(!this.get_isAvailable()) {
			throw haxe_Exception.thrown("load() not implemented");
		} else if(onReady != null) {
			onReady();
		}
	}
	,loadBitmap: function(onLoaded) {
		throw haxe_Exception.thrown("loadBitmap() not implemented");
	}
	,watch: function(onChanged) {
	}
	,get_isAvailable: function() {
		return true;
	}
	,get_size: function() {
		return 0;
	}
	,get_path: function() {
		throw haxe_Exception.thrown("path() not implemented");
	}
	,get_extension: function() {
		var idx = this.name.lastIndexOf(".");
		if(idx < 0) {
			return "";
		}
		return HxOverrides.substr(this.name,idx + 1,null).toLowerCase();
	}
	,__class__: hxd_fs_FileEntry
};
var hxd_fs_FileSystem = function() { };
$hxClasses["hxd.fs.FileSystem"] = hxd_fs_FileSystem;
hxd_fs_FileSystem.__name__ = "hxd.fs.FileSystem";
hxd_fs_FileSystem.__isInterface__ = true;
hxd_fs_FileSystem.prototype = {
	__class__: hxd_fs_FileSystem
};
var hxd_fs__$EmbedFileSystem_EmbedEntry = function(fs,name,relPath,data) {
	this.fs = fs;
	this.name = name;
	this.relPath = relPath;
	this.data = data;
};
$hxClasses["hxd.fs._EmbedFileSystem.EmbedEntry"] = hxd_fs__$EmbedFileSystem_EmbedEntry;
hxd_fs__$EmbedFileSystem_EmbedEntry.__name__ = "hxd.fs._EmbedFileSystem.EmbedEntry";
hxd_fs__$EmbedFileSystem_EmbedEntry.__super__ = hxd_fs_FileEntry;
hxd_fs__$EmbedFileSystem_EmbedEntry.prototype = $extend(hxd_fs_FileEntry.prototype,{
	init: function() {
		if(this.bytes == null) {
			this.bytes = haxe_Resource.getBytes(this.data);
			if(this.bytes == null) {
				throw haxe_Exception.thrown("Missing resource " + this.data);
			}
		}
	}
	,getBytes: function() {
		if(this.bytes == null) {
			this.init();
		}
		return this.bytes;
	}
	,readBytes: function(out,outPos,pos,len) {
		if(this.bytes == null) {
			this.init();
		}
		if(pos + len > this.bytes.length) {
			len = this.bytes.length - pos;
		}
		if(len < 0) {
			len = 0;
		}
		out.blit(outPos,this.bytes,pos,len);
		return len;
	}
	,load: function(onReady) {
		if(onReady != null) {
			haxe_Timer.delay(onReady,1);
		}
	}
	,loadBitmap: function(onLoaded) {
		var rawData = null;
		var _g = 0;
		var _g1 = haxe_Resource.content;
		while(_g < _g1.length) {
			var res = _g1[_g];
			++_g;
			if(res.name == this.data) {
				rawData = res.data;
				break;
			}
		}
		if(rawData == null) {
			throw haxe_Exception.thrown("Missing resource " + this.data);
		}
		var image = new Image();
		image.onload = function(_) {
			var this1 = image;
			onLoaded(this1);
		};
		var extra = "";
		var bytes = rawData.length * 6 >> 3;
		var _g = 0;
		var _g1 = (3 - bytes * 4 % 3) % 3;
		while(_g < _g1) {
			var i = _g++;
			extra += "=";
		}
		var tmp = "data:image/" + this.get_extension() + ";base64," + rawData;
		image.src = tmp + extra;
	}
	,get_path: function() {
		if(this.relPath == ".") {
			return "<root>";
		} else {
			return this.relPath;
		}
	}
	,get_size: function() {
		this.init();
		return this.bytes.length;
	}
	,__class__: hxd_fs__$EmbedFileSystem_EmbedEntry
});
var hxd_fs_EmbedFileSystem = function(root) {
	this.root = root;
};
$hxClasses["hxd.fs.EmbedFileSystem"] = hxd_fs_EmbedFileSystem;
hxd_fs_EmbedFileSystem.__name__ = "hxd.fs.EmbedFileSystem";
hxd_fs_EmbedFileSystem.__interfaces__ = [hxd_fs_FileSystem];
hxd_fs_EmbedFileSystem.resolve = function(path) {
	return "R_" + path.replace(hxd_fs_EmbedFileSystem.invalidChars.r,"_");
};
hxd_fs_EmbedFileSystem.prototype = {
	splitPath: function(path) {
		if(path == ".") {
			return [];
		} else {
			return path.split("/");
		}
	}
	,exists: function(path) {
		var r = this.root;
		var _g = 0;
		var _g1 = this.splitPath(path);
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			r = Reflect.field(r,p);
			if(r == null) {
				return false;
			}
		}
		return true;
	}
	,get: function(path) {
		if(!this.exists(path)) {
			throw haxe_Exception.thrown(new hxd_fs_NotFound(path));
		}
		var id = hxd_fs_EmbedFileSystem.resolve(path);
		return new hxd_fs__$EmbedFileSystem_EmbedEntry(this,path.split("/").pop(),path,id);
	}
	,__class__: hxd_fs_EmbedFileSystem
};
var hxd_fs_FileInput = function(entry) {
	this.nextReadPos = 0;
	this.cacheLen = 0;
	this.cachePos = 0;
	this.entry = entry;
};
$hxClasses["hxd.fs.FileInput"] = hxd_fs_FileInput;
hxd_fs_FileInput.__name__ = "hxd.fs.FileInput";
hxd_fs_FileInput.__super__ = haxe_io_Input;
hxd_fs_FileInput.prototype = $extend(haxe_io_Input.prototype,{
	fetch: function(dataSize) {
		if(dataSize == null) {
			dataSize = 256;
		}
		var prev = this.cache;
		if(this.cache == null || this.cache.length < dataSize) {
			this.cache = hxd_fs_FileInput.PREFETCH_CACHE;
			if(this.cache != null && this.cache.length >= dataSize) {
				hxd_fs_FileInput.PREFETCH_CACHE = null;
			} else {
				this.cache = new haxe_io_Bytes(new ArrayBuffer(dataSize));
			}
		}
		var startPos = 0;
		if(this.cacheLen > 0) {
			startPos = this.cacheLen;
			dataSize -= this.cacheLen;
			this.cache.blit(0,prev,this.cachePos,this.cacheLen);
		}
		var read = this.entry.readBytes(this.cache,startPos,this.nextReadPos,dataSize);
		this.cachePos = 0;
		this.cacheLen = startPos + read;
		this.nextReadPos += read;
		if(this.cacheLen == 0) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
	}
	,skip: function(nbytes) {
		if(this.cacheLen > 0) {
			var a = this.cacheLen;
			var k = a > nbytes ? nbytes : a;
			this.cachePos += k;
			this.cacheLen -= k;
			nbytes -= k;
		}
		this.nextReadPos += nbytes;
	}
	,readByte: function() {
		if(this.cacheLen == 0) {
			this.fetch();
		}
		var b = this.cache.b[this.cachePos++];
		this.cacheLen--;
		return b;
	}
	,readBytes: function(b,pos,len) {
		var tot = 0;
		if(len < 256 && this.cacheLen < len) {
			this.fetch();
		}
		if(this.cacheLen > 0) {
			var b1 = this.cacheLen;
			var k = len > b1 ? b1 : len;
			b.blit(pos,this.cache,this.cachePos,k);
			this.cachePos += k;
			this.cacheLen -= k;
			len -= k;
			if(len == 0) {
				return k;
			}
			pos += k;
			tot += k;
		}
		if(len > 0) {
			var k = this.entry.readBytes(b,pos,this.nextReadPos,len);
			this.nextReadPos += k;
			tot += k;
		}
		return tot;
	}
	,close: function() {
		if(this.cache != null && (hxd_fs_FileInput.PREFETCH_CACHE == null || hxd_fs_FileInput.PREFETCH_CACHE.length < this.cache.length)) {
			hxd_fs_FileInput.PREFETCH_CACHE = this.cache;
		}
		this.cache = null;
		this.cacheLen = 0;
	}
	,__class__: hxd_fs_FileInput
});
var hxd_fs_LoadedBitmap = {};
hxd_fs_LoadedBitmap.toBitmap = function(this1) {
	var bmp = new hxd_BitmapData(this1.width,this1.height);
	bmp.ctx.drawImage(this1,0,0);
	return bmp;
};
var hxd_fs_NotFound = function(path) {
	this.path = path;
};
$hxClasses["hxd.fs.NotFound"] = hxd_fs_NotFound;
hxd_fs_NotFound.__name__ = "hxd.fs.NotFound";
hxd_fs_NotFound.prototype = {
	toString: function() {
		return "Resource file not found '" + this.path + "'";
	}
	,__class__: hxd_fs_NotFound
};
var hxd_impl_Allocator = function() {
};
$hxClasses["hxd.impl.Allocator"] = hxd_impl_Allocator;
hxd_impl_Allocator.__name__ = "hxd.impl.Allocator";
hxd_impl_Allocator.get = function() {
	if(hxd_impl_Allocator.inst == null) {
		hxd_impl_Allocator.inst = new hxd_impl_Allocator();
	}
	return hxd_impl_Allocator.inst;
};
hxd_impl_Allocator.prototype = {
	allocBuffer: function(vertices,stride,flags) {
		var tmp;
		switch(flags) {
		case 0:
			tmp = [h3d_BufferFlag.Dynamic];
			break;
		case 1:
			tmp = [h3d_BufferFlag.UniformBuffer,h3d_BufferFlag.Dynamic];
			break;
		case 2:
			tmp = [h3d_BufferFlag.RawFormat];
			break;
		case 3:
			tmp = [h3d_BufferFlag.Quads,h3d_BufferFlag.RawFormat];
			break;
		}
		return new h3d_Buffer(vertices,stride,tmp);
	}
	,ofFloats: function(v,stride,flags) {
		var nvert = v.pos / stride | 0;
		return this.ofSubFloats(v,stride,nvert,flags);
	}
	,ofSubFloats: function(v,stride,vertices,flags) {
		var b = this.allocBuffer(vertices,stride,flags);
		b.uploadVector(v,0,vertices);
		return b;
	}
	,disposeBuffer: function(b) {
		b.dispose();
	}
	,allocIndexBuffer: function(count) {
		return new h3d_Indexes(count);
	}
	,ofIndexes: function(ib,length) {
		if(length == null) {
			length = -1;
		}
		if(length < 0 && ib != null) {
			length = ib.length;
		}
		var idx = this.allocIndexBuffer(length);
		idx.upload(ib,0,length);
		return idx;
	}
	,disposeIndexBuffer: function(i) {
		i.dispose();
	}
	,onContextLost: function() {
	}
	,__class__: hxd_impl_Allocator
};
var hxd_impl_ArrayIterator_$hxd_$snd_$Channel = function(a) {
	this.i = 0;
	this.a = a;
	this.l = this.a.length;
};
$hxClasses["hxd.impl.ArrayIterator_hxd_snd_Channel"] = hxd_impl_ArrayIterator_$hxd_$snd_$Channel;
hxd_impl_ArrayIterator_$hxd_$snd_$Channel.__name__ = "hxd.impl.ArrayIterator_hxd_snd_Channel";
hxd_impl_ArrayIterator_$hxd_$snd_$Channel.prototype = {
	hasNext: function() {
		return this.i < this.l;
	}
	,next: function() {
		return this.a[this.i++];
	}
	,__class__: hxd_impl_ArrayIterator_$hxd_$snd_$Channel
};
var hxd_impl_AsyncLoader = function() { };
$hxClasses["hxd.impl.AsyncLoader"] = hxd_impl_AsyncLoader;
hxd_impl_AsyncLoader.__name__ = "hxd.impl.AsyncLoader";
hxd_impl_AsyncLoader.__isInterface__ = true;
hxd_impl_AsyncLoader.prototype = {
	__class__: hxd_impl_AsyncLoader
};
var hxd_res_Resource = function(entry) {
	this.entry = entry;
};
$hxClasses["hxd.res.Resource"] = hxd_res_Resource;
hxd_res_Resource.__name__ = "hxd.res.Resource";
hxd_res_Resource.prototype = {
	toString: function() {
		return this.entry.get_path();
	}
	,watch: function(onChanged) {
		if(hxd_res_Resource.LIVE_UPDATE) {
			this.entry.watch(onChanged);
		}
	}
	,__class__: hxd_res_Resource
};
var hxd_res_Any = function(loader,entry) {
	hxd_res_Resource.call(this,entry);
	this.loader = loader;
};
$hxClasses["hxd.res.Any"] = hxd_res_Any;
hxd_res_Any.__name__ = "hxd.res.Any";
hxd_res_Any.__super__ = hxd_res_Resource;
hxd_res_Any.prototype = $extend(hxd_res_Resource.prototype,{
	toTile: function() {
		return this.toImage().toTile();
	}
	,toImage: function() {
		return this.loader.loadCache(this.entry.get_path(),hxd_res_Image);
	}
	,toSound: function() {
		return this.loader.loadCache(this.entry.get_path(),hxd_res_Sound);
	}
	,__class__: hxd_res_Any
});
var hxd_res_BitmapFont = function(entry) {
	hxd_res_Resource.call(this,entry);
	this.loader = hxd_res_Loader.currentInstance;
};
$hxClasses["hxd.res.BitmapFont"] = hxd_res_BitmapFont;
hxd_res_BitmapFont.__name__ = "hxd.res.BitmapFont";
hxd_res_BitmapFont.__super__ = hxd_res_Resource;
hxd_res_BitmapFont.prototype = $extend(hxd_res_Resource.prototype,{
	toFont: function() {
		if(this.font == null) {
			this.font = hxd_fmt_bfnt_FontParser.parse(this.entry.getBytes(),this.entry.get_path(),$bind(this,this.resolveTile));
		}
		return this.font;
	}
	,resolveTile: function(path) {
		return this.loader.load(path).toTile();
	}
	,__class__: hxd_res_BitmapFont
});
var hxd_res_ImageFormat = {};
hxd_res_ImageFormat.getName = function(this1) {
	switch(this1) {
	case 0:
		return "JPG";
	case 1:
		return "PNG";
	case 2:
		return "GIF";
	case 3:
		return "TGA";
	case 4:
		return "DDS";
	case 5:
		return "RAW";
	case 6:
		return "HDR";
	}
};
var hxd_res_ImageInfoFlag = $hxEnums["hxd.res.ImageInfoFlag"] = { __ename__:true,__constructs__:null
	,IsCube: {_hx_name:"IsCube",_hx_index:0,__enum__:"hxd.res.ImageInfoFlag",toString:$estr}
	,Dxt10Header: {_hx_name:"Dxt10Header",_hx_index:1,__enum__:"hxd.res.ImageInfoFlag",toString:$estr}
};
hxd_res_ImageInfoFlag.__constructs__ = [hxd_res_ImageInfoFlag.IsCube,hxd_res_ImageInfoFlag.Dxt10Header];
hxd_res_ImageInfoFlag.__empty_constructs__ = [hxd_res_ImageInfoFlag.IsCube,hxd_res_ImageInfoFlag.Dxt10Header];
var hxd_res_ImageInfo = function() {
	this.layerCount = 1;
	this.mipLevels = 1;
	this.height = 0;
	this.width = 0;
	var this1 = 0;
	this.flags = this1;
};
$hxClasses["hxd.res.ImageInfo"] = hxd_res_ImageInfo;
hxd_res_ImageInfo.__name__ = "hxd.res.ImageInfo";
hxd_res_ImageInfo.prototype = {
	__class__: hxd_res_ImageInfo
};
var hxd_res_Image = function(entry) {
	hxd_res_Resource.call(this,entry);
};
$hxClasses["hxd.res.Image"] = hxd_res_Image;
hxd_res_Image.__name__ = "hxd.res.Image";
hxd_res_Image.setupTextureFlags = function(tex) {
};
hxd_res_Image.__super__ = hxd_res_Resource;
hxd_res_Image.prototype = $extend(hxd_res_Resource.prototype,{
	getInfo: function() {
		if(this.inf != null) {
			return this.inf;
		}
		this.inf = new hxd_res_ImageInfo();
		var f = this.entry.open();
		f.fetch(256);
		var head;
		try {
			head = f.readUInt16();
		} catch( _g ) {
			if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
				head = 0;
			} else {
				throw _g;
			}
		}
		switch(head) {
		case 16163:
			this.inf.dataFormat = 6;
			while(f.readLine() != "") {
			}
			var parts = f.readLine().split(" ");
			this.inf.pixelFormat = hxd_PixelFormat.RGBA32F;
			this.inf.height = Std.parseInt(parts[1]);
			this.inf.width = Std.parseInt(parts[3]);
			break;
		case 17476:
			this.inf.dataFormat = 4;
			f.skip(10);
			this.inf.height = f.readInt32();
			this.inf.width = f.readInt32();
			f.skip(8);
			this.inf.mipLevels = f.readInt32();
			f.skip(48);
			var caps = f.readInt32();
			var fourCC = f.readInt32();
			var bpp = f.readInt32();
			var rMask = f.readInt32();
			var gMask = f.readInt32();
			var bMask = f.readInt32();
			var aMask = f.readInt32();
			var caps2 = f.readInt32();
			var cubes = f.readInt32();
			if((cubes & 65024) == 65024) {
				this.inf.flags |= 1 << hxd_res_ImageInfoFlag.IsCube._hx_index;
			}
			switch(fourCC & 16777215) {
			case 0:
				if(fourCC == 808540228) {
					f.skip(12);
					this.inf.flags |= 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index;
					var dxgi = f.readInt32();
					var tmp;
					switch(dxgi) {
					case 28:
						tmp = hxd_PixelFormat.RGBA;
						break;
					case 71:
						tmp = hxd_PixelFormat.S3TC(1);
						break;
					case 74:
						tmp = hxd_PixelFormat.S3TC(2);
						break;
					case 77:
						tmp = hxd_PixelFormat.S3TC(3);
						break;
					case 95:
						tmp = hxd_PixelFormat.S3TC(6);
						break;
					case 98:
						tmp = hxd_PixelFormat.S3TC(7);
						break;
					default:
						throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported DXGI format " + dxgi);
					}
					this.inf.pixelFormat = tmp;
					var imgType = f.readInt32();
					f.skip(4);
					this.inf.layerCount = f.readInt32();
				} else if((caps & 64) != 0) {
					if(bpp == 32) {
						switch(rMask) {
						case 255:
							if(gMask == 65280) {
								if(bMask == 16711680) {
									if(aMask == -16777216) {
										this.inf.pixelFormat = hxd_PixelFormat.RGBA;
									} else {
										throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
									}
								} else {
									throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
								}
							} else {
								throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
							}
							break;
						case 16711680:
							if(gMask == 65280) {
								if(bMask == 255) {
									if(aMask == -16777216) {
										this.inf.pixelFormat = hxd_PixelFormat.BGRA;
									} else {
										throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
									}
								} else {
									throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
								}
							} else {
								throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
							}
							break;
						default:
							throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
						}
					} else {
						throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
					}
				}
				break;
			case 111:
				if(fourCC == 808540228) {
					f.skip(12);
					this.inf.flags |= 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index;
					var dxgi = f.readInt32();
					var tmp;
					switch(dxgi) {
					case 28:
						tmp = hxd_PixelFormat.RGBA;
						break;
					case 71:
						tmp = hxd_PixelFormat.S3TC(1);
						break;
					case 74:
						tmp = hxd_PixelFormat.S3TC(2);
						break;
					case 77:
						tmp = hxd_PixelFormat.S3TC(3);
						break;
					case 95:
						tmp = hxd_PixelFormat.S3TC(6);
						break;
					case 98:
						tmp = hxd_PixelFormat.S3TC(7);
						break;
					default:
						throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported DXGI format " + dxgi);
					}
					this.inf.pixelFormat = tmp;
					var imgType = f.readInt32();
					f.skip(4);
					this.inf.layerCount = f.readInt32();
				} else {
					this.inf.pixelFormat = hxd_PixelFormat.R16F;
				}
				break;
			case 112:
				if(fourCC == 808540228) {
					f.skip(12);
					this.inf.flags |= 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index;
					var dxgi = f.readInt32();
					var tmp;
					switch(dxgi) {
					case 28:
						tmp = hxd_PixelFormat.RGBA;
						break;
					case 71:
						tmp = hxd_PixelFormat.S3TC(1);
						break;
					case 74:
						tmp = hxd_PixelFormat.S3TC(2);
						break;
					case 77:
						tmp = hxd_PixelFormat.S3TC(3);
						break;
					case 95:
						tmp = hxd_PixelFormat.S3TC(6);
						break;
					case 98:
						tmp = hxd_PixelFormat.S3TC(7);
						break;
					default:
						throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported DXGI format " + dxgi);
					}
					this.inf.pixelFormat = tmp;
					var imgType = f.readInt32();
					f.skip(4);
					this.inf.layerCount = f.readInt32();
				} else {
					this.inf.pixelFormat = hxd_PixelFormat.RG16F;
				}
				break;
			case 113:
				if(fourCC == 808540228) {
					f.skip(12);
					this.inf.flags |= 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index;
					var dxgi = f.readInt32();
					var tmp;
					switch(dxgi) {
					case 28:
						tmp = hxd_PixelFormat.RGBA;
						break;
					case 71:
						tmp = hxd_PixelFormat.S3TC(1);
						break;
					case 74:
						tmp = hxd_PixelFormat.S3TC(2);
						break;
					case 77:
						tmp = hxd_PixelFormat.S3TC(3);
						break;
					case 95:
						tmp = hxd_PixelFormat.S3TC(6);
						break;
					case 98:
						tmp = hxd_PixelFormat.S3TC(7);
						break;
					default:
						throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported DXGI format " + dxgi);
					}
					this.inf.pixelFormat = tmp;
					var imgType = f.readInt32();
					f.skip(4);
					this.inf.layerCount = f.readInt32();
				} else {
					this.inf.pixelFormat = hxd_PixelFormat.RGBA16F;
				}
				break;
			case 114:
				if(fourCC == 808540228) {
					f.skip(12);
					this.inf.flags |= 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index;
					var dxgi = f.readInt32();
					var tmp;
					switch(dxgi) {
					case 28:
						tmp = hxd_PixelFormat.RGBA;
						break;
					case 71:
						tmp = hxd_PixelFormat.S3TC(1);
						break;
					case 74:
						tmp = hxd_PixelFormat.S3TC(2);
						break;
					case 77:
						tmp = hxd_PixelFormat.S3TC(3);
						break;
					case 95:
						tmp = hxd_PixelFormat.S3TC(6);
						break;
					case 98:
						tmp = hxd_PixelFormat.S3TC(7);
						break;
					default:
						throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported DXGI format " + dxgi);
					}
					this.inf.pixelFormat = tmp;
					var imgType = f.readInt32();
					f.skip(4);
					this.inf.layerCount = f.readInt32();
				} else {
					this.inf.pixelFormat = hxd_PixelFormat.R32F;
				}
				break;
			case 115:
				if(fourCC == 808540228) {
					f.skip(12);
					this.inf.flags |= 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index;
					var dxgi = f.readInt32();
					var tmp;
					switch(dxgi) {
					case 28:
						tmp = hxd_PixelFormat.RGBA;
						break;
					case 71:
						tmp = hxd_PixelFormat.S3TC(1);
						break;
					case 74:
						tmp = hxd_PixelFormat.S3TC(2);
						break;
					case 77:
						tmp = hxd_PixelFormat.S3TC(3);
						break;
					case 95:
						tmp = hxd_PixelFormat.S3TC(6);
						break;
					case 98:
						tmp = hxd_PixelFormat.S3TC(7);
						break;
					default:
						throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported DXGI format " + dxgi);
					}
					this.inf.pixelFormat = tmp;
					var imgType = f.readInt32();
					f.skip(4);
					this.inf.layerCount = f.readInt32();
				} else {
					this.inf.pixelFormat = hxd_PixelFormat.RG32F;
				}
				break;
			case 116:
				if(fourCC == 808540228) {
					f.skip(12);
					this.inf.flags |= 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index;
					var dxgi = f.readInt32();
					var tmp;
					switch(dxgi) {
					case 28:
						tmp = hxd_PixelFormat.RGBA;
						break;
					case 71:
						tmp = hxd_PixelFormat.S3TC(1);
						break;
					case 74:
						tmp = hxd_PixelFormat.S3TC(2);
						break;
					case 77:
						tmp = hxd_PixelFormat.S3TC(3);
						break;
					case 95:
						tmp = hxd_PixelFormat.S3TC(6);
						break;
					case 98:
						tmp = hxd_PixelFormat.S3TC(7);
						break;
					default:
						throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported DXGI format " + dxgi);
					}
					this.inf.pixelFormat = tmp;
					var imgType = f.readInt32();
					f.skip(4);
					this.inf.layerCount = f.readInt32();
				} else {
					this.inf.pixelFormat = hxd_PixelFormat.RGBA32F;
				}
				break;
			case 4805697:
				var v = (fourCC >>> 24) - 48;
				var tmp;
				switch(v) {
				case 1:
					tmp = hxd_PixelFormat.S3TC(4);
					break;
				case 2:
					tmp = hxd_PixelFormat.S3TC(5);
					break;
				default:
					tmp = null;
				}
				this.inf.pixelFormat = tmp;
				break;
			case 5527620:
				var dxt = (fourCC >>> 24) - 48;
				var tmp;
				switch(dxt) {
				case 1:
					tmp = hxd_PixelFormat.S3TC(1);
					break;
				case 2:case 3:
					tmp = hxd_PixelFormat.S3TC(2);
					break;
				case 4:case 5:
					tmp = hxd_PixelFormat.S3TC(3);
					break;
				default:
					tmp = null;
				}
				this.inf.pixelFormat = tmp;
				break;
			default:
				if(fourCC == 808540228) {
					f.skip(12);
					this.inf.flags |= 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index;
					var dxgi = f.readInt32();
					var tmp;
					switch(dxgi) {
					case 28:
						tmp = hxd_PixelFormat.RGBA;
						break;
					case 71:
						tmp = hxd_PixelFormat.S3TC(1);
						break;
					case 74:
						tmp = hxd_PixelFormat.S3TC(2);
						break;
					case 77:
						tmp = hxd_PixelFormat.S3TC(3);
						break;
					case 95:
						tmp = hxd_PixelFormat.S3TC(6);
						break;
					case 98:
						tmp = hxd_PixelFormat.S3TC(7);
						break;
					default:
						throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported DXGI format " + dxgi);
					}
					this.inf.pixelFormat = tmp;
					var imgType = f.readInt32();
					f.skip(4);
					this.inf.layerCount = f.readInt32();
				}
			}
			if(this.inf.pixelFormat == null) {
				var fid = String.fromCodePoint((fourCC & 255)) + String.fromCodePoint((fourCC >> 8 & 255)) + String.fromCodePoint((fourCC >> 16 & 255)) + String.fromCodePoint((fourCC >>> 24));
				if((fourCC & 255) == fourCC) {
					fid = "0x" + fourCC;
				}
				throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported 4CC " + fid);
			}
			break;
		case 18759:
			this.inf.dataFormat = 2;
			this.inf.pixelFormat = hxd_PixelFormat.BGRA;
			f.readInt32();
			this.inf.width = f.readUInt16();
			this.inf.height = f.readUInt16();
			break;
		case 20617:
			this.inf.dataFormat = 1;
			f.set_bigEndian(true);
			f.skip(6);
			while(true) {
				var dataLen = f.readInt32();
				if(f.readInt32() == 1229472850) {
					this.inf.width = f.readInt32();
					this.inf.height = f.readInt32();
					var colbits = f.readByte();
					var tmp;
					switch(colbits) {
					case 8:
						tmp = hxd_PixelFormat.BGRA;
						break;
					case 16:
						tmp = hxd_PixelFormat.R16U;
						break;
					case 48:
						tmp = hxd_PixelFormat.RGB16U;
						break;
					case 64:
						tmp = hxd_PixelFormat.RGBA16U;
						break;
					default:
						throw haxe_Exception.thrown("Unsupported png format " + colbits + "(" + this.entry.get_path() + ")");
					}
					this.inf.pixelFormat = tmp;
					break;
				}
				f.skip(dataLen + 4);
			}
			break;
		case 55551:
			this.inf.dataFormat = 0;
			this.inf.pixelFormat = hxd_PixelFormat.BGRA;
			f.set_bigEndian(true);
			_hx_loop3: while(true) switch(f.readUInt16()) {
			case 65472:case 65473:case 65474:
				var len = f.readUInt16();
				var prec = f.readByte();
				this.inf.height = f.readUInt16();
				this.inf.width = f.readUInt16();
				break _hx_loop3;
			default:
				f.skip(f.readUInt16() - 2);
			}
			break;
		default:
			if(this.entry.get_extension() == "tga") {
				this.inf.dataFormat = 3;
				this.inf.pixelFormat = hxd_PixelFormat.ARGB;
				f.skip(10);
				this.inf.width = f.readUInt16();
				this.inf.height = f.readUInt16();
			} else if(this.entry.get_extension() == "raw") {
				this.inf.dataFormat = 5;
				this.inf.pixelFormat = hxd_PixelFormat.R32F;
				var size = Math.sqrt(this.entry.get_size() >> 2) | 0;
				if(this.entry.get_size() != size * size * 4) {
					var size2 = Math.sqrt(this.entry.get_size() >> 1) | 0;
					if(this.entry.get_size() == size2 * size2 * 2) {
						this.inf.pixelFormat = hxd_PixelFormat.R16F;
						size = size2;
					} else {
						throw haxe_Exception.thrown("RAW format does not match 32 bit per components on " + size + "x" + size);
					}
				}
				this.inf.width = this.inf.height = size;
			} else {
				throw haxe_Exception.thrown("Unsupported texture format " + this.entry.get_path());
			}
		}
		f.close();
		if(this.inf.pixelFormat == null) {
			throw haxe_Exception.thrown("Unsupported internal format (" + this.entry.get_path() + ")");
		}
		return this.inf;
	}
	,getPixels: function(fmt,flipY,index) {
		var pixels;
		if(index == null) {
			index = 0;
		}
		switch(this.getInfo().dataFormat) {
		case 0:
			var bytes = this.entry.getBytes();
			if(this.inf.pixelFormat != hxd_PixelFormat.BGRA) {
				throw haxe_Exception.thrown("No support to decode " + Std.string(this.inf.pixelFormat) + " on this platform (" + this.entry.get_path() + ")");
			}
			var p;
			try {
				p = hxd_res_NanoJpeg.decode(bytes);
			} catch( _g ) {
				var e = haxe_Exception.caught(_g).unwrap();
				throw haxe_Exception.thrown("Failed to decode JPG " + this.entry.get_path() + " (" + Std.string(e) + ")");
			}
			pixels = new hxd_Pixels(p.width,p.height,p.pixels,hxd_PixelFormat.BGRA);
			break;
		case 1:
			var bytes = this.entry.getBytes();
			if(this.inf.pixelFormat != hxd_PixelFormat.BGRA) {
				throw haxe_Exception.thrown("No support to decode " + Std.string(this.inf.pixelFormat) + " on this platform (" + this.entry.get_path() + ")");
			}
			var png = new format_png_Reader(new haxe_io_BytesInput(bytes));
			png.checkCRC = false;
			pixels = hxd_Pixels.alloc(this.inf.width,this.inf.height,hxd_PixelFormat.BGRA);
			var pdata = png.read();
			format_png_Tools.extract32(pdata,pixels.bytes,flipY);
			if(flipY) {
				pixels.flags |= 1 << hxd_Flags.FlipY._hx_index;
			}
			break;
		case 2:
			var bytes = this.entry.getBytes();
			var gif = new format_gif_Reader(new haxe_io_BytesInput(bytes)).read();
			if(fmt == hxd_PixelFormat.RGBA) {
				pixels = new hxd_Pixels(this.inf.width,this.inf.height,format_gif_Tools.extractFullRGBA(gif,0),hxd_PixelFormat.RGBA);
			} else {
				pixels = new hxd_Pixels(this.inf.width,this.inf.height,format_gif_Tools.extractFullBGRA(gif,0),hxd_PixelFormat.BGRA);
			}
			break;
		case 3:
			var bytes = this.entry.getBytes();
			var r = new format_tga_Reader(new haxe_io_BytesInput(bytes)).read();
			if(r.header.imageType != format_tga_ImageType.UncompressedTrueColor || r.header.bitsPerPixel != 32) {
				throw haxe_Exception.thrown("Not supported TGA " + Std.string(r.header.imageType) + "/" + r.header.bitsPerPixel);
			}
			var w = r.header.width;
			var h = r.header.height;
			if(fmt == hxd_PixelFormat.RGBA) {
				pixels = hxd_Pixels.alloc(w,h,hxd_PixelFormat.RGBA);
				var bytes = pixels.bytes;
				var _g = 0;
				var _g1 = w * h;
				while(_g < _g1) {
					var i = _g++;
					var c = r.imageData[i];
					c = c >>> 24 | c << 8;
					bytes.setInt32(i << 2,c);
				}
			} else {
				pixels = hxd_Pixels.alloc(w,h,hxd_PixelFormat.ARGB);
				var access = hxd_PixelsARGB.fromPixels(pixels);
				var p = 0;
				var _g = 0;
				var _g1 = h;
				while(_g < _g1) {
					var y = _g++;
					var _g2 = 0;
					var _g3 = w;
					while(_g2 < _g3) {
						var x = _g2++;
						var c = r.imageData[p++];
						access.bytes.setInt32((x + y * access.width << 2) + access.offset,c >>> 24 | c >> 8 & 65280 | c << 8 & 16711680 | c << 24);
					}
				}
			}
			switch(r.header.imageOrigin._hx_index) {
			case 0:
				pixels.flags |= 1 << hxd_Flags.FlipY._hx_index;
				break;
			case 2:
				break;
			default:
				throw haxe_Exception.thrown("Not supported " + Std.string(r.header.imageOrigin));
			}
			break;
		case 4:
			var pos = 128;
			var mipLevel = 0;
			if((this.inf.flags & 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index) != 0) {
				pos += 20;
			}
			if(index > 0) {
				var bpp = hxd_Pixels.calcStride(1,this.inf.pixelFormat);
				var layer = index / this.inf.mipLevels | 0;
				mipLevel = index % this.inf.mipLevels;
				var totSize = 0;
				var _g = 0;
				var _g1 = this.inf.mipLevels;
				while(_g < _g1) {
					var i = _g++;
					var w = this.inf.width >> i;
					var h = this.inf.height >> i;
					if(w == 0) {
						w = 1;
					}
					if(h == 0) {
						h = 1;
					}
					var size = hxd_Pixels.calcDataSize(w,h,this.inf.pixelFormat);
					totSize += size;
					if(i < mipLevel) {
						pos += size;
					} else if(layer == 0) {
						break;
					}
				}
				pos += totSize * layer;
			}
			var bytes;
			var w = this.inf.width >> mipLevel;
			var h = this.inf.height >> mipLevel;
			if(w == 0) {
				w = 1;
			}
			if(h == 0) {
				h = 1;
			}
			if(this.inf.mipLevels == 1 && (this.inf.flags & 1 << hxd_res_ImageInfoFlag.IsCube._hx_index) == 0) {
				bytes = this.entry.getBytes();
			} else {
				var size = hxd_Pixels.calcDataSize(w,h,this.inf.pixelFormat);
				bytes = new haxe_io_Bytes(new ArrayBuffer(size));
				this.entry.readFull(bytes,pos,size);
				pos = 0;
			}
			pixels = new hxd_Pixels(w,h,bytes,this.inf.pixelFormat,pos);
			break;
		case 5:
			var bytes = this.entry.getBytes();
			pixels = new hxd_Pixels(this.inf.width,this.inf.height,bytes,this.inf.pixelFormat);
			break;
		case 6:
			var data = hxd_fmt_hdr_Reader.decode(this.entry.getBytes(),false);
			pixels = new hxd_Pixels(data.width,data.height,data.bytes,this.inf.pixelFormat);
			break;
		}
		if(fmt != null) {
			pixels.convert(fmt);
		}
		if(flipY != null) {
			pixels.setFlip(flipY);
		}
		return pixels;
	}
	,watchCallb: function() {
		var w = this.inf.width;
		var h = this.inf.height;
		this.inf = null;
		var s = this.getInfo();
		if(w != s.width || h != s.height) {
			this.tex.resize(s.width,s.height);
		}
		this.tex.realloc = null;
		this.loadTexture();
	}
	,loadTexture: function(asyncData) {
		var _gthis = this;
		if(this.getInfo().dataFormat == 0) {
			this.tex.flags |= 1 << h3d_mat_TextureFlags.Loading._hx_index;
			this.entry.loadBitmap(function(bmp) {
				var bmp1 = hxd_fs_LoadedBitmap.toBitmap(bmp);
				_gthis.tex.alloc();
				_gthis.tex.uploadBitmap(bmp1);
				bmp1.ctx = null;
				bmp1.pixel = null;
				_gthis.tex.realloc = function() {
					_gthis.loadTexture();
				};
				_gthis.tex.flags &= -1 - (1 << h3d_mat_TextureFlags.Loading._hx_index);
				if(_gthis.tex.waitLoads != null) {
					var arr = _gthis.tex.waitLoads;
					_gthis.tex.waitLoads = null;
					var _g = 0;
					while(_g < arr.length) {
						var f = arr[_g];
						++_g;
						f();
					}
				}
				if(hxd_res_Image.ENABLE_AUTO_WATCH) {
					_gthis.watch($bind(_gthis,_gthis.watchCallb));
				}
			});
			return;
		}
		var load = function() {
			if((_gthis.enableAsyncLoading || (_gthis.tex.flags & 1 << h3d_mat_TextureFlags.AsyncLoading._hx_index) != 0) && asyncData == null && hxd_res_Image.ASYNC_LOADER.isSupported(_gthis)) {
				_gthis.tex.dispose();
				_gthis.tex.format = hxd_PixelFormat.RGBA;
				_gthis.tex.width = 1;
				_gthis.tex.height = 1;
				_gthis.tex.customMipLevels = 1;
				_gthis.tex.flags |= 1 << h3d_mat_TextureFlags.Loading._hx_index;
				_gthis.tex.alloc();
				_gthis.tex.uploadPixels(hxd_res_Image.BLACK_1x1);
				_gthis.tex.width = _gthis.inf.width;
				_gthis.tex.height = _gthis.inf.height;
				hxd_res_Image.ASYNC_LOADER.load(_gthis);
				_gthis.tex.realloc = function() {
					_gthis.loadTexture();
				};
				return;
			}
			var t0 = HxOverrides.now() / 1000;
			_gthis.tex.customMipLevels = _gthis.inf.mipLevels;
			_gthis.tex.alloc();
			if(_gthis.inf.dataFormat == 4) {
				var pos = 128;
				if((_gthis.inf.flags & 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index) != 0) {
					pos += 20;
				}
				var _g = 0;
				var _g1 = _gthis.tex.get_layerCount();
				while(_g < _g1) {
					var layer = _g++;
					var _g2 = 0;
					var _g3 = _gthis.inf.mipLevels;
					while(_g2 < _g3) {
						var mip = _g2++;
						var w = _gthis.inf.width >> mip;
						var h = _gthis.inf.height >> mip;
						if(w == 0) {
							w = 1;
						}
						if(h == 0) {
							h = 1;
						}
						var size = hxd_Pixels.calcDataSize(w,h,_gthis.inf.pixelFormat);
						var bytes = asyncData == null ? _gthis.entry.fetchBytes(pos,size) : asyncData;
						_gthis.tex.uploadPixels(new hxd_Pixels(w,h,bytes,_gthis.inf.pixelFormat,asyncData == null ? 0 : pos),mip,layer);
						pos += size;
					}
				}
			} else {
				var _g = 0;
				var _g1 = _gthis.tex.get_layerCount();
				while(_g < _g1) {
					var layer = _g++;
					var _g2 = 0;
					var _g3 = _gthis.inf.mipLevels;
					while(_g2 < _g3) {
						var mip = _g2++;
						var pixels = _gthis.getPixels(_gthis.tex.format,null,layer * _gthis.inf.mipLevels + mip);
						_gthis.tex.uploadPixels(pixels,mip,layer);
						pixels.dispose();
					}
				}
			}
			if(hxd_res_Image.LOG_TEXTURE_LOAD && asyncData == null) {
				var time = (HxOverrides.now() / 1000 - t0) * 1000.0;
				var _g = _gthis.inf.pixelFormat;
				var fmtStr;
				if(_g._hx_index == 21) {
					var _g1 = _g.v;
					fmtStr = true;
				} else {
					fmtStr = false;
				}
				var fmtStr1 = fmtStr ? "DXT" : hxd_res_ImageFormat.getName(_gthis.inf.dataFormat);
				haxe_Log.trace(fmtStr1 + " " + (time | 0) + "." + (time * 10 | 0) % 10 + "ms " + _gthis.inf.width + "x" + _gthis.inf.height + " " + _gthis.entry.get_path(),{ fileName : "hxd/res/Image.hx", lineNumber : 558, className : "hxd.res.Image", methodName : "loadTexture"});
			}
			_gthis.tex.realloc = function() {
				_gthis.loadTexture();
			};
			if(hxd_res_Image.ENABLE_AUTO_WATCH) {
				_gthis.watch($bind(_gthis,_gthis.watchCallb));
			}
		};
		if(this.entry.get_isAvailable()) {
			load();
		} else {
			this.entry.load(load);
		}
	}
	,toTexture: function() {
		if(this.tex != null) {
			return this.tex;
		}
		this.getInfo();
		var flags = [h3d_mat_TextureFlags.NoAlloc];
		var fmt = this.inf.pixelFormat;
		if(fmt == hxd_PixelFormat.BGRA || fmt == hxd_PixelFormat.ARGB || fmt == hxd_PixelFormat.RGBA) {
			fmt = h3d_mat_Texture.nativeFormat;
		}
		if((this.inf.flags & 1 << hxd_res_ImageInfoFlag.IsCube._hx_index) != 0) {
			flags.push(h3d_mat_TextureFlags.Cube);
		}
		if(this.inf.mipLevels > 1) {
			flags.push(h3d_mat_TextureFlags.MipMapped);
			flags.push(h3d_mat_TextureFlags.ManualMipMapGen);
		}
		if(fmt == hxd_PixelFormat.R16U) {
			throw haxe_Exception.thrown("Unsupported texture format " + Std.string(fmt) + " for " + this.entry.get_path());
		}
		if(this.inf.layerCount > 1) {
			this.tex = new h3d_mat_TextureArray(this.inf.width,this.inf.height,this.inf.layerCount,flags,fmt);
		} else {
			this.tex = new h3d_mat_Texture(this.inf.width,this.inf.height,flags,fmt);
		}
		if(hxd_res_Image.DEFAULT_FILTER != h3d_mat_Filter.Linear) {
			this.tex.set_filter(hxd_res_Image.DEFAULT_FILTER);
		}
		this.tex.setName(this.entry.get_path());
		hxd_res_Image.setupTextureFlags(this.tex);
		this.loadTexture();
		return this.tex;
	}
	,toTile: function() {
		this.getInfo();
		return h2d_Tile.fromTexture(this.toTexture()).sub(0,0,this.inf.width,this.inf.height);
	}
	,__class__: hxd_res_Image
});
var hxd_res_Filter = $hxEnums["hxd.res.Filter"] = { __ename__:true,__constructs__:null
	,Fast: {_hx_name:"Fast",_hx_index:0,__enum__:"hxd.res.Filter",toString:$estr}
	,Chromatic: {_hx_name:"Chromatic",_hx_index:1,__enum__:"hxd.res.Filter",toString:$estr}
};
hxd_res_Filter.__constructs__ = [hxd_res_Filter.Fast,hxd_res_Filter.Chromatic];
hxd_res_Filter.__empty_constructs__ = [hxd_res_Filter.Fast,hxd_res_Filter.Chromatic];
var hxd_res__$NanoJpeg_Component = function() {
};
$hxClasses["hxd.res._NanoJpeg.Component"] = hxd_res__$NanoJpeg_Component;
hxd_res__$NanoJpeg_Component.__name__ = "hxd.res._NanoJpeg.Component";
hxd_res__$NanoJpeg_Component.prototype = {
	__class__: hxd_res__$NanoJpeg_Component
};
var hxd_res_NanoJpeg = function() {
	this.comps = [new hxd_res__$NanoJpeg_Component(),new hxd_res__$NanoJpeg_Component(),new hxd_res__$NanoJpeg_Component()].slice(0);
	var this1 = new Array(64);
	var this2 = new Array(64);
	var this3 = new Array(64);
	var this4 = new Array(64);
	this.qtab = [this1,this2,this3,this4].slice(0);
	var this1 = new Array(16);
	this.counts = this1;
	var this1 = new Array(64);
	this.block = this1;
	this.njZZ = [0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,35,42,49,56,57,50,43,36,29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63].slice(0);
	this.vlctab = [null,null,null,null,null,null,null,null].slice(0);
};
$hxClasses["hxd.res.NanoJpeg"] = hxd_res_NanoJpeg;
hxd_res_NanoJpeg.__name__ = "hxd.res.NanoJpeg";
hxd_res_NanoJpeg.decode = function(bytes,filter,position,size) {
	if(size == null) {
		size = -1;
	}
	if(position == null) {
		position = 0;
	}
	if(hxd_res_NanoJpeg.inst == null) {
		hxd_res_NanoJpeg.inst = new hxd_res_NanoJpeg();
	}
	hxd_res_NanoJpeg.inst.njInit(bytes,position,size,filter);
	return hxd_res_NanoJpeg.inst.njDecode();
};
hxd_res_NanoJpeg.prototype = {
	njInit: function(bytes,pos,size,filter) {
		this.bytes = bytes;
		this.pos = pos;
		this.filter = filter == null ? hxd_res_Filter.Chromatic : filter;
		if(size < 0) {
			size = bytes.length - pos;
		}
		if(this.vlctab[0] == null) {
			this.vlctab[0] = new haxe_io_Bytes(new ArrayBuffer(131072));
		}
		if(this.vlctab[1] == null) {
			this.vlctab[1] = new haxe_io_Bytes(new ArrayBuffer(131072));
		}
		if(this.vlctab[2] == null) {
			this.vlctab[2] = new haxe_io_Bytes(new ArrayBuffer(131072));
		}
		if(this.vlctab[3] == null) {
			this.vlctab[3] = new haxe_io_Bytes(new ArrayBuffer(131072));
		}
		this.size = size;
		this.qtused = 0;
		this.qtavail = 0;
		this.rstinterval = 0;
		this.length = 0;
		this.buf = 0;
		this.bufbits = 0;
		this.progressive = false;
		this.comps[0].dcpred = 0;
		this.comps[1].dcpred = 0;
		this.comps[2].dcpred = 0;
	}
	,cleanup: function() {
		this.bytes = null;
		var _g = 0;
		var _g1 = this.comps;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			if(c.pixels != null) {
				c.pixels = null;
			}
		}
		if(this.vlctab[0] != null) {
			this.vlctab[0] = null;
		}
		if(this.vlctab[1] != null) {
			this.vlctab[1] = null;
		}
		if(this.vlctab[2] != null) {
			this.vlctab[2] = null;
		}
		if(this.vlctab[3] != null) {
			this.vlctab[3] = null;
		}
		if(this.vlctab[4] != null) {
			this.vlctab[4] = null;
		}
		if(this.vlctab[5] != null) {
			this.vlctab[5] = null;
		}
		if(this.vlctab[6] != null) {
			this.vlctab[6] = null;
		}
		if(this.vlctab[7] != null) {
			this.vlctab[7] = null;
		}
	}
	,njShowBits: function(bits) {
		if(bits == 0) {
			return 0;
		}
		while(this.bufbits < bits) {
			if(this.size <= 0) {
				this.buf = this.buf << 8 | 255;
				this.bufbits += 8;
				continue;
			}
			var newbyte = this.bytes.b[this.pos];
			this.pos++;
			this.size--;
			this.bufbits += 8;
			this.buf = this.buf << 8 | newbyte;
			if(newbyte == 255) {
				var marker = this.bytes.b[this.pos];
				this.pos++;
				this.size--;
				switch(marker) {
				case 217:
					this.size = 0;
					break;
				case 0:case 255:
					break;
				default:
					this.buf = this.buf << 8 | marker;
					this.bufbits += 8;
				}
			}
		}
		return this.buf >> this.bufbits - bits & (1 << bits) - 1;
	}
	,njDecodeSOF: function() {
		this.length = this.bytes.b[this.pos] << 8 | this.bytes.b[this.pos + 1];
		this.pos += 2;
		this.size -= 2;
		this.length -= 2;
		if(this.bytes.b[this.pos] != 8) {
			this.notSupported();
		}
		this.height = this.bytes.b[this.pos + 1] << 8 | this.bytes.b[this.pos + 2];
		this.width = this.bytes.b[this.pos + 3] << 8 | this.bytes.b[this.pos + 4];
		this.ncomp = this.bytes.b[this.pos + 5];
		this.pos += 6;
		this.size -= 6;
		this.length -= 6;
		switch(this.ncomp) {
		case 1:case 3:
			break;
		default:
			this.notSupported();
		}
		var ssxmax = 0;
		var ssymax = 0;
		var _g = 0;
		var _g1 = this.ncomp;
		while(_g < _g1) {
			var i = _g++;
			var c = this.comps[i];
			c.cid = this.bytes.b[this.pos];
			c.ssx = this.bytes.b[this.pos + 1] >> 4;
			if((c.ssx & c.ssx - 1) != 0) {
				this.notSupported();
			}
			c.ssy = this.bytes.b[this.pos + 1] & 15;
			if((c.ssy & c.ssy - 1) != 0) {
				this.notSupported();
			}
			c.qtsel = this.bytes.b[this.pos + 2];
			this.pos += 3;
			this.size -= 3;
			this.length -= 3;
			this.qtused |= 1 << c.qtsel;
			if(c.ssx > ssxmax) {
				ssxmax = c.ssx;
			}
			if(c.ssy > ssymax) {
				ssymax = c.ssy;
			}
		}
		if(this.ncomp == 1) {
			var c = this.comps[0];
			ssymax = 1;
			ssxmax = ssymax;
			c.ssx = c.ssy = ssxmax;
		}
		this.mbsizex = ssxmax << 3;
		this.mbsizey = ssymax << 3;
		this.mbwidth = (this.width + this.mbsizex - 1) / this.mbsizex | 0;
		this.mbheight = (this.height + this.mbsizey - 1) / this.mbsizey | 0;
		var _g = 0;
		var _g1 = this.ncomp;
		while(_g < _g1) {
			var i = _g++;
			var c = this.comps[i];
			c.width = (this.width * c.ssx + ssxmax - 1) / ssxmax | 0;
			c.stride = c.width + 7 & 2147483640;
			c.height = (this.height * c.ssy + ssymax - 1) / ssymax | 0;
			c.stride = this.mbwidth * this.mbsizex * c.ssx / ssxmax | 0;
			if(c.width < 3 && c.ssx != ssxmax || c.height < 3 && c.ssy != ssymax) {
				this.notSupported();
			}
			c.pixels = new haxe_io_Bytes(new ArrayBuffer(c.stride * (this.mbheight * this.mbsizey * c.ssy / ssymax | 0)));
		}
		var count = this.length;
		this.pos += count;
		this.size -= count;
		this.length -= count;
	}
	,njDecodeDQT: function() {
		this.length = this.bytes.b[this.pos] << 8 | this.bytes.b[this.pos + 1];
		this.pos += 2;
		this.size -= 2;
		this.length -= 2;
		while(this.length >= 65) {
			var i = this.bytes.b[this.pos];
			this.qtavail |= 1 << i;
			var t = this.qtab[i];
			var _g = 0;
			while(_g < 64) {
				var k = _g++;
				t[k] = this.bytes.b[this.pos + (k + 1)];
			}
			this.pos += 65;
			this.size -= 65;
			this.length -= 65;
		}
	}
	,njDecodeDHT: function() {
		this.length = this.bytes.b[this.pos] << 8 | this.bytes.b[this.pos + 1];
		this.pos += 2;
		this.size -= 2;
		this.length -= 2;
		while(this.length >= 17) {
			var i = this.bytes.b[this.pos];
			i = i >> 4 & 1 | (i & 3) << 1;
			this.counts[0] = this.bytes.b[this.pos + 1];
			this.counts[1] = this.bytes.b[this.pos + 2];
			this.counts[2] = this.bytes.b[this.pos + 3];
			this.counts[3] = this.bytes.b[this.pos + 4];
			this.counts[4] = this.bytes.b[this.pos + 5];
			this.counts[5] = this.bytes.b[this.pos + 6];
			this.counts[6] = this.bytes.b[this.pos + 7];
			this.counts[7] = this.bytes.b[this.pos + 8];
			this.counts[8] = this.bytes.b[this.pos + 9];
			this.counts[9] = this.bytes.b[this.pos + 10];
			this.counts[10] = this.bytes.b[this.pos + 11];
			this.counts[11] = this.bytes.b[this.pos + 12];
			this.counts[12] = this.bytes.b[this.pos + 13];
			this.counts[13] = this.bytes.b[this.pos + 14];
			this.counts[14] = this.bytes.b[this.pos + 15];
			this.counts[15] = this.bytes.b[this.pos + 16];
			this.pos += 17;
			this.size -= 17;
			this.length -= 17;
			var vlc = this.vlctab[i];
			var vpos = 0;
			var remain = 65536;
			var spread = 65536;
			var _g = 1;
			while(_g < 17) {
				var codelen = _g++;
				spread >>= 1;
				var currcnt = this.counts[codelen - 1];
				if(currcnt == 0) {
					continue;
				}
				remain -= currcnt << 16 - codelen;
				var _g1 = 0;
				var _g2 = currcnt;
				while(_g1 < _g2) {
					var i1 = _g1++;
					var code = this.bytes.b[this.pos + i1];
					var _g3 = 0;
					var _g4 = spread;
					while(_g3 < _g4) {
						var j = _g3++;
						vlc.b[vpos++] = codelen;
						vlc.b[vpos++] = code;
					}
				}
				this.pos += currcnt;
				this.size -= currcnt;
				this.length -= currcnt;
			}
			while(remain-- != 0) {
				vlc.b[vpos] = 0;
				vpos += 2;
			}
		}
	}
	,njDecodeDRI: function() {
		this.length = this.bytes.b[this.pos] << 8 | this.bytes.b[this.pos + 1];
		this.pos += 2;
		this.size -= 2;
		this.length -= 2;
		this.rstinterval = this.bytes.b[this.pos] << 8 | this.bytes.b[this.pos + 1];
		var count = this.length;
		this.pos += count;
		this.size -= count;
		this.length -= count;
	}
	,njDecodeBlock: function(c,po) {
		var this1 = c.pixels;
		var out = this1;
		var value;
		var coef = 0;
		var _g = 0;
		while(_g < 64) {
			var i = _g++;
			this.block[i] = 0;
		}
		var c1 = c;
		var c2 = c1.dcpred;
		var vlc = this.vlctab[c.dctabsel];
		var value1 = this.njShowBits(16);
		var bits = vlc.b[value1 << 1];
		if(this.bufbits < bits) {
			this.njShowBits(bits);
		}
		this.bufbits -= bits;
		value1 = vlc.b[value1 << 1 | 1];
		this.vlcCode = value1;
		bits = value1 & 15;
		var tmp;
		if(bits == 0) {
			tmp = 0;
		} else {
			var r = this.njShowBits(bits);
			this.bufbits -= bits;
			value1 = r;
			if(value1 < 1 << bits - 1) {
				value1 += (-1 << bits) + 1;
			}
			tmp = value1;
		}
		c1.dcpred = c2 + tmp;
		var qt = this.qtab[c.qtsel];
		var at = this.vlctab[c.actabsel];
		this.block[0] = c.dcpred * qt[0];
		while(true) {
			var value1 = this.njShowBits(16);
			var bits = at.b[value1 << 1];
			if(this.bufbits < bits) {
				this.njShowBits(bits);
			}
			this.bufbits -= bits;
			value1 = at.b[value1 << 1 | 1];
			this.vlcCode = value1;
			bits = value1 & 15;
			if(bits == 0) {
				value = 0;
			} else {
				var r = this.njShowBits(bits);
				this.bufbits -= bits;
				value1 = r;
				if(value1 < 1 << bits - 1) {
					value1 += (-1 << bits) + 1;
				}
				value = value1;
			}
			if(this.vlcCode == 0) {
				break;
			}
			coef += (this.vlcCode >> 4) + 1;
			this.block[this.njZZ[coef]] = value * qt[coef];
			if(!(coef < 63)) {
				break;
			}
		}
		var bp = 0;
		var x0;
		var x8;
		var x1 = this.block[bp + 4] << 11;
		var x2 = this.block[bp + 6];
		var x3 = this.block[bp + 2];
		var x4 = this.block[bp + 1];
		var x5 = this.block[bp + 7];
		var x6 = this.block[bp + 5];
		var x7 = this.block[bp + 3];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var val = this.block[bp + 7] = this.block[bp] << 3;
			var val1 = this.block[bp + 6] = val;
			var val = this.block[bp + 5] = val1;
			var val1 = this.block[bp + 4] = val;
			var val = this.block[bp + 3] = val1;
			var val1 = this.block[bp + 2] = val;
			var val = this.block[bp + 1] = val1;
			this.block[bp] = val;
		} else {
			x0 = (this.block[bp] << 11) + 128;
			x8 = 565 * (x4 + x5);
			x4 = x8 + 2276 * x4;
			x5 = x8 - 3406 * x5;
			x8 = 2408 * (x6 + x7);
			x6 = x8 - 799 * x6;
			x7 = x8 - 4017 * x7;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2);
			x2 = x1 - 3784 * x2;
			x3 = x1 + 1568 * x3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			this.block[bp] = x7 + x1 >> 8;
			this.block[bp + 1] = x3 + x2 >> 8;
			this.block[bp + 2] = x0 + x4 >> 8;
			this.block[bp + 3] = x8 + x6 >> 8;
			this.block[bp + 4] = x8 - x6 >> 8;
			this.block[bp + 5] = x0 - x4 >> 8;
			this.block[bp + 6] = x3 - x2 >> 8;
			this.block[bp + 7] = x7 - x1 >> 8;
		}
		var bp = 8;
		var x0;
		var x8;
		var x1 = this.block[bp + 4] << 11;
		var x2 = this.block[bp + 6];
		var x3 = this.block[bp + 2];
		var x4 = this.block[bp + 1];
		var x5 = this.block[bp + 7];
		var x6 = this.block[bp + 5];
		var x7 = this.block[bp + 3];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var val = this.block[bp + 7] = this.block[bp] << 3;
			var val1 = this.block[bp + 6] = val;
			var val = this.block[bp + 5] = val1;
			var val1 = this.block[bp + 4] = val;
			var val = this.block[bp + 3] = val1;
			var val1 = this.block[bp + 2] = val;
			var val = this.block[bp + 1] = val1;
			this.block[bp] = val;
		} else {
			x0 = (this.block[bp] << 11) + 128;
			x8 = 565 * (x4 + x5);
			x4 = x8 + 2276 * x4;
			x5 = x8 - 3406 * x5;
			x8 = 2408 * (x6 + x7);
			x6 = x8 - 799 * x6;
			x7 = x8 - 4017 * x7;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2);
			x2 = x1 - 3784 * x2;
			x3 = x1 + 1568 * x3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			this.block[bp] = x7 + x1 >> 8;
			this.block[bp + 1] = x3 + x2 >> 8;
			this.block[bp + 2] = x0 + x4 >> 8;
			this.block[bp + 3] = x8 + x6 >> 8;
			this.block[bp + 4] = x8 - x6 >> 8;
			this.block[bp + 5] = x0 - x4 >> 8;
			this.block[bp + 6] = x3 - x2 >> 8;
			this.block[bp + 7] = x7 - x1 >> 8;
		}
		var bp = 16;
		var x0;
		var x8;
		var x1 = this.block[bp + 4] << 11;
		var x2 = this.block[bp + 6];
		var x3 = this.block[bp + 2];
		var x4 = this.block[bp + 1];
		var x5 = this.block[bp + 7];
		var x6 = this.block[bp + 5];
		var x7 = this.block[bp + 3];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var val = this.block[bp + 7] = this.block[bp] << 3;
			var val1 = this.block[bp + 6] = val;
			var val = this.block[bp + 5] = val1;
			var val1 = this.block[bp + 4] = val;
			var val = this.block[bp + 3] = val1;
			var val1 = this.block[bp + 2] = val;
			var val = this.block[bp + 1] = val1;
			this.block[bp] = val;
		} else {
			x0 = (this.block[bp] << 11) + 128;
			x8 = 565 * (x4 + x5);
			x4 = x8 + 2276 * x4;
			x5 = x8 - 3406 * x5;
			x8 = 2408 * (x6 + x7);
			x6 = x8 - 799 * x6;
			x7 = x8 - 4017 * x7;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2);
			x2 = x1 - 3784 * x2;
			x3 = x1 + 1568 * x3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			this.block[bp] = x7 + x1 >> 8;
			this.block[bp + 1] = x3 + x2 >> 8;
			this.block[bp + 2] = x0 + x4 >> 8;
			this.block[bp + 3] = x8 + x6 >> 8;
			this.block[bp + 4] = x8 - x6 >> 8;
			this.block[bp + 5] = x0 - x4 >> 8;
			this.block[bp + 6] = x3 - x2 >> 8;
			this.block[bp + 7] = x7 - x1 >> 8;
		}
		var bp = 24;
		var x0;
		var x8;
		var x1 = this.block[bp + 4] << 11;
		var x2 = this.block[bp + 6];
		var x3 = this.block[bp + 2];
		var x4 = this.block[bp + 1];
		var x5 = this.block[bp + 7];
		var x6 = this.block[bp + 5];
		var x7 = this.block[bp + 3];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var val = this.block[bp + 7] = this.block[bp] << 3;
			var val1 = this.block[bp + 6] = val;
			var val = this.block[bp + 5] = val1;
			var val1 = this.block[bp + 4] = val;
			var val = this.block[bp + 3] = val1;
			var val1 = this.block[bp + 2] = val;
			var val = this.block[bp + 1] = val1;
			this.block[bp] = val;
		} else {
			x0 = (this.block[bp] << 11) + 128;
			x8 = 565 * (x4 + x5);
			x4 = x8 + 2276 * x4;
			x5 = x8 - 3406 * x5;
			x8 = 2408 * (x6 + x7);
			x6 = x8 - 799 * x6;
			x7 = x8 - 4017 * x7;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2);
			x2 = x1 - 3784 * x2;
			x3 = x1 + 1568 * x3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			this.block[bp] = x7 + x1 >> 8;
			this.block[bp + 1] = x3 + x2 >> 8;
			this.block[bp + 2] = x0 + x4 >> 8;
			this.block[bp + 3] = x8 + x6 >> 8;
			this.block[bp + 4] = x8 - x6 >> 8;
			this.block[bp + 5] = x0 - x4 >> 8;
			this.block[bp + 6] = x3 - x2 >> 8;
			this.block[bp + 7] = x7 - x1 >> 8;
		}
		var bp = 32;
		var x0;
		var x8;
		var x1 = this.block[bp + 4] << 11;
		var x2 = this.block[bp + 6];
		var x3 = this.block[bp + 2];
		var x4 = this.block[bp + 1];
		var x5 = this.block[bp + 7];
		var x6 = this.block[bp + 5];
		var x7 = this.block[bp + 3];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var val = this.block[bp + 7] = this.block[bp] << 3;
			var val1 = this.block[bp + 6] = val;
			var val = this.block[bp + 5] = val1;
			var val1 = this.block[bp + 4] = val;
			var val = this.block[bp + 3] = val1;
			var val1 = this.block[bp + 2] = val;
			var val = this.block[bp + 1] = val1;
			this.block[bp] = val;
		} else {
			x0 = (this.block[bp] << 11) + 128;
			x8 = 565 * (x4 + x5);
			x4 = x8 + 2276 * x4;
			x5 = x8 - 3406 * x5;
			x8 = 2408 * (x6 + x7);
			x6 = x8 - 799 * x6;
			x7 = x8 - 4017 * x7;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2);
			x2 = x1 - 3784 * x2;
			x3 = x1 + 1568 * x3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			this.block[bp] = x7 + x1 >> 8;
			this.block[bp + 1] = x3 + x2 >> 8;
			this.block[bp + 2] = x0 + x4 >> 8;
			this.block[bp + 3] = x8 + x6 >> 8;
			this.block[bp + 4] = x8 - x6 >> 8;
			this.block[bp + 5] = x0 - x4 >> 8;
			this.block[bp + 6] = x3 - x2 >> 8;
			this.block[bp + 7] = x7 - x1 >> 8;
		}
		var bp = 40;
		var x0;
		var x8;
		var x1 = this.block[bp + 4] << 11;
		var x2 = this.block[bp + 6];
		var x3 = this.block[bp + 2];
		var x4 = this.block[bp + 1];
		var x5 = this.block[bp + 7];
		var x6 = this.block[bp + 5];
		var x7 = this.block[bp + 3];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var val = this.block[bp + 7] = this.block[bp] << 3;
			var val1 = this.block[bp + 6] = val;
			var val = this.block[bp + 5] = val1;
			var val1 = this.block[bp + 4] = val;
			var val = this.block[bp + 3] = val1;
			var val1 = this.block[bp + 2] = val;
			var val = this.block[bp + 1] = val1;
			this.block[bp] = val;
		} else {
			x0 = (this.block[bp] << 11) + 128;
			x8 = 565 * (x4 + x5);
			x4 = x8 + 2276 * x4;
			x5 = x8 - 3406 * x5;
			x8 = 2408 * (x6 + x7);
			x6 = x8 - 799 * x6;
			x7 = x8 - 4017 * x7;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2);
			x2 = x1 - 3784 * x2;
			x3 = x1 + 1568 * x3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			this.block[bp] = x7 + x1 >> 8;
			this.block[bp + 1] = x3 + x2 >> 8;
			this.block[bp + 2] = x0 + x4 >> 8;
			this.block[bp + 3] = x8 + x6 >> 8;
			this.block[bp + 4] = x8 - x6 >> 8;
			this.block[bp + 5] = x0 - x4 >> 8;
			this.block[bp + 6] = x3 - x2 >> 8;
			this.block[bp + 7] = x7 - x1 >> 8;
		}
		var bp = 48;
		var x0;
		var x8;
		var x1 = this.block[bp + 4] << 11;
		var x2 = this.block[bp + 6];
		var x3 = this.block[bp + 2];
		var x4 = this.block[bp + 1];
		var x5 = this.block[bp + 7];
		var x6 = this.block[bp + 5];
		var x7 = this.block[bp + 3];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var val = this.block[bp + 7] = this.block[bp] << 3;
			var val1 = this.block[bp + 6] = val;
			var val = this.block[bp + 5] = val1;
			var val1 = this.block[bp + 4] = val;
			var val = this.block[bp + 3] = val1;
			var val1 = this.block[bp + 2] = val;
			var val = this.block[bp + 1] = val1;
			this.block[bp] = val;
		} else {
			x0 = (this.block[bp] << 11) + 128;
			x8 = 565 * (x4 + x5);
			x4 = x8 + 2276 * x4;
			x5 = x8 - 3406 * x5;
			x8 = 2408 * (x6 + x7);
			x6 = x8 - 799 * x6;
			x7 = x8 - 4017 * x7;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2);
			x2 = x1 - 3784 * x2;
			x3 = x1 + 1568 * x3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			this.block[bp] = x7 + x1 >> 8;
			this.block[bp + 1] = x3 + x2 >> 8;
			this.block[bp + 2] = x0 + x4 >> 8;
			this.block[bp + 3] = x8 + x6 >> 8;
			this.block[bp + 4] = x8 - x6 >> 8;
			this.block[bp + 5] = x0 - x4 >> 8;
			this.block[bp + 6] = x3 - x2 >> 8;
			this.block[bp + 7] = x7 - x1 >> 8;
		}
		var bp = 56;
		var x0;
		var x8;
		var x1 = this.block[bp + 4] << 11;
		var x2 = this.block[bp + 6];
		var x3 = this.block[bp + 2];
		var x4 = this.block[bp + 1];
		var x5 = this.block[bp + 7];
		var x6 = this.block[bp + 5];
		var x7 = this.block[bp + 3];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var val = this.block[bp + 7] = this.block[bp] << 3;
			var val1 = this.block[bp + 6] = val;
			var val = this.block[bp + 5] = val1;
			var val1 = this.block[bp + 4] = val;
			var val = this.block[bp + 3] = val1;
			var val1 = this.block[bp + 2] = val;
			var val = this.block[bp + 1] = val1;
			this.block[bp] = val;
		} else {
			x0 = (this.block[bp] << 11) + 128;
			x8 = 565 * (x4 + x5);
			x4 = x8 + 2276 * x4;
			x5 = x8 - 3406 * x5;
			x8 = 2408 * (x6 + x7);
			x6 = x8 - 799 * x6;
			x7 = x8 - 4017 * x7;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2);
			x2 = x1 - 3784 * x2;
			x3 = x1 + 1568 * x3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			this.block[bp] = x7 + x1 >> 8;
			this.block[bp + 1] = x3 + x2 >> 8;
			this.block[bp + 2] = x0 + x4 >> 8;
			this.block[bp + 3] = x8 + x6 >> 8;
			this.block[bp + 4] = x8 - x6 >> 8;
			this.block[bp + 5] = x0 - x4 >> 8;
			this.block[bp + 6] = x3 - x2 >> 8;
			this.block[bp + 7] = x7 - x1 >> 8;
		}
		var po1 = po;
		var stride = c.stride;
		var x0;
		var x8;
		var x1 = this.block[32] << 8;
		var x2 = this.block[48];
		var x3 = this.block[16];
		var x4 = this.block[8];
		var x5 = this.block[56];
		var x6 = this.block[40];
		var x7 = this.block[24];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var x = (this.block[0] + 32 >> 6) + 128;
			x1 = x < 0 ? 0 : x > 255 ? 255 : x;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
		} else {
			x0 = (this.block[0] << 8) + 8192;
			x8 = 565 * (x4 + x5) + 4;
			x4 = x8 + 2276 * x4 >> 3;
			x5 = x8 - 3406 * x5 >> 3;
			x8 = 2408 * (x6 + x7) + 4;
			x6 = x8 - 799 * x6 >> 3;
			x7 = x8 - 4017 * x7 >> 3;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2) + 4;
			x2 = x1 - 3784 * x2 >> 3;
			x3 = x1 + 1568 * x3 >> 3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			var x = (x7 + x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 + x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 + x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 + x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 - x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 - x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 - x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x7 - x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
		}
		var po1 = 1 + po;
		var stride = c.stride;
		var x0;
		var x8;
		var x1 = this.block[33] << 8;
		var x2 = this.block[49];
		var x3 = this.block[17];
		var x4 = this.block[9];
		var x5 = this.block[57];
		var x6 = this.block[41];
		var x7 = this.block[25];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var x = (this.block[1] + 32 >> 6) + 128;
			x1 = x < 0 ? 0 : x > 255 ? 255 : x;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
		} else {
			x0 = (this.block[1] << 8) + 8192;
			x8 = 565 * (x4 + x5) + 4;
			x4 = x8 + 2276 * x4 >> 3;
			x5 = x8 - 3406 * x5 >> 3;
			x8 = 2408 * (x6 + x7) + 4;
			x6 = x8 - 799 * x6 >> 3;
			x7 = x8 - 4017 * x7 >> 3;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2) + 4;
			x2 = x1 - 3784 * x2 >> 3;
			x3 = x1 + 1568 * x3 >> 3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			var x = (x7 + x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 + x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 + x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 + x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 - x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 - x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 - x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x7 - x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
		}
		var po1 = 2 + po;
		var stride = c.stride;
		var x0;
		var x8;
		var x1 = this.block[34] << 8;
		var x2 = this.block[50];
		var x3 = this.block[18];
		var x4 = this.block[10];
		var x5 = this.block[58];
		var x6 = this.block[42];
		var x7 = this.block[26];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var x = (this.block[2] + 32 >> 6) + 128;
			x1 = x < 0 ? 0 : x > 255 ? 255 : x;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
		} else {
			x0 = (this.block[2] << 8) + 8192;
			x8 = 565 * (x4 + x5) + 4;
			x4 = x8 + 2276 * x4 >> 3;
			x5 = x8 - 3406 * x5 >> 3;
			x8 = 2408 * (x6 + x7) + 4;
			x6 = x8 - 799 * x6 >> 3;
			x7 = x8 - 4017 * x7 >> 3;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2) + 4;
			x2 = x1 - 3784 * x2 >> 3;
			x3 = x1 + 1568 * x3 >> 3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			var x = (x7 + x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 + x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 + x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 + x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 - x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 - x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 - x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x7 - x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
		}
		var po1 = 3 + po;
		var stride = c.stride;
		var x0;
		var x8;
		var x1 = this.block[35] << 8;
		var x2 = this.block[51];
		var x3 = this.block[19];
		var x4 = this.block[11];
		var x5 = this.block[59];
		var x6 = this.block[43];
		var x7 = this.block[27];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var x = (this.block[3] + 32 >> 6) + 128;
			x1 = x < 0 ? 0 : x > 255 ? 255 : x;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
		} else {
			x0 = (this.block[3] << 8) + 8192;
			x8 = 565 * (x4 + x5) + 4;
			x4 = x8 + 2276 * x4 >> 3;
			x5 = x8 - 3406 * x5 >> 3;
			x8 = 2408 * (x6 + x7) + 4;
			x6 = x8 - 799 * x6 >> 3;
			x7 = x8 - 4017 * x7 >> 3;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2) + 4;
			x2 = x1 - 3784 * x2 >> 3;
			x3 = x1 + 1568 * x3 >> 3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			var x = (x7 + x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 + x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 + x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 + x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 - x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 - x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 - x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x7 - x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
		}
		var po1 = 4 + po;
		var stride = c.stride;
		var x0;
		var x8;
		var x1 = this.block[36] << 8;
		var x2 = this.block[52];
		var x3 = this.block[20];
		var x4 = this.block[12];
		var x5 = this.block[60];
		var x6 = this.block[44];
		var x7 = this.block[28];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var x = (this.block[4] + 32 >> 6) + 128;
			x1 = x < 0 ? 0 : x > 255 ? 255 : x;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
		} else {
			x0 = (this.block[4] << 8) + 8192;
			x8 = 565 * (x4 + x5) + 4;
			x4 = x8 + 2276 * x4 >> 3;
			x5 = x8 - 3406 * x5 >> 3;
			x8 = 2408 * (x6 + x7) + 4;
			x6 = x8 - 799 * x6 >> 3;
			x7 = x8 - 4017 * x7 >> 3;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2) + 4;
			x2 = x1 - 3784 * x2 >> 3;
			x3 = x1 + 1568 * x3 >> 3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			var x = (x7 + x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 + x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 + x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 + x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 - x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 - x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 - x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x7 - x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
		}
		var po1 = 5 + po;
		var stride = c.stride;
		var x0;
		var x8;
		var x1 = this.block[37] << 8;
		var x2 = this.block[53];
		var x3 = this.block[21];
		var x4 = this.block[13];
		var x5 = this.block[61];
		var x6 = this.block[45];
		var x7 = this.block[29];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var x = (this.block[5] + 32 >> 6) + 128;
			x1 = x < 0 ? 0 : x > 255 ? 255 : x;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
		} else {
			x0 = (this.block[5] << 8) + 8192;
			x8 = 565 * (x4 + x5) + 4;
			x4 = x8 + 2276 * x4 >> 3;
			x5 = x8 - 3406 * x5 >> 3;
			x8 = 2408 * (x6 + x7) + 4;
			x6 = x8 - 799 * x6 >> 3;
			x7 = x8 - 4017 * x7 >> 3;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2) + 4;
			x2 = x1 - 3784 * x2 >> 3;
			x3 = x1 + 1568 * x3 >> 3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			var x = (x7 + x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 + x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 + x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 + x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 - x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 - x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 - x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x7 - x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
		}
		var po1 = 6 + po;
		var stride = c.stride;
		var x0;
		var x8;
		var x1 = this.block[38] << 8;
		var x2 = this.block[54];
		var x3 = this.block[22];
		var x4 = this.block[14];
		var x5 = this.block[62];
		var x6 = this.block[46];
		var x7 = this.block[30];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var x = (this.block[6] + 32 >> 6) + 128;
			x1 = x < 0 ? 0 : x > 255 ? 255 : x;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
		} else {
			x0 = (this.block[6] << 8) + 8192;
			x8 = 565 * (x4 + x5) + 4;
			x4 = x8 + 2276 * x4 >> 3;
			x5 = x8 - 3406 * x5 >> 3;
			x8 = 2408 * (x6 + x7) + 4;
			x6 = x8 - 799 * x6 >> 3;
			x7 = x8 - 4017 * x7 >> 3;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2) + 4;
			x2 = x1 - 3784 * x2 >> 3;
			x3 = x1 + 1568 * x3 >> 3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			var x = (x7 + x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 + x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 + x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 + x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 - x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 - x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 - x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x7 - x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
		}
		var po1 = 7 + po;
		var stride = c.stride;
		var x0;
		var x8;
		var x1 = this.block[39] << 8;
		var x2 = this.block[55];
		var x3 = this.block[23];
		var x4 = this.block[15];
		var x5 = this.block[63];
		var x6 = this.block[47];
		var x7 = this.block[31];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var x = (this.block[7] + 32 >> 6) + 128;
			x1 = x < 0 ? 0 : x > 255 ? 255 : x;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
		} else {
			x0 = (this.block[7] << 8) + 8192;
			x8 = 565 * (x4 + x5) + 4;
			x4 = x8 + 2276 * x4 >> 3;
			x5 = x8 - 3406 * x5 >> 3;
			x8 = 2408 * (x6 + x7) + 4;
			x6 = x8 - 799 * x6 >> 3;
			x7 = x8 - 4017 * x7 >> 3;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2) + 4;
			x2 = x1 - 3784 * x2 >> 3;
			x3 = x1 + 1568 * x3 >> 3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			var x = (x7 + x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 + x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 + x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 + x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 - x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 - x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 - x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x7 - x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
		}
	}
	,notSupported: function() {
		throw haxe_Exception.thrown("This JPG file is not supported");
	}
	,njDecodeScan: function() {
		this.length = this.bytes.b[this.pos] << 8 | this.bytes.b[this.pos + 1];
		this.pos += 2;
		this.size -= 2;
		this.length -= 2;
		if(this.bytes.b[this.pos] != this.ncomp) {
			this.notSupported();
		}
		this.pos += 1;
		this.size -= 1;
		this.length -= 1;
		var _g = 0;
		var _g1 = this.ncomp;
		while(_g < _g1) {
			var i = _g++;
			var c = this.comps[i];
			c.dctabsel = this.bytes.b[this.pos + 1] >> 4 << 1;
			c.actabsel = (this.bytes.b[this.pos + 1] & 3) << 1 | 1;
			this.pos += 2;
			this.size -= 2;
			this.length -= 2;
		}
		var start = this.bytes.b[this.pos];
		var count = this.bytes.b[this.pos + 1];
		var other = this.bytes.b[this.pos + 2];
		if(!this.progressive && start != 0 || count != 63 - start || other != 0) {
			this.notSupported();
		}
		var count = this.length;
		this.pos += count;
		this.size -= count;
		this.length -= count;
		var mbx = 0;
		var mby = 0;
		var rstcount = this.rstinterval;
		var nextrst = 0;
		while(true) {
			var _g = 0;
			var _g1 = this.ncomp;
			while(_g < _g1) {
				var i = _g++;
				var c = this.comps[i];
				var _g2 = 0;
				var _g3 = c.ssy;
				while(_g2 < _g3) {
					var sby = _g2++;
					var _g4 = 0;
					var _g5 = c.ssx;
					while(_g4 < _g5) {
						var sbx = _g4++;
						this.njDecodeBlock(c,(mby * c.ssy + sby) * c.stride + mbx * c.ssx + sbx << 3);
					}
				}
			}
			if(++mbx >= this.mbwidth) {
				mbx = 0;
				if(++mby >= this.mbheight) {
					break;
				}
			}
			if(this.rstinterval != 0 && --rstcount == 0) {
				this.bufbits &= 248;
				var r = this.njShowBits(16);
				this.bufbits -= 16;
				var i1 = r;
				nextrst = nextrst + 1 & 7;
				rstcount = this.rstinterval;
				this.comps[0].dcpred = 0;
				this.comps[1].dcpred = 0;
				this.comps[2].dcpred = 0;
			}
		}
	}
	,njUpsampleH: function(c) {
		var xmax = c.width - 3;
		var cout = new haxe_io_Bytes(new ArrayBuffer(c.width * c.height << 1));
		var this1 = cout;
		var lout = this1;
		var this1 = c.pixels;
		var lin = this1;
		var pi = 0;
		var po = 0;
		var _g = 0;
		var _g1 = c.height;
		while(_g < _g1) {
			var y = _g++;
			var x = 139 * lin.b[pi] + -11 * lin.b[pi + 1] + 64 >> 7;
			lout.b[po] = x < 0 ? 0 : x > 255 ? 255 : x;
			var x1 = 104 * lin.b[pi] + 27 * lin.b[pi + 1] + -3 * lin.b[pi + 2] + 64 >> 7;
			lout.b[po + 1] = x1 < 0 ? 0 : x1 > 255 ? 255 : x1;
			var x2 = 28 * lin.b[pi] + 109 * lin.b[pi + 1] + -9 * lin.b[pi + 2] + 64 >> 7;
			lout.b[po + 2] = x2 < 0 ? 0 : x2 > 255 ? 255 : x2;
			var _g2 = 0;
			var _g3 = xmax;
			while(_g2 < _g3) {
				var x3 = _g2++;
				var x4 = -9 * lin.b[pi + x3] + 111 * lin.b[pi + x3 + 1] + 29 * lin.b[pi + x3 + 2] + -3 * lin.b[pi + x3 + 3] + 64 >> 7;
				lout.b[po + (x3 << 1) + 3] = x4 < 0 ? 0 : x4 > 255 ? 255 : x4;
				var x5 = -3 * lin.b[pi + x3] + 29 * lin.b[pi + x3 + 1] + 111 * lin.b[pi + x3 + 2] + -9 * lin.b[pi + x3 + 3] + 64 >> 7;
				lout.b[po + (x3 << 1) + 4] = x5 < 0 ? 0 : x5 > 255 ? 255 : x5;
			}
			pi += c.stride;
			po += c.width << 1;
			var x6 = 28 * lin.b[pi - 1] + 109 * lin.b[pi - 2] + -9 * lin.b[pi - 3] + 64 >> 7;
			lout.b[po - 3] = x6 < 0 ? 0 : x6 > 255 ? 255 : x6;
			var x7 = 104 * lin.b[pi - 1] + 27 * lin.b[pi - 2] + -3 * lin.b[pi - 3] + 64 >> 7;
			lout.b[po - 2] = x7 < 0 ? 0 : x7 > 255 ? 255 : x7;
			var x8 = 139 * lin.b[pi - 1] + -11 * lin.b[pi - 2] + 64 >> 7;
			lout.b[po - 1] = x8 < 0 ? 0 : x8 > 255 ? 255 : x8;
		}
		c.width <<= 1;
		c.stride = c.width;
		c.pixels = cout;
	}
	,njUpsampleV: function(c) {
		var w = c.width;
		var s1 = c.stride;
		var s2 = s1 + s1;
		var out = new haxe_io_Bytes(new ArrayBuffer(c.width * c.height << 1));
		var pi = 0;
		var po = 0;
		var this1 = out;
		var cout = this1;
		var this1 = c.pixels;
		var cin = this1;
		var _g = 0;
		var _g1 = w;
		while(_g < _g1) {
			var x = _g++;
			po = x;
			pi = po;
			var x1 = 139 * cin.b[pi] + -11 * cin.b[pi + s1] + 64 >> 7;
			cout.b[po] = x1 < 0 ? 0 : x1 > 255 ? 255 : x1;
			po += w;
			var x2 = 104 * cin.b[pi] + 27 * cin.b[pi + s1] + -3 * cin.b[pi + s2] + 64 >> 7;
			cout.b[po] = x2 < 0 ? 0 : x2 > 255 ? 255 : x2;
			po += w;
			var x3 = 28 * cin.b[pi] + 109 * cin.b[pi + s1] + -9 * cin.b[pi + s2] + 64 >> 7;
			cout.b[po] = x3 < 0 ? 0 : x3 > 255 ? 255 : x3;
			po += w;
			pi += s1;
			var _g2 = 0;
			var _g3 = c.height - 2;
			while(_g2 < _g3) {
				var y = _g2++;
				var x4 = -9 * cin.b[pi - s1] + 111 * cin.b[pi] + 29 * cin.b[pi + s1] + -3 * cin.b[pi + s2] + 64 >> 7;
				cout.b[po] = x4 < 0 ? 0 : x4 > 255 ? 255 : x4;
				po += w;
				var x5 = -3 * cin.b[pi - s1] + 29 * cin.b[pi] + 111 * cin.b[pi + s1] + -9 * cin.b[pi + s2] + 64 >> 7;
				cout.b[po] = x5 < 0 ? 0 : x5 > 255 ? 255 : x5;
				po += w;
				pi += s1;
			}
			pi += s1;
			var x6 = 28 * cin.b[pi] + 109 * cin.b[pi - s1] + -9 * cin.b[pi - s2] + 64 >> 7;
			cout.b[po] = x6 < 0 ? 0 : x6 > 255 ? 255 : x6;
			po += w;
			var x7 = 104 * cin.b[pi] + 27 * cin.b[pi - s1] + -3 * cin.b[pi - s2] + 64 >> 7;
			cout.b[po] = x7 < 0 ? 0 : x7 > 255 ? 255 : x7;
			po += w;
			var x8 = 139 * cin.b[pi] + -11 * cin.b[pi - s1] + 64 >> 7;
			cout.b[po] = x8 < 0 ? 0 : x8 > 255 ? 255 : x8;
		}
		c.height <<= 1;
		c.stride = c.width;
		c.pixels = out;
	}
	,njUpsample: function(c) {
		var xshift = 0;
		var yshift = 0;
		while(c.width < this.width) {
			c.width <<= 1;
			++xshift;
		}
		while(c.height < this.height) {
			c.height <<= 1;
			++yshift;
		}
		var out = new haxe_io_Bytes(new ArrayBuffer(c.width * c.height));
		var this1 = c.pixels;
		var lin = this1;
		var pout = 0;
		var this1 = out;
		var lout = this1;
		var _g = 0;
		var _g1 = c.height;
		while(_g < _g1) {
			var y = _g++;
			var pin = (y >> yshift) * c.stride;
			var _g2 = 0;
			var _g3 = c.width;
			while(_g2 < _g3) {
				var x = _g2++;
				lout.b[pout++] = lin.b[(x >> xshift) + pin];
			}
		}
		c.stride = c.width;
		c.pixels = out;
	}
	,njConvert: function() {
		var _g = 0;
		var _g1 = this.ncomp;
		while(_g < _g1) {
			var i = _g++;
			var c = this.comps[i];
			switch(this.filter._hx_index) {
			case 0:
				if(c.width < this.width || c.height < this.height) {
					this.njUpsample(c);
				}
				break;
			case 1:
				while(c.width < this.width || c.height < this.height) {
					if(c.width < this.width) {
						this.njUpsampleH(c);
					}
					if(c.height < this.height) {
						this.njUpsampleV(c);
					}
				}
				break;
			}
			if(c.width < this.width || c.height < this.height) {
				throw haxe_Exception.thrown("assert");
			}
		}
		var pixels = new haxe_io_Bytes(new ArrayBuffer(this.width * this.height * 4));
		if(this.ncomp == 3) {
			var this1 = this.comps[0].pixels;
			var py = this1;
			var this1 = this.comps[1].pixels;
			var pcb = this1;
			var this1 = this.comps[2].pixels;
			var pcr = this1;
			var this1 = pixels;
			var pix = this1;
			var k1 = 0;
			var k2 = 0;
			var k3 = 0;
			var out = 0;
			var _g = 0;
			var _g1 = this.height;
			while(_g < _g1) {
				var yy = _g++;
				var _g2 = 0;
				var _g3 = this.width;
				while(_g2 < _g3) {
					var x = _g2++;
					var y = py.b[k1++] << 8;
					var cb = pcb.b[k2++] - 128;
					var cr = pcr.b[k3++] - 128;
					var x1 = y + 359 * cr + 128 >> 8;
					var r = x1 < 0 ? 0 : x1 > 255 ? 255 : x1;
					var x2 = y - 88 * cb - 183 * cr + 128 >> 8;
					var g = x2 < 0 ? 0 : x2 > 255 ? 255 : x2;
					var x3 = y + 454 * cb + 128 >> 8;
					var b = x3 < 0 ? 0 : x3 > 255 ? 255 : x3;
					pix.b[out++] = b;
					pix.b[out++] = g;
					pix.b[out++] = r;
					pix.b[out++] = 255;
				}
				k1 += this.comps[0].stride - this.width;
				k2 += this.comps[1].stride - this.width;
				k3 += this.comps[2].stride - this.width;
			}
		} else {
			throw haxe_Exception.thrown("TODO");
		}
		return pixels;
	}
	,njDecode: function() {
		if(this.size < 2 || this.bytes.b[this.pos] != 255 || this.bytes.b[this.pos + 1] != 216) {
			throw haxe_Exception.thrown("This file is not a JPEG");
		}
		this.pos += 2;
		this.size -= 2;
		this.length -= 2;
		_hx_loop1: while(true) {
			this.pos += 2;
			this.size -= 2;
			this.length -= 2;
			switch(this.bytes.b[this.pos + (-1)]) {
			case 192:
				this.njDecodeSOF();
				break;
			case 194:
				this.progressive = true;
				if(this.progressive) {
					throw haxe_Exception.thrown("Unsupported progressive JPG");
				}
				if(this.vlctab[4] == null) {
					this.vlctab[4] = new haxe_io_Bytes(new ArrayBuffer(131072));
				}
				if(this.vlctab[5] == null) {
					this.vlctab[5] = new haxe_io_Bytes(new ArrayBuffer(131072));
				}
				if(this.vlctab[6] == null) {
					this.vlctab[6] = new haxe_io_Bytes(new ArrayBuffer(131072));
				}
				if(this.vlctab[7] == null) {
					this.vlctab[7] = new haxe_io_Bytes(new ArrayBuffer(131072));
				}
				this.njDecodeSOF();
				break;
			case 195:
				throw haxe_Exception.thrown("Unsupported lossless JPG");
			case 196:
				this.njDecodeDHT();
				break;
			case 218:
				this.njDecodeScan();
				break _hx_loop1;
			case 219:
				this.njDecodeDQT();
				break;
			case 221:
				this.njDecodeDRI();
				break;
			case 254:
				this.length = this.bytes.b[this.pos] << 8 | this.bytes.b[this.pos + 1];
				this.pos += 2;
				this.size -= 2;
				this.length -= 2;
				var count = this.length;
				this.pos += count;
				this.size -= count;
				this.length -= count;
				break;
			default:
				switch(this.bytes.b[this.pos + (-1)] & 240) {
				case 192:
					throw haxe_Exception.thrown("Unsupported jpeg type " + (this.bytes.b[this.pos + (-1)] & 15));
				case 224:
					this.length = this.bytes.b[this.pos] << 8 | this.bytes.b[this.pos + 1];
					this.pos += 2;
					this.size -= 2;
					this.length -= 2;
					var count1 = this.length;
					this.pos += count1;
					this.size -= count1;
					this.length -= count1;
					break;
				default:
					throw haxe_Exception.thrown("Unsupported jpeg tag 0x" + StringTools.hex(this.bytes.b[this.pos + (-1)],2));
				}
			}
		}
		var pixels = this.njConvert();
		this.cleanup();
		return { pixels : pixels, width : this.width, height : this.height};
	}
	,__class__: hxd_res_NanoJpeg
};
var hxd_res_Sound = function(entry) {
	this.lastPlay = 0.;
	hxd_res_Resource.call(this,entry);
};
$hxClasses["hxd.res.Sound"] = hxd_res_Sound;
hxd_res_Sound.__name__ = "hxd.res.Sound";
hxd_res_Sound.__super__ = hxd_res_Resource;
hxd_res_Sound.prototype = $extend(hxd_res_Resource.prototype,{
	getData: function() {
		if(this.data != null) {
			return this.data;
		}
		var bytes = this.entry.getBytes();
		switch(bytes.b[0]) {
		case 73:case 255:
			this.data = new hxd_snd_Mp3Data(bytes);
			break;
		case 79:
			this.data = new hxd_snd_OggData(bytes);
			break;
		case 82:
			this.data = new hxd_snd_WavData(bytes);
			break;
		default:
		}
		if(this.data == null) {
			throw haxe_Exception.thrown("Unsupported sound format " + this.entry.get_path());
		}
		if(hxd_res_Sound.ENABLE_AUTO_WATCH) {
			this.watch($bind(this,this.watchCallb));
		}
		return this.data;
	}
	,play: function(loop,volume,channelGroup,soundGroup) {
		if(volume == null) {
			volume = 1.;
		}
		if(loop == null) {
			loop = false;
		}
		this.lastPlay = HxOverrides.now() / 1000;
		this.channel = hxd_snd_Manager.get().play(this,channelGroup,soundGroup);
		this.channel.loop = loop;
		this.channel.set_volume(volume);
		return this.channel;
	}
	,watchCallb: function() {
		var old = this.data;
		this.data = null;
		var data = this.getData();
		if(old != null) {
			if(old.channels != data.channels || old.samples != data.samples || old.sampleFormat != data.sampleFormat || old.samplingRate != data.samplingRate) {
				var manager = hxd_snd_Manager.get();
				var ch = manager.getAll(this);
				while(ch.hasNext()) {
					var ch1 = ch.next();
					ch1.duration = data.get_duration();
					ch1.set_position(ch1.position);
				}
			}
		}
	}
	,__class__: hxd_res_Sound
});
var hxd_snd_ChannelBase = function() {
	this.volume = 1.;
	this.bindedEffects = [];
	this.effects = [];
	this.mute = false;
	this.priority = 0.;
};
$hxClasses["hxd.snd.ChannelBase"] = hxd_snd_ChannelBase;
hxd_snd_ChannelBase.__name__ = "hxd.snd.ChannelBase";
hxd_snd_ChannelBase.prototype = {
	set_volume: function(v) {
		this.currentFade = null;
		return this.volume = v;
	}
	,updateCurrentVolume: function(now) {
		if(this.currentFade != null) {
			var f = this.currentFade;
			var dt = now - f.start;
			if(dt >= f.duration) {
				this.set_volume(f.targetVolume);
				if(f.onEnd != null) {
					f.onEnd();
				}
			} else {
				this.set_volume(f.startVolume + dt / f.duration * (f.targetVolume - f.startVolume));
				this.currentFade = f;
			}
		}
		this.currentVolume = this.volume;
	}
	,removeEffect: function(e) {
		HxOverrides.remove(this.effects,e);
	}
	,__class__: hxd_snd_ChannelBase
};
var hxd_snd_Channel = function() {
	this.queue = [];
	this.positionChanged = false;
	this.isLoading = false;
	this.isVirtual = false;
	this.lastStamp = 0.0;
	this.audibleVolume = 1.0;
	this.allowVirtual = true;
	this.loop = false;
	this.pause = false;
	this.position = 0.0;
	hxd_snd_ChannelBase.call(this);
	this.id = hxd_snd_Channel.ID++;
};
$hxClasses["hxd.snd.Channel"] = hxd_snd_Channel;
hxd_snd_Channel.__name__ = "hxd.snd.Channel";
hxd_snd_Channel.__super__ = hxd_snd_ChannelBase;
hxd_snd_Channel.prototype = $extend(hxd_snd_ChannelBase.prototype,{
	onEnd: function() {
	}
	,set_position: function(v) {
		this.lastStamp = HxOverrides.now() / 1000;
		this.positionChanged = true;
		if(v > this.duration) {
			v = this.duration;
		} else if(v < 0) {
			v = 0;
		}
		return this.position = v;
	}
	,updateCurrentVolume: function(now) {
		if(this.pause && this.currentFade != null) {
			var f = this.currentFade;
			this.currentFade = null;
			this.updateCurrentVolume(now);
			this.currentFade = f;
		}
		hxd_snd_ChannelBase.prototype.updateCurrentVolume.call(this,now);
		this.channelGroup.updateCurrentVolume(now);
		this.currentVolume *= this.channelGroup.currentVolume * this.soundGroup.volume;
		if(this.manager != null) {
			var _g = 0;
			var _g1 = this.channelGroup.effects;
			while(_g < _g1.length) {
				var e = _g1[_g];
				++_g;
				this.currentVolume *= e.getVolumeModifier();
			}
			var _g = 0;
			var _g1 = this.effects;
			while(_g < _g1.length) {
				var e = _g1[_g];
				++_g;
				this.currentVolume *= e.getVolumeModifier();
			}
		}
	}
	,calcAudibleVolume: function(now) {
		this.updateCurrentVolume(now);
		this.audibleVolume = this.currentVolume;
		if(this.manager != null) {
			var _g = 0;
			var _g1 = this.channelGroup.effects;
			while(_g < _g1.length) {
				var e = _g1[_g];
				++_g;
				this.audibleVolume = e.applyAudibleVolumeModifier(this.audibleVolume);
			}
			var _g = 0;
			var _g1 = this.effects;
			while(_g < _g1.length) {
				var e = _g1[_g];
				++_g;
				this.audibleVolume = e.applyAudibleVolumeModifier(this.audibleVolume);
			}
		}
	}
	,stop: function() {
		if(this.manager != null) {
			this.manager.releaseChannel(this);
		}
	}
	,isReleased: function() {
		return this.manager == null;
	}
	,__class__: hxd_snd_Channel
});
var hxd_snd_ChannelGroup = function(name) {
	hxd_snd_ChannelBase.call(this);
	this.name = name;
};
$hxClasses["hxd.snd.ChannelGroup"] = hxd_snd_ChannelGroup;
hxd_snd_ChannelGroup.__name__ = "hxd.snd.ChannelGroup";
hxd_snd_ChannelGroup.__super__ = hxd_snd_ChannelBase;
hxd_snd_ChannelGroup.prototype = $extend(hxd_snd_ChannelBase.prototype,{
	__class__: hxd_snd_ChannelGroup
});
var hxd_snd_SampleFormat = $hxEnums["hxd.snd.SampleFormat"] = { __ename__:true,__constructs__:null
	,UI8: {_hx_name:"UI8",_hx_index:0,__enum__:"hxd.snd.SampleFormat",toString:$estr}
	,I16: {_hx_name:"I16",_hx_index:1,__enum__:"hxd.snd.SampleFormat",toString:$estr}
	,F32: {_hx_name:"F32",_hx_index:2,__enum__:"hxd.snd.SampleFormat",toString:$estr}
};
hxd_snd_SampleFormat.__constructs__ = [hxd_snd_SampleFormat.UI8,hxd_snd_SampleFormat.I16,hxd_snd_SampleFormat.F32];
hxd_snd_SampleFormat.__empty_constructs__ = [hxd_snd_SampleFormat.UI8,hxd_snd_SampleFormat.I16,hxd_snd_SampleFormat.F32];
var hxd_snd_Data = function() { };
$hxClasses["hxd.snd.Data"] = hxd_snd_Data;
hxd_snd_Data.__name__ = "hxd.snd.Data";
hxd_snd_Data.prototype = {
	isLoading: function() {
		return false;
	}
	,decode: function(out,outPos,sampleStart,sampleCount) {
		var bpp = this.getBytesPerSample();
		if(sampleStart < 0 || sampleCount < 0 || outPos < 0 || outPos + sampleCount * bpp > out.length) {
			var s = "sampleStart = " + sampleStart;
			s += " sampleCount = " + sampleCount;
			s += " outPos = " + outPos;
			s += " bpp = " + bpp;
			s += " out.length = " + out.length;
			throw haxe_Exception.thrown(s);
		}
		if(sampleStart + sampleCount >= this.samples) {
			var count = 0;
			if(sampleStart < this.samples) {
				count = this.samples - sampleStart;
				this.decodeBuffer(out,outPos,sampleStart,count);
			}
			out.fill(outPos + count * bpp,(sampleCount - count) * bpp,0);
			return;
		}
		this.decodeBuffer(out,outPos,sampleStart,sampleCount);
	}
	,resample: function(rate,format,channels) {
		if(this.sampleFormat == format && this.samplingRate == rate && this.channels == channels) {
			return this;
		}
		var newSamples = Math.ceil(this.samples * (rate / this.samplingRate));
		var bpp = this.getBytesPerSample();
		var data = new haxe_io_Bytes(new ArrayBuffer(bpp * this.samples));
		this.decodeBuffer(data,0,0,this.samples);
		var out = channels * newSamples;
		var out1;
		switch(format._hx_index) {
		case 0:
			out1 = 1;
			break;
		case 1:
			out1 = 2;
			break;
		case 2:
			out1 = 4;
			break;
		}
		var out2 = new haxe_io_Bytes(new ArrayBuffer(out * out1));
		this.resampleBuffer(out2,0,data,0,rate,format,channels,this.samples);
		var data = new hxd_snd_WavData(null);
		data.channels = channels;
		data.samples = newSamples;
		data.sampleFormat = format;
		data.samplingRate = rate;
		data.rawData = out2;
		return data;
	}
	,resampleBuffer: function(out,outPos,input,inPos,rate,format,channels,samples) {
		var bpp = this.getBytesPerSample();
		var newSamples = Math.ceil(samples * (rate / this.samplingRate));
		var resample = samples != newSamples;
		if(!resample && this.sampleFormat == hxd_snd_SampleFormat.I16 && format == hxd_snd_SampleFormat.I16 && channels == 1 && this.channels == 2) {
			var r = inPos;
			var w = outPos;
			var _g = 0;
			var _g1 = samples;
			while(_g < _g1) {
				var i = _g++;
				var sl = input.getUInt16(r);
				r += 2;
				var sr = input.getUInt16(r);
				r += 2;
				var s;
				if((sl ^ sr) >= 32768) {
					if((sl & 32768) != 0) {
						sl |= -65536;
					}
					if((sr & 32768) != 0) {
						sr |= -65536;
					}
					s = sl + sr >> 1 & 65535;
				} else {
					s = sl + sr >> 1;
				}
				out.setUInt16(w,s);
				w += 2;
			}
			return;
		}
		var srcChannels = this.channels;
		var commonChannels = channels < srcChannels ? channels : srcChannels;
		var extraChannels = channels - commonChannels;
		var sval = 0.;
		var ival = 0;
		var _g = 0;
		var _g1 = newSamples;
		while(_g < _g1) {
			var i = _g++;
			var targetSample = i / (newSamples - 1) * (samples - 1);
			var isample = targetSample | 0;
			var offset = targetSample - isample;
			var srcPos = inPos + isample * bpp;
			if(isample == samples - 1) {
				resample = false;
			}
			var _g2 = 0;
			var _g3 = commonChannels;
			while(_g2 < _g3) {
				var k = _g2++;
				var sval1;
				var sval2 = 0.;
				switch(this.sampleFormat._hx_index) {
				case 0:
					sval1 = input.b[srcPos] / 255;
					if(resample) {
						sval2 = input.b[srcPos + bpp] / 255;
					}
					++srcPos;
					break;
				case 1:
					var v = input.getUInt16(srcPos);
					sval1 = ((v & 32768) == 0 ? v : v | -65536) / 32768;
					if(resample) {
						var v1 = input.getUInt16(srcPos + bpp);
						sval2 = ((v1 & 32768) == 0 ? v1 : v1 | -65536) / 32768;
					}
					srcPos += 2;
					break;
				case 2:
					sval1 = input.getFloat(srcPos);
					if(resample) {
						sval2 = input.getFloat(srcPos + bpp);
					}
					srcPos += 4;
					break;
				}
				sval = resample ? sval1 + offset * (sval2 - sval1) : sval1;
				switch(format._hx_index) {
				case 0:
					ival = (sval + 1) * 128 | 0;
					if(ival > 255) {
						ival = 255;
					}
					out.b[outPos++] = ival;
					break;
				case 1:
					ival = sval * 32768 | 0;
					if(ival > 32767) {
						ival = 32767;
					}
					ival &= 65535;
					out.setUInt16(outPos,ival);
					outPos += 2;
					break;
				case 2:
					out.setFloat(outPos,sval);
					outPos += 4;
					break;
				}
			}
			var _g4 = 0;
			var _g5 = extraChannels;
			while(_g4 < _g5) {
				var i1 = _g4++;
				switch(format._hx_index) {
				case 0:
					out.b[outPos++] = ival;
					break;
				case 1:
					out.setUInt16(outPos,ival);
					outPos += 2;
					break;
				case 2:
					out.setFloat(outPos,sval);
					outPos += 4;
					break;
				}
			}
		}
	}
	,decodeBuffer: function(out,outPos,sampleStart,sampleCount) {
		throw haxe_Exception.thrown("Not implemented");
	}
	,getBytesPerSample: function() {
		var tmp;
		switch(this.sampleFormat._hx_index) {
		case 0:
			tmp = 1;
			break;
		case 1:
			tmp = 2;
			break;
		case 2:
			tmp = 4;
			break;
		}
		return this.channels * tmp;
	}
	,load: function(onEnd) {
		onEnd();
	}
	,get_duration: function() {
		return this.samples / this.samplingRate;
	}
	,__class__: hxd_snd_Data
};
var hxd_snd_EffectDriver = function() {
};
$hxClasses["hxd.snd.EffectDriver"] = hxd_snd_EffectDriver;
hxd_snd_EffectDriver.__name__ = "hxd.snd.EffectDriver";
hxd_snd_EffectDriver.prototype = {
	acquire: function() {
	}
	,release: function() {
	}
	,update: function(e) {
	}
	,bind: function(e,source) {
	}
	,apply: function(e,source) {
	}
	,unbind: function(e,source) {
	}
	,__class__: hxd_snd_EffectDriver
};
var hxd_snd_DriverFeature = $hxEnums["hxd.snd.DriverFeature"] = { __ename__:true,__constructs__:null
	,MasterVolume: {_hx_name:"MasterVolume",_hx_index:0,__enum__:"hxd.snd.DriverFeature",toString:$estr}
};
hxd_snd_DriverFeature.__constructs__ = [hxd_snd_DriverFeature.MasterVolume];
hxd_snd_DriverFeature.__empty_constructs__ = [hxd_snd_DriverFeature.MasterVolume];
var hxd_snd_Driver = function() { };
$hxClasses["hxd.snd.Driver"] = hxd_snd_Driver;
hxd_snd_Driver.__name__ = "hxd.snd.Driver";
hxd_snd_Driver.__isInterface__ = true;
hxd_snd_Driver.prototype = {
	__class__: hxd_snd_Driver
};
var hxd_snd_Effect = function(type) {
	this.refs = 0;
	this.priority = 0;
	this.retainTime = 0.0;
	this.lastStamp = 0.0;
	var managerDriver = hxd_snd_Manager.get().driver;
	if(managerDriver != null) {
		this.driver = managerDriver.getEffectDriver(type);
	}
};
$hxClasses["hxd.snd.Effect"] = hxd_snd_Effect;
hxd_snd_Effect.__name__ = "hxd.snd.Effect";
hxd_snd_Effect.prototype = {
	applyAudibleVolumeModifier: function(v) {
		return v;
	}
	,getVolumeModifier: function() {
		return 1;
	}
	,__class__: hxd_snd_Effect
};
var hxd_snd_Listener = function() {
	this.position = new h3d_Vector();
	this.velocity = new h3d_Vector();
	this.direction = new h3d_Vector(1,0,0);
	this.up = new h3d_Vector(0,0,1);
};
$hxClasses["hxd.snd.Listener"] = hxd_snd_Listener;
hxd_snd_Listener.__name__ = "hxd.snd.Listener";
hxd_snd_Listener.prototype = {
	__class__: hxd_snd_Listener
};
var hxd_snd_Source = function(driver) {
	this.start = 0;
	this.playing = false;
	this.volume = -1.0;
	this.id = hxd_snd_Source.ID++;
	this.handle = driver.createSource();
	this.buffers = [];
};
$hxClasses["hxd.snd.Source"] = hxd_snd_Source;
hxd_snd_Source.__name__ = "hxd.snd.Source";
hxd_snd_Source.prototype = {
	__class__: hxd_snd_Source
};
var hxd_snd_Buffer = function(driver) {
	this.handle = driver.createBuffer();
	this.refs = 0;
	this.lastStop = HxOverrides.now() / 1000;
};
$hxClasses["hxd.snd.Buffer"] = hxd_snd_Buffer;
hxd_snd_Buffer.__name__ = "hxd.snd.Buffer";
hxd_snd_Buffer.prototype = {
	dispose: function() {
		hxd_snd_Manager.get().driver.destroyBuffer(this.handle);
	}
	,__class__: hxd_snd_Buffer
};
var hxd_snd_Manager = function() {
	this.suspended = false;
	this.timeOffset = 0.;
	try {
		this.driver = new hxd_snd_webaudio_Driver();
	} catch( _g ) {
		if(typeof(haxe_Exception.caught(_g).unwrap()) == "string") {
			this.driver = null;
		} else {
			throw _g;
		}
	}
	this.masterVolume = 1.0;
	this.hasMasterVolume = this.driver == null ? true : this.driver.hasFeature(hxd_snd_DriverFeature.MasterVolume);
	this.masterSoundGroup = new hxd_snd_SoundGroup("master");
	this.masterChannelGroup = new hxd_snd_ChannelGroup("master");
	this.listener = new hxd_snd_Listener();
	this.soundBufferMap = new haxe_ds_StringMap();
	this.soundBufferKeys = [];
	this.freeStreamBuffers = [];
	this.effectGC = [];
	this.soundBufferCount = 0;
	if(this.driver != null) {
		this.sources = [];
		var _g = 0;
		var _g1 = hxd_snd_Manager.MAX_SOURCES;
		while(_g < _g1) {
			var i = _g++;
			this.sources.push(new hxd_snd_Source(this.driver));
		}
	}
	this.cachedBytes = new haxe_io_Bytes(new ArrayBuffer(24));
	this.resampleBytes = new haxe_io_Bytes(new ArrayBuffer(hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT * 2));
};
$hxClasses["hxd.snd.Manager"] = hxd_snd_Manager;
hxd_snd_Manager.__name__ = "hxd.snd.Manager";
hxd_snd_Manager.get = function() {
	if(hxd_snd_Manager.instance == null) {
		hxd_snd_Manager.instance = new hxd_snd_Manager();
		hxd_snd_Manager.instance.updateEvent = haxe_MainLoop.add(($_=hxd_snd_Manager.instance,$bind($_,$_.update)));
	}
	return hxd_snd_Manager.instance;
};
hxd_snd_Manager.regEffect = function(list,e) {
	var l = list;
	while(l != null) {
		if(l == e) {
			return list;
		}
		l = l.next;
	}
	e.next = list;
	return e;
};
hxd_snd_Manager.prototype = {
	getTmpBytes: function(size) {
		if(this.cachedBytes.length < size) {
			this.cachedBytes = new haxe_io_Bytes(new ArrayBuffer(size));
		}
		return this.cachedBytes;
	}
	,getResampleBytes: function(size) {
		if(this.resampleBytes.length < size) {
			this.resampleBytes = new haxe_io_Bytes(new ArrayBuffer(size));
		}
		return this.resampleBytes;
	}
	,getAll: function(sound) {
		var ch = this.channels;
		var result = [];
		while(ch != null) {
			if(ch.sound == sound) {
				result.push(ch);
			}
			ch = ch.next;
		}
		return new hxd_impl_ArrayIterator_$hxd_$snd_$Channel(result);
	}
	,play: function(sound,channelGroup,soundGroup) {
		if(soundGroup == null) {
			soundGroup = this.masterSoundGroup;
		}
		if(channelGroup == null) {
			channelGroup = this.masterChannelGroup;
		}
		var sdat = sound.getData();
		if(sdat.samples == 0) {
			throw haxe_Exception.thrown(Std.string(sound) + " has no samples");
		}
		var c = new hxd_snd_Channel();
		c.sound = sound;
		c.duration = sdat.get_duration();
		c.manager = this;
		c.soundGroup = soundGroup;
		c.channelGroup = channelGroup;
		c.next = this.channels;
		c.isLoading = sdat.isLoading();
		c.isVirtual = this.driver == null;
		c.lastStamp = HxOverrides.now() / 1000;
		this.channels = c;
		return c;
	}
	,updateVirtualChannels: function(now) {
		var c = this.channels;
		while(c != null) {
			if(c.pause || !c.isVirtual || c.isLoading) {
				c = c.next;
				continue;
			}
			var a = now - c.lastStamp;
			c.set_position(c.position + (a < 0.0 ? 0.0 : a));
			c.lastStamp = now;
			var next = c.next;
			while(c.position >= c.duration) {
				c.set_position(c.position - c.duration);
				c.onEnd();
				if(next != null && next.manager == null) {
					next = null;
				}
				if(c.queue.length > 0) {
					c.sound = c.queue.shift();
					c.duration = c.sound.getData().get_duration();
				} else if(!c.loop) {
					this.releaseChannel(c);
					break;
				}
			}
			c = next;
		}
	}
	,update: function() {
		if(this.timeOffset != 0) {
			var c = this.channels;
			while(c != null) {
				c.lastStamp += this.timeOffset;
				if(c.currentFade != null) {
					c.currentFade.start += this.timeOffset;
				}
				c = c.next;
			}
			var _g = 0;
			var _g1 = this.sources;
			while(_g < _g1.length) {
				var s = _g1[_g];
				++_g;
				var _g2 = 0;
				var _g3 = s.buffers;
				while(_g2 < _g3.length) {
					var b = _g3[_g2];
					++_g2;
					b.lastStop += this.timeOffset;
				}
			}
			this.timeOffset = 0;
		}
		this.now = HxOverrides.now() / 1000;
		if(this.driver == null) {
			this.updateVirtualChannels(this.now);
			return;
		}
		var _g = 0;
		var _g1 = this.sources;
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			var c = s.channel;
			if(c == null) {
				continue;
			}
			if(c.positionChanged) {
				this.releaseSource(s);
				continue;
			}
			var lastBuffer = null;
			var count = this.driver.getProcessedBuffers(s.handle);
			var _g2 = 0;
			var _g3 = count;
			while(_g2 < _g3) {
				var i = _g2++;
				var b = this.unqueueBuffer(s);
				if(b == null) {
					continue;
				}
				lastBuffer = b;
				if(b.isEnd) {
					c.sound = b.sound;
					c.duration = b.sound.getData().get_duration();
					c.set_position(c.duration);
					c.positionChanged = false;
					c.onEnd();
					s.start = 0;
				}
			}
			if(s.buffers.length == 0) {
				if(!lastBuffer.isEnd) {
					c.set_position((lastBuffer.start + lastBuffer.samples) / lastBuffer.sampleRate);
					this.releaseSource(s);
				} else if(c.queue.length > 0) {
					c.sound = c.queue.shift();
					c.duration = c.sound.getData().get_duration();
					c.set_position(0);
					this.releaseSource(s);
				} else if(c.loop) {
					c.set_position(0);
					this.releaseSource(s);
				} else {
					this.releaseChannel(c);
				}
				continue;
			}
			c.sound = s.buffers[0].sound;
			c.duration = c.sound.getData().get_duration();
			var playedSamples = this.driver.getPlayedSampleCount(s.handle);
			if(playedSamples < 0) {
				playedSamples = 0;
			}
			c.set_position(s.start / this.targetRate + playedSamples / s.buffers[0].sampleRate);
			c.positionChanged = false;
			if(s.buffers.length < hxd_snd_Manager.BUFFER_QUEUE_LENGTH) {
				var b1 = s.buffers[s.buffers.length - 1];
				if(!b1.isEnd) {
					this.queueBuffer(s,b1.sound,b1.start + b1.samples);
				} else if(c.queue.length > 0) {
					var snd = c.queue[0];
					if(this.queueBuffer(s,snd,0)) {
						c.queue.shift();
					}
				} else if(c.loop) {
					this.queueBuffer(s,b1.sound,0);
				}
			}
		}
		var c = this.channels;
		while(c != null) {
			c.calcAudibleVolume(this.now);
			if(c.isLoading && !c.sound.getData().isLoading()) {
				c.isLoading = false;
			}
			c.isVirtual = this.suspended || c.pause || c.mute || c.channelGroup.mute || c.allowVirtual && c.audibleVolume < hxd_snd_Manager.VIRTUAL_VOLUME_THRESHOLD || c.isLoading;
			c = c.next;
		}
		var list = this.channels;
		var cmp = $bind(this,this.sortChannel);
		var tmp;
		if(list == null) {
			tmp = null;
		} else {
			var insize = 1;
			var nmerges;
			var psize = 0;
			var qsize = 0;
			var p;
			var q;
			var e;
			var tail;
			while(true) {
				p = list;
				list = null;
				tail = null;
				nmerges = 0;
				while(p != null) {
					++nmerges;
					q = p;
					psize = 0;
					var _g = 0;
					var _g1 = insize;
					while(_g < _g1) {
						var i = _g++;
						++psize;
						q = q.next;
						if(q == null) {
							break;
						}
					}
					qsize = insize;
					while(psize > 0 || qsize > 0 && q != null) {
						if(psize == 0) {
							e = q;
							q = q.next;
							--qsize;
						} else if(qsize == 0 || q == null || cmp(p,q) <= 0) {
							e = p;
							p = p.next;
							--psize;
						} else {
							e = q;
							q = q.next;
							--qsize;
						}
						if(tail != null) {
							tail.next = e;
						} else {
							list = e;
						}
						tail = e;
					}
					p = q;
				}
				tail.next = null;
				if(nmerges <= 1) {
					break;
				}
				insize *= 2;
			}
			tmp = list;
		}
		this.channels = tmp;
		var audibleCount = 0;
		var c = this.channels;
		while(c != null && !c.isVirtual) {
			if(++audibleCount > this.sources.length) {
				c.isVirtual = true;
			} else if(c.soundGroup.maxAudible >= 0) {
				if(c.soundGroup.lastUpdate != this.now) {
					c.soundGroup.lastUpdate = this.now;
					c.soundGroup.numAudible = 0;
				}
				if(++c.soundGroup.numAudible > c.soundGroup.maxAudible) {
					c.isVirtual = true;
					--audibleCount;
				}
			}
			c = c.next;
		}
		var _g = 0;
		var _g1 = this.sources;
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			if(s.channel == null || !s.channel.isVirtual) {
				continue;
			}
			this.releaseSource(s);
		}
		var c = this.channels;
		while(c != null) {
			if(c.source != null || c.isVirtual) {
				c = c.next;
				continue;
			}
			var s = null;
			var _g = 0;
			var _g1 = this.sources;
			while(_g < _g1.length) {
				var s2 = _g1[_g];
				++_g;
				if(s2.channel == null) {
					s = s2;
					break;
				}
			}
			if(s == null) {
				throw haxe_Exception.thrown("could not get a source");
			}
			s.channel = c;
			c.source = s;
			this.checkTargetFormat(c.sound.getData(),c.soundGroup.mono);
			s.start = Math.floor(c.position * this.targetRate);
			if(s.start < 0) {
				s.start = 0;
			}
			this.queueBuffer(s,c.sound,s.start);
			c.positionChanged = false;
			c = c.next;
		}
		var usedEffects = null;
		var volume = this.hasMasterVolume ? 1. : this.masterVolume;
		var _g = 0;
		var _g1 = this.sources;
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			var c = s.channel;
			if(c == null) {
				continue;
			}
			var v = c.currentVolume * volume;
			if(s.volume != v) {
				if(v < 0) {
					v = 0;
				}
				s.volume = v;
				this.driver.setSourceVolume(s.handle,v);
			}
			if(!s.playing) {
				this.driver.playSource(s.handle);
				s.playing = true;
			}
			var i = c.bindedEffects.length;
			while(--i >= 0) {
				var e = c.bindedEffects[i];
				if(c.effects.indexOf(e) < 0 && c.channelGroup.effects.indexOf(e) < 0) {
					this.unbindEffect(c,s,e);
				}
			}
			var _g2 = 0;
			var _g3 = c.channelGroup.effects;
			while(_g2 < _g3.length) {
				var e1 = _g3[_g2];
				++_g2;
				if(c.bindedEffects.indexOf(e1) < 0) {
					this.bindEffect(c,s,e1);
				}
			}
			var _g4 = 0;
			var _g5 = c.effects;
			while(_g4 < _g5.length) {
				var e2 = _g5[_g4];
				++_g4;
				if(c.bindedEffects.indexOf(e2) < 0) {
					this.bindEffect(c,s,e2);
				}
			}
			var _g6 = 0;
			var _g7 = c.bindedEffects;
			while(_g6 < _g7.length) {
				var e3 = _g7[_g6];
				++_g6;
				usedEffects = hxd_snd_Manager.regEffect(usedEffects,e3);
			}
		}
		var list = usedEffects;
		var cmp = $bind(this,this.sortEffect);
		if(list == null) {
			usedEffects = null;
		} else {
			var insize = 1;
			var nmerges;
			var psize = 0;
			var qsize = 0;
			var p;
			var q;
			var e;
			var tail;
			while(true) {
				p = list;
				list = null;
				tail = null;
				nmerges = 0;
				while(p != null) {
					++nmerges;
					q = p;
					psize = 0;
					var _g = 0;
					var _g1 = insize;
					while(_g < _g1) {
						var i = _g++;
						++psize;
						q = q.next;
						if(q == null) {
							break;
						}
					}
					qsize = insize;
					while(psize > 0 || qsize > 0 && q != null) {
						if(psize == 0) {
							e = q;
							q = q.next;
							--qsize;
						} else if(qsize == 0 || q == null || cmp(p,q) <= 0) {
							e = p;
							p = p.next;
							--psize;
						} else {
							e = q;
							q = q.next;
							--qsize;
						}
						if(tail != null) {
							tail.next = e;
						} else {
							list = e;
						}
						tail = e;
					}
					p = q;
				}
				tail.next = null;
				if(nmerges <= 1) {
					break;
				}
				insize *= 2;
			}
			usedEffects = list;
		}
		var e = usedEffects;
		while(e != null) {
			e.driver.update(e);
			e = e.next;
		}
		var _g = 0;
		var _g1 = this.sources;
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			var c = s.channel;
			if(c == null) {
				continue;
			}
			var _g2 = 0;
			var _g3 = c.bindedEffects;
			while(_g2 < _g3.length) {
				var e = _g3[_g2];
				++_g2;
				e.driver.apply(e,s.handle);
			}
		}
		var _g = 0;
		var _g1 = this.effectGC;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			if(this.now - e.lastStamp > e.retainTime) {
				e.driver.release();
				HxOverrides.remove(this.effectGC,e);
				break;
			}
		}
		this.updateVirtualChannels(this.now);
		var _this = this.listener.direction;
		var k = _this.x * _this.x + _this.y * _this.y + _this.z * _this.z;
		if(k < 1e-10) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		_this.x *= k;
		_this.y *= k;
		_this.z *= k;
		var _this = this.listener.up;
		var k = _this.x * _this.x + _this.y * _this.y + _this.z * _this.z;
		if(k < 1e-10) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		_this.x *= k;
		_this.y *= k;
		_this.z *= k;
		if(this.hasMasterVolume) {
			this.driver.setMasterVolume(this.masterVolume);
		}
		this.driver.setListenerParams(this.listener.position,this.listener.direction,this.listener.up,this.listener.velocity);
		this.driver.update();
		if(this.soundBufferCount >= hxd_snd_Manager.SOUND_BUFFER_CACHE_SIZE) {
			var now = HxOverrides.now() / 1000;
			var i = 0;
			while(i < this.soundBufferKeys.length) {
				var k = this.soundBufferKeys[i];
				var b = this.soundBufferMap.h[k];
				++i;
				if(b.refs > 0 || b.lastStop + 60.0 > now) {
					continue;
				}
				var _this = this.soundBufferMap;
				if(Object.prototype.hasOwnProperty.call(_this.h,k)) {
					delete(_this.h[k]);
				}
				HxOverrides.remove(this.soundBufferKeys,k);
				--i;
				b.dispose();
				--this.soundBufferCount;
			}
		}
	}
	,progressiveDecodeBuffer: function(s,snd,start) {
		var data = snd.getData();
		var samples = Math.ceil(hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT / hxd_snd_Manager.BUFFER_STREAM_SPLIT);
		if(s.streamStart != start || s.streamSound != snd) {
			s.streamSound = snd;
			s.streamStart = start;
			s.streamPos = start;
		}
		var end = start + hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT;
		if(s.streamPos == end) {
			return true;
		}
		var bpp = data.getBytesPerSample();
		var reqSize = hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT * bpp;
		if(s.streamBuffer == null || s.streamBuffer.length < reqSize) {
			s.streamBuffer = new haxe_io_Bytes(new ArrayBuffer(reqSize));
			s.streamPos = start;
		}
		var remain = end - s.streamPos;
		if(remain > samples) {
			remain = samples;
		}
		data.decode(s.streamBuffer,(s.streamPos - start) * bpp,s.streamPos,remain);
		s.streamPos += remain;
		return s.streamPos == end;
	}
	,queueBuffer: function(s,snd,start) {
		var data = snd.getData();
		var sgroup = s.channel.soundGroup;
		var b = null;
		if(data.get_duration() <= hxd_snd_Manager.STREAM_DURATION) {
			b = this.getSoundBuffer(snd,sgroup);
			this.driver.queueBuffer(s.handle,b.handle,start,true);
		} else {
			if(s.buffers.length > 0 && hxd_snd_Manager.BUFFER_STREAM_SPLIT > 1 && !this.progressiveDecodeBuffer(s,snd,start)) {
				return false;
			}
			b = this.getStreamBuffer(s,snd,sgroup,start);
			this.driver.queueBuffer(s.handle,b.handle,0,b.isEnd);
		}
		s.buffers.push(b);
		return true;
	}
	,unqueueBuffer: function(s) {
		var b = s.buffers.shift();
		if(b == null) {
			return null;
		}
		this.driver.unqueueBuffer(s.handle,b.handle);
		if(b.isStream) {
			this.freeStreamBuffers.unshift(b);
		} else if(--b.refs == 0) {
			b.lastStop = HxOverrides.now() / 1000;
		}
		return b;
	}
	,bindEffect: function(c,s,e) {
		if(e.refs == 0 && !HxOverrides.remove(this.effectGC,e)) {
			e.driver.acquire();
		}
		++e.refs;
		e.driver.bind(e,s.handle);
		c.bindedEffects.push(e);
	}
	,unbindEffect: function(c,s,e) {
		e.driver.unbind(e,s.handle);
		HxOverrides.remove(c.bindedEffects,e);
		if(--e.refs == 0) {
			e.lastStamp = this.now;
			this.effectGC.push(e);
		}
	}
	,releaseSource: function(s) {
		if(s.channel != null) {
			var _g = 0;
			var _g1 = s.channel.bindedEffects.slice();
			while(_g < _g1.length) {
				var e = _g1[_g];
				++_g;
				this.unbindEffect(s.channel,s,e);
			}
			s.channel.bindedEffects = [];
			s.channel.source = null;
			s.channel = null;
		}
		if(s.playing) {
			s.playing = false;
			this.driver.stopSource(s.handle);
			s.volume = -1.0;
		}
		while(s.buffers.length > 0) this.unqueueBuffer(s);
	}
	,checkTargetFormat: function(dat,forceMono) {
		if(forceMono == null) {
			forceMono = false;
		}
		this.targetRate = dat.samplingRate;
		this.targetChannels = forceMono || dat.channels == 1 ? 1 : 2;
		var tmp;
		switch(dat.sampleFormat._hx_index) {
		case 0:
			tmp = hxd_snd_SampleFormat.UI8;
			break;
		case 1:
			tmp = hxd_snd_SampleFormat.I16;
			break;
		case 2:
			tmp = hxd_snd_SampleFormat.F32;
			break;
		}
		this.targetFormat = tmp;
		if(this.targetChannels == dat.channels && this.targetFormat == dat.sampleFormat) {
			return this.targetRate == dat.samplingRate;
		} else {
			return false;
		}
	}
	,getSoundBuffer: function(snd,grp) {
		var _gthis = this;
		var data = snd.getData();
		var mono = grp.mono;
		var key = snd.entry.get_path();
		if(mono && data.channels != 1) {
			key += "mono";
		}
		var b = this.soundBufferMap.h[key];
		if(b == null) {
			b = new hxd_snd_Buffer(this.driver);
			b.isStream = false;
			b.isEnd = true;
			b.sound = snd;
			data.load(function() {
				_gthis.fillSoundBuffer(b,data,mono);
			});
			this.soundBufferMap.h[key] = b;
			this.soundBufferKeys.push(key);
			++this.soundBufferCount;
		}
		++b.refs;
		return b;
	}
	,fillSoundBuffer: function(buf,dat,forceMono) {
		if(forceMono == null) {
			forceMono = false;
		}
		if(!this.checkTargetFormat(dat,forceMono)) {
			dat = dat.resample(this.targetRate,this.targetFormat,this.targetChannels);
		}
		var length = dat.samples * dat.getBytesPerSample();
		var bytes = this.getTmpBytes(length);
		dat.decode(bytes,0,0,dat.samples);
		this.driver.setBufferData(buf.handle,bytes,length,this.targetFormat,this.targetChannels,this.targetRate);
		buf.sampleRate = this.targetRate;
		buf.samples = dat.samples;
	}
	,getStreamBuffer: function(src,snd,grp,start) {
		var data = snd.getData();
		var b = this.freeStreamBuffers.shift();
		if(b == null) {
			b = new hxd_snd_Buffer(this.driver);
			b.isStream = true;
		}
		var samples = hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT;
		if(start + samples >= data.samples) {
			samples = data.samples - start;
			b.isEnd = true;
		} else {
			b.isEnd = false;
		}
		b.sound = snd;
		b.samples = samples;
		b.start = start;
		var size = samples * data.getBytesPerSample();
		var bytes;
		if(src.streamSound == snd && src.streamStart == start) {
			while(!this.progressiveDecodeBuffer(src,snd,start)) {
			}
			bytes = src.streamBuffer;
		} else {
			bytes = this.getTmpBytes(size);
			data.decode(bytes,0,start,samples);
		}
		if(!this.checkTargetFormat(data,grp.mono)) {
			var size1 = Math.ceil(samples * (this.targetRate / data.samplingRate)) * this.targetChannels;
			var size2;
			switch(this.targetFormat._hx_index) {
			case 0:
				size2 = 1;
				break;
			case 1:
				size2 = 2;
				break;
			case 2:
				size2 = 4;
				break;
			}
			size = size1 * size2;
			var resampleBytes = this.getResampleBytes(size);
			data.resampleBuffer(resampleBytes,0,bytes,0,this.targetRate,this.targetFormat,this.targetChannels,samples);
			bytes = resampleBytes;
		}
		this.driver.setBufferData(b.handle,bytes,size,this.targetFormat,this.targetChannels,this.targetRate);
		b.sampleRate = this.targetRate;
		return b;
	}
	,sortChannel: function(a,b) {
		if(a.isVirtual != b.isVirtual) {
			if(a.isVirtual) {
				return 1;
			} else {
				return -1;
			}
		}
		if(a.channelGroup.priority != b.channelGroup.priority) {
			if(a.channelGroup.priority < b.channelGroup.priority) {
				return 1;
			} else {
				return -1;
			}
		}
		if(a.priority != b.priority) {
			if(a.priority < b.priority) {
				return 1;
			} else {
				return -1;
			}
		}
		if(a.audibleVolume != b.audibleVolume) {
			if(a.audibleVolume < b.audibleVolume) {
				return 1;
			} else {
				return -1;
			}
		}
		if(a.id < b.id) {
			return 1;
		} else {
			return -1;
		}
	}
	,sortEffect: function(a,b) {
		return b.priority - a.priority;
	}
	,releaseChannel: function(c) {
		if(c.manager == null) {
			return;
		}
		if(this.channels == c) {
			this.channels = c.next;
		} else {
			var prev = this.channels;
			while(prev.next != c) prev = prev.next;
			prev.next = c.next;
		}
		var _g = 0;
		var _g1 = c.effects;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			c.removeEffect(e);
		}
		if(c.source != null) {
			this.releaseSource(c.source);
		}
		c.next = null;
		c.manager = null;
		c.effects = null;
		c.bindedEffects = null;
		c.currentFade = null;
		var snd = c.sound;
		if(snd != null && snd.channel == c) {
			snd.channel = null;
		}
	}
	,__class__: hxd_snd_Manager
};
var hxd_snd_Mp3Data = function(bytes) {
	var mp = new format_mp3_Reader(new haxe_io_BytesInput(bytes)).read();
	this.samples = mp.sampleCount;
	var frame = mp.frames[0].data;
	var lame = -1;
	var _g = 0;
	var _g1 = frame.length - 24;
	while(_g < _g1) {
		var i = _g++;
		if(frame.b[i] == 76 && frame.b[i + 1] == 65 && frame.b[i + 2] == 77 && frame.b[i + 3] == 69) {
			lame = i;
			break;
		}
	}
	if(lame >= 0) {
		var startEnd = frame.b[lame + 21] << 16 | frame.b[lame + 22] << 8 | frame.b[lame + 23];
		var start = startEnd >> 12;
		var end = startEnd & 4095;
		this.samples -= start + end + 1152;
	}
	var header = mp.frames[0].header;
	this.sampleFormat = hxd_snd_SampleFormat.F32;
	this.samplingRate = format_mp3_MPEG.srEnum2Num(header.samplingRate);
	this.channels = header.channelMode == format_mp3_ChannelMode.Mono ? 1 : 2;
	var ctx = hxd_snd_webaudio_Context.get();
	if(ctx == null) {
		return;
	}
	ctx.decodeAudioData(bytes.b.bufferValue,$bind(this,this.processBuffer));
	var decodedRate = ctx.sampleRate | 0;
	this.samples = Math.ceil(this.samples * decodedRate / this.samplingRate);
	this.samplingRate = decodedRate;
};
$hxClasses["hxd.snd.Mp3Data"] = hxd_snd_Mp3Data;
hxd_snd_Mp3Data.__name__ = "hxd.snd.Mp3Data";
hxd_snd_Mp3Data.__super__ = hxd_snd_Data;
hxd_snd_Mp3Data.prototype = $extend(hxd_snd_Data.prototype,{
	isLoading: function() {
		return this.buffer == null;
	}
	,load: function(onEnd) {
		if(this.buffer != null) {
			onEnd();
		} else {
			this.onEnd = onEnd;
		}
	}
	,processBuffer: function(buf) {
		var left = buf.getChannelData(0);
		this.samples = buf.length;
		if(this.channels == 1) {
			this.buffer = haxe_io_Bytes.ofData(left.buffer);
			return;
		}
		var right = buf.numberOfChannels < 2 ? left : buf.getChannelData(1);
		var join = new Float32Array(left.length * 2);
		var w = 0;
		var _g = 0;
		var _g1 = buf.length;
		while(_g < _g1) {
			var i = _g++;
			join[w++] = left[i];
			join[w++] = right[i];
		}
		this.buffer = haxe_io_Bytes.ofData(join.buffer);
		if(this.onEnd != null) {
			this.onEnd();
			this.onEnd = null;
		}
	}
	,decodeBuffer: function(out,outPos,sampleStart,sampleCount) {
		if(this.buffer == null) {
			out.fill(outPos,sampleCount * 4 * this.channels,0);
		} else {
			out.blit(outPos,this.buffer,sampleStart * 4 * this.channels,sampleCount * 4 * this.channels);
		}
	}
	,__class__: hxd_snd_Mp3Data
});
var hxd_snd__$OggData_BytesOutput = function() {
};
$hxClasses["hxd.snd._OggData.BytesOutput"] = hxd_snd__$OggData_BytesOutput;
hxd_snd__$OggData_BytesOutput.__name__ = "hxd.snd._OggData.BytesOutput";
hxd_snd__$OggData_BytesOutput.__super__ = haxe_io_Output;
hxd_snd__$OggData_BytesOutput.prototype = $extend(haxe_io_Output.prototype,{
	done: function() {
	}
	,init: function(bytes,position) {
		this.bytes = bytes;
		this.position = position;
	}
	,writeFloat: function(f) {
		this.bytes.setFloat(this.position,f);
		this.position += 4;
	}
	,writeInt16: function(i) {
		this.bytes.setUInt16(this.position,i);
		this.position += 2;
	}
	,__class__: hxd_snd__$OggData_BytesOutput
});
var hxd_snd_OggData = function(bytes) {
	if(bytes != null) {
		this.reader = stb_format_vorbis_Reader.openFromBytes(bytes);
		this.samples = this.reader.get_totalSample();
		this.channels = this.reader.get_header().channel;
		this.samplingRate = this.reader.get_header().sampleRate;
		this.sampleFormat = hxd_snd_SampleFormat.F32;
	}
	this.output = new hxd_snd__$OggData_BytesOutput();
	this.decodedFirst = 0;
	this.decodedLast = 0;
};
$hxClasses["hxd.snd.OggData"] = hxd_snd_OggData;
hxd_snd_OggData.__name__ = "hxd.snd.OggData";
hxd_snd_OggData.__super__ = hxd_snd_Data;
hxd_snd_OggData.prototype = $extend(hxd_snd_Data.prototype,{
	resample: function(rate,format,channels) {
		if(this.sampleFormat == format && this.samplingRate == rate && this.channels == channels) {
			return this;
		}
		switch(format._hx_index) {
		case 1:case 2:
			if(rate % this.samplingRate == 0 && channels >= this.channels) {
				var c = new hxd_snd_OggData(null);
				c.reader = this.reader;
				c.samples = this.samples;
				c.samplingRate = this.samplingRate;
				c.sampleFormat = format;
				c.channels = channels;
				return c;
			} else {
				return hxd_snd_Data.prototype.resample.call(this,rate,format,channels);
			}
			break;
		default:
			return hxd_snd_Data.prototype.resample.call(this,rate,format,channels);
		}
	}
	,decodeBuffer: function(out,outPos,sampleStart,sampleCount) {
		var last = sampleStart + sampleCount;
		var bpp = this.getBytesPerSample();
		if(sampleStart < this.decodedFirst || last > this.decodedLast) {
			var need = sampleCount - sampleStart;
			if(need > 132300 || this.samples > 132300) {
				this.output.init(out,outPos);
				this.reader.set_currentSample(sampleStart);
				this.reader.read(this.output,sampleCount,this.channels,this.samplingRate,this.sampleFormat == hxd_snd_SampleFormat.F32);
				this.output.done();
				return;
			}
			if(this.decoded == null) {
				this.decoded = new haxe_io_Bytes(new ArrayBuffer((this.samples < 132300 ? this.samples : 132300) * bpp));
			}
			need = 132300;
			if(sampleStart + need > this.samples) {
				need = this.samples - sampleStart;
			}
			this.output.init(this.decoded,0);
			this.reader.set_currentSample(sampleStart);
			this.reader.read(this.output,need,this.channels,this.samplingRate,this.sampleFormat == hxd_snd_SampleFormat.F32);
			this.output.done();
			this.decodedFirst = sampleStart;
			this.decodedLast = sampleStart + need;
			if(sampleStart == 0 && need == this.samples) {
				this.reader = null;
				this.output = null;
			}
		}
		out.blit(outPos,this.decoded,(sampleStart - this.decodedFirst) * bpp,sampleCount * bpp);
	}
	,__class__: hxd_snd_OggData
});
var hxd_snd_SoundGroup = function(name) {
	this.name = name;
	this.maxAudible = -1;
	this.volume = 1;
	this.mono = false;
};
$hxClasses["hxd.snd.SoundGroup"] = hxd_snd_SoundGroup;
hxd_snd_SoundGroup.__name__ = "hxd.snd.SoundGroup";
hxd_snd_SoundGroup.prototype = {
	__class__: hxd_snd_SoundGroup
};
var hxd_snd_WavData = function(bytes) {
	if(bytes != null) {
		this.init(new format_wav_Reader(new haxe_io_BytesInput(bytes)).read());
	}
};
$hxClasses["hxd.snd.WavData"] = hxd_snd_WavData;
hxd_snd_WavData.__name__ = "hxd.snd.WavData";
hxd_snd_WavData.__super__ = hxd_snd_Data;
hxd_snd_WavData.prototype = $extend(hxd_snd_Data.prototype,{
	init: function(d) {
		var h = d.header;
		this.samplingRate = h.samplingRate;
		this.channels = h.channels;
		var tmp;
		switch(h.bitsPerSample) {
		case 8:
			tmp = hxd_snd_SampleFormat.UI8;
			break;
		case 16:
			tmp = hxd_snd_SampleFormat.I16;
			break;
		default:
			throw haxe_Exception.thrown("Unsupported WAV " + h.bitsPerSample + " bits");
		}
		this.sampleFormat = tmp;
		this.rawData = d.data;
		this.samples = this.rawData.length / this.getBytesPerSample() | 0;
	}
	,decodeBuffer: function(out,outPos,sampleStart,sampleCount) {
		var bpp = this.getBytesPerSample();
		out.blit(outPos,this.rawData,sampleStart * bpp,sampleCount * bpp);
	}
	,__class__: hxd_snd_WavData
});
var hxd_snd_effect_LowPass = function() {
	hxd_snd_Effect.call(this,"lowpass");
	this.priority = 100;
	this.gainHF = 1.0;
};
$hxClasses["hxd.snd.effect.LowPass"] = hxd_snd_effect_LowPass;
hxd_snd_effect_LowPass.__name__ = "hxd.snd.effect.LowPass";
hxd_snd_effect_LowPass.__super__ = hxd_snd_Effect;
hxd_snd_effect_LowPass.prototype = $extend(hxd_snd_Effect.prototype,{
	__class__: hxd_snd_effect_LowPass
});
var hxd_snd_effect_Pitch = function(value) {
	if(value == null) {
		value = 1.0;
	}
	hxd_snd_Effect.call(this,"pitch");
	this.value = value;
};
$hxClasses["hxd.snd.effect.Pitch"] = hxd_snd_effect_Pitch;
hxd_snd_effect_Pitch.__name__ = "hxd.snd.effect.Pitch";
hxd_snd_effect_Pitch.__super__ = hxd_snd_Effect;
hxd_snd_effect_Pitch.prototype = $extend(hxd_snd_Effect.prototype,{
	__class__: hxd_snd_effect_Pitch
});
var hxd_snd_effect_Spatialization = function() {
	hxd_snd_Effect.call(this,"spatialization");
	this.position = new h3d_Vector();
	this.velocity = new h3d_Vector();
	this.direction = new h3d_Vector();
	this.referenceDistance = 1.0;
	this.rollOffFactor = 1.0;
};
$hxClasses["hxd.snd.effect.Spatialization"] = hxd_snd_effect_Spatialization;
hxd_snd_effect_Spatialization.__name__ = "hxd.snd.effect.Spatialization";
hxd_snd_effect_Spatialization.__super__ = hxd_snd_Effect;
hxd_snd_effect_Spatialization.prototype = $extend(hxd_snd_Effect.prototype,{
	getVolumeModifier: function() {
		if(this.fadeDistance == null) {
			return 1.;
		}
		var _this = hxd_snd_Manager.get().listener.position;
		var v = this.position;
		var dx = v.x - _this.x;
		var dy = v.y - _this.y;
		var dz = v.z - _this.z;
		var dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
		if(this.maxDistance != null) {
			dist -= this.maxDistance;
		} else {
			dist -= this.referenceDistance;
		}
		var volume = 1 - dist / this.fadeDistance;
		if(volume > 1) {
			volume = 1;
		}
		if(volume < 0) {
			volume = 0;
		}
		return volume;
	}
	,applyAudibleVolumeModifier: function(v) {
		var _this = hxd_snd_Manager.get().listener.position;
		var v1 = this.position;
		var dx = v1.x - _this.x;
		var dy = v1.y - _this.y;
		var dz = v1.z - _this.z;
		var dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
		var b = this.referenceDistance;
		if(dist < b) {
			dist = b;
		}
		if(this.maxDistance != null) {
			var b = this.maxDistance;
			if(dist > b) {
				dist = b;
			}
		}
		var volume = this.referenceDistance / (this.referenceDistance + this.rollOffFactor * (dist - this.referenceDistance));
		return v * volume;
	}
	,__class__: hxd_snd_effect_Spatialization
});
var hxd_snd_webaudio_BufferHandle = function() {
};
$hxClasses["hxd.snd.webaudio.BufferHandle"] = hxd_snd_webaudio_BufferHandle;
hxd_snd_webaudio_BufferHandle.__name__ = "hxd.snd.webaudio.BufferHandle";
hxd_snd_webaudio_BufferHandle.prototype = {
	__class__: hxd_snd_webaudio_BufferHandle
};
var hxd_snd_webaudio_SourceHandle = function() {
	this.buffers = [];
	this.sampleOffset = 0;
	this.pitch = 1;
	this.firstPlay = true;
};
$hxClasses["hxd.snd.webaudio.SourceHandle"] = hxd_snd_webaudio_SourceHandle;
hxd_snd_webaudio_SourceHandle.__name__ = "hxd.snd.webaudio.SourceHandle";
hxd_snd_webaudio_SourceHandle.prototype = {
	updateDestination: function() {
		this.destination = this.gain;
		if(this.lowPass != null) {
			this.lowPass.connect(this.destination);
			this.destination = this.lowPass;
		}
		if(this.panner != null) {
			this.panner.connect(this.destination);
			this.destination = this.panner;
		}
		this.gain.connect(hxd_snd_webaudio_Context.destination);
		var _g = 0;
		var _g1 = this.buffers;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			if(b.node != null) {
				b.restart(this);
			}
		}
	}
	,applyPitch: function() {
		var t = 0.;
		var _g = 0;
		var _g1 = this.buffers;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			t = b.readjust(t,this);
		}
	}
	,__class__: hxd_snd_webaudio_SourceHandle
};
var hxd_snd_webaudio_BufferPlayback = function() {
};
$hxClasses["hxd.snd.webaudio.BufferPlayback"] = hxd_snd_webaudio_BufferPlayback;
hxd_snd_webaudio_BufferPlayback.__name__ = "hxd.snd.webaudio.BufferPlayback";
hxd_snd_webaudio_BufferPlayback.prototype = {
	get_currentSample: function() {
		if(this.consumed) {
			return this.buffer.samples;
		}
		if(this.node == null || !this.dirty || this.node.context.currentTime < this.lastTime) {
			return 0;
		}
		this.lastSamples += Math.floor((this.node.context.currentTime - this.lastTime) * this.buffer.inst.sampleRate * this.node.playbackRate.value);
		this.lastTime = this.node.context.currentTime;
		return this.lastSamples;
	}
	,set: function(buf,grainOffset) {
		this.buffer = buf;
		this.offset = isNaN(grainOffset) ? 0 : grainOffset;
		this.dirty = false;
		this.consumed = false;
		this.starts = 0;
		this.ends = 0;
	}
	,start: function(ctx,source,time) {
		this.dirty = true;
		this.consumed = false;
		if(this.node != null) {
			this.stop();
		}
		if(source.firstPlay && this.buffer.samples > 10) {
			source.firstPlay = false;
			var _g = [];
			var _g1 = 0;
			var _g2 = this.buffer.inst.numberOfChannels;
			while(_g1 < _g2) {
				var i = _g1++;
				_g.push(this.buffer.inst.getChannelData(i));
			}
			var channels = _g;
			var j = 0;
			var fade = 0.;
			while(j < 10) {
				var i = 0;
				while(i < channels.length) {
					channels[i][j] *= fade;
					++i;
				}
				++j;
				fade += 0.1;
				if(fade > 1) {
					fade = 1;
				}
			}
		}
		this.node = ctx.createBufferSource();
		this.node.buffer = this.buffer.inst;
		this.node.addEventListener("ended",$bind(this,this.onBufferConsumed));
		this.node.connect(source.destination);
		this.node.playbackRate.value = source.pitch;
		this.node.start(time,this.offset);
		this.lastSamples = 0;
		this.lastTime = time;
		this.starts = time;
		return this.ends = time + (this.buffer.inst.duration - this.offset) / source.pitch;
	}
	,readjust: function(time,source) {
		if(this.consumed || this.node == null) {
			return this.ends;
		}
		var ctx = source.driver.ctx;
		var shiftTime = ctx.currentTime;
		this.node.playbackRate.setValueAtTime(source.pitch,shiftTime);
		var elapsed = shiftTime - this.starts;
		if(elapsed < 0) {
			return this.start(ctx,source,time == 0 ? shiftTime : time);
		}
		this.starts = shiftTime - elapsed / source.pitch;
		return this.ends = this.starts + (this.buffer.inst.duration - this.offset) / source.pitch;
	}
	,restart: function(source) {
		if(this.consumed || this.node == null) {
			return;
		}
		var ctx = hxd_snd_webaudio_Context.get();
		if(ctx.currentTime > this.starts) {
			this.offset += (ctx.currentTime - this.starts) * source.pitch;
			this.start(ctx,source,ctx.currentTime);
		} else {
			this.start(ctx,source,this.starts);
		}
	}
	,stop: function(immediate) {
		if(immediate == null) {
			immediate = true;
		}
		if(this.node != null) {
			this.node.removeEventListener("ended",$bind(this,this.onBufferConsumed));
			if(immediate) {
				this.node.disconnect();
			} else {
				this.node.stop();
			}
			this.node = null;
		}
	}
	,onBufferConsumed: function(e) {
		this.node.removeEventListener("ended",$bind(this,this.onBufferConsumed));
		this.node.disconnect();
		this.node = null;
		this.consumed = true;
	}
	,clear: function() {
		this.buffer = null;
		this.node = null;
	}
	,__class__: hxd_snd_webaudio_BufferPlayback
};
var hxd_snd_webaudio_Context = function() { };
$hxClasses["hxd.snd.webaudio.Context"] = hxd_snd_webaudio_Context;
hxd_snd_webaudio_Context.__name__ = "hxd.snd.webaudio.Context";
hxd_snd_webaudio_Context.get = function() {
	if(hxd_snd_webaudio_Context.ctx == null) {
		try {
			hxd_snd_webaudio_Context.ctx = new AudioContext();
		} catch( _g ) {
			try {
				hxd_snd_webaudio_Context.ctx = new window.webkitAudioContext();
			} catch( _g1 ) {
				hxd_snd_webaudio_Context.ctx = null;
			}
		}
		if(hxd_snd_webaudio_Context.ctx == null) {
			throw haxe_Exception.thrown("WebAudio API not available in this browser!");
		}
		if(hxd_snd_webaudio_Context.ctx.state == "suspended") {
			hxd_snd_webaudio_Context.waitForPageInput();
		}
		hxd_snd_webaudio_Context.ctx.addEventListener("statechange",function(_) {
			if(hxd_snd_webaudio_Context.ctx.state == "suspended") {
				hxd_snd_webaudio_Context.waitForPageInput();
			}
		});
		hxd_snd_webaudio_Context.bufferPool = [];
		hxd_snd_webaudio_Context.gainPool = [];
		hxd_snd_webaudio_Context.masterGain = hxd_snd_webaudio_Context.ctx.createGain();
		hxd_snd_webaudio_Context.masterGain.connect(hxd_snd_webaudio_Context.ctx.destination);
		hxd_snd_webaudio_Context.destination = hxd_snd_webaudio_Context.masterGain;
	}
	return hxd_snd_webaudio_Context.ctx;
};
hxd_snd_webaudio_Context.waitForPageInput = function() {
	if(!hxd_snd_webaudio_Context.suspended) {
		window.document.addEventListener("click",hxd_snd_webaudio_Context.resumeContext);
		window.document.addEventListener("keydown",hxd_snd_webaudio_Context.resumeContext);
		window.document.body.addEventListener("keydown",hxd_snd_webaudio_Context.resumeContext);
		window.document.body.addEventListener("touchend",hxd_snd_webaudio_Context.resumeContext);
		hxd_snd_webaudio_Context.suspended = true;
	}
};
hxd_snd_webaudio_Context.resumeContext = function(_) {
	if(hxd_snd_webaudio_Context.suspended) {
		if(hxd_snd_webaudio_Context.ctx != null) {
			hxd_snd_webaudio_Context.ctx.resume();
		}
		window.document.removeEventListener("click",hxd_snd_webaudio_Context.resumeContext);
		window.document.removeEventListener("keydown",hxd_snd_webaudio_Context.resumeContext);
		window.document.body.removeEventListener("keydown",hxd_snd_webaudio_Context.resumeContext);
		window.document.body.removeEventListener("touchend",hxd_snd_webaudio_Context.resumeContext);
		hxd_snd_webaudio_Context.suspended = false;
	}
};
hxd_snd_webaudio_Context.getBuffer = function(channels,sampleCount,rate) {
	var _g = 0;
	var _g1 = hxd_snd_webaudio_Context.bufferPool;
	while(_g < _g1.length) {
		var pool = _g1[_g];
		++_g;
		if(pool.channels == channels && pool.samples == sampleCount && pool.rate == rate) {
			if(pool.pool.length != 0) {
				return pool.pool.pop();
			} else {
				return hxd_snd_webaudio_Context.ctx.createBuffer(channels,sampleCount,rate);
			}
		}
	}
	var pool = new hxd_snd_webaudio__$Context_BufferPool(channels,sampleCount,rate);
	hxd_snd_webaudio_Context.bufferPool.push(pool);
	return hxd_snd_webaudio_Context.ctx.createBuffer(channels,sampleCount,rate);
};
hxd_snd_webaudio_Context.putBuffer = function(buf) {
	var rate = buf.sampleRate | 0;
	var _g = 0;
	var _g1 = hxd_snd_webaudio_Context.bufferPool;
	while(_g < _g1.length) {
		var pool = _g1[_g];
		++_g;
		if(pool.channels == buf.numberOfChannels && pool.samples == buf.length && pool.rate == rate) {
			pool.pool.push(buf);
			break;
		}
	}
};
var hxd_snd_webaudio__$Context_BufferPool = function(channels,samples,rate) {
	this.pool = [];
	this.channels = channels;
	this.samples = samples;
	this.rate = rate;
};
$hxClasses["hxd.snd.webaudio._Context.BufferPool"] = hxd_snd_webaudio__$Context_BufferPool;
hxd_snd_webaudio__$Context_BufferPool.__name__ = "hxd.snd.webaudio._Context.BufferPool";
hxd_snd_webaudio__$Context_BufferPool.prototype = {
	__class__: hxd_snd_webaudio__$Context_BufferPool
};
var hxd_snd_webaudio_Driver = function() {
	this.playbackPool = [];
	this.ctx = hxd_snd_webaudio_Context.get();
};
$hxClasses["hxd.snd.webaudio.Driver"] = hxd_snd_webaudio_Driver;
hxd_snd_webaudio_Driver.__name__ = "hxd.snd.webaudio.Driver";
hxd_snd_webaudio_Driver.__interfaces__ = [hxd_snd_Driver];
hxd_snd_webaudio_Driver.prototype = {
	hasFeature: function(d) {
		return true;
	}
	,setMasterVolume: function(value) {
		hxd_snd_webaudio_Context.masterGain.gain.value = value;
	}
	,setListenerParams: function(position,direction,up,velocity) {
		this.ctx.listener.setPosition(-position.x,position.y,position.z);
		this.ctx.listener.setOrientation(-direction.x,direction.y,direction.z,-up.x,up.y,up.z);
	}
	,createSource: function() {
		var s = new hxd_snd_webaudio_SourceHandle();
		s.driver = this;
		s.gain = hxd_snd_webaudio_Context.gainPool.length != 0 ? hxd_snd_webaudio_Context.gainPool.pop() : hxd_snd_webaudio_Context.ctx.createGain();
		s.updateDestination();
		return s;
	}
	,playSource: function(source) {
		if(!source.playing) {
			source.playing = true;
			if(source.buffers.length != 0) {
				var time = this.ctx.currentTime;
				var _g = 0;
				var _g1 = source.buffers;
				while(_g < _g1.length) {
					var b = _g1[_g];
					++_g;
					if(b.consumed) {
						continue;
					}
					time = b.start(this.ctx,source,time);
				}
			}
		}
	}
	,stopSource: function(source) {
		source.playing = false;
		source.sampleOffset = 0;
	}
	,setSourceVolume: function(source,value) {
		source.gain.gain.value = value;
	}
	,createBuffer: function() {
		var b = new hxd_snd_webaudio_BufferHandle();
		b.samples = 0;
		return b;
	}
	,setBufferData: function(buffer,data,size,format,channelCount,samplingRate) {
		var sampleCount;
		switch(format._hx_index) {
		case 0:
			sampleCount = 1;
			break;
		case 1:
			sampleCount = 2;
			break;
		case 2:
			sampleCount = 4;
			break;
		}
		var sampleCount1 = size / sampleCount / channelCount | 0;
		buffer.samples = sampleCount1;
		if(sampleCount1 == 0) {
			return;
		}
		if(buffer.inst == null) {
			buffer.inst = hxd_snd_webaudio_Context.getBuffer(channelCount,sampleCount1,samplingRate);
		} else if(buffer.inst.sampleRate != samplingRate || buffer.inst.numberOfChannels != channelCount || buffer.inst.length != sampleCount1) {
			hxd_snd_webaudio_Context.putBuffer(buffer.inst);
			buffer.inst = hxd_snd_webaudio_Context.getBuffer(channelCount,sampleCount1,samplingRate);
		}
		switch(format._hx_index) {
		case 0:
			var ui8 = new Uint8Array(data.b.bufferValue);
			if(channelCount == 1) {
				var chn = buffer.inst.getChannelData(0);
				var _g = 0;
				var _g1 = sampleCount1;
				while(_g < _g1) {
					var i = _g++;
					chn[i] = ui8[i] / 255;
				}
			} else {
				var left = buffer.inst.getChannelData(0);
				var right = buffer.inst.getChannelData(1);
				var r = 0;
				var _g = 0;
				var _g1 = sampleCount1;
				while(_g < _g1) {
					var i = _g++;
					left[i] = ui8[r] / 255;
					right[i] = ui8[r + 1] / 255;
					r += channelCount;
				}
			}
			break;
		case 1:
			var i16 = new Int16Array(data.b.bufferValue);
			if(channelCount == 1) {
				var chn = buffer.inst.getChannelData(0);
				var _g = 0;
				var _g1 = sampleCount1;
				while(_g < _g1) {
					var i = _g++;
					chn[i] = i16[i] / 32768;
				}
			} else {
				var left = buffer.inst.getChannelData(0);
				var right = buffer.inst.getChannelData(1);
				var r = 0;
				var _g = 0;
				var _g1 = sampleCount1;
				while(_g < _g1) {
					var i = _g++;
					left[i] = i16[r] / 32768;
					right[i] = i16[r + 1] / 32768;
					r += channelCount;
				}
			}
			break;
		case 2:
			var f32 = new Float32Array(data.b.bufferValue);
			if(channelCount == 1) {
				var chn = buffer.inst.getChannelData(0);
				var _g = 0;
				var _g1 = sampleCount1;
				while(_g < _g1) {
					var i = _g++;
					chn[i] = f32[i];
				}
			} else {
				var left = buffer.inst.getChannelData(0);
				var right = buffer.inst.getChannelData(1);
				var r = 0;
				var _g = 0;
				var _g1 = sampleCount1;
				while(_g < _g1) {
					var i = _g++;
					left[i] = f32[r];
					right[i] = f32[r + 1];
					r += channelCount;
				}
			}
			break;
		}
	}
	,destroyBuffer: function(buffer) {
		if(buffer.inst != null) {
			hxd_snd_webaudio_Context.putBuffer(buffer.inst);
		}
		buffer.inst = null;
	}
	,queueBuffer: function(source,buffer,sampleStart,endOfStream) {
		var buf = this.playbackPool.length != 0 ? this.playbackPool.pop() : new hxd_snd_webaudio_BufferPlayback();
		if(buffer.inst == null) {
			return;
		}
		buf.set(buffer,sampleStart / buffer.inst.length * buffer.inst.duration);
		buffer.isEnd = endOfStream;
		source.buffers.push(buf);
		if(source.playing) {
			if(source.buffers.length != 1) {
				var t = source.buffers[source.buffers.length - 2].ends;
				var tmp = this.ctx;
				var tmp1;
				if(isFinite(t)) {
					var b = this.ctx.currentTime;
					tmp1 = t < b ? b : t;
				} else {
					tmp1 = this.ctx.currentTime;
				}
				buf.start(tmp,source,tmp1);
			} else {
				buf.start(this.ctx,source,this.ctx.currentTime);
			}
		}
	}
	,unqueueBuffer: function(source,buffer) {
		var i = 0;
		while(i < source.buffers.length) {
			var b = source.buffers[i];
			if(b.buffer == buffer) {
				source.buffers.splice(i,1);
				b.stop(!buffer.isEnd);
				b.clear();
				this.playbackPool.push(b);
				break;
			}
		}
		if(buffer.isEnd || !source.playing) {
			source.sampleOffset = 0;
		} else {
			source.sampleOffset += buffer.samples;
		}
	}
	,getProcessedBuffers: function(source) {
		var cnt = 0;
		var _g = 0;
		var _g1 = source.buffers;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			if(b.consumed) {
				++cnt;
			}
		}
		return cnt;
	}
	,getPlayedSampleCount: function(source) {
		var consumed = 0;
		var buf = null;
		var _g = 0;
		var _g1 = source.buffers;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			if(b.consumed) {
				consumed += b.buffer.samples;
			} else if(b.dirty) {
				buf = b;
				break;
			}
		}
		if(buf != null) {
			return source.sampleOffset + consumed + buf.get_currentSample();
		}
		return source.sampleOffset + consumed;
	}
	,update: function() {
	}
	,getEffectDriver: function(type) {
		switch(type) {
		case "lowpass":
			return new hxd_snd_webaudio_LowPassDriver();
		case "pitch":
			return new hxd_snd_webaudio_PitchDriver();
		case "spatialization":
			return new hxd_snd_webaudio_SpatializationDriver();
		default:
			return new hxd_snd_EffectDriver();
		}
	}
	,__class__: hxd_snd_webaudio_Driver
};
var hxd_snd_webaudio_LowPassDriver = function() {
	this.pool = [];
	hxd_snd_EffectDriver.call(this);
};
$hxClasses["hxd.snd.webaudio.LowPassDriver"] = hxd_snd_webaudio_LowPassDriver;
hxd_snd_webaudio_LowPassDriver.__name__ = "hxd.snd.webaudio.LowPassDriver";
hxd_snd_webaudio_LowPassDriver.__super__ = hxd_snd_EffectDriver;
hxd_snd_webaudio_LowPassDriver.prototype = $extend(hxd_snd_EffectDriver.prototype,{
	get: function(ctx) {
		if(this.pool.length != 0) {
			return this.pool.pop();
		}
		var node = ctx.createBiquadFilter();
		node.type = "lowpass";
		return node;
	}
	,bind: function(e,source) {
		source.lowPass = this.get(source.driver.ctx);
		source.updateDestination();
		this.apply(e,source);
	}
	,apply: function(e,source) {
		var min = 40;
		var max = source.driver.ctx.sampleRate / 2;
		var octaves = Math.log(max / min) / Math.LN2;
		source.lowPass.frequency.value = max * Math.pow(2,octaves * (e.gainHF - 1));
	}
	,unbind: function(e,source) {
		this.pool.push(source.lowPass);
		source.lowPass.disconnect();
		source.lowPass = null;
		if(source.driver != null) {
			source.updateDestination();
		}
	}
	,__class__: hxd_snd_webaudio_LowPassDriver
});
var hxd_snd_webaudio_PitchDriver = function() {
	hxd_snd_EffectDriver.call(this);
};
$hxClasses["hxd.snd.webaudio.PitchDriver"] = hxd_snd_webaudio_PitchDriver;
hxd_snd_webaudio_PitchDriver.__name__ = "hxd.snd.webaudio.PitchDriver";
hxd_snd_webaudio_PitchDriver.__super__ = hxd_snd_EffectDriver;
hxd_snd_webaudio_PitchDriver.prototype = $extend(hxd_snd_EffectDriver.prototype,{
	apply: function(e,source) {
		if(source.pitch != e.value) {
			source.pitch = e.value;
			source.applyPitch();
		}
	}
	,unbind: function(e,source) {
		source.pitch = 1;
		source.applyPitch();
	}
	,__class__: hxd_snd_webaudio_PitchDriver
});
var hxd_snd_webaudio_SpatializationDriver = function() {
	this.pool = [];
	hxd_snd_EffectDriver.call(this);
};
$hxClasses["hxd.snd.webaudio.SpatializationDriver"] = hxd_snd_webaudio_SpatializationDriver;
hxd_snd_webaudio_SpatializationDriver.__name__ = "hxd.snd.webaudio.SpatializationDriver";
hxd_snd_webaudio_SpatializationDriver.__super__ = hxd_snd_EffectDriver;
hxd_snd_webaudio_SpatializationDriver.prototype = $extend(hxd_snd_EffectDriver.prototype,{
	get: function(ctx) {
		if(this.pool.length != 0) {
			return this.pool.pop();
		}
		var node = ctx.createPanner();
		return node;
	}
	,bind: function(e,source) {
		source.panner = this.get(source.driver.ctx);
		source.updateDestination();
		this.apply(e,source);
	}
	,apply: function(e,source) {
		source.panner.setPosition(-e.position.x,e.position.y,e.position.z);
		source.panner.setOrientation(-e.direction.x,e.direction.y,e.direction.z);
		source.panner.rolloffFactor = e.rollOffFactor;
		source.panner.refDistance = e.referenceDistance;
		var maxDist = e.maxDistance == null ? 3.40282347e38 : e.maxDistance;
		source.panner.maxDistance = maxDist;
	}
	,unbind: function(e,source) {
		this.pool.push(source.panner);
		source.panner.disconnect();
		source.panner = null;
		if(source.driver != null) {
			source.updateDestination();
		}
	}
	,__class__: hxd_snd_webaudio_SpatializationDriver
});
var hxsl_Type = $hxEnums["hxsl.Type"] = { __ename__:true,__constructs__:null
	,TVoid: {_hx_name:"TVoid",_hx_index:0,__enum__:"hxsl.Type",toString:$estr}
	,TInt: {_hx_name:"TInt",_hx_index:1,__enum__:"hxsl.Type",toString:$estr}
	,TBool: {_hx_name:"TBool",_hx_index:2,__enum__:"hxsl.Type",toString:$estr}
	,TFloat: {_hx_name:"TFloat",_hx_index:3,__enum__:"hxsl.Type",toString:$estr}
	,TString: {_hx_name:"TString",_hx_index:4,__enum__:"hxsl.Type",toString:$estr}
	,TVec: ($_=function(size,t) { return {_hx_index:5,size:size,t:t,__enum__:"hxsl.Type",toString:$estr}; },$_._hx_name="TVec",$_.__params__ = ["size","t"],$_)
	,TMat3: {_hx_name:"TMat3",_hx_index:6,__enum__:"hxsl.Type",toString:$estr}
	,TMat4: {_hx_name:"TMat4",_hx_index:7,__enum__:"hxsl.Type",toString:$estr}
	,TMat3x4: {_hx_name:"TMat3x4",_hx_index:8,__enum__:"hxsl.Type",toString:$estr}
	,TBytes: ($_=function(size) { return {_hx_index:9,size:size,__enum__:"hxsl.Type",toString:$estr}; },$_._hx_name="TBytes",$_.__params__ = ["size"],$_)
	,TSampler2D: {_hx_name:"TSampler2D",_hx_index:10,__enum__:"hxsl.Type",toString:$estr}
	,TSampler2DArray: {_hx_name:"TSampler2DArray",_hx_index:11,__enum__:"hxsl.Type",toString:$estr}
	,TSamplerCube: {_hx_name:"TSamplerCube",_hx_index:12,__enum__:"hxsl.Type",toString:$estr}
	,TStruct: ($_=function(vl) { return {_hx_index:13,vl:vl,__enum__:"hxsl.Type",toString:$estr}; },$_._hx_name="TStruct",$_.__params__ = ["vl"],$_)
	,TFun: ($_=function(variants) { return {_hx_index:14,variants:variants,__enum__:"hxsl.Type",toString:$estr}; },$_._hx_name="TFun",$_.__params__ = ["variants"],$_)
	,TArray: ($_=function(t,size) { return {_hx_index:15,t:t,size:size,__enum__:"hxsl.Type",toString:$estr}; },$_._hx_name="TArray",$_.__params__ = ["t","size"],$_)
	,TBuffer: ($_=function(t,size) { return {_hx_index:16,t:t,size:size,__enum__:"hxsl.Type",toString:$estr}; },$_._hx_name="TBuffer",$_.__params__ = ["t","size"],$_)
	,TChannel: ($_=function(size) { return {_hx_index:17,size:size,__enum__:"hxsl.Type",toString:$estr}; },$_._hx_name="TChannel",$_.__params__ = ["size"],$_)
	,TMat2: {_hx_name:"TMat2",_hx_index:18,__enum__:"hxsl.Type",toString:$estr}
};
hxsl_Type.__constructs__ = [hxsl_Type.TVoid,hxsl_Type.TInt,hxsl_Type.TBool,hxsl_Type.TFloat,hxsl_Type.TString,hxsl_Type.TVec,hxsl_Type.TMat3,hxsl_Type.TMat4,hxsl_Type.TMat3x4,hxsl_Type.TBytes,hxsl_Type.TSampler2D,hxsl_Type.TSampler2DArray,hxsl_Type.TSamplerCube,hxsl_Type.TStruct,hxsl_Type.TFun,hxsl_Type.TArray,hxsl_Type.TBuffer,hxsl_Type.TChannel,hxsl_Type.TMat2];
hxsl_Type.__empty_constructs__ = [hxsl_Type.TVoid,hxsl_Type.TInt,hxsl_Type.TBool,hxsl_Type.TFloat,hxsl_Type.TString,hxsl_Type.TMat3,hxsl_Type.TMat4,hxsl_Type.TMat3x4,hxsl_Type.TSampler2D,hxsl_Type.TSampler2DArray,hxsl_Type.TSamplerCube,hxsl_Type.TMat2];
var hxsl_VecType = $hxEnums["hxsl.VecType"] = { __ename__:true,__constructs__:null
	,VInt: {_hx_name:"VInt",_hx_index:0,__enum__:"hxsl.VecType",toString:$estr}
	,VFloat: {_hx_name:"VFloat",_hx_index:1,__enum__:"hxsl.VecType",toString:$estr}
	,VBool: {_hx_name:"VBool",_hx_index:2,__enum__:"hxsl.VecType",toString:$estr}
};
hxsl_VecType.__constructs__ = [hxsl_VecType.VInt,hxsl_VecType.VFloat,hxsl_VecType.VBool];
hxsl_VecType.__empty_constructs__ = [hxsl_VecType.VInt,hxsl_VecType.VFloat,hxsl_VecType.VBool];
var hxsl_SizeDecl = $hxEnums["hxsl.SizeDecl"] = { __ename__:true,__constructs__:null
	,SConst: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"hxsl.SizeDecl",toString:$estr}; },$_._hx_name="SConst",$_.__params__ = ["v"],$_)
	,SVar: ($_=function(v) { return {_hx_index:1,v:v,__enum__:"hxsl.SizeDecl",toString:$estr}; },$_._hx_name="SVar",$_.__params__ = ["v"],$_)
};
hxsl_SizeDecl.__constructs__ = [hxsl_SizeDecl.SConst,hxsl_SizeDecl.SVar];
hxsl_SizeDecl.__empty_constructs__ = [];
var hxsl_Error = function(msg,pos) {
	this.msg = msg;
	this.pos = pos;
};
$hxClasses["hxsl.Error"] = hxsl_Error;
hxsl_Error.__name__ = "hxsl.Error";
hxsl_Error.t = function(msg,pos) {
	throw haxe_Exception.thrown(new hxsl_Error(msg,pos));
};
hxsl_Error.prototype = {
	toString: function() {
		return "Error(" + this.msg + ")@" + Std.string(this.pos);
	}
	,__class__: hxsl_Error
};
var hxsl_VarKind = $hxEnums["hxsl.VarKind"] = { __ename__:true,__constructs__:null
	,Global: {_hx_name:"Global",_hx_index:0,__enum__:"hxsl.VarKind",toString:$estr}
	,Input: {_hx_name:"Input",_hx_index:1,__enum__:"hxsl.VarKind",toString:$estr}
	,Param: {_hx_name:"Param",_hx_index:2,__enum__:"hxsl.VarKind",toString:$estr}
	,Var: {_hx_name:"Var",_hx_index:3,__enum__:"hxsl.VarKind",toString:$estr}
	,Local: {_hx_name:"Local",_hx_index:4,__enum__:"hxsl.VarKind",toString:$estr}
	,Output: {_hx_name:"Output",_hx_index:5,__enum__:"hxsl.VarKind",toString:$estr}
	,Function: {_hx_name:"Function",_hx_index:6,__enum__:"hxsl.VarKind",toString:$estr}
};
hxsl_VarKind.__constructs__ = [hxsl_VarKind.Global,hxsl_VarKind.Input,hxsl_VarKind.Param,hxsl_VarKind.Var,hxsl_VarKind.Local,hxsl_VarKind.Output,hxsl_VarKind.Function];
hxsl_VarKind.__empty_constructs__ = [hxsl_VarKind.Global,hxsl_VarKind.Input,hxsl_VarKind.Param,hxsl_VarKind.Var,hxsl_VarKind.Local,hxsl_VarKind.Output,hxsl_VarKind.Function];
var hxsl_VarQualifier = $hxEnums["hxsl.VarQualifier"] = { __ename__:true,__constructs__:null
	,Const: ($_=function(max) { return {_hx_index:0,max:max,__enum__:"hxsl.VarQualifier",toString:$estr}; },$_._hx_name="Const",$_.__params__ = ["max"],$_)
	,Private: {_hx_name:"Private",_hx_index:1,__enum__:"hxsl.VarQualifier",toString:$estr}
	,Nullable: {_hx_name:"Nullable",_hx_index:2,__enum__:"hxsl.VarQualifier",toString:$estr}
	,PerObject: {_hx_name:"PerObject",_hx_index:3,__enum__:"hxsl.VarQualifier",toString:$estr}
	,Name: ($_=function(n) { return {_hx_index:4,n:n,__enum__:"hxsl.VarQualifier",toString:$estr}; },$_._hx_name="Name",$_.__params__ = ["n"],$_)
	,Shared: {_hx_name:"Shared",_hx_index:5,__enum__:"hxsl.VarQualifier",toString:$estr}
	,Precision: ($_=function(p) { return {_hx_index:6,p:p,__enum__:"hxsl.VarQualifier",toString:$estr}; },$_._hx_name="Precision",$_.__params__ = ["p"],$_)
	,Range: ($_=function(min,max) { return {_hx_index:7,min:min,max:max,__enum__:"hxsl.VarQualifier",toString:$estr}; },$_._hx_name="Range",$_.__params__ = ["min","max"],$_)
	,Ignore: {_hx_name:"Ignore",_hx_index:8,__enum__:"hxsl.VarQualifier",toString:$estr}
	,PerInstance: ($_=function(v) { return {_hx_index:9,v:v,__enum__:"hxsl.VarQualifier",toString:$estr}; },$_._hx_name="PerInstance",$_.__params__ = ["v"],$_)
	,Doc: ($_=function(s) { return {_hx_index:10,s:s,__enum__:"hxsl.VarQualifier",toString:$estr}; },$_._hx_name="Doc",$_.__params__ = ["s"],$_)
	,Borrow: ($_=function(source) { return {_hx_index:11,source:source,__enum__:"hxsl.VarQualifier",toString:$estr}; },$_._hx_name="Borrow",$_.__params__ = ["source"],$_)
	,Sampler: ($_=function(name) { return {_hx_index:12,name:name,__enum__:"hxsl.VarQualifier",toString:$estr}; },$_._hx_name="Sampler",$_.__params__ = ["name"],$_)
};
hxsl_VarQualifier.__constructs__ = [hxsl_VarQualifier.Const,hxsl_VarQualifier.Private,hxsl_VarQualifier.Nullable,hxsl_VarQualifier.PerObject,hxsl_VarQualifier.Name,hxsl_VarQualifier.Shared,hxsl_VarQualifier.Precision,hxsl_VarQualifier.Range,hxsl_VarQualifier.Ignore,hxsl_VarQualifier.PerInstance,hxsl_VarQualifier.Doc,hxsl_VarQualifier.Borrow,hxsl_VarQualifier.Sampler];
hxsl_VarQualifier.__empty_constructs__ = [hxsl_VarQualifier.Private,hxsl_VarQualifier.Nullable,hxsl_VarQualifier.PerObject,hxsl_VarQualifier.Shared,hxsl_VarQualifier.Ignore];
var hxsl_Prec = $hxEnums["hxsl.Prec"] = { __ename__:true,__constructs__:null
	,Low: {_hx_name:"Low",_hx_index:0,__enum__:"hxsl.Prec",toString:$estr}
	,Medium: {_hx_name:"Medium",_hx_index:1,__enum__:"hxsl.Prec",toString:$estr}
	,High: {_hx_name:"High",_hx_index:2,__enum__:"hxsl.Prec",toString:$estr}
};
hxsl_Prec.__constructs__ = [hxsl_Prec.Low,hxsl_Prec.Medium,hxsl_Prec.High];
hxsl_Prec.__empty_constructs__ = [hxsl_Prec.Low,hxsl_Prec.Medium,hxsl_Prec.High];
var hxsl_Const = $hxEnums["hxsl.Const"] = { __ename__:true,__constructs__:null
	,CNull: {_hx_name:"CNull",_hx_index:0,__enum__:"hxsl.Const",toString:$estr}
	,CBool: ($_=function(b) { return {_hx_index:1,b:b,__enum__:"hxsl.Const",toString:$estr}; },$_._hx_name="CBool",$_.__params__ = ["b"],$_)
	,CInt: ($_=function(v) { return {_hx_index:2,v:v,__enum__:"hxsl.Const",toString:$estr}; },$_._hx_name="CInt",$_.__params__ = ["v"],$_)
	,CFloat: ($_=function(v) { return {_hx_index:3,v:v,__enum__:"hxsl.Const",toString:$estr}; },$_._hx_name="CFloat",$_.__params__ = ["v"],$_)
	,CString: ($_=function(v) { return {_hx_index:4,v:v,__enum__:"hxsl.Const",toString:$estr}; },$_._hx_name="CString",$_.__params__ = ["v"],$_)
};
hxsl_Const.__constructs__ = [hxsl_Const.CNull,hxsl_Const.CBool,hxsl_Const.CInt,hxsl_Const.CFloat,hxsl_Const.CString];
hxsl_Const.__empty_constructs__ = [hxsl_Const.CNull];
var hxsl_FunctionKind = $hxEnums["hxsl.FunctionKind"] = { __ename__:true,__constructs__:null
	,Vertex: {_hx_name:"Vertex",_hx_index:0,__enum__:"hxsl.FunctionKind",toString:$estr}
	,Fragment: {_hx_name:"Fragment",_hx_index:1,__enum__:"hxsl.FunctionKind",toString:$estr}
	,Init: {_hx_name:"Init",_hx_index:2,__enum__:"hxsl.FunctionKind",toString:$estr}
	,Helper: {_hx_name:"Helper",_hx_index:3,__enum__:"hxsl.FunctionKind",toString:$estr}
};
hxsl_FunctionKind.__constructs__ = [hxsl_FunctionKind.Vertex,hxsl_FunctionKind.Fragment,hxsl_FunctionKind.Init,hxsl_FunctionKind.Helper];
hxsl_FunctionKind.__empty_constructs__ = [hxsl_FunctionKind.Vertex,hxsl_FunctionKind.Fragment,hxsl_FunctionKind.Init,hxsl_FunctionKind.Helper];
var hxsl_TGlobal = $hxEnums["hxsl.TGlobal"] = { __ename__:true,__constructs__:null
	,Radians: {_hx_name:"Radians",_hx_index:0,__enum__:"hxsl.TGlobal",toString:$estr}
	,Degrees: {_hx_name:"Degrees",_hx_index:1,__enum__:"hxsl.TGlobal",toString:$estr}
	,Sin: {_hx_name:"Sin",_hx_index:2,__enum__:"hxsl.TGlobal",toString:$estr}
	,Cos: {_hx_name:"Cos",_hx_index:3,__enum__:"hxsl.TGlobal",toString:$estr}
	,Tan: {_hx_name:"Tan",_hx_index:4,__enum__:"hxsl.TGlobal",toString:$estr}
	,Asin: {_hx_name:"Asin",_hx_index:5,__enum__:"hxsl.TGlobal",toString:$estr}
	,Acos: {_hx_name:"Acos",_hx_index:6,__enum__:"hxsl.TGlobal",toString:$estr}
	,Atan: {_hx_name:"Atan",_hx_index:7,__enum__:"hxsl.TGlobal",toString:$estr}
	,Pow: {_hx_name:"Pow",_hx_index:8,__enum__:"hxsl.TGlobal",toString:$estr}
	,Exp: {_hx_name:"Exp",_hx_index:9,__enum__:"hxsl.TGlobal",toString:$estr}
	,Log: {_hx_name:"Log",_hx_index:10,__enum__:"hxsl.TGlobal",toString:$estr}
	,Exp2: {_hx_name:"Exp2",_hx_index:11,__enum__:"hxsl.TGlobal",toString:$estr}
	,Log2: {_hx_name:"Log2",_hx_index:12,__enum__:"hxsl.TGlobal",toString:$estr}
	,Sqrt: {_hx_name:"Sqrt",_hx_index:13,__enum__:"hxsl.TGlobal",toString:$estr}
	,Inversesqrt: {_hx_name:"Inversesqrt",_hx_index:14,__enum__:"hxsl.TGlobal",toString:$estr}
	,Abs: {_hx_name:"Abs",_hx_index:15,__enum__:"hxsl.TGlobal",toString:$estr}
	,Sign: {_hx_name:"Sign",_hx_index:16,__enum__:"hxsl.TGlobal",toString:$estr}
	,Floor: {_hx_name:"Floor",_hx_index:17,__enum__:"hxsl.TGlobal",toString:$estr}
	,Ceil: {_hx_name:"Ceil",_hx_index:18,__enum__:"hxsl.TGlobal",toString:$estr}
	,Fract: {_hx_name:"Fract",_hx_index:19,__enum__:"hxsl.TGlobal",toString:$estr}
	,Mod: {_hx_name:"Mod",_hx_index:20,__enum__:"hxsl.TGlobal",toString:$estr}
	,Min: {_hx_name:"Min",_hx_index:21,__enum__:"hxsl.TGlobal",toString:$estr}
	,Max: {_hx_name:"Max",_hx_index:22,__enum__:"hxsl.TGlobal",toString:$estr}
	,Clamp: {_hx_name:"Clamp",_hx_index:23,__enum__:"hxsl.TGlobal",toString:$estr}
	,Mix: {_hx_name:"Mix",_hx_index:24,__enum__:"hxsl.TGlobal",toString:$estr}
	,Step: {_hx_name:"Step",_hx_index:25,__enum__:"hxsl.TGlobal",toString:$estr}
	,Smoothstep: {_hx_name:"Smoothstep",_hx_index:26,__enum__:"hxsl.TGlobal",toString:$estr}
	,Length: {_hx_name:"Length",_hx_index:27,__enum__:"hxsl.TGlobal",toString:$estr}
	,Distance: {_hx_name:"Distance",_hx_index:28,__enum__:"hxsl.TGlobal",toString:$estr}
	,Dot: {_hx_name:"Dot",_hx_index:29,__enum__:"hxsl.TGlobal",toString:$estr}
	,Cross: {_hx_name:"Cross",_hx_index:30,__enum__:"hxsl.TGlobal",toString:$estr}
	,Normalize: {_hx_name:"Normalize",_hx_index:31,__enum__:"hxsl.TGlobal",toString:$estr}
	,LReflect: {_hx_name:"LReflect",_hx_index:32,__enum__:"hxsl.TGlobal",toString:$estr}
	,Texture: {_hx_name:"Texture",_hx_index:33,__enum__:"hxsl.TGlobal",toString:$estr}
	,TextureLod: {_hx_name:"TextureLod",_hx_index:34,__enum__:"hxsl.TGlobal",toString:$estr}
	,Texel: {_hx_name:"Texel",_hx_index:35,__enum__:"hxsl.TGlobal",toString:$estr}
	,TextureSize: {_hx_name:"TextureSize",_hx_index:36,__enum__:"hxsl.TGlobal",toString:$estr}
	,ToInt: {_hx_name:"ToInt",_hx_index:37,__enum__:"hxsl.TGlobal",toString:$estr}
	,ToFloat: {_hx_name:"ToFloat",_hx_index:38,__enum__:"hxsl.TGlobal",toString:$estr}
	,ToBool: {_hx_name:"ToBool",_hx_index:39,__enum__:"hxsl.TGlobal",toString:$estr}
	,Vec2: {_hx_name:"Vec2",_hx_index:40,__enum__:"hxsl.TGlobal",toString:$estr}
	,Vec3: {_hx_name:"Vec3",_hx_index:41,__enum__:"hxsl.TGlobal",toString:$estr}
	,Vec4: {_hx_name:"Vec4",_hx_index:42,__enum__:"hxsl.TGlobal",toString:$estr}
	,IVec2: {_hx_name:"IVec2",_hx_index:43,__enum__:"hxsl.TGlobal",toString:$estr}
	,IVec3: {_hx_name:"IVec3",_hx_index:44,__enum__:"hxsl.TGlobal",toString:$estr}
	,IVec4: {_hx_name:"IVec4",_hx_index:45,__enum__:"hxsl.TGlobal",toString:$estr}
	,BVec2: {_hx_name:"BVec2",_hx_index:46,__enum__:"hxsl.TGlobal",toString:$estr}
	,BVec3: {_hx_name:"BVec3",_hx_index:47,__enum__:"hxsl.TGlobal",toString:$estr}
	,BVec4: {_hx_name:"BVec4",_hx_index:48,__enum__:"hxsl.TGlobal",toString:$estr}
	,Mat2: {_hx_name:"Mat2",_hx_index:49,__enum__:"hxsl.TGlobal",toString:$estr}
	,Mat3: {_hx_name:"Mat3",_hx_index:50,__enum__:"hxsl.TGlobal",toString:$estr}
	,Mat4: {_hx_name:"Mat4",_hx_index:51,__enum__:"hxsl.TGlobal",toString:$estr}
	,Mat3x4: {_hx_name:"Mat3x4",_hx_index:52,__enum__:"hxsl.TGlobal",toString:$estr}
	,Saturate: {_hx_name:"Saturate",_hx_index:53,__enum__:"hxsl.TGlobal",toString:$estr}
	,Pack: {_hx_name:"Pack",_hx_index:54,__enum__:"hxsl.TGlobal",toString:$estr}
	,Unpack: {_hx_name:"Unpack",_hx_index:55,__enum__:"hxsl.TGlobal",toString:$estr}
	,PackNormal: {_hx_name:"PackNormal",_hx_index:56,__enum__:"hxsl.TGlobal",toString:$estr}
	,UnpackNormal: {_hx_name:"UnpackNormal",_hx_index:57,__enum__:"hxsl.TGlobal",toString:$estr}
	,ScreenToUv: {_hx_name:"ScreenToUv",_hx_index:58,__enum__:"hxsl.TGlobal",toString:$estr}
	,UvToScreen: {_hx_name:"UvToScreen",_hx_index:59,__enum__:"hxsl.TGlobal",toString:$estr}
	,DFdx: {_hx_name:"DFdx",_hx_index:60,__enum__:"hxsl.TGlobal",toString:$estr}
	,DFdy: {_hx_name:"DFdy",_hx_index:61,__enum__:"hxsl.TGlobal",toString:$estr}
	,Fwidth: {_hx_name:"Fwidth",_hx_index:62,__enum__:"hxsl.TGlobal",toString:$estr}
	,ChannelRead: {_hx_name:"ChannelRead",_hx_index:63,__enum__:"hxsl.TGlobal",toString:$estr}
	,ChannelReadLod: {_hx_name:"ChannelReadLod",_hx_index:64,__enum__:"hxsl.TGlobal",toString:$estr}
	,ChannelFetch: {_hx_name:"ChannelFetch",_hx_index:65,__enum__:"hxsl.TGlobal",toString:$estr}
	,ChannelTextureSize: {_hx_name:"ChannelTextureSize",_hx_index:66,__enum__:"hxsl.TGlobal",toString:$estr}
	,Trace: {_hx_name:"Trace",_hx_index:67,__enum__:"hxsl.TGlobal",toString:$estr}
	,VertexID: {_hx_name:"VertexID",_hx_index:68,__enum__:"hxsl.TGlobal",toString:$estr}
	,InstanceID: {_hx_name:"InstanceID",_hx_index:69,__enum__:"hxsl.TGlobal",toString:$estr}
	,FragCoord: {_hx_name:"FragCoord",_hx_index:70,__enum__:"hxsl.TGlobal",toString:$estr}
	,FrontFacing: {_hx_name:"FrontFacing",_hx_index:71,__enum__:"hxsl.TGlobal",toString:$estr}
};
hxsl_TGlobal.__constructs__ = [hxsl_TGlobal.Radians,hxsl_TGlobal.Degrees,hxsl_TGlobal.Sin,hxsl_TGlobal.Cos,hxsl_TGlobal.Tan,hxsl_TGlobal.Asin,hxsl_TGlobal.Acos,hxsl_TGlobal.Atan,hxsl_TGlobal.Pow,hxsl_TGlobal.Exp,hxsl_TGlobal.Log,hxsl_TGlobal.Exp2,hxsl_TGlobal.Log2,hxsl_TGlobal.Sqrt,hxsl_TGlobal.Inversesqrt,hxsl_TGlobal.Abs,hxsl_TGlobal.Sign,hxsl_TGlobal.Floor,hxsl_TGlobal.Ceil,hxsl_TGlobal.Fract,hxsl_TGlobal.Mod,hxsl_TGlobal.Min,hxsl_TGlobal.Max,hxsl_TGlobal.Clamp,hxsl_TGlobal.Mix,hxsl_TGlobal.Step,hxsl_TGlobal.Smoothstep,hxsl_TGlobal.Length,hxsl_TGlobal.Distance,hxsl_TGlobal.Dot,hxsl_TGlobal.Cross,hxsl_TGlobal.Normalize,hxsl_TGlobal.LReflect,hxsl_TGlobal.Texture,hxsl_TGlobal.TextureLod,hxsl_TGlobal.Texel,hxsl_TGlobal.TextureSize,hxsl_TGlobal.ToInt,hxsl_TGlobal.ToFloat,hxsl_TGlobal.ToBool,hxsl_TGlobal.Vec2,hxsl_TGlobal.Vec3,hxsl_TGlobal.Vec4,hxsl_TGlobal.IVec2,hxsl_TGlobal.IVec3,hxsl_TGlobal.IVec4,hxsl_TGlobal.BVec2,hxsl_TGlobal.BVec3,hxsl_TGlobal.BVec4,hxsl_TGlobal.Mat2,hxsl_TGlobal.Mat3,hxsl_TGlobal.Mat4,hxsl_TGlobal.Mat3x4,hxsl_TGlobal.Saturate,hxsl_TGlobal.Pack,hxsl_TGlobal.Unpack,hxsl_TGlobal.PackNormal,hxsl_TGlobal.UnpackNormal,hxsl_TGlobal.ScreenToUv,hxsl_TGlobal.UvToScreen,hxsl_TGlobal.DFdx,hxsl_TGlobal.DFdy,hxsl_TGlobal.Fwidth,hxsl_TGlobal.ChannelRead,hxsl_TGlobal.ChannelReadLod,hxsl_TGlobal.ChannelFetch,hxsl_TGlobal.ChannelTextureSize,hxsl_TGlobal.Trace,hxsl_TGlobal.VertexID,hxsl_TGlobal.InstanceID,hxsl_TGlobal.FragCoord,hxsl_TGlobal.FrontFacing];
hxsl_TGlobal.__empty_constructs__ = [hxsl_TGlobal.Radians,hxsl_TGlobal.Degrees,hxsl_TGlobal.Sin,hxsl_TGlobal.Cos,hxsl_TGlobal.Tan,hxsl_TGlobal.Asin,hxsl_TGlobal.Acos,hxsl_TGlobal.Atan,hxsl_TGlobal.Pow,hxsl_TGlobal.Exp,hxsl_TGlobal.Log,hxsl_TGlobal.Exp2,hxsl_TGlobal.Log2,hxsl_TGlobal.Sqrt,hxsl_TGlobal.Inversesqrt,hxsl_TGlobal.Abs,hxsl_TGlobal.Sign,hxsl_TGlobal.Floor,hxsl_TGlobal.Ceil,hxsl_TGlobal.Fract,hxsl_TGlobal.Mod,hxsl_TGlobal.Min,hxsl_TGlobal.Max,hxsl_TGlobal.Clamp,hxsl_TGlobal.Mix,hxsl_TGlobal.Step,hxsl_TGlobal.Smoothstep,hxsl_TGlobal.Length,hxsl_TGlobal.Distance,hxsl_TGlobal.Dot,hxsl_TGlobal.Cross,hxsl_TGlobal.Normalize,hxsl_TGlobal.LReflect,hxsl_TGlobal.Texture,hxsl_TGlobal.TextureLod,hxsl_TGlobal.Texel,hxsl_TGlobal.TextureSize,hxsl_TGlobal.ToInt,hxsl_TGlobal.ToFloat,hxsl_TGlobal.ToBool,hxsl_TGlobal.Vec2,hxsl_TGlobal.Vec3,hxsl_TGlobal.Vec4,hxsl_TGlobal.IVec2,hxsl_TGlobal.IVec3,hxsl_TGlobal.IVec4,hxsl_TGlobal.BVec2,hxsl_TGlobal.BVec3,hxsl_TGlobal.BVec4,hxsl_TGlobal.Mat2,hxsl_TGlobal.Mat3,hxsl_TGlobal.Mat4,hxsl_TGlobal.Mat3x4,hxsl_TGlobal.Saturate,hxsl_TGlobal.Pack,hxsl_TGlobal.Unpack,hxsl_TGlobal.PackNormal,hxsl_TGlobal.UnpackNormal,hxsl_TGlobal.ScreenToUv,hxsl_TGlobal.UvToScreen,hxsl_TGlobal.DFdx,hxsl_TGlobal.DFdy,hxsl_TGlobal.Fwidth,hxsl_TGlobal.ChannelRead,hxsl_TGlobal.ChannelReadLod,hxsl_TGlobal.ChannelFetch,hxsl_TGlobal.ChannelTextureSize,hxsl_TGlobal.Trace,hxsl_TGlobal.VertexID,hxsl_TGlobal.InstanceID,hxsl_TGlobal.FragCoord,hxsl_TGlobal.FrontFacing];
var hxsl_Component = $hxEnums["hxsl.Component"] = { __ename__:true,__constructs__:null
	,X: {_hx_name:"X",_hx_index:0,__enum__:"hxsl.Component",toString:$estr}
	,Y: {_hx_name:"Y",_hx_index:1,__enum__:"hxsl.Component",toString:$estr}
	,Z: {_hx_name:"Z",_hx_index:2,__enum__:"hxsl.Component",toString:$estr}
	,W: {_hx_name:"W",_hx_index:3,__enum__:"hxsl.Component",toString:$estr}
};
hxsl_Component.__constructs__ = [hxsl_Component.X,hxsl_Component.Y,hxsl_Component.Z,hxsl_Component.W];
hxsl_Component.__empty_constructs__ = [hxsl_Component.X,hxsl_Component.Y,hxsl_Component.Z,hxsl_Component.W];
var hxsl_TExprDef = $hxEnums["hxsl.TExprDef"] = { __ename__:true,__constructs__:null
	,TConst: ($_=function(c) { return {_hx_index:0,c:c,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TConst",$_.__params__ = ["c"],$_)
	,TVar: ($_=function(v) { return {_hx_index:1,v:v,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TVar",$_.__params__ = ["v"],$_)
	,TGlobal: ($_=function(g) { return {_hx_index:2,g:g,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TGlobal",$_.__params__ = ["g"],$_)
	,TParenthesis: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TParenthesis",$_.__params__ = ["e"],$_)
	,TBlock: ($_=function(el) { return {_hx_index:4,el:el,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TBlock",$_.__params__ = ["el"],$_)
	,TBinop: ($_=function(op,e1,e2) { return {_hx_index:5,op:op,e1:e1,e2:e2,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TBinop",$_.__params__ = ["op","e1","e2"],$_)
	,TUnop: ($_=function(op,e1) { return {_hx_index:6,op:op,e1:e1,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TUnop",$_.__params__ = ["op","e1"],$_)
	,TVarDecl: ($_=function(v,init) { return {_hx_index:7,v:v,init:init,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TVarDecl",$_.__params__ = ["v","init"],$_)
	,TCall: ($_=function(e,args) { return {_hx_index:8,e:e,args:args,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TCall",$_.__params__ = ["e","args"],$_)
	,TSwiz: ($_=function(e,regs) { return {_hx_index:9,e:e,regs:regs,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TSwiz",$_.__params__ = ["e","regs"],$_)
	,TIf: ($_=function(econd,eif,eelse) { return {_hx_index:10,econd:econd,eif:eif,eelse:eelse,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TIf",$_.__params__ = ["econd","eif","eelse"],$_)
	,TDiscard: {_hx_name:"TDiscard",_hx_index:11,__enum__:"hxsl.TExprDef",toString:$estr}
	,TReturn: ($_=function(e) { return {_hx_index:12,e:e,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TReturn",$_.__params__ = ["e"],$_)
	,TFor: ($_=function(v,it,loop) { return {_hx_index:13,v:v,it:it,loop:loop,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TFor",$_.__params__ = ["v","it","loop"],$_)
	,TContinue: {_hx_name:"TContinue",_hx_index:14,__enum__:"hxsl.TExprDef",toString:$estr}
	,TBreak: {_hx_name:"TBreak",_hx_index:15,__enum__:"hxsl.TExprDef",toString:$estr}
	,TArray: ($_=function(e,index) { return {_hx_index:16,e:e,index:index,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TArray",$_.__params__ = ["e","index"],$_)
	,TArrayDecl: ($_=function(el) { return {_hx_index:17,el:el,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TArrayDecl",$_.__params__ = ["el"],$_)
	,TSwitch: ($_=function(e,cases,def) { return {_hx_index:18,e:e,cases:cases,def:def,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TSwitch",$_.__params__ = ["e","cases","def"],$_)
	,TWhile: ($_=function(e,loop,normalWhile) { return {_hx_index:19,e:e,loop:loop,normalWhile:normalWhile,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TWhile",$_.__params__ = ["e","loop","normalWhile"],$_)
	,TMeta: ($_=function(m,args,e) { return {_hx_index:20,m:m,args:args,e:e,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TMeta",$_.__params__ = ["m","args","e"],$_)
};
hxsl_TExprDef.__constructs__ = [hxsl_TExprDef.TConst,hxsl_TExprDef.TVar,hxsl_TExprDef.TGlobal,hxsl_TExprDef.TParenthesis,hxsl_TExprDef.TBlock,hxsl_TExprDef.TBinop,hxsl_TExprDef.TUnop,hxsl_TExprDef.TVarDecl,hxsl_TExprDef.TCall,hxsl_TExprDef.TSwiz,hxsl_TExprDef.TIf,hxsl_TExprDef.TDiscard,hxsl_TExprDef.TReturn,hxsl_TExprDef.TFor,hxsl_TExprDef.TContinue,hxsl_TExprDef.TBreak,hxsl_TExprDef.TArray,hxsl_TExprDef.TArrayDecl,hxsl_TExprDef.TSwitch,hxsl_TExprDef.TWhile,hxsl_TExprDef.TMeta];
hxsl_TExprDef.__empty_constructs__ = [hxsl_TExprDef.TDiscard,hxsl_TExprDef.TContinue,hxsl_TExprDef.TBreak];
var hxsl_Tools = function() { };
$hxClasses["hxsl.Tools"] = hxsl_Tools;
hxsl_Tools.__name__ = "hxsl.Tools";
hxsl_Tools.allocVarId = function() {
	return ++hxsl_Tools.UID;
};
hxsl_Tools.getName = function(v) {
	if(v.qualifiers == null) {
		return v.name;
	}
	var _g = 0;
	var _g1 = v.qualifiers;
	while(_g < _g1.length) {
		var q = _g1[_g];
		++_g;
		if(q._hx_index == 4) {
			var n = q.n;
			return n;
		}
	}
	return v.name;
};
hxsl_Tools.getConstBits = function(v) {
	var _g = v.type;
	switch(_g._hx_index) {
	case 1:
		var _g1 = 0;
		var _g2 = v.qualifiers;
		while(_g1 < _g2.length) {
			var q = _g2[_g1];
			++_g1;
			if(q._hx_index == 0) {
				var n = q.max;
				if(n != null) {
					var bits = 0;
					while(n >= 1 << bits) ++bits;
					return bits;
				}
				return 8;
			}
		}
		break;
	case 2:
		return 1;
	case 17:
		var _g1 = _g.size;
		return 3 + hxsl_Tools.MAX_CHANNELS_BITS;
	default:
	}
	return 0;
};
hxsl_Tools.isConst = function(v) {
	var _g = v.type;
	var tmp;
	if(_g._hx_index == 17) {
		var _g1 = _g.size;
		tmp = true;
	} else {
		tmp = false;
	}
	if(tmp) {
		return true;
	}
	if(v.qualifiers != null) {
		var _g = 0;
		var _g1 = v.qualifiers;
		while(_g < _g1.length) {
			var q = _g1[_g];
			++_g;
			if(q._hx_index == 0) {
				var _g2 = q.max;
				return true;
			}
		}
	}
	return false;
};
hxsl_Tools.hasQualifier = function(v,q) {
	if(v.qualifiers != null) {
		var _g = 0;
		var _g1 = v.qualifiers;
		while(_g < _g1.length) {
			var q2 = _g1[_g];
			++_g;
			if(q2 == q) {
				return true;
			}
		}
	}
	return false;
};
hxsl_Tools.hasBorrowQualifier = function(v,path) {
	if(v.qualifiers != null) {
		var _g = 0;
		var _g1 = v.qualifiers;
		while(_g < _g1.length) {
			var q = _g1[_g];
			++_g;
			if(q._hx_index == 11) {
				var s = q.source;
				return path == s;
			}
		}
	}
	return false;
};
hxsl_Tools.isSampler = function(t) {
	switch(t._hx_index) {
	case 10:case 11:case 12:
		return true;
	case 17:
		var _g = t.size;
		return true;
	default:
		return false;
	}
};
hxsl_Tools.toString = function(t) {
	switch(t._hx_index) {
	case 5:
		var size = t.size;
		var t1 = t.t;
		var prefix;
		switch(t1._hx_index) {
		case 0:
			prefix = "I";
			break;
		case 1:
			prefix = "";
			break;
		case 2:
			prefix = "B";
			break;
		}
		return prefix + "Vec" + size;
	case 9:
		var n = t.size;
		return "Bytes" + n;
	case 13:
		var vl = t.vl;
		var _g = [];
		var _g1 = 0;
		while(_g1 < vl.length) {
			var v = vl[_g1];
			++_g1;
			_g.push(v.name + " : " + hxsl_Tools.toString(v.type));
		}
		return "{" + _g.join(",") + "}";
	case 15:
		var t1 = t.t;
		var s = t.size;
		var tmp = hxsl_Tools.toString(t1) + "[";
		var tmp1;
		switch(s._hx_index) {
		case 0:
			var i = s.v;
			tmp1 = "" + i;
			break;
		case 1:
			var v = s.v;
			tmp1 = v.name;
			break;
		}
		return tmp + tmp1 + "]";
	case 16:
		var t1 = t.t;
		var s = t.size;
		var tmp = "buffer " + hxsl_Tools.toString(t1) + "[";
		var tmp1;
		switch(s._hx_index) {
		case 0:
			var i = s.v;
			tmp1 = "" + i;
			break;
		case 1:
			var v = s.v;
			tmp1 = v.name;
			break;
		}
		return tmp + tmp1 + "]";
	default:
		return HxOverrides.substr($hxEnums[t.__enum__].__constructs__[t._hx_index]._hx_name,1,null);
	}
};
hxsl_Tools.hasSideEffect = function(e) {
	var _g = e.e;
	switch(_g._hx_index) {
	case 0:
		var _g1 = _g.c;
		return false;
	case 1:
		var _g1 = _g.v;
		return false;
	case 2:
		var _g1 = _g.g;
		return false;
	case 3:
		var e = _g.e;
		return hxsl_Tools.hasSideEffect(e);
	case 4:
		var el = _g.el;
		var _g1 = 0;
		while(_g1 < el.length) {
			var e = el[_g1];
			++_g1;
			if(hxsl_Tools.hasSideEffect(e)) {
				return true;
			}
		}
		return false;
	case 5:
		var _g1 = _g.op;
		var _g2 = _g.e1;
		var _g3 = _g.e2;
		switch(_g1._hx_index) {
		case 4:
			return true;
		case 20:
			var _g4 = _g1.op;
			return true;
		default:
			var e1 = _g2;
			var e2 = _g3;
			if(!hxsl_Tools.hasSideEffect(e1)) {
				return hxsl_Tools.hasSideEffect(e2);
			} else {
				return true;
			}
		}
		break;
	case 6:
		var _g1 = _g.op;
		var e1 = _g.e1;
		return hxsl_Tools.hasSideEffect(e1);
	case 7:
		var _g1 = _g.v;
		var _g1 = _g.init;
		return true;
	case 8:
		var e = _g.e;
		var pl = _g.args;
		var _g1 = e.e;
		var tmp;
		if(_g1._hx_index == 2) {
			var _g2 = _g1.g;
			tmp = true;
		} else {
			tmp = false;
		}
		if(!tmp) {
			return true;
		}
		var _g1 = 0;
		while(_g1 < pl.length) {
			var p = pl[_g1];
			++_g1;
			if(hxsl_Tools.hasSideEffect(p)) {
				return true;
			}
		}
		return false;
	case 9:
		var _g1 = _g.regs;
		var e = _g.e;
		return hxsl_Tools.hasSideEffect(e);
	case 10:
		var econd = _g.econd;
		var eif = _g.eif;
		var eelse = _g.eelse;
		if(!(hxsl_Tools.hasSideEffect(econd) || hxsl_Tools.hasSideEffect(eif))) {
			if(eelse != null) {
				return hxsl_Tools.hasSideEffect(eelse);
			} else {
				return false;
			}
		} else {
			return true;
		}
		break;
	case 11:case 14:case 15:
		return true;
	case 12:
		var _g1 = _g.e;
		return true;
	case 13:
		var _g1 = _g.v;
		var it = _g.it;
		var loop = _g.loop;
		if(!hxsl_Tools.hasSideEffect(it)) {
			return hxsl_Tools.hasSideEffect(loop);
		} else {
			return true;
		}
		break;
	case 16:
		var e = _g.e;
		var index = _g.index;
		if(!hxsl_Tools.hasSideEffect(e)) {
			return hxsl_Tools.hasSideEffect(index);
		} else {
			return true;
		}
		break;
	case 17:
		var el = _g.el;
		var _g1 = 0;
		while(_g1 < el.length) {
			var e = el[_g1];
			++_g1;
			if(hxsl_Tools.hasSideEffect(e)) {
				return true;
			}
		}
		return false;
	case 18:
		var e = _g.e;
		var cases = _g.cases;
		var def = _g.def;
		var _g1 = 0;
		while(_g1 < cases.length) {
			var c = cases[_g1];
			++_g1;
			var _g2 = 0;
			var _g3 = c.values;
			while(_g2 < _g3.length) {
				var v = _g3[_g2];
				++_g2;
				if(hxsl_Tools.hasSideEffect(v)) {
					return true;
				}
			}
			if(hxsl_Tools.hasSideEffect(c.expr)) {
				return true;
			}
		}
		if(!hxsl_Tools.hasSideEffect(e)) {
			if(def != null) {
				return hxsl_Tools.hasSideEffect(def);
			} else {
				return false;
			}
		} else {
			return true;
		}
		break;
	case 19:
		var _g1 = _g.normalWhile;
		var e = _g.e;
		var loop = _g.loop;
		if(!hxsl_Tools.hasSideEffect(e)) {
			return hxsl_Tools.hasSideEffect(loop);
		} else {
			return true;
		}
		break;
	case 20:
		var _g1 = _g.m;
		var _g1 = _g.args;
		var e = _g.e;
		return hxsl_Tools.hasSideEffect(e);
	}
};
hxsl_Tools.iter = function(e,f) {
	var _g = e.e;
	switch(_g._hx_index) {
	case 0:
		var _g1 = _g.c;
		break;
	case 1:
		var _g1 = _g.v;
		break;
	case 2:
		var _g1 = _g.g;
		break;
	case 3:
		var e = _g.e;
		f(e);
		break;
	case 4:
		var el = _g.el;
		var _g1 = 0;
		while(_g1 < el.length) {
			var e = el[_g1];
			++_g1;
			f(e);
		}
		break;
	case 5:
		var _g1 = _g.op;
		var e1 = _g.e1;
		var e2 = _g.e2;
		f(e1);
		f(e2);
		break;
	case 6:
		var _g1 = _g.op;
		var e1 = _g.e1;
		f(e1);
		break;
	case 7:
		var _g1 = _g.v;
		var init = _g.init;
		if(init != null) {
			f(init);
		}
		break;
	case 8:
		var e = _g.e;
		var args = _g.args;
		f(e);
		var _g1 = 0;
		while(_g1 < args.length) {
			var a = args[_g1];
			++_g1;
			f(a);
		}
		break;
	case 9:
		var _g1 = _g.regs;
		var e = _g.e;
		f(e);
		break;
	case 10:
		var econd = _g.econd;
		var eif = _g.eif;
		var eelse = _g.eelse;
		f(econd);
		f(eif);
		if(eelse != null) {
			f(eelse);
		}
		break;
	case 11:case 14:case 15:
		break;
	case 12:
		var e = _g.e;
		if(e != null) {
			f(e);
		}
		break;
	case 13:
		var _g1 = _g.v;
		var it = _g.it;
		var loop = _g.loop;
		f(it);
		f(loop);
		break;
	case 16:
		var e = _g.e;
		var index = _g.index;
		f(e);
		f(index);
		break;
	case 17:
		var el = _g.el;
		var _g1 = 0;
		while(_g1 < el.length) {
			var e = el[_g1];
			++_g1;
			f(e);
		}
		break;
	case 18:
		var e = _g.e;
		var cases = _g.cases;
		var def = _g.def;
		f(e);
		var _g1 = 0;
		while(_g1 < cases.length) {
			var c = cases[_g1];
			++_g1;
			var _g2 = 0;
			var _g3 = c.values;
			while(_g2 < _g3.length) {
				var v = _g3[_g2];
				++_g2;
				f(v);
			}
			f(c.expr);
		}
		if(def != null) {
			f(def);
		}
		break;
	case 19:
		var _g1 = _g.normalWhile;
		var e = _g.e;
		var loop = _g.loop;
		f(e);
		f(loop);
		break;
	case 20:
		var _g1 = _g.m;
		var _g1 = _g.args;
		var e = _g.e;
		f(e);
		break;
	}
};
hxsl_Tools.map = function(e,f) {
	var ed;
	var _g = e.e;
	switch(_g._hx_index) {
	case 0:
		var _g1 = _g.c;
		ed = e.e;
		break;
	case 1:
		var _g1 = _g.v;
		ed = e.e;
		break;
	case 2:
		var _g1 = _g.g;
		ed = e.e;
		break;
	case 3:
		var e1 = _g.e;
		ed = hxsl_TExprDef.TParenthesis(f(e1));
		break;
	case 4:
		var el = _g.el;
		var _g1 = [];
		var _g2 = 0;
		while(_g2 < el.length) {
			var e1 = el[_g2];
			++_g2;
			_g1.push(f(e1));
		}
		ed = hxsl_TExprDef.TBlock(_g1);
		break;
	case 5:
		var op = _g.op;
		var e1 = _g.e1;
		var e2 = _g.e2;
		ed = hxsl_TExprDef.TBinop(op,f(e1),f(e2));
		break;
	case 6:
		var op = _g.op;
		var e1 = _g.e1;
		ed = hxsl_TExprDef.TUnop(op,f(e1));
		break;
	case 7:
		var v = _g.v;
		var init = _g.init;
		ed = hxsl_TExprDef.TVarDecl(v,init != null ? f(init) : null);
		break;
	case 8:
		var e1 = _g.e;
		var args = _g.args;
		var ed1 = f(e1);
		var _g1 = [];
		var _g2 = 0;
		while(_g2 < args.length) {
			var a = args[_g2];
			++_g2;
			_g1.push(f(a));
		}
		ed = hxsl_TExprDef.TCall(ed1,_g1);
		break;
	case 9:
		var e1 = _g.e;
		var c = _g.regs;
		ed = hxsl_TExprDef.TSwiz(f(e1),c);
		break;
	case 10:
		var econd = _g.econd;
		var eif = _g.eif;
		var eelse = _g.eelse;
		ed = hxsl_TExprDef.TIf(f(econd),f(eif),eelse != null ? f(eelse) : null);
		break;
	case 11:case 14:case 15:
		ed = e.e;
		break;
	case 12:
		var e1 = _g.e;
		ed = hxsl_TExprDef.TReturn(e1 != null ? f(e1) : null);
		break;
	case 13:
		var v = _g.v;
		var it = _g.it;
		var loop = _g.loop;
		ed = hxsl_TExprDef.TFor(v,f(it),f(loop));
		break;
	case 16:
		var e1 = _g.e;
		var index = _g.index;
		ed = hxsl_TExprDef.TArray(f(e1),f(index));
		break;
	case 17:
		var el = _g.el;
		var _g1 = [];
		var _g2 = 0;
		while(_g2 < el.length) {
			var e1 = el[_g2];
			++_g2;
			_g1.push(f(e1));
		}
		ed = hxsl_TExprDef.TArrayDecl(_g1);
		break;
	case 18:
		var e1 = _g.e;
		var cases = _g.cases;
		var def = _g.def;
		var ed1 = f(e1);
		var _g1 = [];
		var _g2 = 0;
		while(_g2 < cases.length) {
			var c = cases[_g2];
			++_g2;
			var _g3 = [];
			var _g4 = 0;
			var _g5 = c.values;
			while(_g4 < _g5.length) {
				var v = _g5[_g4];
				++_g4;
				_g3.push(f(v));
			}
			_g1.push({ values : _g3, expr : f(c.expr)});
		}
		ed = hxsl_TExprDef.TSwitch(ed1,_g1,def == null ? null : f(def));
		break;
	case 19:
		var e1 = _g.e;
		var loop = _g.loop;
		var normalWhile = _g.normalWhile;
		ed = hxsl_TExprDef.TWhile(f(e1),f(loop),normalWhile);
		break;
	case 20:
		var m = _g.m;
		var args = _g.args;
		var e1 = _g.e;
		ed = hxsl_TExprDef.TMeta(m,args,f(e1));
		break;
	}
	return { e : ed, t : e.t, p : e.p};
};
hxsl_Tools.size = function(t) {
	switch(t._hx_index) {
	case 0:
		return 0;
	case 1:case 3:
		return 1;
	case 2:case 4:case 10:case 11:case 12:
		return 0;
	case 5:
		var _g = t.t;
		var n = t.size;
		return n;
	case 6:
		return 9;
	case 7:
		return 16;
	case 8:
		return 12;
	case 9:
		var s = t.size;
		return s;
	case 13:
		var vl = t.vl;
		var s = 0;
		var _g = 0;
		while(_g < vl.length) {
			var v = vl[_g];
			++_g;
			s += hxsl_Tools.size(v.type);
		}
		return s;
	case 14:
		var _g = t.variants;
		return 0;
	case 15:
		var _g = t.t;
		var _g1 = t.size;
		switch(_g1._hx_index) {
		case 0:
			var v = _g1.v;
			var t1 = _g;
			return hxsl_Tools.size(t1) * v;
		case 1:
			var _g = _g1.v;
			return 0;
		}
		break;
	case 16:
		var _g = t.size;
		if(_g._hx_index == 0) {
			var v = _g.v;
			var t1 = t.t;
			return hxsl_Tools.size(t1) * v;
		} else {
			return 0;
		}
		break;
	case 17:
		var n = t.size;
		return n;
	case 18:
		return 4;
	}
};
var hxsl_Tools2 = function() { };
$hxClasses["hxsl.Tools2"] = hxsl_Tools2;
hxsl_Tools2.__name__ = "hxsl.Tools2";
hxsl_Tools2.toString = function(g) {
	var n = $hxEnums[g.__enum__].__constructs__[g._hx_index]._hx_name;
	return n.charAt(0).toLowerCase() + HxOverrides.substr(n,1,null);
};
var hxsl_BatchShader = function() {
	this.Batch_Count__ = 0;
	hxsl_Shader.call(this);
};
$hxClasses["hxsl.BatchShader"] = hxsl_BatchShader;
hxsl_BatchShader.__name__ = "hxsl.BatchShader";
hxsl_BatchShader.__super__ = hxsl_Shader;
hxsl_BatchShader.prototype = $extend(hxsl_Shader.prototype,{
	get_Batch_HasOffset: function() {
		return this.Batch_HasOffset__;
	}
	,set_Batch_HasOffset: function(_v) {
		this.constModified = true;
		return this.Batch_HasOffset__ = _v;
	}
	,get_Batch_Count: function() {
		return this.Batch_Count__;
	}
	,set_Batch_Count: function(_v) {
		this.constModified = true;
		return this.Batch_Count__ = _v;
	}
	,get_Batch_Buffer: function() {
		return this.Batch_Buffer__;
	}
	,set_Batch_Buffer: function(_v) {
		return this.Batch_Buffer__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		if(this.Batch_HasOffset__) {
			this.constBits |= 1;
		}
		var v = this.Batch_Count__;
		if(v >>> 17 != 0) {
			throw haxe_Exception.thrown("Batch_Count" + " is out of range " + v + ">" + 131071);
		}
		this.constBits |= v << 1;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.Batch_HasOffset__;
		case 1:
			return this.Batch_Count__;
		case 2:
			return this.Batch_Buffer__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,__class__: hxsl_BatchShader
});
var hxsl_SearchMap = function() {
	this.minId = 0;
	this.nexts = [];
};
$hxClasses["hxsl.SearchMap"] = hxsl_SearchMap;
hxsl_SearchMap.__name__ = "hxsl.SearchMap";
hxsl_SearchMap.prototype = {
	set: function(id,s) {
		if(this.minId == 0) {
			this.minId = id;
			this.nexts = [s];
			return;
		}
		var offset = id - this.minId;
		if(offset < 0) {
			var n = [];
			var _g = 0;
			var _g1 = this.nexts.length;
			while(_g < _g1) {
				var i = _g++;
				n[i - offset] = this.nexts[i];
			}
			this.nexts = n;
			this.minId += offset;
			offset = 0;
		}
		this.nexts[offset] = s;
	}
	,__class__: hxsl_SearchMap
};
var hxsl_Cache = function() {
	this.constsToGlobal = false;
	this.linkCache = new hxsl_SearchMap();
	this.linkShaders = new haxe_ds_StringMap();
	this.batchShaders = new haxe_ds_ObjectMap();
	this.byID = new haxe_ds_StringMap();
};
$hxClasses["hxsl.Cache"] = hxsl_Cache;
hxsl_Cache.__name__ = "hxsl.Cache";
hxsl_Cache.get = function() {
	var c = hxsl_Cache.INST;
	if(c == null) {
		c = new hxsl_Cache();
		hxsl_Cache.INST = c;
	}
	return c;
};
hxsl_Cache.prototype = {
	getLinkShader: function(vars) {
		var _g = [];
		var _g1 = 0;
		while(_g1 < vars.length) {
			var v = vars[_g1];
			++_g1;
			_g.push(Std.string(v));
		}
		var key = _g.join(",");
		var shader = this.linkShaders.h[key];
		if(shader != null) {
			return shader;
		}
		var s = new hxsl_SharedShader("");
		var id = HxOverrides.substr(haxe_crypto_Md5.encode(key),0,8);
		s.data = { name : "shaderLinker_" + id, vars : [], funs : []};
		var pos = null;
		var outVars_h = Object.create(null);
		var outputCount = 0;
		var tvec4 = hxsl_Type.TVec(4,hxsl_VecType.VFloat);
		var makeVec = function(g,size,args,makeOutExpr) {
			var out = [];
			var rem = size;
			var _g = 0;
			var _g1 = args.length;
			while(_g < _g1) {
				var i = _g++;
				var e = makeOutExpr(args[args.length - 1 - i],rem - (args.length - 1 - i));
				rem -= hxsl_Tools.size(e.t);
				out.unshift(e);
			}
			return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(g), t : hxsl_Type.TVoid, p : pos},out), t : hxsl_Type.TVec(size,hxsl_VecType.VFloat), p : pos};
		};
		var makeVar = function(name,t,parent) {
			var path = parent == null ? name : hxsl_Tools.getName(parent) + "." + name;
			var v = outVars_h[path];
			if(v != null) {
				return v;
			}
			v = { id : hxsl_Tools.allocVarId(), name : name, type : t, kind : hxsl_VarKind.Var, parent : parent};
			if(parent == null) {
				s.data.vars.push(v);
			} else {
				var _g = parent.type;
				if(_g._hx_index == 13) {
					var vl = _g.vl;
					vl.push(v);
				} else {
					throw haxe_Exception.thrown("assert");
				}
			}
			outVars_h[path] = v;
			return v;
		};
		var makeOutExpr = null;
		makeOutExpr = function(v,rem) {
			switch(v._hx_index) {
			case 0:
				var v1 = v.v;
				return { e : hxsl_TExprDef.TConst(hxsl_Const.CFloat(v1)), t : hxsl_Type.TFloat, p : pos};
			case 1:
				var vname = v.v;
				var size = v.size;
				var v1 = outVars_h[vname];
				if(v1 != null) {
					return { e : hxsl_TExprDef.TVar(v1), t : v1.type, p : pos};
				}
				var path = vname.split(".");
				var parent = null;
				while(path.length > 1) parent = makeVar(path.shift(),hxsl_Type.TStruct([]),parent);
				if(size != null) {
					rem = size;
				}
				v1 = makeVar(path.shift(),rem == 1 ? hxsl_Type.TFloat : hxsl_Type.TVec(rem,hxsl_VecType.VFloat),parent);
				return { e : hxsl_TExprDef.TVar(v1), t : v1.type, p : pos};
			case 2:
				var v1 = v.v;
				return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.PackNormal), t : hxsl_Type.TVoid, p : pos},[makeOutExpr(v1,3)]), t : tvec4, p : pos};
			case 3:
				var v1 = v.v;
				return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Pack), t : hxsl_Type.TVoid, p : pos},[makeOutExpr(v1,1)]), t : tvec4, p : pos};
			case 4:
				var args = v.a;
				return makeVec(hxsl_TGlobal.Vec2,2,args,makeOutExpr);
			case 5:
				var args = v.a;
				return makeVec(hxsl_TGlobal.Vec3,3,args,makeOutExpr);
			case 6:
				var args = v.a;
				return makeVec(hxsl_TGlobal.Vec4,4,args,makeOutExpr);
			case 7:
				var v1 = v.a;
				var comps = v.swiz;
				return { e : hxsl_TExprDef.TSwiz(makeOutExpr(v1,4),comps), t : hxsl_Type.TVec(comps.length,hxsl_VecType.VFloat), p : pos};
			}
		};
		var makeOutput = function(v) {
			outputCount += 1;
			var ov = { id : hxsl_Tools.allocVarId(), type : tvec4, name : "OUTPUT" + (outputCount - 1), kind : hxsl_VarKind.Output};
			s.data.vars.push(ov);
			return { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,{ e : hxsl_TExprDef.TVar(ov), t : tvec4, p : pos},makeOutExpr(v,4)), t : hxsl_Type.TVoid, p : pos};
		};
		var defineFun = function(kind,vars) {
			var fv = { id : hxsl_Tools.allocVarId(), type : hxsl_Type.TFun([]), name : ("" + Std.string(kind)).toLowerCase(), kind : hxsl_VarKind.Function};
			var _g = [];
			var _g1 = 0;
			while(_g1 < vars.length) {
				var v = vars[_g1];
				++_g1;
				_g.push(makeOutput(v));
			}
			var f = { kind : kind, ref : fv, args : [], ret : hxsl_Type.TVoid, expr : { e : hxsl_TExprDef.TBlock(_g), p : pos, t : hxsl_Type.TVoid}};
			s.data.funs.push(f);
		};
		defineFun(hxsl_FunctionKind.Vertex,[hxsl_Output.Value("output.position")]);
		defineFun(hxsl_FunctionKind.Fragment,vars);
		shader = Object.create(hxsl_Shader.prototype);
		shader.shader = s;
		this.linkShaders.h[key] = shader;
		shader.updateConstantsFinal(null);
		return shader;
	}
	,link: function(shaders,batchMode) {
		var c = this.linkCache;
		var _g_l = shaders;
		var _g_last = null;
		while(_g_l != _g_last) {
			var s = _g_l.s;
			_g_l = _g_l.next;
			var s1 = s;
			var i = s1.instance;
			var cs = c.nexts[i.id - c.minId];
			if(cs == null) {
				cs = new hxsl_SearchMap();
				c.set(i.id,cs);
			}
			c = cs;
		}
		if(c.linked == null) {
			c.linked = this.compileRuntimeShader(shaders,batchMode);
		}
		return c.linked;
	}
	,compileRuntimeShader: function(shaders,batchMode) {
		var shaderDatas = [];
		var index = 0;
		var _g_l = shaders;
		var _g_last = null;
		while(_g_l != _g_last) {
			var s = _g_l.s;
			_g_l = _g_l.next;
			var s1 = s;
			var i = s1.instance;
			shaderDatas.push({ inst : i, p : s1.priority, index : index++});
		}
		shaderDatas.reverse();
		haxe_ds_ArraySort.sort(shaderDatas,function(s1,s2) {
			return s2.p - s1.p;
		});
		var linker = new hxsl_Linker(batchMode);
		var s;
		try {
			var _g = [];
			var _g1 = 0;
			while(_g1 < shaderDatas.length) {
				var s1 = shaderDatas[_g1];
				++_g1;
				_g.push(s1.inst.shader);
			}
			s = linker.link(_g);
		} catch( _g ) {
			var _g1 = haxe_Exception.caught(_g).unwrap();
			if(((_g1) instanceof hxsl_Error)) {
				var e = _g1;
				var _g1 = [];
				var _g2 = 0;
				while(_g2 < shaderDatas.length) {
					var s1 = shaderDatas[_g2];
					++_g2;
					_g1.push(hxsl_Printer.shaderToString(s1.inst.shader));
				}
				var shaders1 = _g1;
				e.msg += "\n\nin\n\n" + shaders1.join("\n-----\n");
				throw haxe_Exception.thrown(e);
			} else {
				throw _g;
			}
		}
		if(batchMode) {
			var checkRec = null;
			checkRec = function(v) {
				if(v.qualifiers != null && v.qualifiers.indexOf(hxsl_VarQualifier.PerObject) >= 0) {
					if(v.qualifiers.length == 1) {
						v.qualifiers = null;
					} else {
						v.qualifiers = v.qualifiers.slice();
						HxOverrides.remove(v.qualifiers,hxsl_VarQualifier.PerObject);
					}
					if(v.kind != hxsl_VarKind.Var) {
						v.kind = hxsl_VarKind.Local;
					}
				}
				var _g = v.type;
				if(_g._hx_index == 13) {
					var vl = _g.vl;
					var _g = 0;
					while(_g < vl.length) {
						var v = vl[_g];
						++_g;
						checkRec(v);
					}
				}
			};
			var _g = 0;
			var _g1 = s.vars;
			while(_g < _g1.length) {
				var v = _g1[_g];
				++_g;
				checkRec(v);
			}
		}
		var paramVars = new haxe_ds_IntMap();
		var _g = 0;
		var _g1 = linker.allVars;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			if(v.v.kind == hxsl_VarKind.Param) {
				var _g2 = v.v.type;
				if(_g2._hx_index == 13) {
					var _g3 = _g2.vl;
					continue;
				}
				var inf = shaderDatas[v.instanceIndex];
				paramVars.h[v.id] = { instance : inf.index, index : inf.inst.params.h[v.merged[0].id]};
			}
		}
		var prev = s;
		var s1;
		try {
			s1 = new hxsl_Splitter().split(s);
		} catch( _g ) {
			var _g1 = haxe_Exception.caught(_g).unwrap();
			if(((_g1) instanceof hxsl_Error)) {
				var e = _g1;
				e.msg += "\n\nin\n\n" + hxsl_Printer.shaderToString(s);
				throw haxe_Exception.thrown(e);
			} else {
				throw _g;
			}
		}
		var prev = s1;
		var s = new hxsl_Dce().dce(s1.vertex,s1.fragment);
		var r = this.buildRuntimeShader(s.vertex,s.fragment,paramVars);
		var _g = [];
		var _g4_l = shaders;
		var _g4_last = null;
		while(_g4_l != _g4_last) {
			var s = _g4_l.s;
			_g4_l = _g4_l.next;
			var s1 = s;
			_g.push(new hxsl_ShaderInstanceDesc(s1.shader,s1.constBits));
		}
		r.spec = { instances : _g, signature : null};
		var _g = 0;
		var _g1 = shaderDatas.length;
		while(_g < _g1) {
			var i = _g++;
			var s = shaderDatas[shaderDatas.length - 1 - i];
			r.spec.instances[s.index].index = i;
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = r.spec.instances;
		while(_g1 < _g2.length) {
			var i = _g2[_g1];
			++_g1;
			_g.push(i.shader.data.name + "_" + i.bits + "_" + i.index);
		}
		var signParts = _g;
		var tmp = signParts.join(":");
		r.spec.signature = haxe_crypto_Md5.encode(tmp);
		r.signature = haxe_crypto_Md5.encode(hxsl_Printer.shaderToString(r.vertex.data) + hxsl_Printer.shaderToString(r.fragment.data));
		r.batchMode = batchMode;
		var r2 = this.byID.h[r.signature];
		if(r2 != null) {
			r.id = r2.id;
		} else {
			this.byID.h[r.signature] = r;
		}
		return r;
	}
	,buildRuntimeShader: function(vertex,fragment,paramVars) {
		var r = new hxsl_RuntimeShader();
		r.vertex = this.flattenShader(vertex,hxsl_FunctionKind.Vertex,paramVars);
		r.vertex.vertex = true;
		r.fragment = this.flattenShader(fragment,hxsl_FunctionKind.Fragment,paramVars);
		r.globals = new haxe_ds_IntMap();
		this.initGlobals(r,r.vertex);
		this.initGlobals(r,r.fragment);
		return r;
	}
	,initGlobals: function(r,s) {
		var p = s.globals;
		while(p != null) {
			r.globals.h[p.gid] = true;
			p = p.next;
		}
		var p = s.params;
		while(p != null) {
			if(p.perObjectGlobal != null) {
				r.globals.h[p.perObjectGlobal.gid] = true;
			}
			p = p.next;
		}
	}
	,getPath: function(v) {
		if(v.parent == null) {
			return v.name;
		}
		return this.getPath(v.parent) + "." + v.name;
	}
	,flattenShader: function(s,kind,params) {
		var flat = new hxsl_Flatten();
		var c = new hxsl_RuntimeShaderData();
		var data = flat.flatten(s,kind,this.constsToGlobal);
		var textures = [];
		c.consts = flat.consts;
		c.texturesCount = 0;
		var g = flat.allocData.keys();
		while(g.hasNext()) {
			var g1 = g.next();
			var alloc = flat.allocData.h[g1.__id__];
			switch(g1.kind._hx_index) {
			case 0:
				var _g = [];
				var _g1 = 0;
				while(_g1 < alloc.length) {
					var a = alloc[_g1];
					++_g1;
					if(a.v != null) {
						_g.push(new hxsl_AllocGlobal(a.pos,this.getPath(a.v),a.v.type));
					}
				}
				var out = _g;
				var _g2 = 0;
				var _g3 = out.length - 1;
				while(_g2 < _g3) {
					var i = _g2++;
					out[i].next = out[i + 1];
				}
				var _g4 = g1.type;
				if(_g4._hx_index == 15) {
					var _g5 = _g4.t;
					var _g6 = _g4.size;
					if(_g5._hx_index == 5) {
						if(_g5.size == 4) {
							if(_g5.t._hx_index == 1) {
								if(_g6._hx_index == 0) {
									var size = _g6.v;
									c.globals = out[0];
									c.globalsSize = size;
								} else {
									throw haxe_Exception.thrown("assert");
								}
							} else {
								throw haxe_Exception.thrown("assert");
							}
						} else {
							throw haxe_Exception.thrown("assert");
						}
					} else {
						throw haxe_Exception.thrown("assert");
					}
				} else {
					throw haxe_Exception.thrown("assert");
				}
				break;
			case 2:
				var out1 = [];
				var count = 0;
				var _g7 = 0;
				while(_g7 < alloc.length) {
					var a1 = alloc[_g7];
					++_g7;
					if(a1.v == null) {
						continue;
					}
					var p = params.h[a1.v.id];
					if(p == null) {
						var ap = new hxsl_AllocParam(a1.v.name,a1.pos,-1,-1,a1.v.type);
						ap.perObjectGlobal = new hxsl_AllocGlobal(-1,this.getPath(a1.v),a1.v.type);
						out1.push(ap);
						++count;
						continue;
					}
					var ap1 = new hxsl_AllocParam(a1.v.name,a1.pos,p.instance,p.index,a1.v.type);
					var _g8 = a1.v.type;
					if(_g8._hx_index == 15) {
						var _g9 = _g8.size;
						var t = _g8.t;
						if(hxsl_Tools.isSampler(t)) {
							ap1.pos = -a1.size;
							count += a1.size;
						} else {
							++count;
						}
					} else {
						++count;
					}
					out1.push(ap1);
				}
				var _g10 = 0;
				var _g11 = out1.length - 1;
				while(_g10 < _g11) {
					var i1 = _g10++;
					out1[i1].next = out1[i1 + 1];
				}
				var _g12 = g1.type;
				if(_g12._hx_index == 15) {
					var _g13 = _g12.t;
					var _g14 = _g12.size;
					var t1 = _g13;
					if(hxsl_Tools.isSampler(t1)) {
						textures.push({ t : t1, all : out1});
						c.texturesCount += count;
					} else {
						switch(_g13._hx_index) {
						case 5:
							if(_g13.size == 4) {
								if(_g13.t._hx_index == 1) {
									if(_g14._hx_index == 0) {
										var size1 = _g14.v;
										c.params = out1[0];
										c.paramsSize = size1;
									} else {
										throw haxe_Exception.thrown("assert");
									}
								} else {
									throw haxe_Exception.thrown("assert");
								}
							} else {
								throw haxe_Exception.thrown("assert");
							}
							break;
						case 16:
							var _g15 = _g13.t;
							var _g16 = _g13.size;
							c.buffers = out1[0];
							c.bufferCount = out1.length;
							break;
						default:
							throw haxe_Exception.thrown("assert");
						}
					}
				} else {
					throw haxe_Exception.thrown("assert");
				}
				break;
			default:
				throw haxe_Exception.thrown("assert");
			}
		}
		if(textures.length > 0) {
			textures.sort(function(t1,t2) {
				return t1.t._hx_index - t2.t._hx_index;
			});
			c.textures = textures[0].all[0];
			var _g = 1;
			var _g1 = textures.length;
			while(_g < _g1) {
				var i = _g++;
				var prevAll = textures[i - 1].all;
				var prev = prevAll[prevAll.length - 1];
				prev.next = textures[i].all[0];
			}
		}
		if(c.globals == null) {
			c.globalsSize = 0;
		}
		if(c.params == null) {
			c.paramsSize = 0;
		}
		if(c.buffers == null) {
			c.bufferCount = 0;
		}
		c.data = data;
		return c;
	}
	,__class__: hxsl_Cache
};
var hxsl_Channel = $hxEnums["hxsl.Channel"] = { __ename__:true,__constructs__:null
	,Unknown: {_hx_name:"Unknown",_hx_index:0,__enum__:"hxsl.Channel",toString:$estr}
	,R: {_hx_name:"R",_hx_index:1,__enum__:"hxsl.Channel",toString:$estr}
	,G: {_hx_name:"G",_hx_index:2,__enum__:"hxsl.Channel",toString:$estr}
	,B: {_hx_name:"B",_hx_index:3,__enum__:"hxsl.Channel",toString:$estr}
	,A: {_hx_name:"A",_hx_index:4,__enum__:"hxsl.Channel",toString:$estr}
	,PackedFloat: {_hx_name:"PackedFloat",_hx_index:5,__enum__:"hxsl.Channel",toString:$estr}
	,PackedNormal: {_hx_name:"PackedNormal",_hx_index:6,__enum__:"hxsl.Channel",toString:$estr}
};
hxsl_Channel.__constructs__ = [hxsl_Channel.Unknown,hxsl_Channel.R,hxsl_Channel.G,hxsl_Channel.B,hxsl_Channel.A,hxsl_Channel.PackedFloat,hxsl_Channel.PackedNormal];
hxsl_Channel.__empty_constructs__ = [hxsl_Channel.Unknown,hxsl_Channel.R,hxsl_Channel.G,hxsl_Channel.B,hxsl_Channel.A,hxsl_Channel.PackedFloat,hxsl_Channel.PackedNormal];
var hxsl_Clone = function() {
	this.varMap = new haxe_ds_IntMap();
};
$hxClasses["hxsl.Clone"] = hxsl_Clone;
hxsl_Clone.__name__ = "hxsl.Clone";
hxsl_Clone.shaderData = function(s) {
	return new hxsl_Clone().shader(s);
};
hxsl_Clone.prototype = {
	tvar: function(v) {
		var v2 = this.varMap.h[v.id];
		if(v2 != null) {
			return v2;
		}
		v2 = { id : hxsl_Tools.allocVarId(), type : v.type, name : v.name, kind : v.kind};
		this.varMap.h[v.id] = v2;
		if(v.parent != null) {
			v2.parent = this.tvar(v.parent);
		}
		if(v.qualifiers != null) {
			v2.qualifiers = v.qualifiers.slice();
		}
		v2.type = this.ttype(v.type);
		return v2;
	}
	,tfun: function(f) {
		var tmp = this.ttype(f.ret);
		var f1 = f.kind;
		var tmp1 = this.tvar(f.ref);
		var _g = [];
		var _g1 = 0;
		var _g2 = f.args;
		while(_g1 < _g2.length) {
			var a = _g2[_g1];
			++_g1;
			_g.push(this.tvar(a));
		}
		return { ret : tmp, kind : f1, ref : tmp1, args : _g, expr : this.texpr(f.expr)};
	}
	,ttype: function(t) {
		switch(t._hx_index) {
		case 13:
			var vl = t.vl;
			var _g = [];
			var _g1 = 0;
			while(_g1 < vl.length) {
				var v = vl[_g1];
				++_g1;
				_g.push(this.tvar(v));
			}
			return hxsl_Type.TStruct(_g);
		case 14:
			var vars = t.variants;
			return hxsl_Type.TFun(vars);
		case 15:
			var t1 = t.t;
			var size = t.size;
			var tmp = this.ttype(t1);
			var tmp1;
			switch(size._hx_index) {
			case 0:
				var _g = size.v;
				tmp1 = size;
				break;
			case 1:
				var v = size.v;
				tmp1 = hxsl_SizeDecl.SVar(this.tvar(v));
				break;
			}
			return hxsl_Type.TArray(tmp,tmp1);
		default:
			return t;
		}
	}
	,texpr: function(e) {
		var e2 = hxsl_Tools.map(e,$bind(this,this.texpr));
		e2.t = this.ttype(e.t);
		var _g = e2.e;
		var tmp;
		switch(_g._hx_index) {
		case 1:
			var v = _g.v;
			tmp = hxsl_TExprDef.TVar(this.tvar(v));
			break;
		case 7:
			var v = _g.v;
			var init = _g.init;
			tmp = hxsl_TExprDef.TVarDecl(this.tvar(v),init);
			break;
		case 13:
			var v = _g.v;
			var it = _g.it;
			var loop = _g.loop;
			tmp = hxsl_TExprDef.TFor(this.tvar(v),it,loop);
			break;
		default:
			tmp = e2.e;
		}
		e2.e = tmp;
		return e2;
	}
	,shader: function(s) {
		var s1 = s.name;
		var _g = [];
		var _g1 = 0;
		var _g2 = s.vars;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			_g.push(this.tvar(v));
		}
		var tmp = _g;
		var _g = [];
		var _g1 = 0;
		var _g2 = s.funs;
		while(_g1 < _g2.length) {
			var f = _g2[_g1];
			++_g1;
			_g.push(this.tfun(f));
		}
		return { name : s1, vars : tmp, funs : _g};
	}
	,__class__: hxsl_Clone
};
var hxsl__$Dce_VarDeps = function(v) {
	this.v = v;
	this.used = false;
	this.deps = new haxe_ds_IntMap();
};
$hxClasses["hxsl._Dce.VarDeps"] = hxsl__$Dce_VarDeps;
hxsl__$Dce_VarDeps.__name__ = "hxsl._Dce.VarDeps";
hxsl__$Dce_VarDeps.prototype = {
	__class__: hxsl__$Dce_VarDeps
};
var hxsl_Dce = function() {
};
$hxClasses["hxsl.Dce"] = hxsl_Dce;
hxsl_Dce.__name__ = "hxsl.Dce";
hxsl_Dce.prototype = {
	dce: function(vertex,fragment) {
		this.used = new haxe_ds_IntMap();
		this.channelVars = [];
		var inputs = [];
		var _g = 0;
		var _g1 = vertex.vars;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			var i = this.get(v);
			if(v.kind == hxsl_VarKind.Input) {
				inputs.push(i);
			}
			if(v.kind == hxsl_VarKind.Output) {
				i.keep = true;
			}
		}
		var _g = 0;
		var _g1 = fragment.vars;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			var i = this.get(v);
			if(v.kind == hxsl_VarKind.Output) {
				i.keep = true;
			}
		}
		var _g = 0;
		var _g1 = vertex.funs;
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			this.check(f.expr,[],[]);
		}
		var _g = 0;
		var _g1 = fragment.funs;
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			this.check(f.expr,[],[]);
		}
		var outExprs = [];
		while(true) {
			var v = this.used.iterator();
			while(v.hasNext()) {
				var v1 = v.next();
				if(v1.keep) {
					this.markRec(v1);
				}
			}
			while(inputs.length > 1 && !inputs[inputs.length - 1].used) inputs.pop();
			var _g = 0;
			while(_g < inputs.length) {
				var v2 = inputs[_g];
				++_g;
				this.markRec(v2);
			}
			outExprs = [];
			var _g1 = 0;
			var _g2 = vertex.funs;
			while(_g1 < _g2.length) {
				var f = _g2[_g1];
				++_g1;
				outExprs.push(this.mapExpr(f.expr,false));
			}
			var _g3 = 0;
			var _g4 = fragment.funs;
			while(_g3 < _g4.length) {
				var f1 = _g4[_g3];
				++_g3;
				outExprs.push(this.mapExpr(f1.expr,false));
			}
			this.markAsKeep = false;
			var _g5 = 0;
			while(_g5 < outExprs.length) {
				var e = outExprs[_g5];
				++_g5;
				this.checkBranches(e);
			}
			if(!this.markAsKeep) {
				break;
			}
		}
		var _g = 0;
		var _g1 = vertex.funs;
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			f.expr = outExprs.shift();
		}
		var _g = 0;
		var _g1 = fragment.funs;
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			f.expr = outExprs.shift();
		}
		var v = this.used.iterator();
		while(v.hasNext()) {
			var v1 = v.next();
			if(v1.used) {
				continue;
			}
			if(v1.v.kind == hxsl_VarKind.Input) {
				continue;
			}
			HxOverrides.remove(vertex.vars,v1.v);
			HxOverrides.remove(fragment.vars,v1.v);
		}
		return { fragment : fragment, vertex : vertex};
	}
	,get: function(v) {
		var vd = this.used.h[v.id];
		if(vd == null) {
			vd = new hxsl__$Dce_VarDeps(v);
			this.used.h[v.id] = vd;
		}
		return vd;
	}
	,markRec: function(v) {
		if(v.used) {
			return;
		}
		v.used = true;
		var d = v.deps.iterator();
		while(d.hasNext()) {
			var d1 = d.next();
			this.markRec(d1);
		}
	}
	,link: function(v,writeTo) {
		var vd = this.get(v);
		var _g = 0;
		while(_g < writeTo.length) {
			var w = writeTo[_g];
			++_g;
			if(w == null) {
				if(!vd.keep) {
					vd.keep = true;
					this.markAsKeep = true;
				}
				continue;
			}
			w.deps.h[v.id] = vd;
		}
	}
	,check: function(e,writeTo,isAffected) {
		var _g = e.e;
		switch(_g._hx_index) {
		case 1:
			var v = _g.v;
			this.link(v,writeTo);
			break;
		case 4:
			var el = _g.el;
			var noWrite = [];
			var _g1 = 0;
			var _g2 = el.length;
			while(_g1 < _g2) {
				var i = _g1++;
				this.check(el[i],i < el.length - 1 ? noWrite : writeTo,isAffected);
			}
			break;
		case 5:
			var _g1 = _g.op;
			var _g2 = _g.e1;
			var _g3 = _g.e2;
			switch(_g1._hx_index) {
			case 4:
				var _g4 = _g2.e;
				var _g5 = _g2.p;
				var _g5 = _g2.t;
				switch(_g4._hx_index) {
				case 1:
					var v = _g4.v;
					var e1 = _g3;
					var v1 = this.get(v);
					writeTo.push(v1);
					this.check(e1,writeTo,isAffected);
					writeTo.pop();
					if(isAffected.indexOf(v1) < 0) {
						isAffected.push(v1);
					}
					break;
				case 9:
					var _g5 = _g4.e;
					var _g6 = _g4.regs;
					var _g4 = _g5.e;
					var _g6 = _g5.p;
					var _g6 = _g5.t;
					if(_g4._hx_index == 1) {
						var v = _g4.v;
						var e1 = _g3;
						var v1 = this.get(v);
						writeTo.push(v1);
						this.check(e1,writeTo,isAffected);
						writeTo.pop();
						if(isAffected.indexOf(v1) < 0) {
							isAffected.push(v1);
						}
					} else {
						var _g4 = $bind(this,this.check);
						var writeTo1 = writeTo;
						var isAffected1 = isAffected;
						hxsl_Tools.iter(e,function(e) {
							_g4(e,writeTo1,isAffected1);
						});
					}
					break;
				default:
					var _g5 = $bind(this,this.check);
					var writeTo2 = writeTo;
					var isAffected2 = isAffected;
					hxsl_Tools.iter(e,function(e) {
						_g5(e,writeTo2,isAffected2);
					});
				}
				break;
			case 20:
				var _g6 = _g1.op;
				var _g1 = _g2.e;
				var _g6 = _g2.p;
				var _g6 = _g2.t;
				switch(_g1._hx_index) {
				case 1:
					var v = _g1.v;
					var e1 = _g3;
					var v1 = this.get(v);
					writeTo.push(v1);
					this.check(e1,writeTo,isAffected);
					writeTo.pop();
					if(isAffected.indexOf(v1) < 0) {
						isAffected.push(v1);
					}
					break;
				case 9:
					var _g2 = _g1.e;
					var _g6 = _g1.regs;
					var _g1 = _g2.e;
					var _g6 = _g2.p;
					var _g6 = _g2.t;
					if(_g1._hx_index == 1) {
						var v = _g1.v;
						var e1 = _g3;
						var v1 = this.get(v);
						writeTo.push(v1);
						this.check(e1,writeTo,isAffected);
						writeTo.pop();
						if(isAffected.indexOf(v1) < 0) {
							isAffected.push(v1);
						}
					} else {
						var _g1 = $bind(this,this.check);
						var writeTo3 = writeTo;
						var isAffected3 = isAffected;
						hxsl_Tools.iter(e,function(e) {
							_g1(e,writeTo3,isAffected3);
						});
					}
					break;
				default:
					var _g2 = $bind(this,this.check);
					var writeTo4 = writeTo;
					var isAffected4 = isAffected;
					hxsl_Tools.iter(e,function(e) {
						_g2(e,writeTo4,isAffected4);
					});
				}
				break;
			default:
				var _g3 = $bind(this,this.check);
				var writeTo5 = writeTo;
				var isAffected5 = isAffected;
				hxsl_Tools.iter(e,function(e) {
					_g3(e,writeTo5,isAffected5);
				});
			}
			break;
		case 7:
			var v = _g.v;
			var init = _g.init;
			if(init != null) {
				writeTo.push(this.get(v));
				this.check(init,writeTo,isAffected);
				writeTo.pop();
			} else {
				var _g6 = $bind(this,this.check);
				var writeTo6 = writeTo;
				var isAffected6 = isAffected;
				hxsl_Tools.iter(e,function(e) {
					_g6(e,writeTo6,isAffected6);
				});
			}
			break;
		case 8:
			var _g7 = _g.e;
			var _g8 = _g.args;
			var _g9 = _g7.e;
			var _g10 = _g7.p;
			var _g10 = _g7.t;
			if(_g9._hx_index == 2) {
				switch(_g9.g._hx_index) {
				case 63:
					if(_g8.length == 3) {
						var _g7 = _g8[0];
						var _g9 = _g8[2];
						var _g10 = _g7.e;
						var _g11 = _g7.p;
						var _g11 = _g7.t;
						if(_g10._hx_index == 1) {
							var _g7 = _g9.e;
							var _g11 = _g9.p;
							var _g11 = _g9.t;
							if(_g7._hx_index == 0) {
								var _g9 = _g7.c;
								if(_g9._hx_index == 2) {
									var cid = _g9.v;
									var uv = _g8[1];
									var c = _g10.v;
									this.check(uv,writeTo,isAffected);
									if(this.channelVars[cid] == null) {
										this.channelVars[cid] = c;
										this.link(c,writeTo);
									} else {
										this.link(this.channelVars[cid],writeTo);
									}
								} else {
									var _g7 = $bind(this,this.check);
									var writeTo7 = writeTo;
									var isAffected7 = isAffected;
									hxsl_Tools.iter(e,function(e) {
										_g7(e,writeTo7,isAffected7);
									});
								}
							} else {
								var _g9 = $bind(this,this.check);
								var writeTo8 = writeTo;
								var isAffected8 = isAffected;
								hxsl_Tools.iter(e,function(e) {
									_g9(e,writeTo8,isAffected8);
								});
							}
						} else {
							var _g10 = $bind(this,this.check);
							var writeTo9 = writeTo;
							var isAffected9 = isAffected;
							hxsl_Tools.iter(e,function(e) {
								_g10(e,writeTo9,isAffected9);
							});
						}
					} else {
						var _g11 = $bind(this,this.check);
						var writeTo10 = writeTo;
						var isAffected10 = isAffected;
						hxsl_Tools.iter(e,function(e) {
							_g11(e,writeTo10,isAffected10);
						});
					}
					break;
				case 64:
					if(_g8.length == 4) {
						var _g12 = _g8[0];
						var _g13 = _g8[3];
						var _g14 = _g12.e;
						var _g15 = _g12.p;
						var _g15 = _g12.t;
						if(_g14._hx_index == 1) {
							var _g12 = _g13.e;
							var _g15 = _g13.p;
							var _g15 = _g13.t;
							if(_g12._hx_index == 0) {
								var _g13 = _g12.c;
								if(_g13._hx_index == 2) {
									var cid = _g13.v;
									var lod = _g8[2];
									var uv = _g8[1];
									var c = _g14.v;
									this.check(uv,writeTo,isAffected);
									this.check(lod,writeTo,isAffected);
									if(this.channelVars[cid] == null) {
										this.channelVars[cid] = c;
										this.link(c,writeTo);
									} else {
										this.link(this.channelVars[cid],writeTo);
									}
								} else {
									var _g8 = $bind(this,this.check);
									var writeTo11 = writeTo;
									var isAffected11 = isAffected;
									hxsl_Tools.iter(e,function(e) {
										_g8(e,writeTo11,isAffected11);
									});
								}
							} else {
								var _g12 = $bind(this,this.check);
								var writeTo12 = writeTo;
								var isAffected12 = isAffected;
								hxsl_Tools.iter(e,function(e) {
									_g12(e,writeTo12,isAffected12);
								});
							}
						} else {
							var _g13 = $bind(this,this.check);
							var writeTo13 = writeTo;
							var isAffected13 = isAffected;
							hxsl_Tools.iter(e,function(e) {
								_g13(e,writeTo13,isAffected13);
							});
						}
					} else {
						var _g14 = $bind(this,this.check);
						var writeTo14 = writeTo;
						var isAffected14 = isAffected;
						hxsl_Tools.iter(e,function(e) {
							_g14(e,writeTo14,isAffected14);
						});
					}
					break;
				default:
					var _g15 = $bind(this,this.check);
					var writeTo15 = writeTo;
					var isAffected15 = isAffected;
					hxsl_Tools.iter(e,function(e) {
						_g15(e,writeTo15,isAffected15);
					});
				}
			} else {
				var _g16 = $bind(this,this.check);
				var writeTo16 = writeTo;
				var isAffected16 = isAffected;
				hxsl_Tools.iter(e,function(e) {
					_g16(e,writeTo16,isAffected16);
				});
			}
			break;
		case 10:
			var e1 = _g.econd;
			var eif = _g.eif;
			var eelse = _g.eelse;
			var affect = [];
			this.check(eif,writeTo,affect);
			if(eelse != null) {
				this.check(eelse,writeTo,affect);
			}
			var len = affect.length;
			var _g17 = 0;
			while(_g17 < writeTo.length) {
				var v = writeTo[_g17];
				++_g17;
				if(affect.indexOf(v) < 0) {
					affect.push(v);
				}
			}
			this.check(e1,affect,isAffected);
			var _g17 = 0;
			var _g18 = len;
			while(_g17 < _g18) {
				var i = _g17++;
				var v = affect[i];
				if(isAffected.indexOf(v) < 0) {
					isAffected.push(v);
				}
			}
			break;
		case 13:
			var v = _g.v;
			var it = _g.it;
			var loop = _g.loop;
			var affect = [];
			this.check(loop,writeTo,affect);
			this.check(it,affect,isAffected);
			var _g = 0;
			while(_g < affect.length) {
				var v = affect[_g];
				++_g;
				if(isAffected.indexOf(v) < 0) {
					isAffected.push(v);
				}
			}
			break;
		default:
			var _g = $bind(this,this.check);
			var writeTo17 = writeTo;
			var isAffected17 = isAffected;
			hxsl_Tools.iter(e,function(e) {
				_g(e,writeTo17,isAffected17);
			});
		}
	}
	,checkBranches: function(e) {
		var _g = e.e;
		if(_g._hx_index == 10) {
			var _g1 = _g.eif;
			var _g1 = _g.eelse;
			var cond = _g.econd;
			var writeTo = [null];
			this.check(cond,writeTo,[]);
		}
		hxsl_Tools.iter(e,$bind(this,this.checkBranches));
	}
	,mapExpr: function(e,isVar) {
		var _gthis = this;
		var _g = e.e;
		switch(_g._hx_index) {
		case 4:
			var el = _g.el;
			var out = [];
			var count = 0;
			var _g1 = 0;
			while(_g1 < el.length) {
				var e1 = el[_g1];
				++_g1;
				var isVar1 = isVar && count == el.length - 1;
				var e2 = this.mapExpr(e1,isVar1);
				if(hxsl_Tools.hasSideEffect(e2) || isVar1) {
					out.push(e2);
				}
				++count;
			}
			return { e : hxsl_TExprDef.TBlock(out), p : e.p, t : e.t};
		case 5:
			var _g1 = _g.op;
			var _g2 = _g.e1;
			var _g3 = _g.e2;
			switch(_g1._hx_index) {
			case 4:
				var _g3 = _g2.e;
				var _g4 = _g2.p;
				var _g4 = _g2.t;
				switch(_g3._hx_index) {
				case 1:
					var v = _g3.v;
					if(!this.get(v).used) {
						return { e : hxsl_TExprDef.TConst(hxsl_Const.CNull), t : e.t, p : e.p};
					} else {
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				case 9:
					var _g4 = _g3.e;
					var _g5 = _g3.regs;
					var _g3 = _g4.e;
					var _g5 = _g4.p;
					var _g5 = _g4.t;
					if(_g3._hx_index == 1) {
						var v = _g3.v;
						if(!this.get(v).used) {
							return { e : hxsl_TExprDef.TConst(hxsl_Const.CNull), t : e.t, p : e.p};
						} else {
							return hxsl_Tools.map(e,function(e) {
								return _gthis.mapExpr(e,true);
							});
						}
					} else {
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				default:
					return hxsl_Tools.map(e,function(e) {
						return _gthis.mapExpr(e,true);
					});
				}
				break;
			case 20:
				var _g3 = _g1.op;
				var _g1 = _g2.e;
				var _g3 = _g2.p;
				var _g3 = _g2.t;
				switch(_g1._hx_index) {
				case 1:
					var v = _g1.v;
					if(!this.get(v).used) {
						return { e : hxsl_TExprDef.TConst(hxsl_Const.CNull), t : e.t, p : e.p};
					} else {
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				case 9:
					var _g2 = _g1.e;
					var _g3 = _g1.regs;
					var _g1 = _g2.e;
					var _g3 = _g2.p;
					var _g3 = _g2.t;
					if(_g1._hx_index == 1) {
						var v = _g1.v;
						if(!this.get(v).used) {
							return { e : hxsl_TExprDef.TConst(hxsl_Const.CNull), t : e.t, p : e.p};
						} else {
							return hxsl_Tools.map(e,function(e) {
								return _gthis.mapExpr(e,true);
							});
						}
					} else {
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				default:
					return hxsl_Tools.map(e,function(e) {
						return _gthis.mapExpr(e,true);
					});
				}
				break;
			default:
				return hxsl_Tools.map(e,function(e) {
					return _gthis.mapExpr(e,true);
				});
			}
			break;
		case 7:
			var _g1 = _g.init;
			var v = _g.v;
			if(!this.get(v).used) {
				return { e : hxsl_TExprDef.TConst(hxsl_Const.CNull), t : e.t, p : e.p};
			} else {
				return hxsl_Tools.map(e,function(e) {
					return _gthis.mapExpr(e,true);
				});
			}
			break;
		case 8:
			var _g1 = _g.e;
			var _g2 = _g.args;
			var _g3 = _g1.e;
			var _g4 = _g1.p;
			var _g4 = _g1.t;
			if(_g3._hx_index == 2) {
				switch(_g3.g._hx_index) {
				case 63:
					if(_g2.length == 3) {
						var _g1 = _g2[0];
						var _g1 = _g2[2];
						var _g3 = _g1.e;
						var _g4 = _g1.p;
						var _g4 = _g1.t;
						if(_g3._hx_index == 0) {
							var _g1 = _g3.c;
							if(_g1._hx_index == 2) {
								var cid = _g1.v;
								var uv = _g2[1];
								var c = this.channelVars[cid];
								return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Texture), p : e.p, t : hxsl_Type.TVoid},[{ e : hxsl_TExprDef.TVar(c), t : c.type, p : e.p},this.mapExpr(uv,true)]), t : hxsl_Type.TVoid, p : e.p};
							} else {
								return hxsl_Tools.map(e,function(e) {
									return _gthis.mapExpr(e,true);
								});
							}
						} else {
							return hxsl_Tools.map(e,function(e) {
								return _gthis.mapExpr(e,true);
							});
						}
					} else {
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				case 64:
					if(_g2.length == 4) {
						var _g1 = _g2[0];
						var _g1 = _g2[3];
						var _g3 = _g1.e;
						var _g4 = _g1.p;
						var _g4 = _g1.t;
						if(_g3._hx_index == 0) {
							var _g1 = _g3.c;
							if(_g1._hx_index == 2) {
								var cid = _g1.v;
								var lod = _g2[2];
								var uv = _g2[1];
								var c = this.channelVars[cid];
								return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.TextureLod), p : e.p, t : hxsl_Type.TVoid},[{ e : hxsl_TExprDef.TVar(c), t : c.type, p : e.p},this.mapExpr(uv,true),this.mapExpr(lod,true)]), t : hxsl_Type.TVoid, p : e.p};
							} else {
								return hxsl_Tools.map(e,function(e) {
									return _gthis.mapExpr(e,true);
								});
							}
						} else {
							return hxsl_Tools.map(e,function(e) {
								return _gthis.mapExpr(e,true);
							});
						}
					} else {
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				case 65:
					switch(_g2.length) {
					case 3:
						var _g1 = _g2[0];
						var _g1 = _g2[2];
						var _g3 = _g1.e;
						var _g4 = _g1.p;
						var _g4 = _g1.t;
						if(_g3._hx_index == 0) {
							var _g1 = _g3.c;
							if(_g1._hx_index == 2) {
								var cid = _g1.v;
								var pos = _g2[1];
								var c = this.channelVars[cid];
								return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Texel), p : e.p, t : hxsl_Type.TVoid},[{ e : hxsl_TExprDef.TVar(c), t : c.type, p : e.p},this.mapExpr(pos,true)]), t : hxsl_Type.TVoid, p : e.p};
							} else {
								return hxsl_Tools.map(e,function(e) {
									return _gthis.mapExpr(e,true);
								});
							}
						} else {
							return hxsl_Tools.map(e,function(e) {
								return _gthis.mapExpr(e,true);
							});
						}
						break;
					case 4:
						var _g1 = _g2[0];
						var _g1 = _g2[3];
						var _g3 = _g1.e;
						var _g4 = _g1.p;
						var _g4 = _g1.t;
						if(_g3._hx_index == 0) {
							var _g1 = _g3.c;
							if(_g1._hx_index == 2) {
								var cid = _g1.v;
								var lod = _g2[2];
								var pos = _g2[1];
								var c = this.channelVars[cid];
								return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Texel), p : e.p, t : hxsl_Type.TVoid},[{ e : hxsl_TExprDef.TVar(c), t : c.type, p : e.p},this.mapExpr(pos,true),this.mapExpr(lod,true)]), t : hxsl_Type.TVoid, p : e.p};
							} else {
								return hxsl_Tools.map(e,function(e) {
									return _gthis.mapExpr(e,true);
								});
							}
						} else {
							return hxsl_Tools.map(e,function(e) {
								return _gthis.mapExpr(e,true);
							});
						}
						break;
					default:
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				case 66:
					switch(_g2.length) {
					case 2:
						var _g1 = _g2[0];
						var _g1 = _g2[1];
						var _g3 = _g1.e;
						var _g4 = _g1.p;
						var _g4 = _g1.t;
						if(_g3._hx_index == 0) {
							var _g1 = _g3.c;
							if(_g1._hx_index == 2) {
								var cid = _g1.v;
								var c = this.channelVars[cid];
								return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.TextureSize), p : e.p, t : hxsl_Type.TVoid},[{ e : hxsl_TExprDef.TVar(c), t : c.type, p : e.p}]), t : hxsl_Type.TVoid, p : e.p};
							} else {
								return hxsl_Tools.map(e,function(e) {
									return _gthis.mapExpr(e,true);
								});
							}
						} else {
							return hxsl_Tools.map(e,function(e) {
								return _gthis.mapExpr(e,true);
							});
						}
						break;
					case 3:
						var _g1 = _g2[0];
						var _g1 = _g2[2];
						var _g3 = _g1.e;
						var _g4 = _g1.p;
						var _g4 = _g1.t;
						if(_g3._hx_index == 0) {
							var _g1 = _g3.c;
							if(_g1._hx_index == 2) {
								var cid = _g1.v;
								var lod = _g2[1];
								var c = this.channelVars[cid];
								return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.TextureSize), p : e.p, t : hxsl_Type.TVoid},[{ e : hxsl_TExprDef.TVar(c), t : c.type, p : e.p},this.mapExpr(lod,true)]), t : hxsl_Type.TVoid, p : e.p};
							} else {
								return hxsl_Tools.map(e,function(e) {
									return _gthis.mapExpr(e,true);
								});
							}
						} else {
							return hxsl_Tools.map(e,function(e) {
								return _gthis.mapExpr(e,true);
							});
						}
						break;
					default:
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				default:
					return hxsl_Tools.map(e,function(e) {
						return _gthis.mapExpr(e,true);
					});
				}
			} else {
				return hxsl_Tools.map(e,function(e) {
					return _gthis.mapExpr(e,true);
				});
			}
			break;
		case 10:
			var e1 = _g.econd;
			var econd = _g.eif;
			var eelse = _g.eelse;
			var e2 = this.mapExpr(e1,true);
			var econd1 = this.mapExpr(econd,isVar);
			var eelse1 = eelse == null ? null : this.mapExpr(eelse,isVar);
			if(!isVar && !hxsl_Tools.hasSideEffect(econd1) && (eelse1 == null || !hxsl_Tools.hasSideEffect(eelse1))) {
				return { e : hxsl_TExprDef.TConst(hxsl_Const.CNull), t : e2.t, p : e2.p};
			}
			return { e : hxsl_TExprDef.TIf(e2,econd1,eelse1), p : e2.p, t : e2.t};
		case 13:
			var v = _g.v;
			var it = _g.it;
			var loop = _g.loop;
			var it1 = this.mapExpr(it,true);
			var loop1 = this.mapExpr(loop,false);
			if(!hxsl_Tools.hasSideEffect(loop1)) {
				return { e : hxsl_TExprDef.TConst(hxsl_Const.CNull), t : e.t, p : e.p};
			}
			return { e : hxsl_TExprDef.TFor(v,it1,loop1), p : e.p, t : e.t};
		default:
			return hxsl_Tools.map(e,function(e) {
				return _gthis.mapExpr(e,true);
			});
		}
	}
	,__class__: hxsl_Dce
};
var hxsl_Eval = function() {
	this.varMap = new haxe_ds_ObjectMap();
	this.funMap = new haxe_ds_ObjectMap();
	this.constants = new haxe_ds_IntMap();
};
$hxClasses["hxsl.Eval"] = hxsl_Eval;
hxsl_Eval.__name__ = "hxsl.Eval";
hxsl_Eval.prototype = {
	setConstant: function(v,c) {
		this.constants.h[v.id] = hxsl_TExprDef.TConst(c);
	}
	,mapVar: function(v) {
		var v2 = this.varMap.h[v.__id__];
		if(v2 != null) {
			if(v == v2) {
				return v2;
			} else {
				return this.mapVar(v2);
			}
		}
		if(v.parent != null) {
			this.mapVar(v.parent);
			v2 = this.varMap.h[v.__id__];
			if(v2 != null) {
				if(v == v2) {
					return v2;
				} else {
					return this.mapVar(v2);
				}
			}
		}
		var _g = v.type;
		var v21;
		if(_g._hx_index == 17) {
			var _g1 = _g.size;
			v21 = true;
		} else {
			v21 = false;
		}
		v2 = { id : v21 ? v.id : hxsl_Tools.allocVarId(), name : v.name, type : v.type, kind : v.kind};
		if(v.parent != null) {
			v2.parent = this.mapVar(v.parent);
		}
		if(v.qualifiers != null) {
			v2.qualifiers = v.qualifiers.slice();
		}
		this.varMap.set(v,v2);
		this.varMap.set(v2,v2);
		var _g = v2.type;
		switch(_g._hx_index) {
		case 13:
			var vl = _g.vl;
			var _g1 = [];
			var _g2 = 0;
			while(_g2 < vl.length) {
				var v = vl[_g2];
				++_g2;
				_g1.push(this.mapVar(v));
			}
			v2.type = hxsl_Type.TStruct(_g1);
			break;
		case 15:
			var _g1 = _g.size;
			if(_g1._hx_index == 1) {
				var vs = _g1.v;
				var t = _g.t;
				var c = this.constants.h[vs.id];
				if(c != null) {
					if(c == null) {
						hxsl_Error.t("Integer value expected for array size constant " + vs.name,null);
					} else if(c._hx_index == 0) {
						var _g1 = c.c;
						if(_g1._hx_index == 2) {
							var v = _g1.v;
							var _g1 = v2.type;
							var tmp;
							if(_g1._hx_index == 15) {
								var _g2 = _g1.t;
								var _g2 = _g1.size;
								tmp = true;
							} else {
								tmp = false;
							}
							v2.type = tmp ? hxsl_Type.TArray(t,hxsl_SizeDecl.SConst(v)) : hxsl_Type.TBuffer(t,hxsl_SizeDecl.SConst(v));
						} else {
							hxsl_Error.t("Integer value expected for array size constant " + vs.name,null);
						}
					} else {
						hxsl_Error.t("Integer value expected for array size constant " + vs.name,null);
					}
				} else {
					var vs2 = this.mapVar(vs);
					var _g1 = v2.type;
					var tmp;
					if(_g1._hx_index == 15) {
						var _g2 = _g1.t;
						var _g2 = _g1.size;
						tmp = true;
					} else {
						tmp = false;
					}
					v2.type = tmp ? hxsl_Type.TArray(t,hxsl_SizeDecl.SVar(vs2)) : hxsl_Type.TBuffer(t,hxsl_SizeDecl.SVar(vs2));
				}
			}
			break;
		case 16:
			var _g1 = _g.size;
			if(_g1._hx_index == 1) {
				var vs = _g1.v;
				var t = _g.t;
				var c = this.constants.h[vs.id];
				if(c != null) {
					if(c == null) {
						hxsl_Error.t("Integer value expected for array size constant " + vs.name,null);
					} else if(c._hx_index == 0) {
						var _g = c.c;
						if(_g._hx_index == 2) {
							var v = _g.v;
							var _g = v2.type;
							var tmp;
							if(_g._hx_index == 15) {
								var _g1 = _g.t;
								var _g1 = _g.size;
								tmp = true;
							} else {
								tmp = false;
							}
							v2.type = tmp ? hxsl_Type.TArray(t,hxsl_SizeDecl.SConst(v)) : hxsl_Type.TBuffer(t,hxsl_SizeDecl.SConst(v));
						} else {
							hxsl_Error.t("Integer value expected for array size constant " + vs.name,null);
						}
					} else {
						hxsl_Error.t("Integer value expected for array size constant " + vs.name,null);
					}
				} else {
					var vs2 = this.mapVar(vs);
					var _g = v2.type;
					var tmp;
					if(_g._hx_index == 15) {
						var _g1 = _g.t;
						var _g1 = _g.size;
						tmp = true;
					} else {
						tmp = false;
					}
					v2.type = tmp ? hxsl_Type.TArray(t,hxsl_SizeDecl.SVar(vs2)) : hxsl_Type.TBuffer(t,hxsl_SizeDecl.SVar(vs2));
				}
			}
			break;
		default:
		}
		return v2;
	}
	,checkSamplerRec: function(t) {
		if(hxsl_Tools.isSampler(t)) {
			return true;
		}
		switch(t._hx_index) {
		case 13:
			var vl = t.vl;
			var _g = 0;
			while(_g < vl.length) {
				var v = vl[_g];
				++_g;
				if(this.checkSamplerRec(v.type)) {
					return true;
				}
			}
			return false;
		case 15:
			var _g = t.size;
			var t1 = t.t;
			return this.checkSamplerRec(t1);
		case 16:
			var _g = t.t;
			var size = t.size;
			return true;
		default:
		}
		return false;
	}
	,needsInline: function(f) {
		var _g = 0;
		var _g1 = f.args;
		while(_g < _g1.length) {
			var a = _g1[_g];
			++_g;
			if(this.checkSamplerRec(a.type)) {
				return true;
			}
		}
		return false;
	}
	,'eval': function(s) {
		var funs = [];
		var _g = 0;
		var _g1 = s.funs;
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			var f1 = f.kind;
			var f2 = this.mapVar(f.ref);
			var _g2 = [];
			var _g3 = 0;
			var _g4 = f.args;
			while(_g3 < _g4.length) {
				var a = _g4[_g3];
				++_g3;
				_g2.push(this.mapVar(a));
			}
			var f21 = { kind : f1, ref : f2, args : _g2, ret : f.ret, expr : f.expr};
			if(f.kind == hxsl_FunctionKind.Helper && this.inlineCalls || this.needsInline(f21)) {
				this.funMap.set(f21.ref,f);
			} else {
				funs.push(f21);
			}
		}
		var _g = 0;
		var _g1 = funs.length;
		while(_g < _g1) {
			var i = _g++;
			this.curFun = funs[i];
			this.curFun.expr = this.evalExpr(this.curFun.expr,false);
		}
		var s1 = s.name;
		var _g = [];
		var _g1 = 0;
		var _g2 = s.vars;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			_g.push(this.mapVar(v));
		}
		return { name : s1, vars : _g, funs : funs};
	}
	,hasReturn: function(e) {
		this.markReturn = false;
		this.hasReturnLoop(e);
		return this.markReturn;
	}
	,hasReturnLoop: function(e) {
		var _g = e.e;
		if(_g._hx_index == 12) {
			var _g1 = _g.e;
			this.markReturn = true;
		} else if(!this.markReturn) {
			hxsl_Tools.iter(e,$bind(this,this.hasReturnLoop));
		}
	}
	,handleReturn: function(e,isFinal) {
		if(isFinal == null) {
			isFinal = false;
		}
		var _g = e.e;
		switch(_g._hx_index) {
		case 3:
			var v = _g.e;
			var v1 = this.handleReturn(v,isFinal);
			return { e : hxsl_TExprDef.TParenthesis(v1), t : v1.t, p : e.p};
		case 4:
			var el = _g.el;
			var i = 0;
			var last = el.length;
			var out = [];
			_hx_loop1: while(i < last) {
				var e1 = el[i++];
				if(i == last) {
					out.push(this.handleReturn(e1,isFinal));
				} else {
					var _g1 = e1.e;
					switch(_g1._hx_index) {
					case 10:
						if(_g1.eelse == null) {
							var eif = _g1.eif;
							var econd = _g1.econd;
							if(isFinal && this.hasReturn(eif)) {
								out.push(this.handleReturn({ e : hxsl_TExprDef.TIf(econd,eif,{ e : hxsl_TExprDef.TBlock(el.slice(i)), t : e1.t, p : e1.p}), t : e1.t, p : e1.p}));
								break _hx_loop1;
							} else {
								out.push(this.handleReturn(e1));
							}
						} else {
							out.push(this.handleReturn(e1));
						}
						break;
					case 12:
						var e2 = _g1.e;
						out.push(this.handleReturn(e2,isFinal));
						break _hx_loop1;
					default:
						out.push(this.handleReturn(e1));
					}
				}
			}
			var t = isFinal ? out.length == 0 ? hxsl_Type.TVoid : out[out.length - 1].t : e.t;
			return { e : hxsl_TExprDef.TBlock(out), t : t, p : e.p};
		case 10:
			var cond = _g.econd;
			var eif = _g.eif;
			var eelse = _g.eelse;
			if(eelse != null && isFinal) {
				var cond1 = this.handleReturn(cond);
				var eif1 = this.handleReturn(eif,isFinal);
				return { e : hxsl_TExprDef.TIf(cond1,eif1,this.handleReturn(eelse,isFinal)), t : eif1.t, p : e.p};
			} else {
				return hxsl_Tools.map(e,$bind(this,this.handleReturnDef));
			}
			break;
		case 12:
			var v = _g.e;
			if(!isFinal) {
				hxsl_Error.t("Cannot inline not final return",e.p);
			}
			if(v == null) {
				return { e : hxsl_TExprDef.TBlock([]), t : hxsl_Type.TVoid, p : e.p};
			}
			return this.handleReturn(v,true);
		default:
			return hxsl_Tools.map(e,$bind(this,this.handleReturnDef));
		}
	}
	,handleReturnDef: function(e) {
		return this.handleReturn(e);
	}
	,evalCall: function(g,args,oldArgs,pos) {
		switch(g._hx_index) {
		case 38:
			if(args.length == 1) {
				var _g = args[0];
				var _g1 = _g.e;
				var _g2 = _g.p;
				var _g2 = _g.t;
				if(_g1._hx_index == 0) {
					var _g = _g1.c;
					if(_g._hx_index == 2) {
						var i = _g.v;
						return hxsl_TExprDef.TConst(hxsl_Const.CFloat(i));
					} else {
						return null;
					}
				} else {
					return null;
				}
			} else {
				return null;
			}
			break;
		case 63:case 64:
			var i;
			var _g = args[0].e;
			if(_g._hx_index == 0) {
				var _g1 = _g.c;
				if(_g1._hx_index == 2) {
					var i1 = _g1.v;
					i = i1;
				} else {
					hxsl_Error.t("Cannot eval complex channel " + hxsl_Printer.toString(args[0],true) + " " + this.constantsToString(),pos);
					throw haxe_Exception.thrown("assert");
				}
			} else {
				hxsl_Error.t("Cannot eval complex channel " + hxsl_Printer.toString(args[0],true) + " " + this.constantsToString(),pos);
				throw haxe_Exception.thrown("assert");
			}
			var channel = oldArgs[0];
			var _g = channel.e;
			var channel1;
			if(_g._hx_index == 1) {
				var v = _g.v;
				channel1 = hxsl_TExprDef.TVar(this.mapVar(v));
			} else {
				throw haxe_Exception.thrown("assert");
			}
			channel = { e : channel1, t : channel.t, p : channel.p};
			var count;
			var _g = channel.t;
			if(_g._hx_index == 17) {
				var i1 = _g.size;
				count = i1;
			} else {
				throw haxe_Exception.thrown("assert");
			}
			var channelMode = Type.createEnumIndex(hxsl_Channel,i & 7,null);
			var targs = [channel];
			var _g = 1;
			var _g1 = args.length;
			while(_g < _g1) {
				var i1 = _g++;
				targs.push(args[i1]);
			}
			targs.push({ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(i >> 3)), t : hxsl_Type.TInt, p : pos});
			var tget = { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(g), t : hxsl_Type.TVoid, p : pos},targs), t : hxsl_Type.TVoid, p : pos};
			switch(channelMode._hx_index) {
			case 0:
				var zero = { e : hxsl_TExprDef.TConst(hxsl_Const.CFloat(0.)), t : hxsl_Type.TFloat, p : pos};
				if(count == 1) {
					return zero.e;
				}
				return hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal([hxsl_TGlobal.Vec2,hxsl_TGlobal.Vec3,hxsl_TGlobal.Vec4][count - 2]), t : hxsl_Type.TVoid, p : pos},[zero]);
			case 1:case 2:case 3:case 4:
				var tmp;
				switch(count) {
				case 1:
					switch(channelMode._hx_index) {
					case 1:
						tmp = [hxsl_Component.X];
						break;
					case 2:
						tmp = [hxsl_Component.Y];
						break;
					case 3:
						tmp = [hxsl_Component.Z];
						break;
					case 4:
						tmp = [hxsl_Component.W];
						break;
					default:
						throw haxe_Exception.thrown("Invalid channel value " + Std.string(channelMode) + " for " + count + " channels");
					}
					break;
				case 2:
					switch(channelMode._hx_index) {
					case 1:
						tmp = [hxsl_Component.X,hxsl_Component.Y];
						break;
					case 2:
						tmp = [hxsl_Component.Y,hxsl_Component.Z];
						break;
					case 3:
						tmp = [hxsl_Component.Z,hxsl_Component.W];
						break;
					default:
						throw haxe_Exception.thrown("Invalid channel value " + Std.string(channelMode) + " for " + count + " channels");
					}
					break;
				case 3:
					switch(channelMode._hx_index) {
					case 1:
						tmp = [hxsl_Component.X,hxsl_Component.Y,hxsl_Component.Z];
						break;
					case 2:
						tmp = [hxsl_Component.Y,hxsl_Component.Z,hxsl_Component.W];
						break;
					default:
						throw haxe_Exception.thrown("Invalid channel value " + Std.string(channelMode) + " for " + count + " channels");
					}
					break;
				default:
					throw haxe_Exception.thrown("Invalid channel value " + Std.string(channelMode) + " for " + count + " channels");
				}
				return hxsl_TExprDef.TSwiz(tget,tmp);
			case 5:
				return hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Unpack), t : hxsl_Type.TVoid, p : pos},[tget]);
			case 6:
				return hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.UnpackNormal), t : hxsl_Type.TVoid, p : pos},[tget]);
			}
			break;
		case 67:
			var args1 = args;
			var _g = 0;
			while(_g < args1.length) {
				var a = args1[_g];
				++_g;
				haxe_Log.trace(hxsl_Printer.toString(a),{ fileName : a.p.file, lineNumber : 0, className : null, methodName : null});
			}
			return hxsl_TExprDef.TBlock([]);
		default:
			return null;
		}
	}
	,constantsToString: function() {
		var _g = [];
		var c = this.constants.keys();
		while(c.hasNext()) {
			var c1 = c.next();
			_g.push(c1 + " => " + hxsl_Printer.toString({ e : this.constants.h[c1], t : hxsl_Type.TVoid, p : null},true));
		}
		return _g.toString();
	}
	,ifBlock: function(e) {
		var tmp;
		if(e != null) {
			var _g = e.e;
			var tmp1;
			if(_g._hx_index == 10) {
				var _g1 = _g.econd;
				var _g1 = _g.eif;
				var _g1 = _g.eelse;
				tmp1 = true;
			} else {
				tmp1 = false;
			}
			tmp = !tmp1;
		} else {
			tmp = true;
		}
		if(tmp) {
			return e;
		}
		return { e : hxsl_TExprDef.TBlock([e]), t : e.t, p : e.p};
	}
	,evalExpr: function(e,isVal) {
		if(isVal == null) {
			isVal = true;
		}
		var _gthis = this;
		var d;
		var _g = e.e;
		switch(_g._hx_index) {
		case 0:
			var _g1 = _g.c;
			d = e.e;
			break;
		case 1:
			var v = _g.v;
			var c = this.constants.h[v.id];
			if(c != null) {
				d = c;
			} else {
				var v2 = this.mapVar(v);
				d = hxsl_TExprDef.TVar(v2);
			}
			break;
		case 2:
			var _g1 = _g.g;
			d = e.e;
			break;
		case 3:
			var e1 = _g.e;
			var e2 = this.evalExpr(e1,isVal);
			var _g1 = e2.e;
			if(_g1._hx_index == 0) {
				var _g2 = _g1.c;
				d = e2.e;
			} else {
				d = hxsl_TExprDef.TParenthesis(e2);
			}
			break;
		case 4:
			var el = _g.el;
			var out = [];
			var last = el.length - 1;
			var _g1 = 0;
			var _g2 = el.length;
			while(_g1 < _g2) {
				var i = _g1++;
				var isVal1 = isVal && i == last;
				var e1 = this.evalExpr(el[i],isVal1);
				var _g3 = e1.e;
				switch(_g3._hx_index) {
				case 0:
					var _g4 = _g3.c;
					if(isVal1) {
						out.push(e1);
					}
					break;
				case 1:
					var _g5 = _g3.v;
					if(isVal1) {
						out.push(e1);
					}
					break;
				default:
					out.push(e1);
				}
			}
			d = out.length == 1 && this.curFun.kind != hxsl_FunctionKind.Init ? out[0].e : hxsl_TExprDef.TBlock(out);
			break;
		case 5:
			var op = _g.op;
			var e1 = _g.e1;
			var e2 = _g.e2;
			var e11 = this.evalExpr(e1);
			var e21 = this.evalExpr(e2);
			switch(op._hx_index) {
			case 0:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					switch(_g3._hx_index) {
					case 2:
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 2) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CInt(a + b | 0));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 3:
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 3) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CFloat(a + b));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					default:
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 1:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					switch(_g3._hx_index) {
					case 2:
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 2) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CInt(a * b | 0));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 3:
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 3) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CFloat(a * b));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					default:
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 2:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					switch(_g3._hx_index) {
					case 2:
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 2) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CInt(a / b | 0));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 3:
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 3) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CFloat(a / b));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					default:
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 3:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					switch(_g3._hx_index) {
					case 2:
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 2) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CInt(a - b | 0));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 3:
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 3) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CFloat(a - b));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					default:
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 4:case 21:
				d = hxsl_TExprDef.TBinop(op,e11,e21);
				break;
			case 5:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					switch(_g3._hx_index) {
					case 0:
						d = _g2._hx_index == 0 ? _g2.c._hx_index == 0 ? hxsl_TExprDef.TConst(hxsl_Const.CBool(true)) : hxsl_TExprDef.TConst(hxsl_Const.CBool(false)) : hxsl_TExprDef.TBinop(op,e11,e21);
						break;
					case 1:
						var _g1 = _g3.b;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 1:
								var b = _g4.b;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a == b ? 0 : 1) == 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 2:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 2:
								var b = _g4.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(a - b == 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 3:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 3:
								var b = _g4.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a > b ? 1 : a == b ? 0 : -1) == 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 4:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g3 = _g2.c;
							switch(_g3._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 4:
								var b = _g3.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a > b ? 1 : a == b ? 0 : -1) == 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 6:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					switch(_g3._hx_index) {
					case 0:
						d = _g2._hx_index == 0 ? _g2.c._hx_index == 0 ? hxsl_TExprDef.TConst(hxsl_Const.CBool(false)) : hxsl_TExprDef.TConst(hxsl_Const.CBool(true)) : hxsl_TExprDef.TBinop(op,e11,e21);
						break;
					case 1:
						var _g1 = _g3.b;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 1:
								var b = _g4.b;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a == b ? 0 : 1) != 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 2:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 2:
								var b = _g4.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(a - b != 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 3:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 3:
								var b = _g4.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a > b ? 1 : a == b ? 0 : -1) != 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 4:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g3 = _g2.c;
							switch(_g3._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 4:
								var b = _g3.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a > b ? 1 : a == b ? 0 : -1) != 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 7:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					switch(_g3._hx_index) {
					case 0:
						d = _g2._hx_index == 0 ? _g2.c._hx_index == 0 ? hxsl_TExprDef.TConst(hxsl_Const.CBool(false)) : hxsl_TExprDef.TConst(hxsl_Const.CBool(false)) : hxsl_TExprDef.TBinop(op,e11,e21);
						break;
					case 1:
						var _g1 = _g3.b;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 1:
								var b = _g4.b;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a == b ? 0 : 1) > 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 2:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 2:
								var b = _g4.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(a - b > 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 3:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 3:
								var b = _g4.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a > b ? 1 : a == b ? 0 : -1) > 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 4:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g3 = _g2.c;
							switch(_g3._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 4:
								var b = _g3.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a > b ? 1 : a == b ? 0 : -1) > 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 8:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					switch(_g3._hx_index) {
					case 0:
						d = _g2._hx_index == 0 ? _g2.c._hx_index == 0 ? hxsl_TExprDef.TConst(hxsl_Const.CBool(true)) : hxsl_TExprDef.TConst(hxsl_Const.CBool(false)) : hxsl_TExprDef.TBinop(op,e11,e21);
						break;
					case 1:
						var _g1 = _g3.b;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 1:
								var b = _g4.b;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a == b ? 0 : 1) >= 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 2:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 2:
								var b = _g4.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(a - b >= 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 3:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 3:
								var b = _g4.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a > b ? 1 : a == b ? 0 : -1) >= 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 4:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g3 = _g2.c;
							switch(_g3._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 4:
								var b = _g3.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a > b ? 1 : a == b ? 0 : -1) >= 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 9:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					switch(_g3._hx_index) {
					case 0:
						d = _g2._hx_index == 0 ? _g2.c._hx_index == 0 ? hxsl_TExprDef.TConst(hxsl_Const.CBool(false)) : hxsl_TExprDef.TConst(hxsl_Const.CBool(true)) : hxsl_TExprDef.TBinop(op,e11,e21);
						break;
					case 1:
						var _g1 = _g3.b;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 1:
								var b = _g4.b;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a == b ? 0 : 1) < 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 2:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 2:
								var b = _g4.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(a - b < 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 3:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 3:
								var b = _g4.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a > b ? 1 : a == b ? 0 : -1) < 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 4:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g3 = _g2.c;
							switch(_g3._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 4:
								var b = _g3.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a > b ? 1 : a == b ? 0 : -1) < 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 10:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					switch(_g3._hx_index) {
					case 0:
						d = _g2._hx_index == 0 ? _g2.c._hx_index == 0 ? hxsl_TExprDef.TConst(hxsl_Const.CBool(true)) : hxsl_TExprDef.TConst(hxsl_Const.CBool(true)) : hxsl_TExprDef.TBinop(op,e11,e21);
						break;
					case 1:
						var _g1 = _g3.b;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 1:
								var b = _g4.b;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a == b ? 0 : 1) <= 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 2:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 2:
								var b = _g4.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(a - b <= 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 3:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 3:
								var b = _g4.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a > b ? 1 : a == b ? 0 : -1) <= 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 4:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g3 = _g2.c;
							switch(_g3._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 4:
								var b = _g3.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a > b ? 1 : a == b ? 0 : -1) <= 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 11:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					if(_g3._hx_index == 2) {
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 2) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CInt(a & b));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
					} else {
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 12:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					if(_g3._hx_index == 2) {
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 2) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CInt(a | b));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
					} else {
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 13:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					if(_g3._hx_index == 2) {
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 2) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CInt(a ^ b));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
					} else {
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 14:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					if(_g3._hx_index == 1) {
						var _g1 = _g3.b;
						if(_g2._hx_index == 0) {
							var _g3 = _g2.c;
							if(_g3._hx_index == 1) {
								var b = _g3.b;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(a && b));
							} else {
								var a = _g1;
								d = a == false ? hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) : e21.e;
							}
						} else {
							var a = _g1;
							d = a == false ? hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) : e21.e;
						}
					} else if(_g2._hx_index == 0) {
						var _g1 = _g2.c;
						if(_g1._hx_index == 1) {
							var a = _g1.b;
							d = a == false ? hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) : e11.e;
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
					} else {
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else if(_g2._hx_index == 0) {
					var _g1 = _g2.c;
					if(_g1._hx_index == 1) {
						var a = _g1.b;
						d = a == false ? hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) : e11.e;
					} else {
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 15:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					if(_g3._hx_index == 1) {
						var _g1 = _g3.b;
						if(_g2._hx_index == 0) {
							var _g3 = _g2.c;
							if(_g3._hx_index == 1) {
								var b = _g3.b;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(a || b));
							} else {
								var a = _g1;
								d = a == true ? hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) : e21.e;
							}
						} else {
							var a = _g1;
							d = a == true ? hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) : e21.e;
						}
					} else if(_g2._hx_index == 0) {
						var _g1 = _g2.c;
						if(_g1._hx_index == 1) {
							var a = _g1.b;
							d = a == true ? hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) : e11.e;
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
					} else {
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else if(_g2._hx_index == 0) {
					var _g1 = _g2.c;
					if(_g1._hx_index == 1) {
						var a = _g1.b;
						d = a == true ? hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) : e11.e;
					} else {
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 16:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					if(_g3._hx_index == 2) {
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 2) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CInt(a << b));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
					} else {
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 17:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					if(_g3._hx_index == 2) {
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 2) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CInt(a >> b));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
					} else {
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 18:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					if(_g3._hx_index == 2) {
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 2) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CInt(a >>> b));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
					} else {
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 19:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					switch(_g3._hx_index) {
					case 2:
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 2) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CInt(a % b | 0));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 3:
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 3) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CFloat(a % b));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					default:
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 20:
				var _g1 = op.op;
				d = hxsl_TExprDef.TBinop(op,e11,e21);
				break;
			default:
				throw haxe_Exception.thrown("assert");
			}
			break;
		case 6:
			var op = _g.op;
			var e1 = _g.e1;
			var e2 = this.evalExpr(e1);
			var _g1 = e2.e;
			if(_g1._hx_index == 0) {
				var c = _g1.c;
				switch(op._hx_index) {
				case 2:
					if(c._hx_index == 1) {
						var b = c.b;
						d = hxsl_TExprDef.TConst(hxsl_Const.CBool(!b));
					} else {
						d = hxsl_TExprDef.TUnop(op,e2);
					}
					break;
				case 3:
					switch(c._hx_index) {
					case 2:
						var i = c.v;
						d = hxsl_TExprDef.TConst(hxsl_Const.CInt(-i));
						break;
					case 3:
						var f = c.v;
						d = hxsl_TExprDef.TConst(hxsl_Const.CFloat(-f));
						break;
					default:
						d = hxsl_TExprDef.TUnop(op,e2);
					}
					break;
				default:
					d = hxsl_TExprDef.TUnop(op,e2);
				}
			} else {
				d = hxsl_TExprDef.TUnop(op,e2);
			}
			break;
		case 7:
			var v = _g.v;
			var init = _g.init;
			d = hxsl_TExprDef.TVarDecl(this.mapVar(v),init == null ? null : this.evalExpr(init));
			break;
		case 8:
			var c = _g.e;
			var eargs = _g.args;
			var c1 = this.evalExpr(c);
			var _g1 = [];
			var _g2 = 0;
			while(_g2 < eargs.length) {
				var a = eargs[_g2];
				++_g2;
				_g1.push(this.evalExpr(a));
			}
			var args = _g1;
			var _g1 = c1.e;
			switch(_g1._hx_index) {
			case 1:
				var v = _g1.v;
				if(this.funMap.h.__keys__[v.__id__] != null) {
					var f = this.funMap.h[v.__id__];
					var outExprs = [];
					var undo = [];
					var _g2 = 0;
					var _g3 = f.args.length;
					while(_g2 < _g3) {
						var i = _g2++;
						var v = [f.args[i]];
						var e1 = args[i];
						var _g4 = e1.e;
						switch(_g4._hx_index) {
						case 0:
							var _g5 = _g4.c;
							var old = [this.constants.h[v[0].id]];
							undo.push((function(old,v) {
								return function() {
									if(old[0] == null) {
										_gthis.constants.remove(v[0].id);
									} else {
										_gthis.constants.h[v[0].id] = old[0];
									}
								};
							})(old,v));
							this.constants.h[v[0].id] = e1.e;
							break;
						case 1:
							var _g6 = _g4.v;
							var _g7 = _g6.id;
							var _g8 = _g6.name;
							var _g9 = _g6.parent;
							var _g10 = _g6.qualifiers;
							var _g11 = _g6.type;
							switch(_g6.kind._hx_index) {
							case 0:case 1:case 2:
								var old1 = [this.constants.h[v[0].id]];
								undo.push((function(old,v) {
									return function() {
										if(old[0] == null) {
											_gthis.constants.remove(v[0].id);
										} else {
											_gthis.constants.h[v[0].id] = old[0];
										}
									};
								})(old1,v));
								this.constants.h[v[0].id] = e1.e;
								break;
							default:
								var old2 = [this.varMap.h[v[0].__id__]];
								if(old2[0] == null) {
									undo.push((function(v) {
										return function() {
											_gthis.varMap.remove(v[0]);
										};
									})(v));
								} else {
									this.varMap.remove(v[0]);
									undo.push((function(old,v) {
										return function() {
											_gthis.varMap.set(v[0],old[0]);
										};
									})(old2,v));
								}
								var v2 = this.mapVar(v[0]);
								outExprs.push({ e : hxsl_TExprDef.TVarDecl(v2,e1), t : hxsl_Type.TVoid, p : e1.p});
							}
							break;
						default:
							var old3 = [this.varMap.h[v[0].__id__]];
							if(old3[0] == null) {
								undo.push((function(v) {
									return function() {
										_gthis.varMap.remove(v[0]);
									};
								})(v));
							} else {
								this.varMap.remove(v[0]);
								undo.push((function(old,v) {
									return function() {
										_gthis.varMap.set(v[0],old[0]);
									};
								})(old3,v));
							}
							var v21 = this.mapVar(v[0]);
							outExprs.push({ e : hxsl_TExprDef.TVarDecl(v21,e1), t : hxsl_Type.TVoid, p : e1.p});
						}
					}
					var e1 = this.handleReturn(this.evalExpr(f.expr,false),true);
					var _g2 = 0;
					while(_g2 < undo.length) {
						var u = undo[_g2];
						++_g2;
						u();
					}
					var _g2 = e1.e;
					if(_g2._hx_index == 4) {
						var el = _g2.el;
						var _g2 = 0;
						while(_g2 < el.length) {
							var e2 = el[_g2];
							++_g2;
							outExprs.push(e2);
						}
					} else {
						outExprs.push(e1);
					}
					d = hxsl_TExprDef.TBlock(outExprs);
				} else {
					d = hxsl_TExprDef.TCall(c1,args);
				}
				break;
			case 2:
				var g = _g1.g;
				var v1 = this.evalCall(g,args,eargs,e.p);
				d = v1 != null ? v1 : hxsl_TExprDef.TCall(c1,args);
				break;
			default:
				d = hxsl_Error.t("Cannot eval non-static call expresssion '" + new hxsl_Printer().exprString(c1) + "'",c1.p);
			}
			break;
		case 9:
			var e1 = _g.e;
			var r = _g.regs;
			d = hxsl_TExprDef.TSwiz(this.evalExpr(e1),r.slice());
			break;
		case 10:
			var econd = _g.econd;
			var eif = _g.eif;
			var eelse = _g.eelse;
			var econd1 = this.evalExpr(econd);
			var _g1 = econd1.e;
			if(_g1._hx_index == 0) {
				var _g2 = _g1.c;
				if(_g2._hx_index == 1) {
					var b = _g2.b;
					d = b ? this.evalExpr(eif,isVal).e : eelse == null ? hxsl_TExprDef.TConst(hxsl_Const.CNull) : this.evalExpr(eelse,isVal).e;
				} else if(isVal && eelse != null && this.eliminateConditionals) {
					d = hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mix), t : e.t, p : e.p},[this.evalExpr(eelse,true),this.evalExpr(eif,true),{ e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.ToFloat), t : hxsl_Type.TFun([]), p : econd1.p},[econd1]), t : hxsl_Type.TFloat, p : e.p}]);
				} else {
					eif = this.evalExpr(eif,isVal);
					if(eelse != null) {
						eelse = this.evalExpr(eelse,isVal);
						var _g1 = eelse.e;
						if(_g1._hx_index == 0 && _g1.c._hx_index == 0) {
							eelse = null;
						}
					}
					eif = this.ifBlock(eif);
					eelse = this.ifBlock(eelse);
					d = hxsl_TExprDef.TIf(econd1,eif,eelse);
				}
			} else if(isVal && eelse != null && this.eliminateConditionals) {
				d = hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mix), t : e.t, p : e.p},[this.evalExpr(eelse,true),this.evalExpr(eif,true),{ e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.ToFloat), t : hxsl_Type.TFun([]), p : econd1.p},[econd1]), t : hxsl_Type.TFloat, p : e.p}]);
			} else {
				eif = this.evalExpr(eif,isVal);
				if(eelse != null) {
					eelse = this.evalExpr(eelse,isVal);
					var _g1 = eelse.e;
					if(_g1._hx_index == 0 && _g1.c._hx_index == 0) {
						eelse = null;
					}
				}
				eif = this.ifBlock(eif);
				eelse = this.ifBlock(eelse);
				d = hxsl_TExprDef.TIf(econd1,eif,eelse);
			}
			break;
		case 11:
			d = hxsl_TExprDef.TDiscard;
			break;
		case 12:
			var e1 = _g.e;
			d = hxsl_TExprDef.TReturn(e1 == null ? null : this.evalExpr(e1));
			break;
		case 13:
			var v1 = _g.v;
			var it = _g.it;
			var loop = _g.loop;
			var v2 = this.mapVar(v1);
			var it1 = this.evalExpr(it);
			var e1;
			var _g1 = it1.e;
			if(_g1._hx_index == 5) {
				var _g2 = _g1.e1;
				var _g3 = _g1.e2;
				if(_g1.op._hx_index == 21) {
					var _g1 = _g2.e;
					var _g4 = _g2.p;
					var _g4 = _g2.t;
					if(_g1._hx_index == 0) {
						var _g2 = _g1.c;
						if(_g2._hx_index == 2) {
							var _g1 = _g3.e;
							var _g4 = _g3.p;
							var _g4 = _g3.t;
							if(_g1._hx_index == 0) {
								var _g3 = _g1.c;
								if(_g3._hx_index == 2) {
									var len = _g3.v;
									var start = _g2.v;
									if(this.unrollLoops) {
										var out = [];
										var _g1 = start;
										var _g2 = len;
										while(_g1 < _g2) {
											var i = _g1++;
											this.constants.h[v1.id] = hxsl_TExprDef.TConst(hxsl_Const.CInt(i));
											out.push(this.evalExpr(loop,false));
										}
										this.constants.remove(v1.id);
										e1 = hxsl_TExprDef.TBlock(out);
									} else {
										e1 = hxsl_TExprDef.TFor(v2,it1,this.ifBlock(this.evalExpr(loop,false)));
									}
								} else {
									e1 = hxsl_TExprDef.TFor(v2,it1,this.ifBlock(this.evalExpr(loop,false)));
								}
							} else {
								e1 = hxsl_TExprDef.TFor(v2,it1,this.ifBlock(this.evalExpr(loop,false)));
							}
						} else {
							e1 = hxsl_TExprDef.TFor(v2,it1,this.ifBlock(this.evalExpr(loop,false)));
						}
					} else {
						e1 = hxsl_TExprDef.TFor(v2,it1,this.ifBlock(this.evalExpr(loop,false)));
					}
				} else {
					e1 = hxsl_TExprDef.TFor(v2,it1,this.ifBlock(this.evalExpr(loop,false)));
				}
			} else {
				e1 = hxsl_TExprDef.TFor(v2,it1,this.ifBlock(this.evalExpr(loop,false)));
			}
			this.varMap.remove(v1);
			d = e1;
			break;
		case 14:
			d = hxsl_TExprDef.TContinue;
			break;
		case 15:
			d = hxsl_TExprDef.TBreak;
			break;
		case 16:
			var e1 = _g.e;
			var e2 = _g.index;
			var e11 = this.evalExpr(e1);
			var e21 = this.evalExpr(e2);
			var _g1 = e11.e;
			var _g2 = e21.e;
			if(_g1._hx_index == 17) {
				if(_g2._hx_index == 0) {
					var _g3 = _g2.c;
					if(_g3._hx_index == 2) {
						var i = _g3.v;
						var el = _g1.el;
						d = i >= 0 && i < el.length ? el[i].e : hxsl_TExprDef.TArray(e11,e21);
					} else {
						d = hxsl_TExprDef.TArray(e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TArray(e11,e21);
				}
			} else {
				d = hxsl_TExprDef.TArray(e11,e21);
			}
			break;
		case 17:
			var el = _g.el;
			var _g1 = [];
			var _g2 = 0;
			while(_g2 < el.length) {
				var e1 = el[_g2];
				++_g2;
				_g1.push(this.evalExpr(e1));
			}
			d = hxsl_TExprDef.TArrayDecl(_g1);
			break;
		case 18:
			var e1 = _g.e;
			var cases = _g.cases;
			var def = _g.def;
			var e2 = this.evalExpr(e1);
			var _g1 = [];
			var _g2 = 0;
			while(_g2 < cases.length) {
				var c = cases[_g2];
				++_g2;
				var _g3 = [];
				var _g4 = 0;
				var _g5 = c.values;
				while(_g4 < _g5.length) {
					var v1 = _g5[_g4];
					++_g4;
					_g3.push(this.evalExpr(v1));
				}
				_g1.push({ values : _g3, expr : this.evalExpr(c.expr,isVal)});
			}
			var cases = _g1;
			var def1 = def == null ? null : this.evalExpr(def,isVal);
			var hasCase = false;
			var _g1 = e2.e;
			if(_g1._hx_index == 0) {
				var c = _g1.c;
				if(c._hx_index == 2) {
					var val = c.v;
					var _g1 = 0;
					while(_g1 < cases.length) {
						var c1 = cases[_g1];
						++_g1;
						var _g2 = 0;
						var _g3 = c1.values;
						while(_g2 < _g3.length) {
							var v1 = _g3[_g2];
							++_g2;
							var _g4 = v1.e;
							if(_g4._hx_index == 0) {
								var cst = _g4.c;
								switch(cst._hx_index) {
								case 2:
									var k = cst.v;
									if(k == val) {
										return c1.expr;
									}
									break;
								case 3:
									var k1 = cst.v;
									if(k1 == val) {
										return c1.expr;
									}
									break;
								default:
								}
							} else {
								hasCase = true;
							}
						}
					}
				} else {
					throw haxe_Exception.thrown("Unsupported switch constant " + Std.string(c));
				}
			} else {
				hasCase = true;
			}
			d = hasCase ? hxsl_TExprDef.TSwitch(e2,cases,def1) : def1 == null ? hxsl_TExprDef.TBlock([]) : def1.e;
			break;
		case 19:
			var cond = _g.e;
			var loop = _g.loop;
			var normalWhile = _g.normalWhile;
			var cond1 = this.evalExpr(cond);
			var loop1 = this.evalExpr(loop,false);
			d = hxsl_TExprDef.TWhile(cond1,this.ifBlock(loop1),normalWhile);
			break;
		case 20:
			var name = _g.m;
			var args = _g.args;
			var e1 = _g.e;
			var e2;
			if(name == "unroll") {
				var old4 = this.unrollLoops;
				this.unrollLoops = true;
				e2 = this.evalExpr(e1,isVal);
				this.unrollLoops = false;
			} else {
				e2 = this.evalExpr(e1,isVal);
			}
			d = hxsl_TExprDef.TMeta(name,args,e2);
			break;
		}
		return { e : d, t : e.t, p : e.p};
	}
	,__class__: hxsl_Eval
};
var hxsl__$Flatten_Alloc = function(g,t,pos,size) {
	this.g = g;
	this.t = t;
	this.pos = pos;
	this.size = size;
};
$hxClasses["hxsl._Flatten.Alloc"] = hxsl__$Flatten_Alloc;
hxsl__$Flatten_Alloc.__name__ = "hxsl._Flatten.Alloc";
hxsl__$Flatten_Alloc.prototype = {
	__class__: hxsl__$Flatten_Alloc
};
var hxsl_ARead = $hxEnums["hxsl.ARead"] = { __ename__:true,__constructs__:null
	,AIndex: ($_=function(a) { return {_hx_index:0,a:a,__enum__:"hxsl.ARead",toString:$estr}; },$_._hx_name="AIndex",$_.__params__ = ["a"],$_)
	,AOffset: ($_=function(a,stride,delta) { return {_hx_index:1,a:a,stride:stride,delta:delta,__enum__:"hxsl.ARead",toString:$estr}; },$_._hx_name="AOffset",$_.__params__ = ["a","stride","delta"],$_)
};
hxsl_ARead.__constructs__ = [hxsl_ARead.AIndex,hxsl_ARead.AOffset];
hxsl_ARead.__empty_constructs__ = [];
var hxsl_Flatten = function() {
};
$hxClasses["hxsl.Flatten"] = hxsl_Flatten;
hxsl_Flatten.__name__ = "hxsl.Flatten";
hxsl_Flatten.prototype = {
	flatten: function(s,kind,constsToGlobal) {
		this.globals = [];
		this.params = [];
		this.outVars = [];
		if(constsToGlobal) {
			this.consts = [];
			var p = s.funs[0].expr.p;
			var gc = { id : hxsl_Tools.allocVarId(), name : "__consts__", kind : hxsl_VarKind.Global, type : null};
			this.econsts = { e : hxsl_TExprDef.TVar(gc), t : null, p : p};
			var s1 = s.name;
			var s2 = s.vars.slice();
			var _g = [];
			var _g1 = 0;
			var _g2 = s.funs;
			while(_g1 < _g2.length) {
				var f = _g2[_g1];
				++_g1;
				_g.push(this.mapFun(f,$bind(this,this.mapConsts)));
			}
			s = { name : s1, vars : s2, funs : _g};
			var _g = 0;
			var _g1 = s.vars;
			while(_g < _g1.length) {
				var v = _g1[_g];
				++_g;
				var _g2 = v.type;
				if(_g2._hx_index == 9) {
					var _g3 = _g2.size;
					this.allocConst(255,p);
				}
			}
			if(this.consts.length > 0) {
				gc.type = this.econsts.t = hxsl_Type.TArray(hxsl_Type.TFloat,hxsl_SizeDecl.SConst(this.consts.length));
				s.vars.push(gc);
			}
		}
		this.varMap = new haxe_ds_ObjectMap();
		this.allocData = new haxe_ds_ObjectMap();
		var _g = 0;
		var _g1 = s.vars;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			this.gatherVar(v);
		}
		var prefix;
		switch(kind._hx_index) {
		case 0:
			prefix = "vertex";
			break;
		case 1:
			prefix = "fragment";
			break;
		default:
			throw haxe_Exception.thrown("assert");
		}
		this.pack(prefix + "Globals",hxsl_VarKind.Global,this.globals,hxsl_VecType.VFloat);
		this.pack(prefix + "Params",hxsl_VarKind.Param,this.params,hxsl_VecType.VFloat);
		var allVars = this.globals.concat(this.params);
		var textures = this.packTextures(prefix + "Textures",allVars,hxsl_Type.TSampler2D).concat(this.packTextures(prefix + "TexturesCube",allVars,hxsl_Type.TSamplerCube)).concat(this.packTextures(prefix + "TexturesArray",allVars,hxsl_Type.TSampler2DArray));
		this.packBuffers(allVars);
		var _g = [];
		var _g1 = 0;
		var _g2 = s.funs;
		while(_g1 < _g2.length) {
			var f = _g2[_g1];
			++_g1;
			_g.push(this.mapFun(f,$bind(this,this.mapExpr)));
		}
		var funs = _g;
		return { name : s.name, vars : this.outVars, funs : funs};
	}
	,mapFun: function(f,mapExpr) {
		return { kind : f.kind, ret : f.ret, args : f.args, ref : f.ref, expr : mapExpr(f.expr)};
	}
	,mapExpr: function(e) {
		var _g = e.e;
		switch(_g._hx_index) {
		case 1:
			var v = _g.v;
			var a = this.varMap.h[v.__id__];
			if(a != null) {
				e = this.access(a,v.type,e.p,hxsl_ARead.AIndex(a));
			}
			break;
		case 16:
			var _g1 = _g.e;
			var _g2 = _g1.e;
			var _g3 = _g1.t;
			if(_g2._hx_index == 1) {
				var v = _g2.v;
				var vp = _g1.p;
				var eindex = _g.index;
				var _g = eindex.e;
				var e1;
				if(_g._hx_index == 0) {
					var _g1 = _g.c;
					if(_g1._hx_index == 2) {
						var _g = _g1.v;
						e1 = true;
					} else {
						e1 = false;
					}
				} else {
					e1 = false;
				}
				if(!e1) {
					var a = this.varMap.h[v.__id__];
					if(a != null) {
						var _g = v.type;
						if(_g._hx_index == 15) {
							var _g1 = _g.t;
							var _g2 = _g.size;
							var t = _g1;
							if(hxsl_Tools.isSampler(t)) {
								eindex = this.toInt(this.mapExpr(eindex));
								e = this.access(a,t,vp,hxsl_ARead.AOffset(a,1,eindex));
							} else {
								var t = _g1;
								var stride = this.varSize(t,a.t);
								if(stride == 0 || (stride & 3) != 0) {
									throw haxe_Exception.thrown(new hxsl_Error("Dynamic access to an Array which size is not 4 components-aligned is not allowed",e.p));
								}
								stride >>= 2;
								eindex = this.toInt(this.mapExpr(eindex));
								e = this.access(a,t,vp,hxsl_ARead.AOffset(a,stride,stride == 1 ? eindex : { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpMult,eindex,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(stride)), t : hxsl_Type.TInt, p : vp}), t : hxsl_Type.TInt, p : vp}));
							}
						} else {
							throw haxe_Exception.thrown("assert");
						}
					}
				} else {
					e = hxsl_Tools.map(e,$bind(this,this.mapExpr));
				}
			} else {
				e = hxsl_Tools.map(e,$bind(this,this.mapExpr));
			}
			break;
		default:
			e = hxsl_Tools.map(e,$bind(this,this.mapExpr));
		}
		return this.optimize(e);
	}
	,mapConsts: function(e) {
		var _g = e.e;
		switch(_g._hx_index) {
		case 0:
			var c = _g.c;
			switch(c._hx_index) {
			case 2:
				var v = c.v;
				return this.allocConst(v,e.p);
			case 3:
				var v = c.v;
				return this.allocConst(v,e.p);
			default:
				return e;
			}
			break;
		case 2:
			var g = _g.g;
			switch(g._hx_index) {
			case 0:
				this.allocConst(Math.PI / 180,e.p);
				break;
			case 1:
				this.allocConst(180 / Math.PI,e.p);
				break;
			case 9:
				this.allocConst(1.4426950408889634,e.p);
				break;
			case 10:
				this.allocConst(0.6931471805599453,e.p);
				break;
			case 24:
				this.allocConst(1,e.p);
				break;
			case 26:
				this.allocConst(2.0,e.p);
				this.allocConst(3.0,e.p);
				break;
			case 54:
				this.allocConsts([1,255,65025,16581375],e.p);
				this.allocConsts([0.00392156862745098,0.00392156862745098,0.00392156862745098,0],e.p);
				break;
			case 55:
				this.allocConsts([1,0.00392156862745098,1.5378700499807768e-005,6.0308629411010845e-008],e.p);
				break;
			case 56:
				this.allocConst(1,e.p);
				this.allocConst(0.5,e.p);
				break;
			case 57:
				this.allocConst(0.5,e.p);
				break;
			case 58:
				this.allocConsts([0.5,0.5],e.p);
				this.allocConsts([0.5,-0.5],e.p);
				break;
			case 59:
				this.allocConsts([2,-2],e.p);
				this.allocConsts([-1,1],e.p);
				break;
			default:
			}
			break;
		case 5:
			var _g1 = _g.e1;
			var _g1 = _g.e2;
			if(_g.op._hx_index == 1) {
				var _g2 = _g1.e;
				var _g2 = _g1.p;
				if(_g1.t._hx_index == 8) {
					this.allocConst(1,e.p);
				}
			}
			break;
		case 8:
			var _g1 = _g.e;
			var _g2 = _g.args;
			var _g3 = _g1.e;
			var _g4 = _g1.p;
			var _g4 = _g1.t;
			if(_g3._hx_index == 2) {
				if(_g3.g._hx_index == 42) {
					if(_g2.length == 2) {
						var _g1 = _g2[0];
						var _g3 = _g2[1];
						var _g2 = _g1.e;
						var _g4 = _g1.p;
						var _g4 = _g1.t;
						if(_g2._hx_index == 1) {
							var _g1 = _g2.v;
							var _g2 = _g1.id;
							var _g2 = _g1.name;
							var _g2 = _g1.parent;
							var _g2 = _g1.qualifiers;
							var _g2 = _g1.type;
							switch(_g1.kind._hx_index) {
							case 0:
								if(_g4._hx_index == 5) {
									if(_g4.size == 3) {
										if(_g4.t._hx_index == 1) {
											var _g1 = _g3.e;
											var _g2 = _g3.p;
											var _g2 = _g3.t;
											if(_g1._hx_index == 0) {
												var _g2 = _g1.c;
												if(_g2._hx_index == 2) {
													if(_g2.v == 1) {
														return e;
													}
												}
											}
										}
									}
								}
								break;
							case 1:
								if(_g4._hx_index == 5) {
									if(_g4.size == 3) {
										if(_g4.t._hx_index == 1) {
											var _g1 = _g3.e;
											var _g2 = _g3.p;
											var _g2 = _g3.t;
											if(_g1._hx_index == 0) {
												var _g2 = _g1.c;
												if(_g2._hx_index == 2) {
													if(_g2.v == 1) {
														return e;
													}
												}
											}
										}
									}
								}
								break;
							case 2:
								if(_g4._hx_index == 5) {
									if(_g4.size == 3) {
										if(_g4.t._hx_index == 1) {
											var _g1 = _g3.e;
											var _g2 = _g3.p;
											var _g2 = _g3.t;
											if(_g1._hx_index == 0) {
												var _g2 = _g1.c;
												if(_g2._hx_index == 2) {
													if(_g2.v == 1) {
														return e;
													}
												}
											}
										}
									}
								}
								break;
							case 3:
								if(_g4._hx_index == 5) {
									if(_g4.size == 3) {
										if(_g4.t._hx_index == 1) {
											var _g1 = _g3.e;
											var _g2 = _g3.p;
											var _g2 = _g3.t;
											if(_g1._hx_index == 0) {
												var _g2 = _g1.c;
												if(_g2._hx_index == 2) {
													if(_g2.v == 1) {
														return e;
													}
												}
											}
										}
									}
								}
								break;
							default:
							}
						}
					}
				}
			}
			break;
		case 16:
			var _g1 = _g.e;
			var _g2 = _g.index;
			var _g = _g2.e;
			var _g3 = _g2.p;
			var _g3 = _g2.t;
			if(_g._hx_index == 0) {
				var _g3 = _g.c;
				if(_g3._hx_index == 2) {
					var _g = _g3.v;
					var eindex = _g2;
					var ea = _g1;
					return { e : hxsl_TExprDef.TArray(this.mapConsts(ea),eindex), t : e.t, p : e.p};
				} else {
					var eindex = _g2;
					var ea = _g1;
					var _g = ea.t;
					if(_g._hx_index == 15) {
						var _g3 = _g.size;
						var t = _g.t;
						var stride = this.varSize(t,hxsl_VecType.VFloat) >> 2;
						this.allocConst(stride,e.p);
					}
				}
			} else {
				var eindex = _g2;
				var ea = _g1;
				var _g = ea.t;
				if(_g._hx_index == 15) {
					var _g1 = _g.size;
					var t = _g.t;
					var stride = this.varSize(t,hxsl_VecType.VFloat) >> 2;
					this.allocConst(stride,e.p);
				}
			}
			break;
		default:
		}
		return hxsl_Tools.map(e,$bind(this,this.mapConsts));
	}
	,allocConst: function(v,p) {
		var index = this.consts.indexOf(v);
		if(index < 0) {
			index = this.consts.length;
			this.consts.push(v);
		}
		return { e : hxsl_TExprDef.TArray(this.econsts,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : p}), t : hxsl_Type.TFloat, p : p};
	}
	,allocConsts: function(va,p) {
		var _gthis = this;
		var pad = va.length - 1 & 3;
		var index = -1;
		var _g = 0;
		var _g1 = this.consts.length - (va.length - 1);
		while(_g < _g1) {
			var i = _g++;
			if(i >> 2 != i + pad >> 2) {
				continue;
			}
			var found = true;
			var _g2 = 0;
			var _g3 = va.length;
			while(_g2 < _g3) {
				var j = _g2++;
				if(this.consts[i + j] != va[j]) {
					found = false;
					break;
				}
			}
			if(found) {
				index = i;
				break;
			}
		}
		if(index < 0) {
			while(this.consts.length >> 2 != this.consts.length + pad >> 2) this.consts.push(0);
			index = this.consts.length;
			var _g = 0;
			while(_g < va.length) {
				var v = va[_g];
				++_g;
				this.consts.push(v);
			}
		}
		switch(va.length) {
		case 1:
			return { e : hxsl_TExprDef.TArray(_gthis.econsts,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : p}), t : hxsl_Type.TFloat, p : p};
		case 2:
			return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Vec2), t : hxsl_Type.TVoid, p : p},[{ e : hxsl_TExprDef.TArray(_gthis.econsts,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : p}), t : hxsl_Type.TFloat, p : p},{ e : hxsl_TExprDef.TArray(_gthis.econsts,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index + 1)), t : hxsl_Type.TInt, p : p}), t : hxsl_Type.TFloat, p : p}]), t : hxsl_Type.TVec(2,hxsl_VecType.VFloat), p : p};
		case 3:
			return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Vec3), t : hxsl_Type.TVoid, p : p},[{ e : hxsl_TExprDef.TArray(_gthis.econsts,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : p}), t : hxsl_Type.TFloat, p : p},{ e : hxsl_TExprDef.TArray(_gthis.econsts,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index + 1)), t : hxsl_Type.TInt, p : p}), t : hxsl_Type.TFloat, p : p},{ e : hxsl_TExprDef.TArray(_gthis.econsts,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index + 2)), t : hxsl_Type.TInt, p : p}), t : hxsl_Type.TFloat, p : p}]), t : hxsl_Type.TVec(3,hxsl_VecType.VFloat), p : p};
		case 4:
			return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Vec4), t : hxsl_Type.TVoid, p : p},[{ e : hxsl_TExprDef.TArray(_gthis.econsts,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : p}), t : hxsl_Type.TFloat, p : p},{ e : hxsl_TExprDef.TArray(_gthis.econsts,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index + 1)), t : hxsl_Type.TInt, p : p}), t : hxsl_Type.TFloat, p : p},{ e : hxsl_TExprDef.TArray(_gthis.econsts,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index + 3)), t : hxsl_Type.TInt, p : p}), t : hxsl_Type.TFloat, p : p},{ e : hxsl_TExprDef.TArray(_gthis.econsts,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index + 4)), t : hxsl_Type.TInt, p : p}), t : hxsl_Type.TFloat, p : p}]), t : hxsl_Type.TVec(4,hxsl_VecType.VFloat), p : p};
		default:
			throw haxe_Exception.thrown("assert");
		}
	}
	,access: function(a,t,pos,acc) {
		var _gthis = this;
		switch(t._hx_index) {
		case 6:
			var tmp = this.access(a,hxsl_Type.TMat3x4,pos,acc);
			return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mat3), t : hxsl_Type.TFun([]), p : pos},[tmp]), t : hxsl_Type.TMat3, p : pos};
		case 7:
			var tmp = hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mat4);
			var tmp1 = hxsl_Type.TFun([]);
			var tmp2;
			switch(acc._hx_index) {
			case 0:
				var a1 = acc.a;
				var offs = a1.t == null ? a1.pos : a1.pos >> 2;
				tmp2 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			case 1:
				var a1 = acc.a;
				var stride = acc.stride;
				var delta = acc.delta;
				var index = a1.t == null ? a1.pos : a1.pos >> 2;
				var offset = index == 0 ? delta : { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos};
				tmp2 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},offset), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			}
			var tmp3;
			switch(acc._hx_index) {
			case 0:
				var a1 = acc.a;
				var offs = a1.t == null ? a1.pos : a1.pos >> 2;
				tmp3 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs + 1)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			case 1:
				var a1 = acc.a;
				var stride = acc.stride;
				var delta = acc.delta;
				var index = (a1.t == null ? a1.pos : a1.pos >> 2) + 1;
				var offset = index == 0 ? delta : { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos};
				tmp3 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},offset), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			}
			var tmp4;
			switch(acc._hx_index) {
			case 0:
				var a1 = acc.a;
				var offs = a1.t == null ? a1.pos : a1.pos >> 2;
				tmp4 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs + 2)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			case 1:
				var a1 = acc.a;
				var stride = acc.stride;
				var delta = acc.delta;
				var index = (a1.t == null ? a1.pos : a1.pos >> 2) + 2;
				var offset = index == 0 ? delta : { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos};
				tmp4 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},offset), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			}
			var tmp5;
			switch(acc._hx_index) {
			case 0:
				var a1 = acc.a;
				var offs = a1.t == null ? a1.pos : a1.pos >> 2;
				tmp5 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs + 3)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			case 1:
				var a1 = acc.a;
				var stride = acc.stride;
				var delta = acc.delta;
				var index = (a1.t == null ? a1.pos : a1.pos >> 2) + 3;
				var offset = index == 0 ? delta : { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos};
				tmp5 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},offset), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			}
			return { e : hxsl_TExprDef.TCall({ e : tmp, t : tmp1, p : pos},[tmp2,tmp3,tmp4,tmp5]), t : hxsl_Type.TMat4, p : pos};
		case 8:
			var tmp = hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mat3x4);
			var tmp1 = hxsl_Type.TFun([]);
			var tmp2;
			switch(acc._hx_index) {
			case 0:
				var a1 = acc.a;
				var offs = a1.t == null ? a1.pos : a1.pos >> 2;
				tmp2 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			case 1:
				var a1 = acc.a;
				var stride = acc.stride;
				var delta = acc.delta;
				var index = a1.t == null ? a1.pos : a1.pos >> 2;
				var offset = index == 0 ? delta : { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos};
				tmp2 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},offset), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			}
			var tmp3;
			switch(acc._hx_index) {
			case 0:
				var a1 = acc.a;
				var offs = a1.t == null ? a1.pos : a1.pos >> 2;
				tmp3 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs + 1)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			case 1:
				var a1 = acc.a;
				var stride = acc.stride;
				var delta = acc.delta;
				var index = (a1.t == null ? a1.pos : a1.pos >> 2) + 1;
				var offset = index == 0 ? delta : { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos};
				tmp3 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},offset), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			}
			var tmp4;
			switch(acc._hx_index) {
			case 0:
				var a1 = acc.a;
				var offs = a1.t == null ? a1.pos : a1.pos >> 2;
				tmp4 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs + 2)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			case 1:
				var a1 = acc.a;
				var stride = acc.stride;
				var delta = acc.delta;
				var index = (a1.t == null ? a1.pos : a1.pos >> 2) + 2;
				var offset = index == 0 ? delta : { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos};
				tmp4 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},offset), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			}
			return { e : hxsl_TExprDef.TCall({ e : tmp, t : tmp1, p : pos},[tmp2,tmp3,tmp4]), t : hxsl_Type.TMat3x4, p : pos};
		case 15:
			var _g = t.size;
			if(_g._hx_index == 0) {
				var len = _g.v;
				var t1 = t.t;
				var stride = a.size / len | 0;
				var _g = [];
				var _g1 = 0;
				var _g2 = len;
				while(_g1 < _g2) {
					var i = _g1++;
					var a1 = new hxsl__$Flatten_Alloc(a.g,a.t,a.pos + stride * i,stride);
					_g.push(this.access(a1,t1,pos,hxsl_ARead.AIndex(a1)));
				}
				var earr = _g;
				return { e : hxsl_TExprDef.TArrayDecl(earr), t : t1, p : pos};
			} else {
				if(hxsl_Tools.isSampler(t)) {
					var e;
					switch(acc._hx_index) {
					case 0:
						var a1 = acc.a;
						var offs = a1.t == null ? a1.pos : a1.pos >> 2;
						e = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,a1.t), p : pos};
						break;
					case 1:
						var a1 = acc.a;
						var stride = acc.stride;
						var delta = acc.delta;
						var index = a1.t == null ? a1.pos : a1.pos >> 2;
						var offset = index == 0 ? delta : { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos};
						e = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},offset), t : hxsl_Type.TVec(4,a1.t), p : pos};
						break;
					}
					e.t = t;
					return e;
				}
				var size = this.varSize(t,a.t);
				if(size > 4) {
					return hxsl_Error.t("Access not supported for " + hxsl_Tools.toString(t),null);
				}
				var e;
				switch(acc._hx_index) {
				case 0:
					var a1 = acc.a;
					var offs = a1.t == null ? a1.pos : a1.pos >> 2;
					e = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,a1.t), p : pos};
					break;
				case 1:
					var a1 = acc.a;
					var stride = acc.stride;
					var delta = acc.delta;
					var index = a1.t == null ? a1.pos : a1.pos >> 2;
					var offset = index == 0 ? delta : { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos};
					e = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},offset), t : hxsl_Type.TVec(4,a1.t), p : pos};
					break;
				}
				if(size == 4) {
					if(a.pos == -1) {
						return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Vec4), t : hxsl_Type.TFun([]), p : pos},[{ e : hxsl_TExprDef.TConst(hxsl_Const.CFloat(0)), t : hxsl_Type.TFloat, p : pos}]), t : hxsl_Type.TVec(4,hxsl_VecType.VFloat), p : pos};
					}
					if((a.pos & 3) != 0) {
						throw haxe_Exception.thrown("assert");
					}
				} else {
					var sw = [];
					var _g = 0;
					var _g1 = size;
					while(_g < _g1) {
						var i = _g++;
						sw.push(hxsl_Tools.SWIZ[i + (a.pos & 3)]);
					}
					e = { e : hxsl_TExprDef.TSwiz(e,sw), t : t, p : pos};
				}
				switch(t._hx_index) {
				case 1:
					e.t = hxsl_Type.TFloat;
					e = this.toInt(e);
					break;
				case 5:
					if(t.t._hx_index == 0) {
						var size = t.size;
						e.t = hxsl_Type.TVec(size,hxsl_VecType.VFloat);
						e = { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal([hxsl_TGlobal.IVec2,hxsl_TGlobal.IVec3,hxsl_TGlobal.IVec4][size - 2]), t : hxsl_Type.TFun([]), p : pos},[e]), t : t, p : pos};
					}
					break;
				default:
				}
				return e;
			}
			break;
		default:
			if(hxsl_Tools.isSampler(t)) {
				var e;
				switch(acc._hx_index) {
				case 0:
					var a1 = acc.a;
					var offs = a1.t == null ? a1.pos : a1.pos >> 2;
					e = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,a1.t), p : pos};
					break;
				case 1:
					var a1 = acc.a;
					var stride = acc.stride;
					var delta = acc.delta;
					var index = a1.t == null ? a1.pos : a1.pos >> 2;
					var offset = index == 0 ? delta : { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos};
					e = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},offset), t : hxsl_Type.TVec(4,a1.t), p : pos};
					break;
				}
				e.t = t;
				return e;
			}
			var size = this.varSize(t,a.t);
			if(size > 4) {
				return hxsl_Error.t("Access not supported for " + hxsl_Tools.toString(t),null);
			}
			var e;
			switch(acc._hx_index) {
			case 0:
				var a1 = acc.a;
				var offs = a1.t == null ? a1.pos : a1.pos >> 2;
				e = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			case 1:
				var a1 = acc.a;
				var stride = acc.stride;
				var delta = acc.delta;
				var index = a1.t == null ? a1.pos : a1.pos >> 2;
				var offset = index == 0 ? delta : { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos};
				e = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},offset), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			}
			if(size == 4) {
				if(a.pos == -1) {
					return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Vec4), t : hxsl_Type.TFun([]), p : pos},[{ e : hxsl_TExprDef.TConst(hxsl_Const.CFloat(0)), t : hxsl_Type.TFloat, p : pos}]), t : hxsl_Type.TVec(4,hxsl_VecType.VFloat), p : pos};
				}
				if((a.pos & 3) != 0) {
					throw haxe_Exception.thrown("assert");
				}
			} else {
				var sw = [];
				var _g = 0;
				var _g1 = size;
				while(_g < _g1) {
					var i = _g++;
					sw.push(hxsl_Tools.SWIZ[i + (a.pos & 3)]);
				}
				e = { e : hxsl_TExprDef.TSwiz(e,sw), t : t, p : pos};
			}
			switch(t._hx_index) {
			case 1:
				e.t = hxsl_Type.TFloat;
				e = this.toInt(e);
				break;
			case 5:
				if(t.t._hx_index == 0) {
					var size = t.size;
					e.t = hxsl_Type.TVec(size,hxsl_VecType.VFloat);
					e = { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal([hxsl_TGlobal.IVec2,hxsl_TGlobal.IVec3,hxsl_TGlobal.IVec4][size - 2]), t : hxsl_Type.TFun([]), p : pos},[e]), t : t, p : pos};
				}
				break;
			default:
			}
			return e;
		}
	}
	,toInt: function(e) {
		if(e.t == hxsl_Type.TInt) {
			return e;
		}
		return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.ToInt), t : hxsl_Type.TFun([]), p : e.p},[e]), t : hxsl_Type.TInt, p : e.p};
	}
	,optimize: function(e) {
		var _g = e.e;
		switch(_g._hx_index) {
		case 8:
			var _g1 = _g.e;
			var _g2 = _g.args;
			var _g3 = _g1.e;
			var _g4 = _g1.p;
			var _g4 = _g1.t;
			if(_g3._hx_index == 2) {
				if(_g3.g._hx_index == 52) {
					if(_g2.length == 1) {
						var _g1 = _g2[0];
						var _g2 = _g1.e;
						var _g3 = _g1.p;
						var _g3 = _g1.t;
						if(_g2._hx_index == 8) {
							var _g1 = _g2.e;
							var _g3 = _g1.e;
							var _g4 = _g1.p;
							var _g4 = _g1.t;
							if(_g3._hx_index == 2) {
								if(_g3.g._hx_index == 51) {
									var args = _g2.args;
									var rem = 0;
									var size = 0;
									while(size < 4) {
										var t = args[args.length - 1 - rem].t;
										size += this.varSize(t,hxsl_VecType.VFloat);
										++rem;
									}
									if(size == 4) {
										var _g1 = 0;
										var _g2 = rem;
										while(_g1 < _g2) {
											var i = _g1++;
											args.pop();
										}
										var emat;
										var _g1 = e.e;
										if(_g1._hx_index == 8) {
											var _g2 = _g1.args;
											var e1 = _g1.e;
											emat = e1;
										} else {
											throw haxe_Exception.thrown("assert");
										}
										return { e : hxsl_TExprDef.TCall(emat,args), t : e.t, p : e.p};
									}
								}
							}
						}
					}
				}
			}
			break;
		case 16:
			var _g1 = _g.e;
			var _g2 = _g.index;
			var _g = _g1.e;
			var _g3 = _g1.p;
			var _g3 = _g1.t;
			if(_g._hx_index == 17) {
				var _g1 = _g2.e;
				var _g3 = _g2.p;
				var _g3 = _g2.t;
				if(_g1._hx_index == 0) {
					var _g2 = _g1.c;
					if(_g2._hx_index == 2) {
						var i = _g2.v;
						var el = _g.el;
						if(i >= 0 && i < el.length) {
							return el[i];
						}
						hxsl_Error.t("Reading outside array bounds",e.p);
					}
				}
			}
			break;
		default:
		}
		return e;
	}
	,packTextures: function(name,vars,t) {
		var alloc = [];
		var g = { id : hxsl_Tools.allocVarId(), name : name, type : t, kind : hxsl_VarKind.Param};
		var pos = 0;
		var samplers = [];
		var _g = 0;
		while(_g < vars.length) {
			var v = vars[_g];
			++_g;
			var count = 1;
			if(v.type != t) {
				var _g1 = v.type;
				switch(_g1._hx_index) {
				case 15:
					var _g2 = _g1.size;
					if(_g2._hx_index == 0) {
						var n = _g2.v;
						var t2 = _g1.t;
						if(t2 == t) {
							count = n;
						} else {
							continue;
						}
					} else {
						continue;
					}
					break;
				case 17:
					var _g3 = _g1.size;
					if(t != hxsl_Type.TSampler2D) {
						continue;
					}
					break;
				default:
					continue;
				}
			}
			var a = new hxsl__$Flatten_Alloc(g,null,pos,count);
			a.v = v;
			if(v.qualifiers != null) {
				var _g4 = 0;
				var _g5 = v.qualifiers;
				while(_g4 < _g5.length) {
					var q = _g5[_g4];
					++_g4;
					if(q._hx_index == 12) {
						var name = q.name;
						var _g6 = 0;
						var _g7 = count;
						while(_g6 < _g7) {
							var i = _g6++;
							samplers[pos + i] = name;
						}
					}
				}
			}
			this.varMap.set(v,a);
			alloc.push(a);
			pos += count;
		}
		g.type = hxsl_Type.TArray(t,hxsl_SizeDecl.SConst(pos));
		if(samplers.length > 0) {
			var _g = 0;
			var _g1 = pos;
			while(_g < _g1) {
				var i = _g++;
				if(samplers[i] == null) {
					samplers[i] = "";
				}
			}
			if(g.qualifiers == null) {
				g.qualifiers = [];
			}
			g.qualifiers.push(hxsl_VarQualifier.Sampler(samplers.join(",")));
		}
		if(alloc.length > 0) {
			this.outVars.push(g);
			this.allocData.set(g,alloc);
		}
		return alloc;
	}
	,packBuffers: function(vars) {
		var alloc = [];
		var g = { id : hxsl_Tools.allocVarId(), name : "buffers", type : hxsl_Type.TVoid, kind : hxsl_VarKind.Param};
		var _g = 0;
		while(_g < vars.length) {
			var v = vars[_g];
			++_g;
			var _g1 = v.type;
			var tmp;
			if(_g1._hx_index == 16) {
				var _g2 = _g1.t;
				var _g3 = _g1.size;
				tmp = true;
			} else {
				tmp = false;
			}
			if(tmp) {
				var a = new hxsl__$Flatten_Alloc(g,null,alloc.length,1);
				a.v = v;
				alloc.push(a);
				this.outVars.push(v);
			}
		}
		g.type = hxsl_Type.TArray(hxsl_Type.TBuffer(hxsl_Type.TVoid,hxsl_SizeDecl.SConst(0)),hxsl_SizeDecl.SConst(alloc.length));
		this.allocData.set(g,alloc);
	}
	,pack: function(name,kind,vars,t) {
		var alloc = [];
		var apos = 0;
		var g = { id : hxsl_Tools.allocVarId(), name : name, type : hxsl_Type.TVec(0,t), kind : kind};
		var _g = 0;
		while(_g < vars.length) {
			var v = vars[_g];
			++_g;
			var tmp;
			if(!hxsl_Tools.isSampler(v.type)) {
				var _g1 = v.type;
				if(_g1._hx_index == 16) {
					var _g2 = _g1.t;
					var _g3 = _g1.size;
					tmp = true;
				} else {
					tmp = false;
				}
			} else {
				tmp = true;
			}
			if(tmp) {
				continue;
			}
			var _g4 = v.type;
			if(_g4._hx_index == 15) {
				var _g5 = _g4.size;
				var t1 = _g4.t;
				if(hxsl_Tools.isSampler(t1)) {
					continue;
				}
			}
			var size = this.varSize(v.type,t);
			if(size == 0) {
				var a = new hxsl__$Flatten_Alloc(g,t,-1,size);
				a.v = v;
				this.varMap.set(v,a);
				continue;
			}
			var best = null;
			var _g6 = 0;
			while(_g6 < alloc.length) {
				var a1 = alloc[_g6];
				++_g6;
				if(a1.v == null && a1.size >= size && (best == null || best.size > a1.size)) {
					best = a1;
				}
			}
			if(best != null) {
				var free = best.size - size;
				if(free > 0) {
					var i = alloc.indexOf(best);
					var a2 = new hxsl__$Flatten_Alloc(g,t,best.pos + size,free);
					alloc.splice(i + 1,0,a2);
					best.size = size;
				}
				best.v = v;
				this.varMap.set(v,best);
			} else {
				var a3 = new hxsl__$Flatten_Alloc(g,t,apos,size);
				apos += size;
				a3.v = v;
				this.varMap.set(v,a3);
				alloc.push(a3);
				var pad = (4 - size % 4) % 4;
				if(pad > 0) {
					var a4 = new hxsl__$Flatten_Alloc(g,t,apos,pad);
					apos += pad;
					alloc.push(a4);
				}
			}
		}
		g.type = hxsl_Type.TArray(hxsl_Type.TVec(4,t),hxsl_SizeDecl.SConst(apos >> 2));
		if(apos > 0) {
			this.outVars.push(g);
			this.allocData.set(g,alloc);
		}
		return g;
	}
	,varSize: function(v,t) {
		switch(v._hx_index) {
		case 1:case 3:
			if(t == hxsl_VecType.VFloat) {
				return 1;
			} else {
				throw haxe_Exception.thrown(hxsl_Tools.toString(v) + " size unknown for type " + Std.string(t));
			}
			break;
		case 5:
			var n = v.size;
			var t2 = v.t;
			if(t == t2) {
				return n;
			} else {
				throw haxe_Exception.thrown(hxsl_Tools.toString(v) + " size unknown for type " + Std.string(t));
			}
			break;
		case 7:
			if(t == hxsl_VecType.VFloat) {
				return 16;
			} else {
				throw haxe_Exception.thrown(hxsl_Tools.toString(v) + " size unknown for type " + Std.string(t));
			}
			break;
		case 6:case 8:
			if(t == hxsl_VecType.VFloat) {
				return 12;
			} else {
				throw haxe_Exception.thrown(hxsl_Tools.toString(v) + " size unknown for type " + Std.string(t));
			}
			break;
		case 15:
			var _g = v.size;
			if(_g._hx_index == 0) {
				var n = _g.v;
				var at = v.t;
				return this.varSize(at,t) * n;
			} else {
				throw haxe_Exception.thrown(hxsl_Tools.toString(v) + " size unknown for type " + Std.string(t));
			}
			break;
		default:
			throw haxe_Exception.thrown(hxsl_Tools.toString(v) + " size unknown for type " + Std.string(t));
		}
	}
	,gatherVar: function(v) {
		var _g = v.type;
		if(_g._hx_index == 13) {
			var vl = _g.vl;
			var _g = 0;
			while(_g < vl.length) {
				var v1 = vl[_g];
				++_g;
				this.gatherVar(v1);
			}
		} else {
			switch(v.kind._hx_index) {
			case 0:
				if(hxsl_Tools.hasQualifier(v,hxsl_VarQualifier.PerObject)) {
					this.params.push(v);
				} else {
					this.globals.push(v);
				}
				break;
			case 2:
				this.params.push(v);
				break;
			default:
				this.outVars.push(v);
			}
		}
	}
	,__class__: hxsl_Flatten
};
var hxsl_Globals = function() {
	this.channels = [];
	this.map = new haxe_ds_IntMap();
};
$hxClasses["hxsl.Globals"] = hxsl_Globals;
hxsl_Globals.__name__ = "hxsl.Globals";
hxsl_Globals.allocID = function(path) {
	if(hxsl_Globals.MAP == null) {
		hxsl_Globals.MAP = new haxe_ds_StringMap();
		hxsl_Globals.ALL = [];
	}
	var id = hxsl_Globals.MAP.h[path];
	if(id == null) {
		id = hxsl_Globals.ALL.length;
		hxsl_Globals.ALL.push(path);
		hxsl_Globals.MAP.h[path] = id;
	}
	return id;
};
hxsl_Globals.getIDName = function(id) {
	return hxsl_Globals.ALL[id];
};
hxsl_Globals.prototype = {
	set: function(path,v) {
		var this1 = this.map;
		var key = hxsl_Globals.allocID(path);
		this1.h[key] = v;
	}
	,allocChannelID: function(t) {
		var _g = 0;
		var _g1 = this.maxChannels;
		while(_g < _g1) {
			var i = _g++;
			if(this.channels[i] == t) {
				return i;
			}
		}
		if(this.maxChannels == 1 << hxsl_Tools.MAX_CHANNELS_BITS) {
			throw haxe_Exception.thrown("Too many unique channels");
		}
		var i = this.maxChannels++;
		this.channels[i] = t;
		return i;
	}
	,__class__: hxsl_Globals
};
var js_Boot = function() { };
$hxClasses["js.Boot"] = js_Boot;
js_Boot.__name__ = "js.Boot";
js_Boot.getClass = function(o) {
	if(o == null) {
		return null;
	} else if(((o) instanceof Array)) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var con = e.__constructs__[o._hx_index];
			var n = con._hx_name;
			if(con.__params__) {
				s = s + "\t";
				return n + "(" + ((function($this) {
					var $r;
					var _g = [];
					{
						var _g1 = 0;
						var _g2 = con.__params__;
						while(true) {
							if(!(_g1 < _g2.length)) {
								break;
							}
							var p = _g2[_g1];
							_g1 = _g1 + 1;
							_g.push(js_Boot.__string_rec(o[p],s));
						}
					}
					$r = _g;
					return $r;
				}(this))).join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	var intf = cc.__interfaces__;
	if(intf != null) {
		var _g = 0;
		var _g1 = intf.length;
		while(_g < _g1) {
			var i = _g++;
			var i1 = intf[i];
			if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__downcastCheck = function(o,cl) {
	if(!((o) instanceof cl)) {
		if(cl.__isInterface__) {
			return js_Boot.__interfLoop(js_Boot.getClass(o),cl);
		} else {
			return false;
		}
	} else {
		return true;
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var hxsl_GlslOut = function() {
	this.outIndex = 0;
	this.uniformBuffer = 0;
	this.exprIds = 0;
	this.varNames = new haxe_ds_IntMap();
	this.allNames = new haxe_ds_StringMap();
};
$hxClasses["hxsl.GlslOut"] = hxsl_GlslOut;
hxsl_GlslOut.__name__ = "hxsl.GlslOut";
hxsl_GlslOut.prototype = {
	decl: function(s) {
		var _g = 0;
		var _g1 = this.decls;
		while(_g < _g1.length) {
			var d = _g1[_g];
			++_g;
			if(d == s) {
				return;
			}
		}
		if(HxOverrides.cca(s,0) == 35) {
			this.decls.unshift(s);
		} else {
			this.decls.push(s);
		}
	}
	,addType: function(t) {
		switch(t._hx_index) {
		case 0:
			this.buf.b += Std.string("void");
			break;
		case 1:
			this.buf.b += Std.string("int");
			break;
		case 2:
			this.buf.b += Std.string("bool");
			break;
		case 3:
			this.buf.b += Std.string("float");
			break;
		case 4:
			this.buf.b += Std.string("string");
			break;
		case 5:
			var size = t.size;
			var k = t.t;
			switch(k._hx_index) {
			case 0:
				this.buf.b += Std.string("i");
				break;
			case 1:
				break;
			case 2:
				this.buf.b += Std.string("b");
				break;
			}
			this.buf.b += Std.string("vec");
			this.buf.b += Std.string(size);
			break;
		case 6:
			this.buf.b += Std.string("mat3");
			break;
		case 7:
			this.buf.b += Std.string("mat4");
			break;
		case 8:
			this.decl(hxsl_GlslOut.MAT34);
			this.buf.b += Std.string("_mat3x4");
			break;
		case 9:
			var n = t.size;
			this.buf.b += Std.string("vec");
			this.buf.b += Std.string(n);
			break;
		case 10:
			this.buf.b += Std.string("sampler2D");
			break;
		case 11:
			this.buf.b += Std.string("sampler2DArray");
			if(this.glES != null) {
				this.decl("precision lowp sampler2DArray;");
			}
			break;
		case 12:
			this.buf.b += Std.string("samplerCube");
			break;
		case 13:
			var vl = t.vl;
			this.buf.b += Std.string("struct { ");
			var _g = 0;
			while(_g < vl.length) {
				var v = vl[_g];
				++_g;
				this.addVar(v);
				this.buf.b += Std.string(";");
			}
			this.buf.b += Std.string(" }");
			break;
		case 14:
			var _g = t.variants;
			this.buf.b += Std.string("function");
			break;
		case 15:
			var t1 = t.t;
			var size = t.size;
			this.addType(t1);
			this.buf.b += Std.string("[");
			switch(size._hx_index) {
			case 0:
				var _g = size.v;
				if(_g == 1) {
					if(this.intelDriverFix) {
						this.buf.b += Std.string(2);
					} else {
						var v = _g;
						this.buf.b += Std.string(v);
					}
				} else {
					var v = _g;
					this.buf.b += Std.string(v);
				}
				break;
			case 1:
				var v = size.v;
				var v1 = this.varName(v);
				this.buf.b += Std.string(v1);
				break;
			}
			this.buf.b += Std.string("]");
			break;
		case 16:
			var _g = t.t;
			var _g = t.size;
			throw haxe_Exception.thrown("assert");
		case 17:
			var n = t.size;
			this.buf.b += Std.string("channel" + n);
			break;
		case 18:
			this.buf.b += Std.string("mat2");
			break;
		}
	}
	,addVar: function(v) {
		var _g = v.type;
		switch(_g._hx_index) {
		case 15:
			var t = _g.t;
			var size = _g.size;
			var old = v.type;
			v.type = t;
			this.addVar(v);
			v.type = old;
			this.buf.b += Std.string("[");
			switch(size._hx_index) {
			case 0:
				var _g1 = size.v;
				if(_g1 == 1) {
					if(this.intelDriverFix) {
						this.buf.b += Std.string(2);
					} else {
						var n = _g1;
						this.buf.b += Std.string(n);
					}
				} else {
					var n = _g1;
					this.buf.b += Std.string(n);
				}
				break;
			case 1:
				var v1 = size.v;
				var v2 = this.varName(v1);
				this.buf.b += Std.string(v2);
				break;
			}
			this.buf.b += Std.string("]");
			break;
		case 16:
			var t = _g.t;
			var size = _g.size;
			this.buf.b += Std.string((this.isVertex ? "vertex_" : "") + "uniform_buffer" + this.uniformBuffer++);
			this.buf.b += Std.string(" { ");
			v.type = hxsl_Type.TArray(t,size);
			this.addVar(v);
			v.type = hxsl_Type.TBuffer(t,size);
			this.buf.b += Std.string("; }");
			break;
		default:
			this.addType(v.type);
			this.buf.b += Std.string(" ");
			var v1 = this.varName(v);
			this.buf.b += Std.string(v1);
		}
	}
	,addValue: function(e,tabs) {
		var _g = e.e;
		switch(_g._hx_index) {
		case 4:
			var el = _g.el;
			var name = "val" + this.exprIds++;
			var tmp = this.buf;
			this.buf = new StringBuf();
			this.addType(e.t);
			this.buf.b += Std.string(" ");
			this.buf.b += Std.string(name);
			this.buf.b += Std.string("(void)");
			var el2 = el.slice();
			var last = el2[el2.length - 1];
			el2[el2.length - 1] = { e : hxsl_TExprDef.TReturn(last), t : e.t, p : last.p};
			var e2 = { t : hxsl_Type.TVoid, e : hxsl_TExprDef.TBlock(el2), p : e.p};
			this.addExpr(e2,"");
			this.exprValues.push(this.buf.b);
			this.buf = tmp;
			this.buf.b += Std.string(name);
			this.buf.b += Std.string("()");
			break;
		case 10:
			var econd = _g.econd;
			var eif = _g.eif;
			var eelse = _g.eelse;
			this.buf.b += Std.string("( ");
			this.addValue(econd,tabs);
			this.buf.b += Std.string(" ) ? ");
			this.addValue(eif,tabs);
			this.buf.b += Std.string(" : ");
			this.addValue(eelse,tabs);
			break;
		case 20:
			var _g1 = _g.m;
			var _g1 = _g.args;
			var e1 = _g.e;
			this.addValue(e1,tabs);
			break;
		default:
			this.addExpr(e,tabs);
		}
	}
	,addBlock: function(e,tabs) {
		this.addExpr(e,tabs);
	}
	,getFunName: function(g,args,rt) {
		switch(g._hx_index) {
		case 20:
			if(rt == hxsl_Type.TInt && this.glES != null) {
				this.decl("int _imod( int x, int y ) { return int(mod(float(x),float(y))); }");
				return "_imod";
			}
			break;
		case 33:
			var _g = args[0].t;
			switch(_g._hx_index) {
			case 10:case 11:
				if(this.glES != null && this.glES <= 2) {
					return "texture2D";
				}
				break;
			case 12:
				if(this.glES != null && this.glES <= 2) {
					return "textureCube";
				}
				break;
			case 17:
				var _g1 = _g.size;
				if(this.glES != null && this.glES <= 2) {
					return "texture2D";
				}
				break;
			default:
			}
			break;
		case 34:
			var _g = args[0].t;
			switch(_g._hx_index) {
			case 10:case 11:
				if(this.glES != null && this.glES <= 2) {
					this.decl("#extension GL_EXT_shader_texture_lod : enable");
					return "texture2DLodEXT";
				}
				break;
			case 12:
				if(this.glES != null && this.glES <= 2) {
					this.decl("#extension GL_EXT_shader_texture_lod : enable");
					return "textureCubeLodEXT";
				}
				break;
			case 17:
				var _g1 = _g.size;
				if(this.glES != null && this.glES <= 2) {
					this.decl("#extension GL_EXT_shader_texture_lod : enable");
					return "texture2DLodEXT";
				}
				break;
			default:
			}
			break;
		case 35:
			return "texelFetch";
		case 36:
			var _g = args[0].t;
			switch(_g._hx_index) {
			case 10:
				this.decl("vec2 _textureSize(sampler2D sampler, int lod) { return vec2(textureSize(sampler, lod)); }");
				break;
			case 11:
				this.decl("vec3 _textureSize(sampler2DArray sampler, int lod) { return vec3(textureSize(sampler, lod)); }");
				break;
			case 12:
				this.decl("vec2 _textureSize(samplerCube sampler, int lod) { return vec2(textureSize(sampler, lod)); }");
				break;
			case 17:
				var _g1 = _g.size;
				this.decl("vec2 _textureSize(sampler2D sampler, int lod) { return vec2(textureSize(sampler, lod)); }");
				break;
			default:
			}
			return "_textureSize";
		case 50:
			if(args[0].t == hxsl_Type.TMat3x4) {
				this.decl(hxsl_GlslOut.MAT34);
				this.decl("mat3 _mat3( _mat3x4 v ) { return mat3(v.a.xyz,v.b.xyz,v.c.xyz); }");
				return "_mat3";
			}
			break;
		case 52:
			this.decl(hxsl_GlslOut.MAT34);
			if(args.length == 1) {
				this.decl("_mat3x4 mat_to_34( mat4 m ) { return _mat3x4(m[0],m[1],m[2]); }");
				return "mat_to_34";
			}
			break;
		case 54:
			this.decl("vec4 pack( float v ) { vec4 color = fract(v * vec4(1, 255, 255.*255., 255.*255.*255.)); return color - color.yzww * vec4(1. / 255., 1. / 255., 1. / 255., 0.); }");
			break;
		case 55:
			this.decl("float unpack( vec4 color ) { return dot(color,vec4(1., 1. / 255., 1. / (255. * 255.), 1. / (255. * 255. * 255.))); }");
			break;
		case 56:
			this.decl("vec4 packNormal( vec3 v ) { return vec4((v + vec3(1.)) * vec3(0.5),1.); }");
			break;
		case 57:
			this.decl("vec3 unpackNormal( vec4 v ) { return normalize((v.xyz - vec3(0.5)) * vec3(2.)); }");
			break;
		case 58:
			this.decl("vec2 screenToUv( vec2 v ) { return v * vec2(0.5,-0.5) + vec2(0.5,0.5); }");
			break;
		case 59:
			this.decl("vec2 uvToScreen( vec2 v ) { return v * vec2(2.,-2.) + vec2(-1., 1.); }");
			break;
		case 60:case 61:case 62:
			if(this.isVertex) {
				throw haxe_Exception.thrown("Can't use " + Std.string(g) + " in vertex shader");
			}
			if(this.version < 300) {
				this.decl("#extension GL_OES_standard_derivatives:enable");
			}
			break;
		default:
		}
		return hxsl_GlslOut.GLOBALS[g._hx_index];
	}
	,addExpr: function(e,tabs) {
		var _g = e.e;
		switch(_g._hx_index) {
		case 0:
			var c = _g.c;
			switch(c._hx_index) {
			case 0:
				this.buf.b += Std.string("null");
				break;
			case 1:
				var b = c.b;
				this.buf.b += Std.string(b);
				break;
			case 2:
				var v = c.v;
				this.buf.b += Std.string(v);
				break;
			case 3:
				var f = c.v;
				var str = "" + f;
				this.buf.b += Std.string(str);
				if(str.indexOf(".") == -1 && str.indexOf("e") == -1) {
					this.buf.b += Std.string(".");
				}
				break;
			case 4:
				var v = c.v;
				this.buf.b += Std.string("\"" + v + "\"");
				break;
			}
			break;
		case 1:
			var v = _g.v;
			var v1 = this.varName(v);
			this.buf.b += Std.string(v1);
			break;
		case 2:
			var g = _g.g;
			this.buf.b += Std.string(hxsl_GlslOut.GLOBALS[g._hx_index]);
			break;
		case 3:
			var e1 = _g.e;
			this.buf.b += Std.string("(");
			this.addValue(e1,tabs);
			this.buf.b += Std.string(")");
			break;
		case 4:
			var el = _g.el;
			this.buf.b += Std.string("{\n");
			var t2 = tabs + "\t";
			var _g1 = 0;
			while(_g1 < el.length) {
				var e1 = el[_g1];
				++_g1;
				this.buf.b += Std.string(t2);
				this.addExpr(e1,t2);
				this.newLine(e1);
			}
			this.buf.b += Std.string(tabs);
			this.buf.b += Std.string("}");
			break;
		case 5:
			var op = _g.op;
			var e1 = _g.e1;
			var e2 = _g.e2;
			var _g1 = e1.t;
			var _g2 = e2.t;
			switch(op._hx_index) {
			case 1:
				if(_g1._hx_index == 5) {
					if(_g1.size == 3) {
						if(_g1.t._hx_index == 1) {
							if(_g2._hx_index == 8) {
								this.decl(hxsl_GlslOut.MAT34);
								this.decl("vec3 m3x4mult( vec3 v, _mat3x4 m) { vec4 ve = vec4(v,1.0); return vec3(dot(m.a,ve),dot(m.b,ve),dot(m.c,ve)); }");
								var tmp;
								if(op._hx_index == 20) {
									var _g3 = op.op;
									tmp = true;
								} else {
									tmp = false;
								}
								if(tmp) {
									this.addValue(e1,tabs);
									this.buf.b += Std.string(" = ");
								}
								this.buf.b += Std.string("m3x4mult(");
								this.addValue(e1,tabs);
								this.buf.b += Std.string(",");
								this.addValue(e2,tabs);
								this.buf.b += Std.string(")");
							} else {
								this.addValue(e1,tabs);
								this.buf.b += Std.string(" ");
								var v = hxsl_Printer.opStr(op);
								this.buf.b += Std.string(v);
								this.buf.b += Std.string(" ");
								this.addValue(e2,tabs);
							}
						} else {
							this.addValue(e1,tabs);
							this.buf.b += Std.string(" ");
							var v = hxsl_Printer.opStr(op);
							this.buf.b += Std.string(v);
							this.buf.b += Std.string(" ");
							this.addValue(e2,tabs);
						}
					} else {
						this.addValue(e1,tabs);
						this.buf.b += Std.string(" ");
						var v = hxsl_Printer.opStr(op);
						this.buf.b += Std.string(v);
						this.buf.b += Std.string(" ");
						this.addValue(e2,tabs);
					}
				} else {
					this.addValue(e1,tabs);
					this.buf.b += Std.string(" ");
					var v = hxsl_Printer.opStr(op);
					this.buf.b += Std.string(v);
					this.buf.b += Std.string(" ");
					this.addValue(e2,tabs);
				}
				break;
			case 5:
				if(_g1._hx_index == 5) {
					var _g3 = _g1.t;
					if(_g2._hx_index == 5) {
						var _g3 = _g2.size;
						var _g3 = _g2.t;
						var n = _g1.size;
						this.buf.b += Std.string("vec" + n + "(");
						var v;
						switch(op._hx_index) {
						case 5:
							v = "equal";
							break;
						case 6:
							v = "notEqual";
							break;
						case 7:
							v = "greaterThan";
							break;
						case 8:
							v = "greaterThanEqual";
							break;
						case 9:
							v = "lessThan";
							break;
						case 10:
							v = "lessThanEqual";
							break;
						default:
							throw haxe_Exception.thrown("assert");
						}
						this.buf.b += Std.string(v);
						this.buf.b += Std.string("(");
						this.addValue(e1,tabs);
						this.buf.b += Std.string(",");
						this.addValue(e2,tabs);
						this.buf.b += Std.string("))");
					} else {
						this.addValue(e1,tabs);
						this.buf.b += Std.string(" ");
						var v = hxsl_Printer.opStr(op);
						this.buf.b += Std.string(v);
						this.buf.b += Std.string(" ");
						this.addValue(e2,tabs);
					}
				} else {
					this.addValue(e1,tabs);
					this.buf.b += Std.string(" ");
					var v = hxsl_Printer.opStr(op);
					this.buf.b += Std.string(v);
					this.buf.b += Std.string(" ");
					this.addValue(e2,tabs);
				}
				break;
			case 6:
				if(_g1._hx_index == 5) {
					var _g3 = _g1.t;
					if(_g2._hx_index == 5) {
						var _g3 = _g2.size;
						var _g3 = _g2.t;
						var n = _g1.size;
						this.buf.b += Std.string("vec" + n + "(");
						var v;
						switch(op._hx_index) {
						case 5:
							v = "equal";
							break;
						case 6:
							v = "notEqual";
							break;
						case 7:
							v = "greaterThan";
							break;
						case 8:
							v = "greaterThanEqual";
							break;
						case 9:
							v = "lessThan";
							break;
						case 10:
							v = "lessThanEqual";
							break;
						default:
							throw haxe_Exception.thrown("assert");
						}
						this.buf.b += Std.string(v);
						this.buf.b += Std.string("(");
						this.addValue(e1,tabs);
						this.buf.b += Std.string(",");
						this.addValue(e2,tabs);
						this.buf.b += Std.string("))");
					} else {
						this.addValue(e1,tabs);
						this.buf.b += Std.string(" ");
						var v = hxsl_Printer.opStr(op);
						this.buf.b += Std.string(v);
						this.buf.b += Std.string(" ");
						this.addValue(e2,tabs);
					}
				} else {
					this.addValue(e1,tabs);
					this.buf.b += Std.string(" ");
					var v = hxsl_Printer.opStr(op);
					this.buf.b += Std.string(v);
					this.buf.b += Std.string(" ");
					this.addValue(e2,tabs);
				}
				break;
			case 7:
				if(_g1._hx_index == 5) {
					var _g3 = _g1.t;
					if(_g2._hx_index == 5) {
						var _g3 = _g2.size;
						var _g3 = _g2.t;
						var n = _g1.size;
						this.buf.b += Std.string("vec" + n + "(");
						var v;
						switch(op._hx_index) {
						case 5:
							v = "equal";
							break;
						case 6:
							v = "notEqual";
							break;
						case 7:
							v = "greaterThan";
							break;
						case 8:
							v = "greaterThanEqual";
							break;
						case 9:
							v = "lessThan";
							break;
						case 10:
							v = "lessThanEqual";
							break;
						default:
							throw haxe_Exception.thrown("assert");
						}
						this.buf.b += Std.string(v);
						this.buf.b += Std.string("(");
						this.addValue(e1,tabs);
						this.buf.b += Std.string(",");
						this.addValue(e2,tabs);
						this.buf.b += Std.string("))");
					} else {
						this.addValue(e1,tabs);
						this.buf.b += Std.string(" ");
						var v = hxsl_Printer.opStr(op);
						this.buf.b += Std.string(v);
						this.buf.b += Std.string(" ");
						this.addValue(e2,tabs);
					}
				} else {
					this.addValue(e1,tabs);
					this.buf.b += Std.string(" ");
					var v = hxsl_Printer.opStr(op);
					this.buf.b += Std.string(v);
					this.buf.b += Std.string(" ");
					this.addValue(e2,tabs);
				}
				break;
			case 8:
				if(_g1._hx_index == 5) {
					var _g3 = _g1.t;
					if(_g2._hx_index == 5) {
						var _g3 = _g2.size;
						var _g3 = _g2.t;
						var n = _g1.size;
						this.buf.b += Std.string("vec" + n + "(");
						var v;
						switch(op._hx_index) {
						case 5:
							v = "equal";
							break;
						case 6:
							v = "notEqual";
							break;
						case 7:
							v = "greaterThan";
							break;
						case 8:
							v = "greaterThanEqual";
							break;
						case 9:
							v = "lessThan";
							break;
						case 10:
							v = "lessThanEqual";
							break;
						default:
							throw haxe_Exception.thrown("assert");
						}
						this.buf.b += Std.string(v);
						this.buf.b += Std.string("(");
						this.addValue(e1,tabs);
						this.buf.b += Std.string(",");
						this.addValue(e2,tabs);
						this.buf.b += Std.string("))");
					} else {
						this.addValue(e1,tabs);
						this.buf.b += Std.string(" ");
						var v = hxsl_Printer.opStr(op);
						this.buf.b += Std.string(v);
						this.buf.b += Std.string(" ");
						this.addValue(e2,tabs);
					}
				} else {
					this.addValue(e1,tabs);
					this.buf.b += Std.string(" ");
					var v = hxsl_Printer.opStr(op);
					this.buf.b += Std.string(v);
					this.buf.b += Std.string(" ");
					this.addValue(e2,tabs);
				}
				break;
			case 9:
				if(_g1._hx_index == 5) {
					var _g3 = _g1.t;
					if(_g2._hx_index == 5) {
						var _g3 = _g2.size;
						var _g3 = _g2.t;
						var n = _g1.size;
						this.buf.b += Std.string("vec" + n + "(");
						var v;
						switch(op._hx_index) {
						case 5:
							v = "equal";
							break;
						case 6:
							v = "notEqual";
							break;
						case 7:
							v = "greaterThan";
							break;
						case 8:
							v = "greaterThanEqual";
							break;
						case 9:
							v = "lessThan";
							break;
						case 10:
							v = "lessThanEqual";
							break;
						default:
							throw haxe_Exception.thrown("assert");
						}
						this.buf.b += Std.string(v);
						this.buf.b += Std.string("(");
						this.addValue(e1,tabs);
						this.buf.b += Std.string(",");
						this.addValue(e2,tabs);
						this.buf.b += Std.string("))");
					} else {
						this.addValue(e1,tabs);
						this.buf.b += Std.string(" ");
						var v = hxsl_Printer.opStr(op);
						this.buf.b += Std.string(v);
						this.buf.b += Std.string(" ");
						this.addValue(e2,tabs);
					}
				} else {
					this.addValue(e1,tabs);
					this.buf.b += Std.string(" ");
					var v = hxsl_Printer.opStr(op);
					this.buf.b += Std.string(v);
					this.buf.b += Std.string(" ");
					this.addValue(e2,tabs);
				}
				break;
			case 10:
				if(_g1._hx_index == 5) {
					var _g3 = _g1.t;
					if(_g2._hx_index == 5) {
						var _g3 = _g2.size;
						var _g3 = _g2.t;
						var n = _g1.size;
						this.buf.b += Std.string("vec" + n + "(");
						var v;
						switch(op._hx_index) {
						case 5:
							v = "equal";
							break;
						case 6:
							v = "notEqual";
							break;
						case 7:
							v = "greaterThan";
							break;
						case 8:
							v = "greaterThanEqual";
							break;
						case 9:
							v = "lessThan";
							break;
						case 10:
							v = "lessThanEqual";
							break;
						default:
							throw haxe_Exception.thrown("assert");
						}
						this.buf.b += Std.string(v);
						this.buf.b += Std.string("(");
						this.addValue(e1,tabs);
						this.buf.b += Std.string(",");
						this.addValue(e2,tabs);
						this.buf.b += Std.string("))");
					} else {
						this.addValue(e1,tabs);
						this.buf.b += Std.string(" ");
						var v = hxsl_Printer.opStr(op);
						this.buf.b += Std.string(v);
						this.buf.b += Std.string(" ");
						this.addValue(e2,tabs);
					}
				} else {
					this.addValue(e1,tabs);
					this.buf.b += Std.string(" ");
					var v = hxsl_Printer.opStr(op);
					this.buf.b += Std.string(v);
					this.buf.b += Std.string(" ");
					this.addValue(e2,tabs);
				}
				break;
			case 18:
				this.decl("int _ushr( int i, int j ) { return int(uint(i) >> uint(j)); }");
				this.buf.b += Std.string("_ushr(");
				this.addValue(e1,tabs);
				this.buf.b += Std.string(",");
				this.addValue(e2,tabs);
				this.buf.b += Std.string(")");
				break;
			case 19:
				if(e.t != hxsl_Type.TInt) {
					var tmp;
					if(op._hx_index == 20) {
						var _g3 = op.op;
						tmp = true;
					} else {
						tmp = false;
					}
					if(tmp) {
						this.addValue(e1,tabs);
						this.buf.b += Std.string(" = ");
					}
					this.addExpr({ e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mod), t : hxsl_Type.TFun([]), p : e.p},[e1,e2]), t : e.t, p : e.p},tabs);
				} else {
					this.addValue(e1,tabs);
					this.buf.b += Std.string(" ");
					var v = hxsl_Printer.opStr(op);
					this.buf.b += Std.string(v);
					this.buf.b += Std.string(" ");
					this.addValue(e2,tabs);
				}
				break;
			case 20:
				switch(op.op._hx_index) {
				case 1:
					if(_g1._hx_index == 5) {
						if(_g1.size == 3) {
							if(_g1.t._hx_index == 1) {
								if(_g2._hx_index == 8) {
									this.decl(hxsl_GlslOut.MAT34);
									this.decl("vec3 m3x4mult( vec3 v, _mat3x4 m) { vec4 ve = vec4(v,1.0); return vec3(dot(m.a,ve),dot(m.b,ve),dot(m.c,ve)); }");
									var tmp;
									if(op._hx_index == 20) {
										var _g1 = op.op;
										tmp = true;
									} else {
										tmp = false;
									}
									if(tmp) {
										this.addValue(e1,tabs);
										this.buf.b += Std.string(" = ");
									}
									this.buf.b += Std.string("m3x4mult(");
									this.addValue(e1,tabs);
									this.buf.b += Std.string(",");
									this.addValue(e2,tabs);
									this.buf.b += Std.string(")");
								} else {
									this.addValue(e1,tabs);
									this.buf.b += Std.string(" ");
									var v = hxsl_Printer.opStr(op);
									this.buf.b += Std.string(v);
									this.buf.b += Std.string(" ");
									this.addValue(e2,tabs);
								}
							} else {
								this.addValue(e1,tabs);
								this.buf.b += Std.string(" ");
								var v = hxsl_Printer.opStr(op);
								this.buf.b += Std.string(v);
								this.buf.b += Std.string(" ");
								this.addValue(e2,tabs);
							}
						} else {
							this.addValue(e1,tabs);
							this.buf.b += Std.string(" ");
							var v = hxsl_Printer.opStr(op);
							this.buf.b += Std.string(v);
							this.buf.b += Std.string(" ");
							this.addValue(e2,tabs);
						}
					} else {
						this.addValue(e1,tabs);
						this.buf.b += Std.string(" ");
						var v = hxsl_Printer.opStr(op);
						this.buf.b += Std.string(v);
						this.buf.b += Std.string(" ");
						this.addValue(e2,tabs);
					}
					break;
				case 19:
					if(e.t != hxsl_Type.TInt) {
						var tmp;
						if(op._hx_index == 20) {
							var _g1 = op.op;
							tmp = true;
						} else {
							tmp = false;
						}
						if(tmp) {
							this.addValue(e1,tabs);
							this.buf.b += Std.string(" = ");
						}
						this.addExpr({ e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mod), t : hxsl_Type.TFun([]), p : e.p},[e1,e2]), t : e.t, p : e.p},tabs);
					} else {
						this.addValue(e1,tabs);
						this.buf.b += Std.string(" ");
						var v = hxsl_Printer.opStr(op);
						this.buf.b += Std.string(v);
						this.buf.b += Std.string(" ");
						this.addValue(e2,tabs);
					}
					break;
				default:
					this.addValue(e1,tabs);
					this.buf.b += Std.string(" ");
					var v = hxsl_Printer.opStr(op);
					this.buf.b += Std.string(v);
					this.buf.b += Std.string(" ");
					this.addValue(e2,tabs);
				}
				break;
			default:
				this.addValue(e1,tabs);
				this.buf.b += Std.string(" ");
				var v = hxsl_Printer.opStr(op);
				this.buf.b += Std.string(v);
				this.buf.b += Std.string(" ");
				this.addValue(e2,tabs);
			}
			break;
		case 6:
			var op = _g.op;
			var e1 = _g.e1;
			var v;
			switch(op._hx_index) {
			case 0:
				v = "++";
				break;
			case 1:
				v = "--";
				break;
			case 2:
				v = "!";
				break;
			case 3:
				v = "-";
				break;
			case 4:
				v = "~";
				break;
			default:
				throw haxe_Exception.thrown("assert");
			}
			this.buf.b += Std.string(v);
			this.addValue(e1,tabs);
			break;
		case 7:
			var v = _g.v;
			var init = _g.init;
			this.locals.h[v.id] = v;
			if(init != null) {
				var v1 = this.varName(v);
				this.buf.b += Std.string(v1);
				this.buf.b += Std.string(" = ");
				this.addValue(init,tabs);
			} else {
				this.buf.b += Std.string("/*var*/");
			}
			break;
		case 8:
			var _g1 = _g.e;
			var _g2 = _g.args;
			var _g3 = _g1.e;
			var _g4 = _g1.p;
			var _g4 = _g1.t;
			if(_g3._hx_index == 2) {
				var _g4 = _g3.g;
				switch(_g4._hx_index) {
				case 35:
					var g = _g4;
					var args = _g2;
					var v = this.getFunName(g,args,e.t);
					this.buf.b += Std.string(v);
					this.buf.b += Std.string("(");
					this.addValue(args[0],tabs);
					this.buf.b += Std.string(", ");
					this.addValue(args[1],tabs);
					if(args.length != 2) {
						this.buf.b += Std.string(", ");
						this.addValue(args[2],tabs);
						this.buf.b += Std.string(")");
					} else {
						this.buf.b += Std.string(", 0)");
					}
					break;
				case 36:
					var g = _g4;
					var args = _g2;
					var v = this.getFunName(g,args,e.t);
					this.buf.b += Std.string(v);
					this.buf.b += Std.string("(");
					this.addValue(args[0],tabs);
					if(args.length != 1) {
						this.buf.b += Std.string(", ");
						this.addValue(args[1],tabs);
						this.buf.b += Std.string(")");
					} else {
						this.buf.b += Std.string(", 0)");
					}
					break;
				case 53:
					if(_g2.length == 1) {
						var e1 = _g2[0];
						this.buf.b += Std.string("clamp(");
						this.addValue(e1,tabs);
						this.buf.b += Std.string(", 0., 1.)");
					} else {
						var v = _g1;
						var args = _g2;
						var _g3 = v.e;
						if(_g3._hx_index == 2) {
							var g = _g3.g;
							var v1 = this.getFunName(g,args,e.t);
							this.buf.b += Std.string(v1);
						} else {
							this.addValue(v,tabs);
						}
						this.buf.b += Std.string("(");
						var first = true;
						var _g3 = 0;
						while(_g3 < args.length) {
							var e1 = args[_g3];
							++_g3;
							if(first) {
								first = false;
							} else {
								this.buf.b += Std.string(", ");
							}
							this.addValue(e1,tabs);
						}
						this.buf.b += Std.string(")");
					}
					break;
				default:
					var v = _g1;
					var args = _g2;
					var _g3 = v.e;
					if(_g3._hx_index == 2) {
						var g = _g3.g;
						var v1 = this.getFunName(g,args,e.t);
						this.buf.b += Std.string(v1);
					} else {
						this.addValue(v,tabs);
					}
					this.buf.b += Std.string("(");
					var first = true;
					var _g3 = 0;
					while(_g3 < args.length) {
						var e1 = args[_g3];
						++_g3;
						if(first) {
							first = false;
						} else {
							this.buf.b += Std.string(", ");
						}
						this.addValue(e1,tabs);
					}
					this.buf.b += Std.string(")");
				}
			} else {
				var v = _g1;
				var args = _g2;
				var _g1 = v.e;
				if(_g1._hx_index == 2) {
					var g = _g1.g;
					var v1 = this.getFunName(g,args,e.t);
					this.buf.b += Std.string(v1);
				} else {
					this.addValue(v,tabs);
				}
				this.buf.b += Std.string("(");
				var first = true;
				var _g1 = 0;
				while(_g1 < args.length) {
					var e1 = args[_g1];
					++_g1;
					if(first) {
						first = false;
					} else {
						this.buf.b += Std.string(", ");
					}
					this.addValue(e1,tabs);
				}
				this.buf.b += Std.string(")");
			}
			break;
		case 9:
			var e1 = _g.e;
			var regs = _g.regs;
			if(e1.t._hx_index == 3) {
				var _g1 = 0;
				while(_g1 < regs.length) {
					var r = regs[_g1];
					++_g1;
					if(r != hxsl_Component.X) {
						throw haxe_Exception.thrown("assert");
					}
				}
				switch(regs.length) {
				case 1:
					this.addValue(e1,tabs);
					break;
				case 2:
					this.decl("vec2 _vec2( float v ) { return vec2(v,v); }");
					this.buf.b += Std.string("_vec2(");
					this.addValue(e1,tabs);
					this.buf.b += Std.string(")");
					break;
				case 3:
					this.decl("vec3 _vec3( float v ) { return vec3(v,v,v); }");
					this.buf.b += Std.string("_vec3(");
					this.addValue(e1,tabs);
					this.buf.b += Std.string(")");
					break;
				case 4:
					this.decl("vec4 _vec4( float v ) { return vec4(v,v,v,v); }");
					this.buf.b += Std.string("_vec4(");
					this.addValue(e1,tabs);
					this.buf.b += Std.string(")");
					break;
				default:
					throw haxe_Exception.thrown("assert");
				}
			} else {
				this.addValue(e1,tabs);
				this.buf.b += Std.string(".");
				var _g1 = 0;
				while(_g1 < regs.length) {
					var r = regs[_g1];
					++_g1;
					var _this = this.buf;
					var _this1 = _this.b;
					var tmp;
					switch(r._hx_index) {
					case 0:
						tmp = "x";
						break;
					case 1:
						tmp = "y";
						break;
					case 2:
						tmp = "z";
						break;
					case 3:
						tmp = "w";
						break;
					}
					_this.b = _this1 + Std.string(tmp);
				}
			}
			break;
		case 10:
			var econd = _g.econd;
			var eif = _g.eif;
			var eelse = _g.eelse;
			this.buf.b += Std.string("if( ");
			this.addValue(econd,tabs);
			this.buf.b += Std.string(") ");
			this.addExpr(eif,tabs);
			if(eelse != null) {
				if(!this.isBlock(eif)) {
					this.buf.b += Std.string(";");
				}
				this.buf.b += Std.string(" else ");
				this.addExpr(eelse,tabs);
			}
			break;
		case 11:
			this.buf.b += Std.string("discard");
			break;
		case 12:
			var e1 = _g.e;
			if(e1 == null) {
				this.buf.b += Std.string("return");
			} else {
				this.buf.b += Std.string("return ");
				this.addValue(e1,tabs);
			}
			break;
		case 13:
			var v = _g.v;
			var it = _g.it;
			var loop = _g.loop;
			this.locals.h[v.id] = v;
			var _g1 = it.e;
			if(_g1._hx_index == 5) {
				if(_g1.op._hx_index == 21) {
					var e1 = _g1.e1;
					var e2 = _g1.e2;
					this.buf.b += Std.string("for(");
					this.buf.b += Std.string(v.name + "=");
					this.addValue(e1,tabs);
					this.buf.b += Std.string(";" + v.name + "<");
					this.addValue(e2,tabs);
					this.buf.b += Std.string(";" + v.name + "++) ");
					this.addBlock(loop,tabs);
				} else {
					throw haxe_Exception.thrown("assert");
				}
			} else {
				throw haxe_Exception.thrown("assert");
			}
			break;
		case 14:
			this.buf.b += Std.string("continue");
			break;
		case 15:
			this.buf.b += Std.string("break");
			break;
		case 16:
			var e1 = _g.e;
			var index = _g.index;
			this.addValue(e1,tabs);
			this.buf.b += Std.string("[");
			this.addValue(index,tabs);
			this.buf.b += Std.string("]");
			break;
		case 17:
			var el = _g.el;
			var _g1 = e.t;
			if(_g1._hx_index == 15) {
				var _g2 = _g1.size;
				var t = _g1.t;
				this.addType(t);
			} else {
				throw haxe_Exception.thrown("assert");
			}
			this.buf.b += Std.string("[" + el.length + "]");
			this.buf.b += Std.string("(");
			var first = true;
			var _g1 = 0;
			while(_g1 < el.length) {
				var e = el[_g1];
				++_g1;
				if(first) {
					first = false;
				} else {
					this.buf.b += Std.string(", ");
				}
				this.addValue(e,tabs);
			}
			this.buf.b += Std.string(")");
			break;
		case 18:
			var _g1 = _g.e;
			var _g1 = _g.cases;
			var _g1 = _g.def;
			this.buf.b += Std.string("switch(...)");
			break;
		case 19:
			var _g1 = _g.e;
			var _g2 = _g.loop;
			if(_g.normalWhile == false) {
				var loop = _g2;
				var e = _g1;
				var old = tabs;
				tabs += "\t";
				this.buf.b += Std.string("do ");
				this.addBlock(loop,tabs);
				this.buf.b += Std.string(" while( ");
				this.addValue(e,tabs);
				this.buf.b += Std.string(" )");
			} else {
				var loop = _g2;
				var e = _g1;
				this.buf.b += Std.string("while( ");
				this.addValue(e,tabs);
				this.buf.b += Std.string(" ) ");
				this.addBlock(loop,tabs);
			}
			break;
		case 20:
			var _g1 = _g.m;
			var _g1 = _g.args;
			var e = _g.e;
			this.addExpr(e,tabs);
			break;
		}
	}
	,varName: function(v) {
		if(v.kind == hxsl_VarKind.Output) {
			if(this.isVertex) {
				return "gl_Position";
			}
			if(this.glES != null && this.glES <= 2) {
				if(this.outIndexes == null) {
					return "gl_FragColor";
				}
				return "gl_FragData[" + this.outIndexes.h[v.id] + "]";
			}
		}
		var n = this.varNames.h[v.id];
		if(n != null) {
			return n;
		}
		n = v.name;
		if(Object.prototype.hasOwnProperty.call(hxsl_GlslOut.KWDS.h,n)) {
			n = "_" + n;
		}
		if(Object.prototype.hasOwnProperty.call(this.allNames.h,n)) {
			var k = 2;
			n += "_";
			while(Object.prototype.hasOwnProperty.call(this.allNames.h,n + k)) ++k;
			n += k;
		}
		this.varNames.h[v.id] = n;
		this.allNames.h[n] = v.id;
		return n;
	}
	,newLine: function(e) {
		if(this.isBlock(e)) {
			this.buf.b += Std.string("\n");
		} else {
			this.buf.b += Std.string(";\n");
		}
	}
	,isBlock: function(e) {
		var _g = e.e;
		switch(_g._hx_index) {
		case 4:
			var _g1 = _g.el;
			return true;
		case 13:
			var _g1 = _g.v;
			var _g1 = _g.it;
			var loop = _g.loop;
			return this.isBlock(loop);
		case 19:
			var _g1 = _g.e;
			if(_g.normalWhile == true) {
				var loop = _g.loop;
				return this.isBlock(loop);
			} else {
				return false;
			}
			break;
		default:
			return false;
		}
	}
	,initVar: function(v) {
		switch(v.kind._hx_index) {
		case 0:case 2:
			var _g = v.type;
			var tmp;
			if(_g._hx_index == 16) {
				var _g1 = _g.t;
				var _g1 = _g.size;
				tmp = true;
			} else {
				tmp = false;
			}
			if(tmp) {
				this.buf.b += Std.string("layout(std140) ");
			}
			this.buf.b += Std.string("uniform ");
			break;
		case 1:
			this.buf.b += Std.string(this.glES != null && this.glES <= 2 ? "attribute " : "in ");
			break;
		case 3:
			this.buf.b += Std.string(this.glES != null && this.glES <= 2 ? "varying " : this.isVertex ? "out " : "in ");
			break;
		case 4:
			break;
		case 5:
			if(this.glES != null && this.glES <= 2) {
				this.outIndexes.h[v.id] = this.outIndex++;
				return;
			}
			if(this.isVertex) {
				return;
			}
			if(this.glES != null) {
				this.buf.b += Std.string("layout(location=" + this.outIndex++ + ") ");
			}
			this.buf.b += Std.string("out ");
			break;
		case 6:
			return;
		}
		if(v.qualifiers != null) {
			var _g = 0;
			var _g1 = v.qualifiers;
			while(_g < _g1.length) {
				var q = _g1[_g];
				++_g;
				if(q._hx_index == 6) {
					var p = q.p;
					switch(p._hx_index) {
					case 0:
						this.buf.b += Std.string("lowp ");
						break;
					case 1:
						this.buf.b += Std.string("mediump ");
						break;
					case 2:
						this.buf.b += Std.string("highp ");
						break;
					}
				}
			}
		}
		this.addVar(v);
		this.buf.b += Std.string(";\n");
	}
	,initVars: function(s) {
		this.outIndex = 0;
		this.uniformBuffer = 0;
		this.outIndexes = new haxe_ds_IntMap();
		var _g = 0;
		var _g1 = s.vars;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			this.initVar(v);
		}
		this.buf.b += Std.string("\n");
		if(this.outIndex < 2) {
			this.outIndexes = null;
		} else if(!this.isVertex && (this.glES != null && this.glES <= 2)) {
			this.decl("#extension GL_EXT_draw_buffers : enable");
		}
	}
	,run: function(s) {
		this.locals = new haxe_ds_IntMap();
		this.decls = [];
		this.buf = new StringBuf();
		this.exprValues = [];
		if(s.funs.length != 1) {
			throw haxe_Exception.thrown("assert");
		}
		var f = s.funs[0];
		this.isVertex = f.kind == hxsl_FunctionKind.Vertex;
		if(this.isVertex) {
			this.decl("precision highp float;");
		} else {
			this.decl("precision mediump float;");
		}
		this.initVars(s);
		var tmp = this.buf;
		this.buf = new StringBuf();
		this.buf.b += Std.string("void main(void) {\n");
		var _g = f.expr.e;
		if(_g._hx_index == 4) {
			var el = _g.el;
			var _g = 0;
			while(_g < el.length) {
				var e = el[_g];
				++_g;
				this.buf.b += Std.string("\t");
				this.addExpr(e,"\t");
				this.newLine(e);
			}
		} else {
			this.addExpr(f.expr,"");
		}
		if(this.isVertex) {
			this.buf.b += Std.string("\tgl_Position.z += gl_Position.z - gl_Position.w;\n");
		}
		this.buf.b += Std.string("}");
		this.exprValues.push(this.buf.b);
		this.buf = tmp;
		var locals = Lambda.array(this.locals);
		locals.sort(function(v1,v2) {
			return Reflect.compare(v1.name,v2.name);
		});
		var _g = 0;
		while(_g < locals.length) {
			var v = locals[_g];
			++_g;
			this.addVar(v);
			this.buf.b += Std.string(";\n");
		}
		this.buf.b += Std.string("\n");
		var _g = 0;
		var _g1 = this.exprValues;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			this.buf.b += Std.string(e);
			this.buf.b += Std.string("\n\n");
		}
		if(this.glES != null) {
			this.decl("#version " + (this.version < 100 ? 100 : this.version) + (this.version > 150 ? " es" : ""));
		} else if(this.version != null) {
			this.decl("#version " + (this.version > 150 ? 150 : this.version));
		} else {
			this.decl("#version 130");
		}
		this.decls.push(this.buf.b);
		this.buf = null;
		return this.decls.join("\n");
	}
	,__class__: hxsl_GlslOut
};
var hxsl__$Linker_AllocatedVar = function() {
};
$hxClasses["hxsl._Linker.AllocatedVar"] = hxsl__$Linker_AllocatedVar;
hxsl__$Linker_AllocatedVar.__name__ = "hxsl._Linker.AllocatedVar";
hxsl__$Linker_AllocatedVar.prototype = {
	__class__: hxsl__$Linker_AllocatedVar
};
var hxsl__$Linker_ShaderInfos = function(n,v) {
	this.name = n;
	this.uid = hxsl__$Linker_ShaderInfos.UID++;
	this.vertex = v;
	this.processed = new haxe_ds_IntMap();
	this.usedFunctions = [];
	this.read = new haxe_ds_IntMap();
	this.write = new haxe_ds_IntMap();
};
$hxClasses["hxsl._Linker.ShaderInfos"] = hxsl__$Linker_ShaderInfos;
hxsl__$Linker_ShaderInfos.__name__ = "hxsl._Linker.ShaderInfos";
hxsl__$Linker_ShaderInfos.prototype = {
	__class__: hxsl__$Linker_ShaderInfos
};
var hxsl_Linker = function(batchMode) {
	if(batchMode == null) {
		batchMode = false;
	}
	this.debugDepth = 0;
	this.batchMode = batchMode;
};
$hxClasses["hxsl.Linker"] = hxsl_Linker;
hxsl_Linker.__name__ = "hxsl.Linker";
hxsl_Linker.prototype = {
	error: function(msg,p) {
		return hxsl_Error.t(msg,p);
	}
	,mergeVar: function(path,v,v2,p,shaderName) {
		switch(v.kind._hx_index) {
		case 2:
			if(!(shaderName != null && hxsl_Tools.hasBorrowQualifier(v2,shaderName))) {
				throw haxe_Exception.thrown("assert");
			}
			break;
		case 0:case 1:case 3:case 4:case 5:
			break;
		case 6:
			throw haxe_Exception.thrown("assert");
		}
		if(v.kind != v2.kind && v.kind != hxsl_VarKind.Local && v2.kind != hxsl_VarKind.Local) {
			this.error("'" + path + "' kind does not match : " + Std.string(v.kind) + " should be " + Std.string(v2.kind),p);
		}
		var _g = v.type;
		var _g1 = v2.type;
		if(_g._hx_index == 13) {
			if(_g1._hx_index == 13) {
				var fl2 = _g1.vl;
				var fl1 = _g.vl;
				var _g = 0;
				while(_g < fl1.length) {
					var f1 = fl1[_g];
					++_g;
					var ft = null;
					var _g1 = 0;
					while(_g1 < fl2.length) {
						var f2 = fl2[_g1];
						++_g1;
						if(f1.name == f2.name) {
							ft = f2;
							break;
						}
					}
					if(ft == null) {
						fl2.push(this.allocVar(f1,p,shaderName).v);
					} else {
						this.mergeVar(path + "." + ft.name,f1,ft,p,shaderName);
					}
				}
			} else if(!Type.enumEq(v.type,v2.type)) {
				this.error("'" + path + "' type does not match : " + hxsl_Tools.toString(v.type) + " should be " + hxsl_Tools.toString(v2.type),p);
			}
		} else if(!Type.enumEq(v.type,v2.type)) {
			this.error("'" + path + "' type does not match : " + hxsl_Tools.toString(v.type) + " should be " + hxsl_Tools.toString(v2.type),p);
		}
	}
	,allocVar: function(v,p,shaderName,path,parent) {
		var _gthis = this;
		if(v.parent != null && parent == null) {
			parent = this.allocVar(v.parent,p,shaderName);
			var p1 = parent.v;
			path = p1.name;
			p1 = p1.parent;
			while(p1 != null) {
				path = p1.name + "." + path;
				p1 = p1.parent;
			}
		}
		var key = path == null ? v.name : path + "." + v.name;
		if(v.qualifiers != null) {
			var _g = 0;
			var _g1 = v.qualifiers;
			while(_g < _g1.length) {
				var q = _g1[_g];
				++_g;
				if(q._hx_index == 4) {
					var n = q.n;
					key = n;
				}
			}
		}
		var v2 = this.varMap.h[key];
		var vname = v.name;
		if(v2 != null) {
			var _g = 0;
			var _g1 = v2.merged;
			while(_g < _g1.length) {
				var vm = _g1[_g];
				++_g;
				if(vm == v) {
					return v2;
				}
			}
			var tmp;
			var borrowed = hxsl_Tools.hasBorrowQualifier(v2.v,shaderName);
			if(!(v.kind == hxsl_VarKind.Param && !borrowed && !hxsl_Tools.hasQualifier(v,hxsl_VarQualifier.Shared) && !_gthis.isBatchShader || v.kind == hxsl_VarKind.Function || (v.kind == hxsl_VarKind.Var || v.kind == hxsl_VarKind.Local) && hxsl_Tools.hasQualifier(v,hxsl_VarQualifier.Private))) {
				var v1 = v2.v;
				var borrowed = hxsl_Tools.hasBorrowQualifier(v,v2.rootShaderName);
				tmp = v1.kind == hxsl_VarKind.Param && !borrowed && !hxsl_Tools.hasQualifier(v1,hxsl_VarQualifier.Shared) && !_gthis.isBatchShader || v1.kind == hxsl_VarKind.Function || (v1.kind == hxsl_VarKind.Var || v1.kind == hxsl_VarKind.Local) && hxsl_Tools.hasQualifier(v1,hxsl_VarQualifier.Private);
			} else {
				tmp = true;
			}
			if(tmp || v.kind == hxsl_VarKind.Param && v2.v.kind == hxsl_VarKind.Param) {
				var k = 2;
				while(true) {
					var a = this.varMap.h[key + k];
					if(a == null) {
						break;
					}
					var _g = 0;
					var _g1 = a.merged;
					while(_g < _g1.length) {
						var vm = _g1[_g];
						++_g;
						if(vm == v) {
							return a;
						}
					}
					++k;
				}
				vname += k;
				key += k;
			} else {
				v2.merged.push(v);
				this.mergeVar(key,v,v2.v,p,v2.rootShaderName);
				this.varIdMap.h[v.id] = v2.id;
				return v2;
			}
		}
		var vid = this.allVars.length + 1;
		var v2 = { id : vid, name : vname, type : v.type, kind : v.kind, qualifiers : v.qualifiers, parent : parent == null ? null : parent.v};
		var a = new hxsl__$Linker_AllocatedVar();
		a.v = v2;
		a.merged = [v];
		a.path = key;
		a.id = vid;
		a.parent = parent;
		a.instanceIndex = this.curInstance;
		a.rootShaderName = shaderName;
		this.allVars.push(a);
		this.varMap.h[key] = a;
		var _g = v2.type;
		if(_g._hx_index == 13) {
			var vl = _g.vl;
			var _g = [];
			var _g1 = 0;
			while(_g1 < vl.length) {
				var v = vl[_g1];
				++_g1;
				_g.push(this.allocVar(v,p,shaderName,key,a).v);
			}
			v2.type = hxsl_Type.TStruct(_g);
		}
		return a;
	}
	,mapExprVar: function(e) {
		var _g = e.e;
		switch(_g._hx_index) {
		case 1:
			var v = _g.v;
			if(!this.locals.h.hasOwnProperty(v.id)) {
				var v1 = this.allocVar(v,e.p);
				if(this.curShader != null && !this.curShader.write.h.hasOwnProperty(v1.id)) {
					this.curShader.read.h[v1.id] = v1;
					if(this.curShader.vertex == null && v1.v.kind == hxsl_VarKind.Var) {
						this.curShader.vertex = false;
					}
				}
				return { e : hxsl_TExprDef.TVar(v1.v), t : v1.v.type, p : e.p};
			}
			break;
		case 5:
			var op = _g.op;
			var e1 = _g.e1;
			var e2 = _g.e2;
			var _g1 = e1.e;
			switch(op._hx_index) {
			case 4:
				switch(_g1._hx_index) {
				case 1:
					var _g2 = _g1.v;
					var v = _g2;
					if(!this.locals.h.hasOwnProperty(v.id)) {
						var e21 = this.mapExprVar(e2);
						var v1 = this.allocVar(v,e1.p);
						if(this.curShader != null) {
							this.curShader.write.h[v1.id] = v1;
						}
						return { e : hxsl_TExprDef.TBinop(op,{ e : hxsl_TExprDef.TVar(v1.v), t : v1.v.type, p : e.p},e21), t : e.t, p : e.p};
					} else {
						var v = _g2;
						if(!this.locals.h.hasOwnProperty(v.id)) {
							var e11 = this.mapExprVar(e1);
							var e21 = this.mapExprVar(e2);
							var v1 = this.allocVar(v,e11.p);
							if(this.curShader != null) {
								this.curShader.write.h[v1.id] = v1;
							}
							return { e : hxsl_TExprDef.TBinop(op,e11,e21), t : e.t, p : e.p};
						}
					}
					break;
				case 9:
					var _g2 = _g1.e;
					var _g3 = _g1.regs;
					var _g3 = _g2.e;
					var _g4 = _g2.p;
					var _g4 = _g2.t;
					if(_g3._hx_index == 1) {
						var v = _g3.v;
						if(!this.locals.h.hasOwnProperty(v.id)) {
							var e11 = this.mapExprVar(e1);
							var e21 = this.mapExprVar(e2);
							var v1 = this.allocVar(v,e11.p);
							if(this.curShader != null) {
								this.curShader.write.h[v1.id] = v1;
							}
							return { e : hxsl_TExprDef.TBinop(op,e11,e21), t : e.t, p : e.p};
						}
					}
					break;
				default:
				}
				break;
			case 20:
				var _g2 = op.op;
				switch(_g1._hx_index) {
				case 1:
					var v = _g1.v;
					if(!this.locals.h.hasOwnProperty(v.id)) {
						var e11 = this.mapExprVar(e1);
						var e21 = this.mapExprVar(e2);
						var v1 = this.allocVar(v,e11.p);
						if(this.curShader != null) {
							this.curShader.write.h[v1.id] = v1;
						}
						return { e : hxsl_TExprDef.TBinop(op,e11,e21), t : e.t, p : e.p};
					}
					break;
				case 9:
					var _g2 = _g1.e;
					var _g3 = _g1.regs;
					var _g1 = _g2.e;
					var _g3 = _g2.p;
					var _g3 = _g2.t;
					if(_g1._hx_index == 1) {
						var v = _g1.v;
						if(!this.locals.h.hasOwnProperty(v.id)) {
							var e11 = this.mapExprVar(e1);
							var e21 = this.mapExprVar(e2);
							var v1 = this.allocVar(v,e11.p);
							if(this.curShader != null) {
								this.curShader.write.h[v1.id] = v1;
							}
							return { e : hxsl_TExprDef.TBinop(op,e11,e21), t : e.t, p : e.p};
						}
					}
					break;
				default:
				}
				break;
			default:
			}
			break;
		case 7:
			var _g1 = _g.init;
			var v = _g.v;
			this.locals.h[v.id] = true;
			break;
		case 11:
			if(this.curShader != null) {
				this.curShader.vertex = false;
				this.curShader.hasDiscard = true;
			}
			break;
		case 13:
			var _g1 = _g.it;
			var _g1 = _g.loop;
			var v = _g.v;
			this.locals.h[v.id] = true;
			break;
		default:
		}
		return hxsl_Tools.map(e,$bind(this,this.mapExprVar));
	}
	,addShader: function(name,vertex,e,p) {
		var s = new hxsl__$Linker_ShaderInfos(name,vertex);
		this.curShader = s;
		s.priority = p;
		s.body = this.mapExprVar(e);
		this.shaders.push(s);
		this.curShader = null;
		return s;
	}
	,sortByPriorityDesc: function(s1,s2) {
		if(s1.priority == s2.priority) {
			return s1.uid - s2.uid;
		}
		return s2.priority - s1.priority;
	}
	,buildDependency: function(s,v,isWritten) {
		var found = !isWritten;
		var _g = 0;
		var _g1 = this.shaders;
		while(_g < _g1.length) {
			var parent = _g1[_g];
			++_g;
			if(parent == s) {
				found = true;
				continue;
			} else if(!found) {
				continue;
			}
			if(!parent.write.h.hasOwnProperty(v.id)) {
				continue;
			}
			if(s.vertex) {
				if(parent.vertex == false) {
					continue;
				}
				if(parent.vertex == null) {
					parent.vertex = true;
				}
			}
			s.deps.set(parent,true);
			this.debugDepth++;
			this.initDependencies(parent);
			this.debugDepth--;
			if(!parent.read.h.hasOwnProperty(v.id)) {
				return;
			}
		}
		if(v.v.kind == hxsl_VarKind.Var) {
			this.error("Variable " + v.path + " required by " + s.name + " is missing initializer",null);
		}
	}
	,initDependencies: function(s) {
		if(s.deps != null) {
			return;
		}
		s.deps = new haxe_ds_ObjectMap();
		var r = s.read.iterator();
		while(r.hasNext()) {
			var r1 = r.next();
			this.buildDependency(s,r1,s.write.h.hasOwnProperty(r1.id));
		}
		if(s.vertex == null) {
			var d = s.deps.keys();
			while(d.hasNext()) {
				var d1 = d.next();
				if(d1.vertex == false) {
					s.vertex = false;
					break;
				}
			}
		}
		if(s.vertex) {
			var d = s.deps.keys();
			while(d.hasNext()) {
				var d1 = d.next();
				if(d1.vertex == null) {
					d1.vertex = true;
				}
			}
		}
	}
	,collect: function(cur,out,vertex) {
		if(cur.onStack) {
			this.error("Loop in shader dependencies (" + cur.name + ")",null);
		}
		if(cur.marked == vertex) {
			return;
		}
		cur.marked = vertex;
		cur.onStack = true;
		var _g = [];
		var d = cur.deps.keys();
		while(d.hasNext()) {
			var d1 = d.next();
			_g.push(d1);
		}
		var deps = _g;
		deps.sort($bind(this,this.sortByPriorityDesc));
		var _g = 0;
		while(_g < deps.length) {
			var d = deps[_g];
			++_g;
			this.collect(d,out,vertex);
		}
		if(cur.vertex == null) {
			cur.vertex = vertex;
		}
		if(cur.vertex == vertex) {
			out.push(cur);
		}
		cur.onStack = false;
	}
	,uniqueLocals: function(expr,locals) {
		var _g = expr.e;
		switch(_g._hx_index) {
		case 4:
			var el = _g.el;
			var _g1 = new haxe_ds_StringMap();
			var h = locals.h;
			var k_h = h;
			var k_keys = Object.keys(h);
			var k_length = k_keys.length;
			var k_current = 0;
			while(k_current < k_length) {
				var k = k_keys[k_current++];
				_g1.h[k] = true;
			}
			var locals1 = _g1;
			var _g1 = 0;
			while(_g1 < el.length) {
				var e = el[_g1];
				++_g1;
				this.uniqueLocals(e,locals1);
			}
			break;
		case 7:
			var _g1 = _g.init;
			var v = _g.v;
			if(Object.prototype.hasOwnProperty.call(locals.h,v.name)) {
				var k = 2;
				while(Object.prototype.hasOwnProperty.call(locals.h,v.name + k)) ++k;
				v.name += k;
			}
			locals.h[v.name] = true;
			break;
		default:
			var _g = $bind(this,this.uniqueLocals);
			var locals1 = locals;
			hxsl_Tools.iter(expr,function(expr) {
				_g(expr,locals1);
			});
		}
	}
	,link: function(shadersData) {
		var _gthis = this;
		this.varMap = new haxe_ds_StringMap();
		this.varIdMap = new haxe_ds_IntMap();
		this.allVars = [];
		this.shaders = [];
		this.locals = new haxe_ds_IntMap();
		var dupShaders = new haxe_ds_ObjectMap();
		var _g = [];
		var _g1 = 0;
		while(_g1 < shadersData.length) {
			var s = shadersData[_g1];
			++_g1;
			var s1 = s;
			var sreal = s1;
			if(dupShaders.h.__keys__[s1.__id__] != null) {
				s1 = hxsl_Clone.shaderData(s1);
			}
			dupShaders.set(s1,sreal);
			_g.push(s1);
		}
		shadersData = _g;
		this.curInstance = 0;
		var outVars = [];
		var _g = 0;
		while(_g < shadersData.length) {
			var s = shadersData[_g];
			++_g;
			this.isBatchShader = this.batchMode && StringTools.startsWith(s.name,"batchShader_");
			var _g1 = 0;
			var _g2 = s.vars;
			while(_g1 < _g2.length) {
				var v = _g2[_g1];
				++_g1;
				var v2 = this.allocVar(v,null,s.name);
				if(this.isBatchShader && v2.v.kind == hxsl_VarKind.Param && !StringTools.startsWith(v2.path,"Batch_")) {
					v2.v.kind = hxsl_VarKind.Local;
				}
				if(v.kind == hxsl_VarKind.Output) {
					outVars.push(v);
				}
			}
			var _g3 = 0;
			var _g4 = s.funs;
			while(_g3 < _g4.length) {
				var f = _g4[_g3];
				++_g3;
				var v1 = this.allocVar(f.ref,f.expr.p);
				v1.kind = f.kind;
			}
			this.curInstance++;
		}
		var priority = 0;
		var initPrio_init = [-3000];
		var initPrio_vert = [-2000];
		var initPrio_frag = [-1000];
		var _g = 0;
		while(_g < shadersData.length) {
			var s = shadersData[_g];
			++_g;
			var _g1 = 0;
			var _g2 = s.funs;
			while(_g1 < _g2.length) {
				var f = _g2[_g1];
				++_g1;
				var v = this.allocVar(f.ref,f.expr.p);
				if(v.kind == null) {
					throw haxe_Exception.thrown("assert");
				}
				switch(v.kind._hx_index) {
				case 0:case 1:
					this.addShader(s.name + "." + (v.kind == hxsl_FunctionKind.Vertex ? "vertex" : "fragment"),v.kind == hxsl_FunctionKind.Vertex,f.expr,priority);
					break;
				case 2:
					var prio;
					var status;
					switch(f.ref.name) {
					case "__init__fragment":
						prio = initPrio_frag;
						status = false;
						break;
					case "__init__vertex":
						prio = initPrio_vert;
						status = true;
						break;
					default:
						prio = initPrio_init;
						status = null;
					}
					var _g3 = f.expr.e;
					if(_g3._hx_index == 4) {
						var el = _g3.el;
						var index = 0;
						var _g4 = 0;
						while(_g4 < el.length) {
							var e = el[_g4];
							++_g4;
							this.addShader(s.name + "." + f.ref.name + index++,status,e,prio[0]++);
						}
					} else {
						this.addShader(s.name + "." + f.ref.name,status,f.expr,prio[0]++);
					}
					break;
				case 3:
					throw haxe_Exception.thrown("Unexpected helper function in linker " + v.v.name);
				}
			}
			++priority;
		}
		this.shaders.sort($bind(this,this.sortByPriorityDesc));
		var entry = new hxsl__$Linker_ShaderInfos("<entry>",false);
		entry.deps = new haxe_ds_ObjectMap();
		var _g = 0;
		while(_g < outVars.length) {
			var v = outVars[_g];
			++_g;
			this.buildDependency(entry,this.allocVar(v,null),false);
		}
		var _g = 0;
		var _g1 = this.shaders;
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			if(s.hasDiscard) {
				this.initDependencies(s);
				entry.deps.set(s,true);
			}
		}
		var _g = 0;
		var _g1 = this.shaders;
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			if(s.vertex != null) {
				continue;
			}
			var onlyParams = true;
			var r = s.read.iterator();
			while(r.hasNext()) {
				var r1 = r.next();
				if(r1.v.kind != hxsl_VarKind.Param) {
					onlyParams = false;
					break;
				}
			}
			if(onlyParams) {
				s.vertex = false;
			}
		}
		var v = [];
		var f = [];
		this.collect(entry,v,true);
		this.collect(entry,f,false);
		if(f.pop() != entry) {
			throw haxe_Exception.thrown("assert");
		}
		var _g = 0;
		var _g1 = this.shaders;
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			s.marked = null;
		}
		var _g = 0;
		var _g1 = v.concat(f);
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			var d = s.deps.keys();
			while(d.hasNext()) {
				var d1 = d.next();
				if(d1.marked == null) {
					this.error(d1.name + " needed by " + s.name + " is unreachable",null);
				}
			}
			s.marked = true;
		}
		var outVars = [];
		var varMap_h = { };
		var addVar = null;
		addVar = function(v) {
			if(varMap_h.hasOwnProperty(v.id)) {
				return;
			}
			varMap_h[v.id] = true;
			if(v.v.parent != null) {
				addVar(v.parent);
			} else {
				outVars.push(v.v);
			}
		};
		var _g = 0;
		var _g1 = v.concat(f);
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			var v1 = s.read.iterator();
			while(v1.hasNext()) {
				var v2 = v1.next();
				addVar(v2);
			}
			var v3 = s.write.iterator();
			while(v3.hasNext()) {
				var v4 = v3.next();
				addVar(v4);
			}
		}
		var cleanVar = null;
		cleanVar = function(v) {
			var _g = v.type;
			if(_g._hx_index == 13) {
				var vl = _g.vl;
				if(v.kind != hxsl_VarKind.Input) {
					var vout = [];
					var _g = 0;
					while(_g < vl.length) {
						var v1 = vl[_g];
						++_g;
						if(varMap_h.hasOwnProperty(v1.id)) {
							cleanVar(v1);
							vout.push(v1);
						}
					}
					v.type = hxsl_Type.TStruct(vout);
				}
			}
		};
		var _g = 0;
		while(_g < outVars.length) {
			var v1 = outVars[_g];
			++_g;
			cleanVar(v1);
		}
		var build = function(kind,name,a) {
			var v = { id : hxsl_Tools.allocVarId(), name : name, type : hxsl_Type.TFun([{ ret : hxsl_Type.TVoid, args : []}]), kind : hxsl_VarKind.Function};
			outVars.push(v);
			var exprs = [];
			var _g = 0;
			while(_g < a.length) {
				var s = a[_g];
				++_g;
				var _g1 = s.body.e;
				if(_g1._hx_index == 4) {
					var el = _g1.el;
					var _g2 = 0;
					while(_g2 < el.length) {
						var e = el[_g2];
						++_g2;
						exprs.push(e);
					}
				} else {
					exprs.push(s.body);
				}
			}
			var expr = { e : hxsl_TExprDef.TBlock(exprs), t : hxsl_Type.TVoid, p : exprs.length == 0 ? null : exprs[0].p};
			_gthis.uniqueLocals(expr,new haxe_ds_StringMap());
			return { kind : kind, ref : v, ret : hxsl_Type.TVoid, args : [], expr : expr};
		};
		var funs = [build(hxsl_FunctionKind.Vertex,"vertex",v),build(hxsl_FunctionKind.Fragment,"fragment",f)];
		var s = dupShaders.keys();
		while(s.hasNext()) {
			var s1 = s.next();
			var sreal = dupShaders.h[s1.__id__];
			if(s1 == sreal) {
				continue;
			}
			var _g = 0;
			var _g1 = s1.vars.length;
			while(_g < _g1) {
				var i = _g++;
				this.allocVar(s1.vars[i],null).merged.unshift(sreal.vars[i]);
			}
		}
		return { name : "out", vars : outVars, funs : funs};
	}
	,__class__: hxsl_Linker
};
var hxsl_Output = $hxEnums["hxsl.Output"] = { __ename__:true,__constructs__:null
	,Const: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"hxsl.Output",toString:$estr}; },$_._hx_name="Const",$_.__params__ = ["v"],$_)
	,Value: ($_=function(v,size) { return {_hx_index:1,v:v,size:size,__enum__:"hxsl.Output",toString:$estr}; },$_._hx_name="Value",$_.__params__ = ["v","size"],$_)
	,PackNormal: ($_=function(v) { return {_hx_index:2,v:v,__enum__:"hxsl.Output",toString:$estr}; },$_._hx_name="PackNormal",$_.__params__ = ["v"],$_)
	,PackFloat: ($_=function(v) { return {_hx_index:3,v:v,__enum__:"hxsl.Output",toString:$estr}; },$_._hx_name="PackFloat",$_.__params__ = ["v"],$_)
	,Vec2: ($_=function(a) { return {_hx_index:4,a:a,__enum__:"hxsl.Output",toString:$estr}; },$_._hx_name="Vec2",$_.__params__ = ["a"],$_)
	,Vec3: ($_=function(a) { return {_hx_index:5,a:a,__enum__:"hxsl.Output",toString:$estr}; },$_._hx_name="Vec3",$_.__params__ = ["a"],$_)
	,Vec4: ($_=function(a) { return {_hx_index:6,a:a,__enum__:"hxsl.Output",toString:$estr}; },$_._hx_name="Vec4",$_.__params__ = ["a"],$_)
	,Swiz: ($_=function(a,swiz) { return {_hx_index:7,a:a,swiz:swiz,__enum__:"hxsl.Output",toString:$estr}; },$_._hx_name="Swiz",$_.__params__ = ["a","swiz"],$_)
};
hxsl_Output.__constructs__ = [hxsl_Output.Const,hxsl_Output.Value,hxsl_Output.PackNormal,hxsl_Output.PackFloat,hxsl_Output.Vec2,hxsl_Output.Vec3,hxsl_Output.Vec4,hxsl_Output.Swiz];
hxsl_Output.__empty_constructs__ = [];
var hxsl_Printer = function(varId) {
	if(varId == null) {
		varId = false;
	}
	this.varId = varId;
};
$hxClasses["hxsl.Printer"] = hxsl_Printer;
hxsl_Printer.__name__ = "hxsl.Printer";
hxsl_Printer.opStr = function(op) {
	switch(op._hx_index) {
	case 0:
		return "+";
	case 1:
		return "*";
	case 2:
		return "/";
	case 3:
		return "-";
	case 4:
		return "=";
	case 5:
		return "==";
	case 6:
		return "!=";
	case 7:
		return ">";
	case 8:
		return ">=";
	case 9:
		return "<";
	case 10:
		return "<=";
	case 11:
		return "&";
	case 12:
		return "|";
	case 13:
		return "^";
	case 14:
		return "&&";
	case 15:
		return "||";
	case 16:
		return "<<";
	case 17:
		return ">>";
	case 18:
		return ">>>";
	case 19:
		return "%";
	case 20:
		var op1 = op.op;
		return hxsl_Printer.opStr(op1) + "=";
	case 21:
		return "...";
	case 22:
		return "=>";
	default:
		return "??" + Std.string(op);
	}
};
hxsl_Printer.toString = function(e,varId) {
	if(varId == null) {
		varId = false;
	}
	return new hxsl_Printer(varId).exprString(e);
};
hxsl_Printer.shaderToString = function(s,varId) {
	if(varId == null) {
		varId = false;
	}
	return new hxsl_Printer(varId).shaderString(s);
};
hxsl_Printer.prototype = {
	shaderString: function(s) {
		this.buffer = new StringBuf();
		var _g = 0;
		var _g1 = s.vars;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			this.addVar(v,null);
			this.buffer.b += Std.string(";\n");
		}
		if(s.vars.length > 0) {
			this.buffer.b += Std.string("\n");
		}
		var _g = 0;
		var _g1 = s.funs;
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			this.addFun(f);
			this.buffer.b += Std.string("\n\n");
		}
		return this.buffer.b;
	}
	,exprString: function(e) {
		this.buffer = new StringBuf();
		this.addExpr(e,"");
		return this.buffer.b;
	}
	,addVar: function(v,defKind,tabs,parent) {
		if(tabs == null) {
			tabs = "";
		}
		if(v.qualifiers != null) {
			var _g = 0;
			var _g1 = v.qualifiers;
			while(_g < _g1.length) {
				var q = _g1[_g];
				++_g;
				var v1;
				switch(q._hx_index) {
				case 0:
					var max = q.max;
					v1 = "const" + (max == null ? "" : "(" + max + ")");
					break;
				case 1:
					v1 = "private";
					break;
				case 2:
					v1 = "nullable";
					break;
				case 3:
					v1 = "perObject";
					break;
				case 4:
					var n = q.n;
					v1 = "name('" + n + "')";
					break;
				case 5:
					v1 = "shared";
					break;
				case 6:
					var p = q.p;
					v1 = $hxEnums[p.__enum__].__constructs__[p._hx_index]._hx_name.toLowerCase() + "p";
					break;
				case 7:
					var min = q.min;
					var max1 = q.max;
					v1 = "range(" + min + "," + max1 + ")";
					break;
				case 8:
					v1 = "ignore";
					break;
				case 9:
					var n1 = q.v;
					v1 = "perInstance(" + n1 + ")";
					break;
				case 10:
					var s = q.s;
					v1 = "doc(\"" + StringTools.replace(s,"\"","\\\"") + "\")";
					break;
				case 11:
					var s1 = q.source;
					v1 = "borrow(" + s1 + ")";
					break;
				case 12:
					var s2 = q.name;
					v1 = "sampler(" + s2 + ")";
					break;
				}
				this.buffer.b += Std.string("@" + v1 + " ");
			}
		}
		if(v.kind != defKind) {
			switch(v.kind._hx_index) {
			case 0:
				this.buffer.b += Std.string("@global ");
				break;
			case 1:
				this.buffer.b += Std.string("@input ");
				break;
			case 2:
				this.buffer.b += Std.string("@param ");
				break;
			case 3:
				this.buffer.b += Std.string("@varying ");
				break;
			case 4:
				this.buffer.b += Std.string("@local ");
				break;
			case 5:
				this.buffer.b += Std.string("@output ");
				break;
			case 6:
				this.buffer.b += Std.string("@function ");
				break;
			}
		}
		this.buffer.b += Std.string("var ");
		if(v.parent == parent) {
			this.buffer.b += Std.string(v.name + (this.varId ? "@" + v.id : ""));
		} else {
			this.addVarName(v);
		}
		this.buffer.b += Std.string(" : ");
		var _g = v.type;
		if(_g._hx_index == 13) {
			var vl = _g.vl;
			this.buffer.b += Std.string("{");
			var first = true;
			var _g = 0;
			while(_g < vl.length) {
				var v1 = vl[_g];
				++_g;
				if(first) {
					first = false;
				} else {
					this.buffer.b += Std.string(", ");
				}
				this.addVar(v1,v1.kind,tabs,v1);
			}
			this.buffer.b += Std.string("}");
		} else {
			var v1 = hxsl_Tools.toString(v.type);
			this.buffer.b += Std.string(v1);
		}
	}
	,addFun: function(f) {
		this.buffer.b += Std.string("function " + f.ref.name + "(");
		var first = true;
		var _g = 0;
		var _g1 = f.args;
		while(_g < _g1.length) {
			var a = _g1[_g];
			++_g;
			if(first) {
				this.buffer.b += Std.string(" ");
				first = false;
			} else {
				this.buffer.b += Std.string(", ");
			}
			this.addVar(a,hxsl_VarKind.Local);
		}
		if(f.args.length > 0) {
			this.buffer.b += Std.string(" ");
		}
		var v = ") : " + hxsl_Tools.toString(f.ret) + " ";
		this.buffer.b += Std.string(v);
		this.addExpr(f.expr,"");
	}
	,addVarName: function(v) {
		if(v.parent != null) {
			this.addVarName(v.parent);
			this.buffer.b += Std.string(".");
		}
		this.buffer.b += Std.string(v.name);
		if(this.varId) {
			this.buffer.b += Std.string("@" + v.id);
		}
	}
	,addConst: function(c) {
		var _this = this.buffer;
		var _this1 = _this.b;
		var tmp;
		switch(c._hx_index) {
		case 0:
			tmp = "null";
			break;
		case 1:
			var b = c.b;
			tmp = b;
			break;
		case 2:
			var i = c.v;
			tmp = i;
			break;
		case 3:
			var f = c.v;
			tmp = f;
			break;
		case 4:
			var s = c.v;
			tmp = "\"" + s + "\"";
			break;
		}
		_this.b = _this1 + Std.string(tmp);
	}
	,addExpr: function(e,tabs) {
		var _g = e.e;
		switch(_g._hx_index) {
		case 0:
			var c = _g.c;
			this.addConst(c);
			break;
		case 1:
			var v = _g.v;
			this.addVarName(v);
			break;
		case 2:
			var g = _g.g;
			var v = hxsl_Tools2.toString(g);
			this.buffer.b += Std.string(v);
			break;
		case 3:
			var e = _g.e;
			this.buffer.b += Std.string("(");
			this.addExpr(e,tabs);
			this.buffer.b += Std.string(")");
			break;
		case 4:
			var el = _g.el;
			this.buffer.b += Std.string("{");
			tabs += "\t";
			var _g1 = 0;
			while(_g1 < el.length) {
				var e = el[_g1];
				++_g1;
				this.buffer.b += Std.string("\n" + tabs);
				this.addExpr(e,tabs);
				this.buffer.b += Std.string(";");
			}
			tabs = HxOverrides.substr(tabs,1,null);
			if(el.length > 0) {
				this.buffer.b += Std.string("\n" + tabs);
			}
			this.buffer.b += Std.string("}");
			break;
		case 5:
			var op = _g.op;
			var e1 = _g.e1;
			var e2 = _g.e2;
			this.addExpr(e1,tabs);
			var v = " " + hxsl_Printer.opStr(op) + " ";
			this.buffer.b += Std.string(v);
			this.addExpr(e2,tabs);
			break;
		case 6:
			var op = _g.op;
			var e = _g.e1;
			var v;
			switch(op._hx_index) {
			case 0:
				v = "++";
				break;
			case 1:
				v = "--";
				break;
			case 2:
				v = "!";
				break;
			case 3:
				v = "-";
				break;
			case 4:
				v = "~";
				break;
			default:
				throw haxe_Exception.thrown("assert");
			}
			this.buffer.b += Std.string(v);
			this.addExpr(e,tabs);
			break;
		case 7:
			var v = _g.v;
			var init = _g.init;
			this.addVar(v,hxsl_VarKind.Local,tabs);
			if(init != null) {
				this.buffer.b += Std.string(" = ");
				this.addExpr(init,tabs);
			}
			break;
		case 8:
			var e = _g.e;
			var el = _g.args;
			this.addExpr(e,tabs);
			this.buffer.b += Std.string("(");
			var first = true;
			var _g1 = 0;
			while(_g1 < el.length) {
				var e = el[_g1];
				++_g1;
				if(first) {
					first = false;
				} else {
					this.buffer.b += Std.string(", ");
				}
				this.addExpr(e,tabs);
			}
			this.buffer.b += Std.string(")");
			break;
		case 9:
			var e = _g.e;
			var regs = _g.regs;
			this.addExpr(e,tabs);
			this.buffer.b += Std.string(".");
			var _g1 = 0;
			while(_g1 < regs.length) {
				var r = regs[_g1];
				++_g1;
				this.buffer.b += Std.string(hxsl_Printer.SWIZ[r._hx_index]);
			}
			break;
		case 10:
			var cond = _g.econd;
			var eif = _g.eif;
			var eelse = _g.eelse;
			this.buffer.b += Std.string("if( ");
			this.addExpr(cond,tabs);
			this.buffer.b += Std.string(" ) ");
			this.addExpr(eif,tabs);
			if(eelse != null) {
				this.buffer.b += Std.string(" else ");
				this.addExpr(eelse,tabs);
			}
			break;
		case 11:
			this.buffer.b += Std.string("discard");
			break;
		case 12:
			var e = _g.e;
			this.buffer.b += Std.string("return");
			if(e != null) {
				this.buffer.b += Std.string(" ");
				this.addExpr(e,tabs);
			}
			break;
		case 13:
			var v = _g.v;
			var it = _g.it;
			var loop = _g.loop;
			this.buffer.b += Std.string("for( ");
			this.addVarName(v);
			this.buffer.b += Std.string(" in ");
			this.addExpr(it,tabs);
			this.buffer.b += Std.string(" ) ");
			this.addExpr(loop,tabs);
			break;
		case 14:
			this.buffer.b += Std.string("continue");
			break;
		case 15:
			this.buffer.b += Std.string("break");
			break;
		case 16:
			var e1 = _g.e;
			var e2 = _g.index;
			this.addExpr(e1,tabs);
			this.buffer.b += Std.string("[");
			this.addExpr(e2,tabs);
			this.buffer.b += Std.string("]");
			break;
		case 17:
			var el = _g.el;
			this.buffer.b += Std.string("[");
			var first = true;
			var _g1 = 0;
			while(_g1 < el.length) {
				var e = el[_g1];
				++_g1;
				if(first) {
					first = false;
				} else {
					this.buffer.b += Std.string(", ");
				}
				this.addExpr(e,tabs);
			}
			this.buffer.b += Std.string("]");
			break;
		case 18:
			var e = _g.e;
			var cases = _g.cases;
			var def = _g.def;
			this.buffer.b += Std.string("switch( ");
			this.addExpr(e,tabs);
			this.buffer.b += Std.string(") {");
			var old = tabs;
			var _g1 = 0;
			while(_g1 < cases.length) {
				var c = cases[_g1];
				++_g1;
				this.buffer.b += Std.string("\n" + tabs);
				this.buffer.b += Std.string("case ");
				var first = true;
				var _g2 = 0;
				var _g3 = c.values;
				while(_g2 < _g3.length) {
					var v = _g3[_g2];
					++_g2;
					if(first) {
						first = false;
					} else {
						this.buffer.b += Std.string(", ");
					}
					this.addExpr(v,tabs);
				}
				tabs += "\t";
				this.buffer.b += Std.string(":\n" + tabs);
				this.addExpr(c.expr,tabs);
				tabs = old;
			}
			if(def != null) {
				this.buffer.b += Std.string("\n" + tabs);
				tabs += "\t";
				this.buffer.b += Std.string("default:\n" + tabs);
				this.addExpr(def,tabs);
				tabs = old;
			}
			this.buffer.b += Std.string("\n" + tabs + "}");
			break;
		case 19:
			var _g1 = _g.e;
			var _g2 = _g.loop;
			if(_g.normalWhile == false) {
				var loop = _g2;
				var e = _g1;
				var old = tabs;
				tabs += "\t";
				this.buffer.b += Std.string("do {\n" + tabs);
				this.addExpr(loop,tabs);
				tabs = old;
				this.buffer.b += Std.string("\n" + tabs + "} while( ");
				this.addExpr(e,tabs);
				this.buffer.b += Std.string(" )");
			} else {
				var loop = _g2;
				var e = _g1;
				this.buffer.b += Std.string("while( ");
				this.addExpr(e,tabs);
				var old = tabs;
				tabs += "\t";
				this.buffer.b += Std.string(" ) {\n" + tabs);
				this.addExpr(loop,tabs);
				tabs = old;
				this.buffer.b += Std.string("\n" + tabs + "}");
			}
			break;
		case 20:
			var m = _g.m;
			var args = _g.args;
			var e = _g.e;
			this.buffer.b += Std.string("@");
			this.buffer.b += Std.string(m);
			if(args.length > 0) {
				this.buffer.b += Std.string("(");
				var first = true;
				var _g = 0;
				while(_g < args.length) {
					var c = args[_g];
					++_g;
					if(first) {
						first = false;
					} else {
						this.buffer.b += Std.string(", ");
					}
					this.addConst(c);
				}
				this.buffer.b += Std.string(")");
			}
			this.buffer.b += Std.string(" ");
			this.addExpr(e,tabs);
			break;
		}
	}
	,__class__: hxsl_Printer
};
var hxsl_AllocParam = function(name,pos,instance,index,type) {
	this.name = name;
	this.pos = pos;
	this.instance = instance;
	this.index = index;
	this.type = type;
};
$hxClasses["hxsl.AllocParam"] = hxsl_AllocParam;
hxsl_AllocParam.__name__ = "hxsl.AllocParam";
hxsl_AllocParam.prototype = {
	__class__: hxsl_AllocParam
};
var hxsl_AllocGlobal = function(pos,path,type) {
	this.pos = pos;
	this.path = path;
	this.gid = hxsl_Globals.allocID(path);
	this.type = type;
};
$hxClasses["hxsl.AllocGlobal"] = hxsl_AllocGlobal;
hxsl_AllocGlobal.__name__ = "hxsl.AllocGlobal";
hxsl_AllocGlobal.prototype = {
	__class__: hxsl_AllocGlobal
};
var hxsl_RuntimeShaderData = function() {
};
$hxClasses["hxsl.RuntimeShaderData"] = hxsl_RuntimeShaderData;
hxsl_RuntimeShaderData.__name__ = "hxsl.RuntimeShaderData";
hxsl_RuntimeShaderData.prototype = {
	__class__: hxsl_RuntimeShaderData
};
var hxsl_ShaderInstanceDesc = function(shader,bits) {
	this.shader = shader;
	this.bits = bits;
};
$hxClasses["hxsl.ShaderInstanceDesc"] = hxsl_ShaderInstanceDesc;
hxsl_ShaderInstanceDesc.__name__ = "hxsl.ShaderInstanceDesc";
hxsl_ShaderInstanceDesc.prototype = {
	__class__: hxsl_ShaderInstanceDesc
};
var hxsl_RuntimeShader = function() {
	this.id = hxsl_RuntimeShader.UID++;
};
$hxClasses["hxsl.RuntimeShader"] = hxsl_RuntimeShader;
hxsl_RuntimeShader.__name__ = "hxsl.RuntimeShader";
hxsl_RuntimeShader.prototype = {
	__class__: hxsl_RuntimeShader
};
var hxsl_Serializer = function() {
};
$hxClasses["hxsl.Serializer"] = hxsl_Serializer;
hxsl_Serializer.__name__ = "hxsl.Serializer";
hxsl_Serializer.prototype = {
	readVarInt: function() {
		var b = this.input.readByte();
		if(b < 128) {
			return b;
		}
		if(b == 255) {
			return this.input.readInt32();
		}
		return (b & 127) << 8 | this.input.readByte();
	}
	,readType: function() {
		switch(this.input.readByte()) {
		case 0:
			return hxsl_Type.TVoid;
		case 1:
			return hxsl_Type.TInt;
		case 2:
			return hxsl_Type.TBool;
		case 3:
			return hxsl_Type.TFloat;
		case 4:
			return hxsl_Type.TString;
		case 5:
			var bits = this.input.readByte();
			var v = hxsl_Serializer.TVECS.h[bits];
			if(v == null) {
				v = hxsl_Type.TVec(bits & 7,Type.createEnumIndex(hxsl_VecType,bits >> 3,null));
				hxsl_Serializer.TVECS.h[bits] = v;
			}
			return v;
		case 6:
			return hxsl_Type.TMat3;
		case 7:
			return hxsl_Type.TMat4;
		case 8:
			return hxsl_Type.TMat3x4;
		case 9:
			return hxsl_Type.TBytes(this.input.readInt32());
		case 10:
			return hxsl_Type.TSampler2D;
		case 11:
			return hxsl_Type.TSampler2DArray;
		case 12:
			return hxsl_Type.TSamplerCube;
		case 13:
			var id = this.readVarInt();
			var t = this.types[id];
			if(t != null) {
				return t;
			}
			var f = $bind(this,this.readVar);
			var _g = [];
			var _g1 = 0;
			var _g2 = this.readVarInt();
			while(_g1 < _g2) {
				var i = _g1++;
				_g.push(f());
			}
			t = hxsl_Type.TStruct(_g);
			this.types[id] = t;
			return t;
		case 14:
			return hxsl_Type.TFun(null);
		case 15:
			var t = this.readType();
			var v = this.readVar();
			return hxsl_Type.TArray(t,v == null ? hxsl_SizeDecl.SConst(this.readVarInt()) : hxsl_SizeDecl.SVar(v));
		case 16:
			var t = this.readType();
			var v = this.readVar();
			return hxsl_Type.TBuffer(t,v == null ? hxsl_SizeDecl.SConst(this.readVarInt()) : hxsl_SizeDecl.SVar(v));
		case 17:
			return hxsl_Type.TChannel(this.input.readByte());
		case 18:
			return hxsl_Type.TMat2;
		default:
			throw haxe_Exception.thrown("assert");
		}
	}
	,readString: function() {
		var len = this.readVarInt();
		var s = this.input.read(len).getString(0,len);
		return s;
	}
	,readConst: function() {
		switch(this.input.readByte()) {
		case 0:
			return hxsl_Const.CNull;
		case 1:
			return hxsl_Const.CBool(this.input.readByte() != 0);
		case 2:
			return hxsl_Const.CInt(this.input.readInt32());
		case 3:
			return hxsl_Const.CFloat(this.input.readDouble());
		case 4:
			return hxsl_Const.CString(this.readString());
		default:
			throw haxe_Exception.thrown("assert");
		}
	}
	,readExpr: function() {
		var _gthis = this;
		var k = this.input.readByte();
		if(k-- == 0) {
			return null;
		}
		var e;
		switch(k) {
		case 0:
			e = hxsl_TExprDef.TConst(this.readConst());
			break;
		case 1:
			e = hxsl_TExprDef.TVar(this.readVar());
			break;
		case 2:
			e = hxsl_TExprDef.TGlobal(hxsl_Serializer.TGLOBALS[this.input.readByte()]);
			break;
		case 3:
			e = hxsl_TExprDef.TParenthesis(this.readExpr());
			break;
		case 4:
			var f = $bind(this,this.readExpr);
			var _g = [];
			var _g1 = 0;
			var _g2 = this.readVarInt();
			while(_g1 < _g2) {
				var i = _g1++;
				_g.push(f());
			}
			e = hxsl_TExprDef.TBlock(_g);
			break;
		case 5:
			var op = this.input.readByte();
			e = hxsl_TExprDef.TBinop(op >= 128 ? haxe_macro_Binop.OpAssignOp(hxsl_Serializer.BOPS[op & 127]) : hxsl_Serializer.BOPS[op],this.readExpr(),this.readExpr());
			break;
		case 6:
			e = hxsl_TExprDef.TUnop(hxsl_Serializer.UNOPS[this.input.readByte()],this.readExpr());
			break;
		case 7:
			e = hxsl_TExprDef.TVarDecl(this.readVar(),this.readExpr());
			break;
		case 8:
			var e1 = this.readExpr();
			var f = $bind(this,this.readExpr);
			var _g = [];
			var _g1 = 0;
			var _g2 = this.readVarInt();
			while(_g1 < _g2) {
				var i = _g1++;
				_g.push(f());
			}
			e = hxsl_TExprDef.TCall(e1,_g);
			break;
		case 9:
			var e1 = this.readExpr();
			var bits = this.input.readUInt16();
			var swiz = hxsl_Serializer.TSWIZ.h[bits];
			if(swiz == null) {
				var _g = [];
				var _g1 = 0;
				var _g2 = (bits & 3) + 1;
				while(_g1 < _g2) {
					var i = _g1++;
					_g.push(hxsl_Serializer.REGS[bits >> i * 2 + 2 & 3]);
				}
				swiz = _g;
				hxsl_Serializer.TSWIZ.h[bits] = swiz;
			}
			e = hxsl_TExprDef.TSwiz(e1,swiz);
			break;
		case 10:
			e = hxsl_TExprDef.TIf(this.readExpr(),this.readExpr(),this.readExpr());
			break;
		case 11:
			e = hxsl_TExprDef.TDiscard;
			break;
		case 12:
			e = hxsl_TExprDef.TReturn(this.readExpr());
			break;
		case 13:
			e = hxsl_TExprDef.TFor(this.readVar(),this.readExpr(),this.readExpr());
			break;
		case 14:
			e = hxsl_TExprDef.TContinue;
			break;
		case 15:
			e = hxsl_TExprDef.TBreak;
			break;
		case 16:
			e = hxsl_TExprDef.TArray(this.readExpr(),this.readExpr());
			break;
		case 17:
			var f = $bind(this,this.readExpr);
			var _g = [];
			var _g1 = 0;
			var _g2 = this.readVarInt();
			while(_g1 < _g2) {
				var i = _g1++;
				_g.push(f());
			}
			e = hxsl_TExprDef.TArrayDecl(_g);
			break;
		case 18:
			var e1 = this.readExpr();
			var _g = [];
			var _g1 = 0;
			var _g2 = this.readVarInt();
			while(_g1 < _g2) {
				var i = _g1++;
				var f = $bind(_gthis,_gthis.readExpr);
				var _g3 = [];
				var _g4 = 0;
				var _g5 = _gthis.readVarInt();
				while(_g4 < _g5) {
					var i1 = _g4++;
					_g3.push(f());
				}
				_g.push({ values : _g3, expr : _gthis.readExpr()});
			}
			e = hxsl_TExprDef.TSwitch(e1,_g,this.readExpr());
			break;
		case 19:
			e = hxsl_TExprDef.TWhile(this.readExpr(),this.readExpr(),this.input.readByte() != 0);
			break;
		case 20:
			var e1 = this.readString();
			var f = $bind(this,this.readConst);
			var _g = [];
			var _g1 = 0;
			var _g2 = this.readVarInt();
			while(_g1 < _g2) {
				var i = _g1++;
				_g.push(f());
			}
			e = hxsl_TExprDef.TMeta(e1,_g,this.readExpr());
			break;
		default:
			throw haxe_Exception.thrown("assert");
		}
		return { e : e, t : this.readType(), p : null};
	}
	,readVar: function() {
		var id = this.readVarInt();
		if(id == 0) {
			return null;
		}
		var v = this.varMap.h[id];
		if(v != null) {
			return v;
		}
		v = { id : hxsl_Tools.allocVarId(), name : this.readString(), type : null, kind : null};
		this.varMap.h[id] = v;
		v.type = this.readType();
		v.kind = hxsl_Serializer.VKINDS[this.input.readByte()];
		v.parent = this.readVar();
		var nq = this.input.readByte();
		if(nq > 0) {
			v.qualifiers = [];
			var _g = 0;
			var _g1 = nq;
			while(_g < _g1) {
				var i = _g++;
				var qid = this.input.readByte();
				var q;
				switch(qid) {
				case 0:
					var n = this.input.readInt32();
					q = hxsl_VarQualifier.Const(n == 0 ? null : n);
					break;
				case 1:
					q = hxsl_VarQualifier.Private;
					break;
				case 2:
					q = hxsl_VarQualifier.Nullable;
					break;
				case 3:
					q = hxsl_VarQualifier.PerObject;
					break;
				case 4:
					q = hxsl_VarQualifier.Name(this.readString());
					break;
				case 5:
					q = hxsl_VarQualifier.Shared;
					break;
				case 6:
					q = hxsl_VarQualifier.Precision(hxsl_Serializer.PRECS[this.input.readByte()]);
					break;
				case 7:
					q = hxsl_VarQualifier.Range(this.input.readDouble(),this.input.readDouble());
					break;
				case 8:
					q = hxsl_VarQualifier.Ignore;
					break;
				case 9:
					q = hxsl_VarQualifier.PerInstance(this.input.readInt32());
					break;
				case 10:
					q = hxsl_VarQualifier.Doc(this.readString());
					break;
				case 11:
					q = hxsl_VarQualifier.Borrow(this.readString());
					break;
				case 12:
					q = hxsl_VarQualifier.Sampler(this.readString());
					break;
				default:
					throw haxe_Exception.thrown("assert");
				}
				v.qualifiers.push(q);
			}
		}
		return v;
	}
	,readFun: function() {
		var tmp = hxsl_Serializer.FKIND[this.input.readByte()];
		var tmp1 = this.readVar();
		var f = $bind(this,this.readVar);
		var _g = [];
		var _g1 = 0;
		var _g2 = this.readVarInt();
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push(f());
		}
		return { kind : tmp, ref : tmp1, args : _g, ret : this.readType(), expr : this.readExpr()};
	}
	,unserialize: function(data) {
		this.input = new haxe_io_BytesInput(haxe_crypto_Base64.decode(data,false));
		if(this.input.readByte() != (hxsl_Serializer.SIGN & 255) || this.input.readByte() != (hxsl_Serializer.SIGN >> 8 & 255) || this.input.readByte() != (hxsl_Serializer.SIGN >> 16 & 255)) {
			throw haxe_Exception.thrown("Invalid HXSL data");
		}
		this.varMap = new haxe_ds_IntMap();
		this.types = [];
		var tmp = this.readString();
		var f = $bind(this,this.readVar);
		var _g = [];
		var _g1 = 0;
		var _g2 = this.readVarInt();
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push(f());
		}
		var tmp1 = _g;
		var f = $bind(this,this.readFun);
		var _g = [];
		var _g1 = 0;
		var _g2 = this.readVarInt();
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push(f());
		}
		return { name : tmp, vars : tmp1, funs : _g};
	}
	,__class__: hxsl_Serializer
};
var hxsl_ShaderList = function(s,n) {
	this.s = s;
	this.next = n;
};
$hxClasses["hxsl.ShaderList"] = hxsl_ShaderList;
hxsl_ShaderList.__name__ = "hxsl.ShaderList";
hxsl_ShaderList.addSort = function(s,shaders) {
	var prev = null;
	var hd = shaders;
	while(hd != null && hd.s.priority < s.priority) {
		prev = hd;
		hd = hd.next;
	}
	if(prev == null) {
		var l = new hxsl_ShaderList(s,shaders);
		hxsl_ShaderList.checkSize(l);
		return l;
	}
	prev.next = new hxsl_ShaderList(s,prev.next);
	hxsl_ShaderList.checkSize(shaders);
	return shaders;
};
hxsl_ShaderList.checkSize = function(list) {
	if(hxsl_ShaderList.MAX_LIST_SIZE <= 0) {
		return;
	}
	var hd = list;
	var count = 0;
	while(hd != null) {
		if(!hxsl_ShaderList.ALLOW_DUPLICATES && hd.next != null && hd.next.s == hd.s) {
			throw haxe_Exception.thrown("Duplicate shader " + Std.string(hd.s));
		}
		++count;
		hd = hd.next;
	}
	if(count > hxsl_ShaderList.MAX_LIST_SIZE) {
		throw haxe_Exception.thrown("Too many shaders");
	}
};
hxsl_ShaderList.prototype = {
	__class__: hxsl_ShaderList
};
var hxsl_ShaderInstance = function(shader) {
	this.id = ++hxsl_ShaderInstance.UID;
	this.shader = shader;
	this.params = new haxe_ds_IntMap();
};
$hxClasses["hxsl.ShaderInstance"] = hxsl_ShaderInstance;
hxsl_ShaderInstance.__name__ = "hxsl.ShaderInstance";
hxsl_ShaderInstance.prototype = {
	__class__: hxsl_ShaderInstance
};
var hxsl_ShaderGlobal = function(v,gid) {
	this.v = v;
	this.globalId = gid;
};
$hxClasses["hxsl.ShaderGlobal"] = hxsl_ShaderGlobal;
hxsl_ShaderGlobal.__name__ = "hxsl.ShaderGlobal";
hxsl_ShaderGlobal.prototype = {
	__class__: hxsl_ShaderGlobal
};
var hxsl_ShaderConst = function(v,pos,bits) {
	this.v = v;
	this.pos = pos;
	this.bits = bits;
};
$hxClasses["hxsl.ShaderConst"] = hxsl_ShaderConst;
hxsl_ShaderConst.__name__ = "hxsl.ShaderConst";
hxsl_ShaderConst.prototype = {
	__class__: hxsl_ShaderConst
};
var hxsl_SharedShader = function(src) {
	this.instanceCache = new haxe_ds_IntMap();
	this.consts = null;
	this.globals = [];
	if(src == "") {
		return;
	}
	this.data = new hxsl_Serializer().unserialize(src);
	var _g = 0;
	var _g1 = this.data.vars;
	while(_g < _g1.length) {
		var v = _g1[_g];
		++_g;
		this.initVarId(v);
	}
	this.data = hxsl_SharedShader.compactMem(this.data);
	this.initialize();
};
$hxClasses["hxsl.SharedShader"] = hxsl_SharedShader;
hxsl_SharedShader.__name__ = "hxsl.SharedShader";
hxsl_SharedShader.compactMem = function(mem) {
	return mem;
};
hxsl_SharedShader.prototype = {
	initialize: function() {
		var _g = 0;
		var _g1 = this.data.vars;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			this.browseVar(v);
		}
	}
	,makeInstance: function(constBits) {
		var $eval = new hxsl_Eval();
		var c = this.consts;
		while(c != null) {
			var c1 = c.v;
			var _g = c.v.type;
			var tmp;
			switch(_g._hx_index) {
			case 1:
				tmp = hxsl_Const.CInt(constBits >>> c.pos & (1 << c.bits) - 1);
				break;
			case 2:
				tmp = hxsl_Const.CBool((constBits >>> c.pos & 1) != 0);
				break;
			case 17:
				var _g1 = _g.size;
				tmp = hxsl_Const.CInt(constBits >>> c.pos & (1 << c.bits) - 1);
				break;
			default:
				throw haxe_Exception.thrown("assert");
			}
			$eval.setConstant(c1,tmp);
			c = c.next;
		}
		$eval.inlineCalls = true;
		$eval.unrollLoops = hxsl_SharedShader.UNROLL_LOOPS;
		var edata = $eval.eval(this.data);
		edata = hxsl_SharedShader.compactMem(edata);
		var i = new hxsl_ShaderInstance(edata);
		this.paramsCount = 0;
		var _g = 0;
		var _g1 = this.data.vars;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			this.addParam($eval,i,v);
		}
		this.instanceCache.h[constBits] = i;
		return i;
	}
	,addParam: function($eval,i,v) {
		var _g = v.type;
		if(_g._hx_index == 13) {
			var vl = _g.vl;
			var _g = 0;
			while(_g < vl.length) {
				var v1 = vl[_g];
				++_g;
				this.addParam($eval,i,v1);
			}
		} else if(v.kind == hxsl_VarKind.Param) {
			i.params.h[$eval.varMap.h[v.__id__].id] = this.paramsCount;
			this.paramsCount++;
		}
	}
	,initVarId: function(v) {
		v.id = hxsl_Tools.allocVarId();
		var _g = v.type;
		if(_g._hx_index == 13) {
			var vl = _g.vl;
			var _g = 0;
			while(_g < vl.length) {
				var v = vl[_g];
				++_g;
				this.initVarId(v);
			}
		}
	}
	,browseVar: function(v,path) {
		if(path == null) {
			path = hxsl_Tools.getName(v);
		} else {
			path += "." + v.name;
		}
		var _g = v.type;
		if(_g._hx_index == 13) {
			var vl = _g.vl;
			var _g = 0;
			while(_g < vl.length) {
				var vs = vl[_g];
				++_g;
				this.browseVar(vs,path);
			}
		} else {
			var globalId = 0;
			if(v.kind == hxsl_VarKind.Global) {
				globalId = hxsl_Globals.allocID(path);
				this.globals.push(new hxsl_ShaderGlobal(v,globalId));
			}
			if(!hxsl_Tools.isConst(v)) {
				return;
			}
			var bits = hxsl_Tools.getConstBits(v);
			if(bits > 0) {
				var pos = this.consts == null ? 0 : this.consts.pos + this.consts.bits;
				var c = new hxsl_ShaderConst(v,pos,bits);
				c.globalId = globalId;
				c.next = this.consts;
				this.consts = c;
			}
		}
	}
	,__class__: hxsl_SharedShader
};
var hxsl__$Splitter_VarProps = function(v) {
	this.v = v;
	this.read = 0;
	this.write = 0;
};
$hxClasses["hxsl._Splitter.VarProps"] = hxsl__$Splitter_VarProps;
hxsl__$Splitter_VarProps.__name__ = "hxsl._Splitter.VarProps";
hxsl__$Splitter_VarProps.prototype = {
	__class__: hxsl__$Splitter_VarProps
};
var hxsl_Splitter = function() {
};
$hxClasses["hxsl.Splitter"] = hxsl_Splitter;
hxsl_Splitter.__name__ = "hxsl.Splitter";
hxsl_Splitter.prototype = {
	split: function(s) {
		var vfun = null;
		var vvars = new haxe_ds_IntMap();
		var ffun = null;
		var fvars = new haxe_ds_IntMap();
		this.varNames = new haxe_ds_StringMap();
		this.varMap = new haxe_ds_ObjectMap();
		var _g = 0;
		var _g1 = s.funs;
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			switch(f.kind._hx_index) {
			case 0:
				this.vars = vvars;
				vfun = f;
				this.checkExpr(f.expr);
				break;
			case 1:
				this.vars = fvars;
				ffun = f;
				this.checkExpr(f.expr);
				break;
			default:
				throw haxe_Exception.thrown("assert");
			}
		}
		vfun = { ret : vfun.ret, ref : vfun.ref, kind : vfun.kind, args : vfun.args, expr : this.mapVars(vfun.expr)};
		var _g = 0;
		var _g1 = Lambda.array(vvars);
		while(_g < _g1.length) {
			var inf = _g1[_g];
			++_g;
			var v = inf.v;
			switch(v.kind._hx_index) {
			case 3:case 4:
				v.kind = fvars.h.hasOwnProperty(v.id) ? hxsl_VarKind.Var : hxsl_VarKind.Local;
				break;
			default:
			}
			switch(v.kind._hx_index) {
			case 3:case 5:
				if(inf.read > 0 || inf.write > 1) {
					var nv = { id : hxsl_Tools.allocVarId(), name : v.name, kind : v.kind, type : v.type};
					this.vars = vvars;
					var ninf = this.get(nv);
					v.kind = hxsl_VarKind.Local;
					var p = vfun.expr.p;
					var e = { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,{ e : hxsl_TExprDef.TVar(nv), t : nv.type, p : p},{ e : hxsl_TExprDef.TVar(v), t : v.type, p : p}), t : nv.type, p : p};
					this.addExpr(vfun,e);
					this.checkExpr(e);
					if(nv.kind == hxsl_VarKind.Var) {
						var old = fvars.h[v.id];
						this.varMap.set(v,nv);
						fvars.remove(v.id);
						var np = new hxsl__$Splitter_VarProps(nv);
						np.read = old.read;
						np.write = old.write;
						fvars.h[nv.id] = np;
					}
				}
				break;
			default:
			}
		}
		var finits = [];
		var todo = [];
		var inf = fvars.iterator();
		while(inf.hasNext()) {
			var inf1 = inf.next();
			var v = inf1.v;
			switch(v.kind._hx_index) {
			case 1:
				var nv = { id : hxsl_Tools.allocVarId(), name : v.name, kind : hxsl_VarKind.Var, type : v.type};
				this.uniqueName(nv);
				var i = vvars.h[v.id];
				if(i == null) {
					i = new hxsl__$Splitter_VarProps(v);
					vvars.h[v.id] = i;
				}
				i.read++;
				var vp = new hxsl__$Splitter_VarProps(nv);
				vp.write = 1;
				vvars.h[nv.id] = vp;
				var fp = new hxsl__$Splitter_VarProps(nv);
				fp.read = 1;
				todo.push(fp);
				this.addExpr(vfun,{ e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,{ e : hxsl_TExprDef.TVar(nv), t : v.type, p : vfun.expr.p},{ e : hxsl_TExprDef.TVar(v), t : v.type, p : vfun.expr.p}), t : v.type, p : vfun.expr.p});
				this.varMap.set(v,nv);
				inf1.local = true;
				break;
			case 3:
				if(inf1.write > 0) {
					var nv1 = { id : hxsl_Tools.allocVarId(), name : v.name, kind : hxsl_VarKind.Local, type : v.type};
					this.uniqueName(nv1);
					finits.push({ e : hxsl_TExprDef.TVarDecl(nv1,{ e : hxsl_TExprDef.TVar(v), t : v.type, p : ffun.expr.p}), t : hxsl_Type.TVoid, p : ffun.expr.p});
					this.varMap.set(v,nv1);
				}
				break;
			default:
			}
		}
		var _g = 0;
		while(_g < todo.length) {
			var v = todo[_g];
			++_g;
			fvars.h[v.v.id] = v;
		}
		var v = vvars.iterator();
		while(v.hasNext()) {
			var v1 = v.next();
			this.checkVar(v1,true,vvars,vfun.expr.p);
		}
		var v = fvars.iterator();
		while(v.hasNext()) {
			var v1 = v.next();
			this.checkVar(v1,false,vvars,ffun.expr.p);
		}
		var v = this.varMap.keys();
		while(v.hasNext()) {
			var v1 = v.next();
			var v2 = this.varMap.h[this.varMap.h[v1.__id__].__id__];
			if(v2 != null) {
				this.varMap.set(v1,v2);
			}
		}
		ffun = { ret : ffun.ret, ref : ffun.ref, kind : ffun.kind, args : ffun.args, expr : this.mapVars(ffun.expr)};
		var _g = ffun.expr.e;
		if(_g._hx_index == 4) {
			var el = _g.el;
			var _g = 0;
			while(_g < finits.length) {
				var e = finits[_g];
				++_g;
				el.unshift(e);
			}
		} else {
			finits.push(ffun.expr);
			ffun.expr = { e : hxsl_TExprDef.TBlock(finits), t : hxsl_Type.TVoid, p : ffun.expr.p};
		}
		var _g = [];
		var v = vvars.iterator();
		while(v.hasNext()) {
			var v1 = v.next();
			if(!v1.local) {
				_g.push(v1.v);
			}
		}
		var vvars = _g;
		var _g = [];
		var v = fvars.iterator();
		while(v.hasNext()) {
			var v1 = v.next();
			if(!v1.local) {
				_g.push(v1.v);
			}
		}
		var fvars = _g;
		vvars.sort(function(v1,v2) {
			return v1.id - v2.id;
		});
		fvars.sort(function(v1,v2) {
			return v1.id - v2.id;
		});
		return { vertex : { name : "vertex", vars : vvars, funs : [vfun]}, fragment : { name : "fragment", vars : fvars, funs : [ffun]}};
	}
	,addExpr: function(f,e) {
		var _g = f.expr.e;
		if(_g._hx_index == 4) {
			var el = _g.el;
			el.push(e);
		} else {
			f.expr = { e : hxsl_TExprDef.TBlock([f.expr,e]), t : hxsl_Type.TVoid, p : f.expr.p};
		}
	}
	,checkVar: function(v,vertex,vvars,p) {
		switch(v.v.kind._hx_index) {
		case 3:
			if(!vertex) {
				var i = vvars.h[v.v.id];
				if(i == null || i.write == 0) {
					throw haxe_Exception.thrown(new hxsl_Error("Varying " + v.v.name + " is not written by vertex shader",p));
				}
			}
			break;
		case 4:
			if(v.requireInit) {
				throw haxe_Exception.thrown(new hxsl_Error("Variable " + v.v.name + " is used without being initialized",p));
			}
			break;
		default:
		}
	}
	,mapVars: function(e) {
		var _g = e.e;
		switch(_g._hx_index) {
		case 1:
			var v = _g.v;
			var v2 = this.varMap.h[v.__id__];
			if(v2 == null) {
				return e;
			} else {
				return { e : hxsl_TExprDef.TVar(v2), t : e.t, p : e.p};
			}
			break;
		case 7:
			var v = _g.v;
			var init = _g.init;
			var v2 = this.varMap.h[v.__id__];
			if(v2 == null) {
				return hxsl_Tools.map(e,$bind(this,this.mapVars));
			} else {
				return { e : hxsl_TExprDef.TVarDecl(v2,this.mapVars(init)), t : e.t, p : e.p};
			}
			break;
		case 13:
			var v = _g.v;
			var it = _g.it;
			var loop = _g.loop;
			var v2 = this.varMap.h[v.__id__];
			if(v2 == null) {
				return hxsl_Tools.map(e,$bind(this,this.mapVars));
			} else {
				return { e : hxsl_TExprDef.TFor(v2,this.mapVars(it),this.mapVars(loop)), t : e.t, p : e.p};
			}
			break;
		default:
			return hxsl_Tools.map(e,$bind(this,this.mapVars));
		}
	}
	,get: function(v) {
		var i = this.vars.h[v.id];
		if(i == null) {
			var v2 = this.varMap.h[v.__id__];
			if(v2 != null) {
				return this.get(v2);
			}
			var oldName = v.name;
			this.uniqueName(v);
			if(v.kind == hxsl_VarKind.Local && oldName != v.name) {
				var nv = { id : hxsl_Tools.allocVarId(), name : v.name, kind : v.kind, type : v.type};
				this.varMap.set(v,nv);
				v.name = oldName;
				v = nv;
			}
			i = new hxsl__$Splitter_VarProps(v);
			this.vars.h[v.id] = i;
		}
		return i;
	}
	,uniqueName: function(v) {
		if(v.kind == hxsl_VarKind.Global || v.kind == hxsl_VarKind.Output || v.kind == hxsl_VarKind.Input) {
			return;
		}
		v.parent = null;
		var n = this.varNames.h[v.name];
		if(n != null && n != v) {
			var prefix = v.name;
			while(HxOverrides.cca(prefix,prefix.length - 1) >= 48 && HxOverrides.cca(prefix,prefix.length - 1) <= 57) prefix = HxOverrides.substr(prefix,0,-1);
			var k = prefix == v.name ? 2 : Std.parseInt(HxOverrides.substr(v.name,prefix.length,null));
			while(Object.prototype.hasOwnProperty.call(this.varNames.h,prefix + k)) ++k;
			v.name = prefix + k;
		}
		this.varNames.h[v.name] = v;
	}
	,checkExpr: function(e) {
		var _g = e.e;
		switch(_g._hx_index) {
		case 1:
			var v = _g.v;
			var inf = this.get(v);
			if(inf.write == 0) {
				inf.requireInit = true;
			}
			inf.read++;
			break;
		case 5:
			var _g1 = _g.op;
			var _g2 = _g.e1;
			var _g3 = _g.e2;
			switch(_g1._hx_index) {
			case 4:
				var _g4 = _g2.e;
				var _g5 = _g2.p;
				var _g5 = _g2.t;
				switch(_g4._hx_index) {
				case 1:
					var v = _g4.v;
					var e1 = _g3;
					var inf = this.get(v);
					inf.write++;
					this.checkExpr(e1);
					break;
				case 9:
					var _g5 = _g4.e;
					var _g6 = _g4.regs;
					var _g4 = _g5.e;
					var _g6 = _g5.p;
					var _g6 = _g5.t;
					if(_g4._hx_index == 1) {
						var v = _g4.v;
						var e1 = _g3;
						var inf = this.get(v);
						inf.write++;
						this.checkExpr(e1);
					} else {
						hxsl_Tools.iter(e,$bind(this,this.checkExpr));
					}
					break;
				default:
					hxsl_Tools.iter(e,$bind(this,this.checkExpr));
				}
				break;
			case 20:
				var _g4 = _g1.op;
				var _g1 = _g2.e;
				var _g4 = _g2.p;
				var _g4 = _g2.t;
				switch(_g1._hx_index) {
				case 1:
					var v = _g1.v;
					var e1 = _g3;
					var inf = this.get(v);
					if(inf.write == 0) {
						inf.requireInit = true;
					}
					inf.read++;
					inf.write++;
					this.checkExpr(e1);
					break;
				case 9:
					var _g2 = _g1.e;
					var _g4 = _g1.regs;
					var _g1 = _g2.e;
					var _g4 = _g2.p;
					var _g4 = _g2.t;
					if(_g1._hx_index == 1) {
						var v = _g1.v;
						var e1 = _g3;
						var inf = this.get(v);
						if(inf.write == 0) {
							inf.requireInit = true;
						}
						inf.read++;
						inf.write++;
						this.checkExpr(e1);
					} else {
						hxsl_Tools.iter(e,$bind(this,this.checkExpr));
					}
					break;
				default:
					hxsl_Tools.iter(e,$bind(this,this.checkExpr));
				}
				break;
			default:
				hxsl_Tools.iter(e,$bind(this,this.checkExpr));
			}
			break;
		case 7:
			var v = _g.v;
			var init = _g.init;
			var inf = this.get(v);
			inf.local = true;
			if(init != null) {
				this.checkExpr(init);
				inf.write++;
			}
			break;
		case 13:
			var v = _g.v;
			var it = _g.it;
			var loop = _g.loop;
			this.checkExpr(it);
			var inf = this.get(v);
			inf.local = true;
			inf.write++;
			this.checkExpr(loop);
			break;
		default:
			hxsl_Tools.iter(e,$bind(this,this.checkExpr));
		}
	}
	,__class__: hxsl_Splitter
};
var js_html__$CanvasElement_CanvasUtil = function() { };
$hxClasses["js.html._CanvasElement.CanvasUtil"] = js_html__$CanvasElement_CanvasUtil;
js_html__$CanvasElement_CanvasUtil.__name__ = "js.html._CanvasElement.CanvasUtil";
js_html__$CanvasElement_CanvasUtil.getContextWebGL = function(canvas,attribs) {
	var name = "webgl";
	var ctx = canvas.getContext(name,attribs);
	if(ctx != null) {
		return ctx;
	}
	var name = "experimental-webgl";
	var ctx = canvas.getContext(name,attribs);
	if(ctx != null) {
		return ctx;
	}
	return null;
};
Math.__name__ = "Math";
var stb_format_tools_Crc32 = function() { };
$hxClasses["stb.format.tools.Crc32"] = stb_format_tools_Crc32;
stb_format_tools_Crc32.__name__ = "stb.format.tools.Crc32";
stb_format_tools_Crc32.init = function() {
	if(stb_format_tools_Crc32.table != null) {
		return;
	}
	var this1 = new Array(256);
	stb_format_tools_Crc32.table = this1;
	var _g = 0;
	while(_g < 256) {
		var i = _g++;
		var s = i << 24;
		s = s << 1 ^ (UInt.gte(s,1 << 31) ? 79764919 : 0);
		s = s << 1 ^ (UInt.gte(s,1 << 31) ? 79764919 : 0);
		s = s << 1 ^ (UInt.gte(s,1 << 31) ? 79764919 : 0);
		s = s << 1 ^ (UInt.gte(s,1 << 31) ? 79764919 : 0);
		s = s << 1 ^ (UInt.gte(s,1 << 31) ? 79764919 : 0);
		s = s << 1 ^ (UInt.gte(s,1 << 31) ? 79764919 : 0);
		s = s << 1 ^ (UInt.gte(s,1 << 31) ? 79764919 : 0);
		s = s << 1 ^ (UInt.gte(s,1 << 31) ? 79764919 : 0);
		stb_format_tools_Crc32.table[i] = s;
	}
};
var stb_format_vorbis_Reader = function(input,seekFunc,inputLength) {
	this.seekFunc = seekFunc;
	this.inputLength = inputLength;
	this.decoder = stb_format_vorbis_VorbisDecoder.start(input);
	this.decoder.setupSampleNumber(seekFunc,inputLength);
	this.loopStart = this.get_header().comment.get_loopStart();
	this.loopLength = this.get_header().comment.get_loopLength();
};
$hxClasses["stb.format.vorbis.Reader"] = stb_format_vorbis_Reader;
stb_format_vorbis_Reader.__name__ = "stb.format.vorbis.Reader";
stb_format_vorbis_Reader.openFromBytes = function(bytes) {
	var input = new haxe_io_BytesInput(bytes);
	var bytes1 = input;
	return new stb_format_vorbis_Reader(input,function(pos) {
		stb_format_vorbis_Reader.seekBytes(bytes1,pos);
	},bytes.length);
};
stb_format_vorbis_Reader.seekBytes = function(bytes,pos) {
	bytes.set_position(pos);
};
stb_format_vorbis_Reader.prototype = {
	get_header: function() {
		return this.decoder.header;
	}
	,get_totalSample: function() {
		return this.decoder.totalSample;
	}
	,set_currentSample: function(value) {
		this.decoder.seek(this.seekFunc,this.inputLength,value);
		return this.decoder.currentSample;
	}
	,read: function(output,samples,channels,sampleRate,useFloat) {
		if(useFloat == null) {
			useFloat = false;
		}
		this.decoder.ensurePosition(this.seekFunc);
		if(samples == null) {
			samples = this.decoder.totalSample;
		}
		if(channels == null) {
			channels = this.get_header().channel;
		}
		if(sampleRate == null) {
			sampleRate = this.get_header().sampleRate;
		}
		return this.decoder.read(output,samples,channels,sampleRate,useFloat);
	}
	,__class__: stb_format_vorbis_Reader
};
var stb_format_vorbis_VorbisDecodeState = function(input) {
	this.nextSeg = 0;
	this.firstDecode = false;
	this.bytesInSeg = 0;
	this.validBits = 0;
	this.input = input;
	this.inputPosition = 0;
	this.page = new stb_format_vorbis_data_Page();
	stb_format_tools_Crc32.init();
};
$hxClasses["stb.format.vorbis.VorbisDecodeState"] = stb_format_vorbis_VorbisDecodeState;
stb_format_vorbis_VorbisDecodeState.__name__ = "stb.format.vorbis.VorbisDecodeState";
stb_format_vorbis_VorbisDecodeState.prototype = {
	setup: function(loc0,loc1) {
		this.inputPosition += 1;
		var segmentCount = this.input.readByte();
		this.inputPosition += segmentCount;
		var this1 = new Array(segmentCount);
		var vec = this1;
		var _g = 0;
		var _g1 = segmentCount;
		while(_g < _g1) {
			var i = _g++;
			vec[i] = this.input.readByte();
		}
		this.segments = vec;
		this.endSegWithKnownLoc = -2;
		if(loc0 != -1 || loc1 != -1) {
			var i = segmentCount - 1;
			while(i >= 0) {
				if(this.segments[i] < 255) {
					break;
				}
				if(i >= 0) {
					this.endSegWithKnownLoc = i;
					this.knownLocForPacket = loc0;
				}
				--i;
			}
		}
		if(this.firstDecode) {
			var i = 0;
			var len = 0;
			var p = new stb_format_vorbis_data_ProbedPage();
			var _g = 0;
			var _g1 = segmentCount;
			while(_g < _g1) {
				var i = _g++;
				len += this.segments[i];
			}
			len += 27 + segmentCount;
			p.pageStart = this.firstAudioPageOffset;
			p.pageEnd = p.pageStart + len;
			p.firstDecodedSample = 0;
			p.lastDecodedSample = loc0;
			this.pFirst = p;
		}
		this.nextSeg = 0;
	}
	,clone: function(seekFunc) {
		var state = Object.create(stb_format_vorbis_VorbisDecodeState.prototype);
		seekFunc(this.inputPosition);
		state.input = this.input;
		state.eof = this.eof;
		state.validBits = this.validBits;
		state.discardSamplesDeferred = this.discardSamplesDeferred;
		state.firstDecode = this.firstDecode;
		state.nextSeg = this.nextSeg;
		state.bytesInSeg = this.bytesInSeg;
		state.acc = state.acc;
		state.lastSeg = this.lastSeg;
		state.lastSegWhich = this.lastSegWhich;
		state.currentLoc = this.currentLoc;
		state.currentLocValid = this.currentLocValid;
		state.inputPosition = this.inputPosition;
		state.firstAudioPageOffset = this.firstAudioPageOffset;
		state.error = this.error;
		state.segments = this.segments;
		state.pFirst = this.pFirst;
		state.pLast = this.pLast;
		state.page = this.page.clone();
		return state;
	}
	,next: function() {
		if(this.lastSeg) {
			return 0;
		}
		if(this.nextSeg == -1) {
			this.lastSegWhich = this.segments.length - 1;
			try {
				this.page.start(this);
			} catch( _g ) {
				var _g1 = haxe_Exception.caught(_g).unwrap();
				if(((_g1) instanceof stb_format_vorbis_data_ReaderError)) {
					var e = _g1;
					this.lastSeg = true;
					this.error = e;
					return 0;
				} else {
					throw _g;
				}
			}
			if((this.page.flag & 1) == 0) {
				throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.CONTINUED_PACKET_FLAG_INVALID,null,{ fileName : "stb/format/vorbis/VorbisDecodeState.hx", lineNumber : 171, className : "stb.format.vorbis.VorbisDecodeState", methodName : "next"}));
			}
		}
		var len = this.segments[this.nextSeg++];
		if(len < 255) {
			this.lastSeg = true;
			this.lastSegWhich = this.nextSeg - 1;
		}
		if(this.nextSeg >= this.segments.length) {
			this.nextSeg = -1;
		}
		this.bytesInSeg = len;
		return len;
	}
	,startPacket: function() {
		while(this.nextSeg == -1) {
			this.page.start(this);
			if((this.page.flag & 1) != 0) {
				throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.MISSING_CAPTURE_PATTERN,null,{ fileName : "stb/format/vorbis/VorbisDecodeState.hx", lineNumber : 193, className : "stb.format.vorbis.VorbisDecodeState", methodName : "startPacket"}));
			}
		}
		this.lastSeg = false;
		this.validBits = 0;
		this.bytesInSeg = 0;
	}
	,maybeStartPacket: function() {
		if(this.nextSeg == -1) {
			var eof = false;
			var x;
			try {
				this.inputPosition += 1;
				x = this.input.readByte();
			} catch( _g ) {
				if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
					eof = true;
					x = 0;
				} else {
					throw _g;
				}
			}
			if(eof) {
				return false;
			}
			var tmp;
			var tmp1;
			var tmp2;
			if(x == 79) {
				this.inputPosition += 1;
				tmp2 = this.input.readByte() != 103;
			} else {
				tmp2 = true;
			}
			if(!tmp2) {
				this.inputPosition += 1;
				tmp1 = this.input.readByte() != 103;
			} else {
				tmp1 = true;
			}
			if(!tmp1) {
				this.inputPosition += 1;
				tmp = this.input.readByte() != 83;
			} else {
				tmp = true;
			}
			if(tmp) {
				throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.MISSING_CAPTURE_PATTERN,null,{ fileName : "stb/format/vorbis/VorbisDecodeState.hx", lineNumber : 218, className : "stb.format.vorbis.VorbisDecodeState", methodName : "maybeStartPacket"}));
			}
			this.page.startWithoutCapturePattern(this);
		}
		this.startPacket();
		return true;
	}
	,readBits: function(n) {
		if(this.validBits < 0) {
			return 0;
		} else if(this.validBits < n) {
			if(n > 24) {
				return this.readBits(24) + (this.readBits(n - 24) << 24);
			} else {
				if(this.validBits == 0) {
					this.acc = 0;
				}
				while(true) {
					if(this.bytesInSeg == 0 && (this.lastSeg || this.next() == 0)) {
						this.validBits = -1;
						break;
					} else {
						this.bytesInSeg--;
						this.inputPosition += 1;
						this.acc = this.acc + (this.input.readByte() << this.validBits);
						this.validBits += 8;
					}
					if(!(this.validBits < n)) {
						break;
					}
				}
				if(this.validBits < 0) {
					return 0;
				} else {
					var z = this.acc & (1 << n) - 1;
					this.acc = this.acc >>> n;
					this.validBits -= n;
					return z;
				}
			}
		} else {
			var z = this.acc & (1 << n) - 1;
			this.acc = this.acc >>> n;
			this.validBits -= n;
			return z;
		}
	}
	,firstPageValidate: function() {
		if(this.segments.length != 1) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_FIRST_PAGE,"segmentCount",{ fileName : "stb/format/vorbis/VorbisDecodeState.hx", lineNumber : 307, className : "stb.format.vorbis.VorbisDecodeState", methodName : "firstPageValidate"}));
		}
		if(this.segments[0] != 30) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_FIRST_PAGE,"decodeState head",{ fileName : "stb/format/vorbis/VorbisDecodeState.hx", lineNumber : 310, className : "stb.format.vorbis.VorbisDecodeState", methodName : "firstPageValidate"}));
		}
	}
	,startFirstDecode: function() {
		this.firstAudioPageOffset = this.inputPosition;
		this.firstDecode = true;
	}
	,prepHuffman: function() {
		if(this.validBits <= 24) {
			if(this.validBits == 0) {
				this.acc = 0;
			}
			while(true) {
				if(this.bytesInSeg == 0 && (this.lastSeg || this.next() == 0)) {
					return;
				} else {
					this.bytesInSeg--;
					this.inputPosition += 1;
					this.acc = this.acc + (this.input.readByte() << this.validBits);
					this.validBits += 8;
				}
				if(!(this.validBits <= 24)) {
					break;
				}
			}
		}
	}
	,finishDecodePacket: function(previousLength,n,r) {
		var left = r.left.start;
		var currentLocValid = false;
		var n2 = n >> 1;
		if(this.firstDecode) {
			this.currentLoc = -n2;
			this.discardSamplesDeferred = n - r.right.end;
			currentLocValid = true;
			this.firstDecode = false;
		} else if(this.discardSamplesDeferred != 0) {
			r.left.start += this.discardSamplesDeferred;
			left = r.left.start;
			this.discardSamplesDeferred = 0;
		} else {
			var tmp = previousLength == 0 && currentLocValid;
		}
		if(this.lastSegWhich == this.endSegWithKnownLoc) {
			if(currentLocValid && (this.page.flag & 4) != 0) {
				var currentEnd = this.knownLocForPacket - (n - r.right.end);
				if(currentEnd < this.currentLoc + r.right.end) {
					var len = currentEnd < this.currentLoc ? 0 : currentEnd - this.currentLoc;
					len += r.left.start;
					this.currentLoc += len;
					return { len : len, left : left, right : r.right.start};
				}
			}
			this.currentLoc = this.knownLocForPacket - (n2 - r.left.start);
			currentLocValid = true;
		}
		if(currentLocValid) {
			this.currentLoc += r.right.start - r.left.start;
		}
		return { len : r.right.end, left : left, right : r.right.start};
	}
	,getSampleNumber: function(seekFunc,inputLength) {
		var restoreOffset = this.inputPosition;
		var previousSafe = UInt.gte(inputLength,65536) && UInt.gte(inputLength - 65536,this.firstAudioPageOffset) ? inputLength - 65536 : this.firstAudioPageOffset;
		seekFunc(this.inputPosition = previousSafe);
		var end = 0;
		var last = false;
		var _g = this.findPage(seekFunc,inputLength);
		switch(_g._hx_index) {
		case 0:
			var e = _g.end;
			var l = _g.last;
			end = e;
			last = l;
			break;
		case 1:
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.CANT_FIND_LAST_PAGE,null,{ fileName : "stb/format/vorbis/VorbisDecodeState.hx", lineNumber : 518, className : "stb.format.vorbis.VorbisDecodeState", methodName : "getSampleNumber"}));
		}
		var lastPageLoc = this.inputPosition;
		_hx_loop1: while(!last) {
			seekFunc(this.inputPosition = end);
			var _g = this.findPage(seekFunc,inputLength);
			switch(_g._hx_index) {
			case 0:
				var e = _g.end;
				var l = _g.last;
				end = e;
				last = l;
				break;
			case 1:
				break _hx_loop1;
			}
			previousSafe = lastPageLoc + 1;
			lastPageLoc = this.inputPosition;
		}
		seekFunc(this.inputPosition = lastPageLoc);
		this.inputPosition += 6;
		var this1 = new Array(6);
		var vec = this1;
		var _g = 0;
		var _g1 = 6;
		while(_g < _g1) {
			var i = _g++;
			vec[i] = this.input.readByte();
		}
		var vorbisHeader = vec;
		this.inputPosition += 4;
		var lo = this.input.readInt32();
		this.inputPosition += 4;
		var hi = this.input.readInt32();
		if(lo == -1 && hi == -1 || hi > 0) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.CANT_FIND_LAST_PAGE,null,{ fileName : "stb/format/vorbis/VorbisDecodeState.hx", lineNumber : 552, className : "stb.format.vorbis.VorbisDecodeState", methodName : "getSampleNumber"}));
		}
		this.pLast = new stb_format_vorbis_data_ProbedPage();
		this.pLast.pageStart = lastPageLoc;
		this.pLast.pageEnd = end;
		this.pLast.lastDecodedSample = lo;
		this.pLast.firstDecodedSample = null;
		this.pLast.afterPreviousPageStart = previousSafe;
		seekFunc(this.inputPosition = restoreOffset);
		return lo;
	}
	,findPage: function(seekFunc,inputLength) {
		try {
			while(true) {
				this.inputPosition += 1;
				var n = this.input.readByte();
				if(n == 79) {
					var retryLoc = this.inputPosition;
					if(retryLoc - 25 > inputLength) {
						return stb_format_vorbis__$VorbisDecodeState_FindPageResult.NotFound;
					}
					var tmp;
					var tmp1;
					this.inputPosition += 1;
					if(this.input.readByte() == 103) {
						this.inputPosition += 1;
						tmp1 = this.input.readByte() != 103;
					} else {
						tmp1 = true;
					}
					if(!tmp1) {
						this.inputPosition += 1;
						tmp = this.input.readByte() != 83;
					} else {
						tmp = true;
					}
					if(tmp) {
						continue;
					}
					var this1 = new Array(27);
					var header = this1;
					header[0] = 79;
					header[1] = 103;
					header[2] = 103;
					header[3] = 83;
					this.inputPosition += 1;
					header[4] = this.input.readByte();
					this.inputPosition += 1;
					header[5] = this.input.readByte();
					this.inputPosition += 1;
					header[6] = this.input.readByte();
					this.inputPosition += 1;
					header[7] = this.input.readByte();
					this.inputPosition += 1;
					header[8] = this.input.readByte();
					this.inputPosition += 1;
					header[9] = this.input.readByte();
					this.inputPosition += 1;
					header[10] = this.input.readByte();
					this.inputPosition += 1;
					header[11] = this.input.readByte();
					this.inputPosition += 1;
					header[12] = this.input.readByte();
					this.inputPosition += 1;
					header[13] = this.input.readByte();
					this.inputPosition += 1;
					header[14] = this.input.readByte();
					this.inputPosition += 1;
					header[15] = this.input.readByte();
					this.inputPosition += 1;
					header[16] = this.input.readByte();
					this.inputPosition += 1;
					header[17] = this.input.readByte();
					this.inputPosition += 1;
					header[18] = this.input.readByte();
					this.inputPosition += 1;
					header[19] = this.input.readByte();
					this.inputPosition += 1;
					header[20] = this.input.readByte();
					this.inputPosition += 1;
					header[21] = this.input.readByte();
					this.inputPosition += 1;
					header[22] = this.input.readByte();
					this.inputPosition += 1;
					header[23] = this.input.readByte();
					this.inputPosition += 1;
					header[24] = this.input.readByte();
					this.inputPosition += 1;
					header[25] = this.input.readByte();
					this.inputPosition += 1;
					header[26] = this.input.readByte();
					if(header[4] != 0) {
						seekFunc(this.inputPosition = retryLoc);
						continue;
					}
					var goal = header[22] + (header[23] << 8) + (header[24] << 16) + (header[25] << 24);
					header[22] = 0;
					header[23] = 0;
					header[24] = 0;
					header[25] = 0;
					var crc = 0;
					var _g = 0;
					while(_g < 27) {
						var i = _g++;
						crc = crc << 8 ^ stb_format_tools_Crc32.table[header[i] ^ crc >>> 24];
					}
					var len = 0;
					try {
						var _g1 = 0;
						var _g2 = header[26];
						while(_g1 < _g2) {
							var i1 = _g1++;
							this.inputPosition += 1;
							var s = this.input.readByte();
							crc = crc << 8 ^ stb_format_tools_Crc32.table[s ^ crc >>> 24];
							len += s;
						}
						var _g3 = 0;
						var _g4 = len;
						while(_g3 < _g4) {
							var i2 = _g3++;
							this.inputPosition += 1;
							var byte = this.input.readByte();
							crc = crc << 8 ^ stb_format_tools_Crc32.table[byte ^ crc >>> 24];
						}
					} catch( _g5 ) {
						if(((haxe_Exception.caught(_g5).unwrap()) instanceof haxe_io_Eof)) {
							return stb_format_vorbis__$VorbisDecodeState_FindPageResult.NotFound;
						} else {
							throw _g5;
						}
					}
					if(crc == goal) {
						var end = this.inputPosition;
						seekFunc(this.inputPosition = retryLoc - 1);
						return stb_format_vorbis__$VorbisDecodeState_FindPageResult.Found(end,(header[5] & 4) != 0);
					}
				}
			}
		} catch( _g ) {
			if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
				return stb_format_vorbis__$VorbisDecodeState_FindPageResult.NotFound;
			} else {
				throw _g;
			}
		}
	}
	,analyzePage: function(seekFunc,h) {
		var z = new stb_format_vorbis_data_ProbedPage();
		var this1 = new Array(255);
		var packetType = this1;
		z.pageStart = this.inputPosition;
		this.inputPosition += 27;
		var this1 = new Array(27);
		var vec = this1;
		var _g = 0;
		var _g1 = 27;
		while(_g < _g1) {
			var i = _g++;
			vec[i] = this.input.readByte();
		}
		var pageHeader = vec;
		var n = pageHeader[26];
		this.inputPosition += n;
		var this1 = new Array(n);
		var vec = this1;
		var _g = 0;
		var _g1 = n;
		while(_g < _g1) {
			var i = _g++;
			vec[i] = this.input.readByte();
		}
		var lacing = vec;
		var len = 0;
		var _g = 0;
		var _g1 = pageHeader[26];
		while(_g < _g1) {
			var i = _g++;
			len += lacing[i];
		}
		z.pageEnd = z.pageStart + 27 + pageHeader[26] + len;
		z.lastDecodedSample = pageHeader[6] + (pageHeader[7] << 8) + (pageHeader[8] << 16) + (pageHeader[9] << 16);
		if((pageHeader[5] & 4) != 0) {
			z.firstDecodedSample = null;
			seekFunc(this.inputPosition = z.pageStart);
			return z;
		}
		var numPacket = 0;
		var packetStart = (pageHeader[5] & 1) == 0;
		var modeCount = h.modes.length;
		var _g = 0;
		var _g1 = pageHeader[26];
		while(_g < _g1) {
			var i = _g++;
			if(packetStart) {
				if(lacing[i] == 0) {
					seekFunc(this.inputPosition = z.pageStart);
					return null;
				}
				this.inputPosition += 1;
				var n = this.input.readByte();
				if((n & 1) != 0) {
					seekFunc(this.inputPosition = z.pageStart);
					return null;
				}
				n >>= 1;
				var n1 = modeCount - 1;
				var log2_4 = [0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4];
				var b = n1 < 16384 ? n1 < 16 ? log2_4[n1] : n1 < 512 ? 5 + log2_4[n1 >> 5] : 10 + log2_4[n1 >> 10] : n1 < 16777216 ? n1 < 524288 ? 15 + log2_4[n1 >> 15] : 20 + log2_4[n1 >> 20] : n1 < 536870912 ? 25 + log2_4[n1 >> 25] : n1 < -2147483648 ? 30 + log2_4[n1 >> 30] : 0;
				n &= (1 << b) - 1;
				if(n >= modeCount) {
					seekFunc(this.inputPosition = z.pageStart);
					return null;
				}
				packetType[numPacket++] = h.modes[n].blockflag;
				var len = lacing[i] - 1;
				this.inputPosition += len;
				var this1 = new Array(len);
				var vec = this1;
				var _g2 = 0;
				var _g3 = len;
				while(_g2 < _g3) {
					var i1 = _g2++;
					vec[i1] = this.input.readByte();
				}
			} else {
				var len1 = lacing[i];
				this.inputPosition += len1;
				var this2 = new Array(len1);
				var vec1 = this2;
				var _g4 = 0;
				var _g5 = len1;
				while(_g4 < _g5) {
					var i2 = _g4++;
					vec1[i2] = this.input.readByte();
				}
			}
			packetStart = lacing[i] < 255;
		}
		var samples = 0;
		if(numPacket > 1) {
			samples += packetType[numPacket - 1] ? h.blocksize1 : h.blocksize0;
		}
		var i = numPacket - 2;
		while(i >= 1) {
			--i;
			if(packetType[i]) {
				if(packetType[i + 1]) {
					samples += h.blocksize1 >> 1;
				} else {
					samples += (h.blocksize1 - h.blocksize0 >> 2) + (h.blocksize0 >> 1);
				}
			} else {
				samples += h.blocksize0 >> 1;
			}
			--i;
		}
		z.firstDecodedSample = z.lastDecodedSample - samples;
		seekFunc(this.inputPosition = z.pageStart);
		return z;
	}
	,decodeScalarRaw: function(c) {
		this.prepHuffman();
		var codewordLengths = c.codewordLengths;
		var codewords = c.codewords;
		var sortedCodewords = c.sortedCodewords;
		if(c.entries > 8 ? sortedCodewords != null : codewords != null) {
			var n = this.acc;
			n = (n & -1431655766) >>> 1 | (n & 1431655765) << 1;
			n = (n & -858993460) >>> 2 | (n & 858993459) << 2;
			n = (n & -252645136) >>> 4 | (n & 252645135) << 4;
			n = (n & -16711936) >>> 8 | (n & 16711935) << 8;
			var code = n >>> 16 | n << 16;
			var x = 0;
			var n = c.sortedEntries;
			while(n > 1) {
				var m = x + (n >> 1);
				if(UInt.gte(code,sortedCodewords[m])) {
					x = m;
					n -= n >> 1;
				} else {
					n >>= 1;
				}
			}
			if(!c.sparse) {
				x = c.sortedValues[x];
			}
			var len = codewordLengths[x];
			if(this.validBits >= len) {
				this.acc = this.acc >>> len;
				this.validBits -= len;
				return x;
			}
			this.validBits = 0;
			return -1;
		}
		var _g = 0;
		var _g1 = c.entries;
		while(_g < _g1) {
			var i = _g++;
			var cl = codewordLengths[i];
			if(cl == 255) {
				continue;
			}
			if(codewords[i] == (this.acc & (1 << cl) - 1)) {
				if(this.validBits >= cl) {
					this.acc = this.acc >>> cl;
					this.validBits -= cl;
					return i;
				}
				this.validBits = 0;
				return -1;
			}
		}
		this.error = new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_STREAM,null,{ fileName : "stb/format/vorbis/VorbisDecodeState.hx", lineNumber : 846, className : "stb.format.vorbis.VorbisDecodeState", methodName : "decodeScalarRaw"});
		this.validBits = 0;
		return -1;
	}
	,__class__: stb_format_vorbis_VorbisDecodeState
};
var stb_format_vorbis__$VorbisDecodeState_FindPageResult = $hxEnums["stb.format.vorbis._VorbisDecodeState.FindPageResult"] = { __ename__:true,__constructs__:null
	,Found: ($_=function(end,last) { return {_hx_index:0,end:end,last:last,__enum__:"stb.format.vorbis._VorbisDecodeState.FindPageResult",toString:$estr}; },$_._hx_name="Found",$_.__params__ = ["end","last"],$_)
	,NotFound: {_hx_name:"NotFound",_hx_index:1,__enum__:"stb.format.vorbis._VorbisDecodeState.FindPageResult",toString:$estr}
};
stb_format_vorbis__$VorbisDecodeState_FindPageResult.__constructs__ = [stb_format_vorbis__$VorbisDecodeState_FindPageResult.Found,stb_format_vorbis__$VorbisDecodeState_FindPageResult.NotFound];
stb_format_vorbis__$VorbisDecodeState_FindPageResult.__empty_constructs__ = [stb_format_vorbis__$VorbisDecodeState_FindPageResult.NotFound];
var stb_format_vorbis_VorbisDecoder = function(header,decodeState) {
	this.header = header;
	this.decodeState = decodeState;
	this.totalSample = null;
	this.currentSample = 0;
	this.previousLength = 0;
	var this1 = new Array(header.channel);
	this.channelBuffers = this1;
	var this1 = new Array(header.channel);
	this.previousWindow = this1;
	var this1 = new Array(header.channel);
	this.finalY = this1;
	var _g = 0;
	var _g1 = header.channel;
	while(_g < _g1) {
		var i = _g++;
		var this1 = this.channelBuffers;
		var this2 = new Array(header.blocksize1);
		var vec = this2;
		this1[i] = vec;
		var this3 = this.previousWindow;
		var this4 = new Array(header.blocksize1 / 2 | 0);
		var vec1 = this4;
		this3[i] = vec1;
		this.finalY[i] = [];
	}
	var this1 = new Array(2);
	this.a = this1;
	var this1 = new Array(2);
	this.b = this1;
	var this1 = new Array(2);
	this.c = this1;
	var this1 = new Array(2);
	this.window = this1;
	var this1 = new Array(2);
	this.bitReverseData = this1;
	this.initBlocksize(0,header.blocksize0);
	this.initBlocksize(1,header.blocksize1);
};
$hxClasses["stb.format.vorbis.VorbisDecoder"] = stb_format_vorbis_VorbisDecoder;
stb_format_vorbis_VorbisDecoder.__name__ = "stb.format.vorbis.VorbisDecoder";
stb_format_vorbis_VorbisDecoder.start = function(input) {
	var decodeState = new stb_format_vorbis_VorbisDecodeState(input);
	var header = stb_format_vorbis_data_Header.read(decodeState);
	var decoder = new stb_format_vorbis_VorbisDecoder(header,decodeState);
	decodeState.startFirstDecode();
	decoder.pumpFirstFrame();
	return decoder;
};
stb_format_vorbis_VorbisDecoder.prototype = {
	read: function(output,samples,channels,sampleRate,useFloat) {
		var b = this.header.sampleRate;
		if((UInt.toFloat(sampleRate) % UInt.toFloat(b) | 0) != 0) {
			throw haxe_Exception.thrown("Unsupported sampleRate : can't convert " + (this.header.sampleRate == null ? "null" : Std.string(UInt.toFloat(this.header.sampleRate))) + " to " + sampleRate);
		}
		if(channels % this.header.channel != 0) {
			throw haxe_Exception.thrown("Unsupported channels : can't convert " + this.header.channel + " to " + channels);
		}
		var b = this.header.sampleRate;
		var sampleRepeat = UInt.toFloat(sampleRate) / UInt.toFloat(b) | 0;
		var channelRepeat = channels / this.header.channel | 0;
		var n = 0;
		var len = Math.floor(samples / sampleRepeat);
		if(this.totalSample != null && len > this.totalSample - this.currentSample) {
			len = this.totalSample - this.currentSample;
		}
		while(n < len) {
			var k = this.channelBufferEnd - this.channelBufferStart;
			if(k >= len - n) {
				k = len - n;
			}
			var _g = this.channelBufferStart;
			var _g1 = this.channelBufferStart + k;
			while(_g < _g1) {
				var j = _g++;
				var _g2 = 0;
				var _g3 = sampleRepeat;
				while(_g2 < _g3) {
					var sr = _g2++;
					var _g4 = 0;
					var _g5 = this.header.channel;
					while(_g4 < _g5) {
						var i = _g4++;
						var _g6 = 0;
						var _g7 = channelRepeat;
						while(_g6 < _g7) {
							var cr = _g6++;
							var value = this.channelBuffers[i][j];
							if(value > 1) {
								value = 1;
							} else if(value < -1) {
								value = -1;
							}
							if(useFloat) {
								output.writeFloat(value);
							} else {
								output.writeInt16(Math.floor(value * 32767));
							}
						}
					}
				}
			}
			n += k;
			this.channelBufferStart += k;
			if(n == len || this.getFrameFloat() == 0) {
				break;
			}
		}
		var _g = n;
		var _g1 = len;
		while(_g < _g1) {
			var j = _g++;
			var _g2 = 0;
			var _g3 = sampleRepeat;
			while(_g2 < _g3) {
				var sr = _g2++;
				var _g4 = 0;
				var _g5 = this.header.channel;
				while(_g4 < _g5) {
					var i = _g4++;
					var _g6 = 0;
					var _g7 = channelRepeat;
					while(_g6 < _g7) {
						var cr = _g6++;
						if(useFloat) {
							output.writeFloat(0);
						} else {
							output.writeInt16(0);
						}
					}
				}
			}
		}
		this.currentSample += len;
		return len * sampleRepeat;
	}
	,skipSamples: function(len) {
		var n = 0;
		if(this.totalSample != null && len > this.totalSample - this.currentSample) {
			len = this.totalSample - this.currentSample;
		}
		while(n < len) {
			var k = this.channelBufferEnd - this.channelBufferStart;
			if(k >= len - n) {
				k = len - n;
			}
			n += k;
			this.channelBufferStart += k;
			if(n == len || this.getFrameFloat() == 0) {
				break;
			}
		}
		this.currentSample += len;
		return len;
	}
	,setupSampleNumber: function(seekFunc,inputLength) {
		if(this.totalSample == null) {
			this.totalSample = this.decodeState.getSampleNumber(seekFunc,inputLength);
		}
	}
	,seek: function(seekFunc,inputLength,sampleNumber) {
		if(this.currentSample == sampleNumber) {
			return;
		}
		if(this.totalSample == null) {
			this.setupSampleNumber(seekFunc,inputLength);
			if(this.totalSample == 0) {
				throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.CANT_FIND_LAST_PAGE,null,{ fileName : "stb/format/vorbis/VorbisDecoder.hx", lineNumber : 182, className : "stb.format.vorbis.VorbisDecoder", methodName : "seek"}));
			}
		}
		if(sampleNumber < 0) {
			sampleNumber = 0;
		}
		var p0 = this.decodeState.pFirst;
		var p1 = this.decodeState.pLast;
		if(sampleNumber >= p1.lastDecodedSample) {
			sampleNumber = p1.lastDecodedSample - 1;
		}
		if(sampleNumber < p0.lastDecodedSample) {
			this.seekFrameFromPage(seekFunc,p0.pageStart,0,sampleNumber);
		} else {
			var attempts = 0;
			while(p0.pageEnd < p1.pageStart) {
				var startOffset = p0.pageEnd;
				var endOffset = p1.afterPreviousPageStart;
				var startSample = p0.lastDecodedSample;
				var endSample = p1.lastDecodedSample;
				if(startSample == null || endSample == null) {
					throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.SEEK_FAILED,null,{ fileName : "stb/format/vorbis/VorbisDecoder.hx", lineNumber : 214, className : "stb.format.vorbis.VorbisDecoder", methodName : "seek"}));
				}
				if(UInt.gt(endOffset,startOffset + 4000)) {
					endOffset = endOffset - 4000;
				}
				var probe = startOffset + Math.floor(UInt.toFloat(endOffset - startOffset) / UInt.toFloat(endSample - startSample) * (sampleNumber - startSample));
				if(attempts >= 4) {
					var probe2 = startOffset + (endOffset - startOffset >>> 1);
					probe = attempts >= 8 ? probe2 : UInt.gt(probe2,probe) ? probe + (probe2 - probe >>> 1) : probe2 + (probe - probe2 >>> 1);
				}
				++attempts;
				seekFunc(this.decodeState.inputPosition = probe);
				var _g = this.decodeState.findPage(seekFunc,inputLength);
				switch(_g._hx_index) {
				case 0:
					var _g1 = _g.end;
					var _g2 = _g.last;
					break;
				case 1:
					throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.SEEK_FAILED,null,{ fileName : "stb/format/vorbis/VorbisDecoder.hx", lineNumber : 244, className : "stb.format.vorbis.VorbisDecoder", methodName : "seek"}));
				}
				var q = this.decodeState.analyzePage(seekFunc,this.header);
				if(q == null) {
					throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.SEEK_FAILED,null,{ fileName : "stb/format/vorbis/VorbisDecoder.hx", lineNumber : 250, className : "stb.format.vorbis.VorbisDecoder", methodName : "seek"}));
				}
				q.afterPreviousPageStart = probe;
				if(q.pageStart == p1.pageStart) {
					p1 = q;
					continue;
				}
				if(sampleNumber < q.lastDecodedSample) {
					p1 = q;
				} else {
					p0 = q;
				}
			}
			if(p0.lastDecodedSample <= sampleNumber && sampleNumber < p1.lastDecodedSample) {
				this.seekFrameFromPage(seekFunc,p1.pageStart,p0.lastDecodedSample,sampleNumber);
			} else {
				throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.SEEK_FAILED,null,{ fileName : "stb/format/vorbis/VorbisDecoder.hx", lineNumber : 270, className : "stb.format.vorbis.VorbisDecoder", methodName : "seek"}));
			}
		}
	}
	,seekFrameFromPage: function(seekFunc,pageStart,firstSample,targetSample) {
		var frame = 0;
		var frameStart = firstSample;
		seekFunc(this.decodeState.inputPosition = pageStart);
		this.decodeState.nextSeg = -1;
		var leftEnd = 0;
		var leftStart = 0;
		var prevState = null;
		var lastState = null;
		while(true) {
			prevState = lastState;
			lastState = this.decodeState.clone(seekFunc);
			var initialResult = this.decodeInitial();
			if(initialResult == null) {
				lastState = prevState;
				break;
			}
			leftStart = initialResult.left.start;
			leftEnd = initialResult.left.end;
			var start = frame == 0 ? leftEnd : leftStart;
			if(targetSample < frameStart + initialResult.right.start - start) {
				break;
			}
			var _this = this.decodeState;
			while(_this.bytesInSeg != 0 || !_this.lastSeg && _this.next() != 0) {
				_this.bytesInSeg--;
				_this.inputPosition += 1;
				_this.input.readByte();
			}
			frameStart += initialResult.right.start - start;
			++frame;
		}
		this.decodeState = lastState;
		seekFunc(this.decodeState.inputPosition);
		this.previousLength = 0;
		this.pumpFirstFrame();
		this.currentSample = frameStart;
		this.skipSamples(targetSample - frameStart);
	}
	,ensurePosition: function(seekFunc) {
		seekFunc(this.decodeState.inputPosition);
	}
	,getFrameFloat: function() {
		var result = this.decodePacket();
		if(result == null) {
			this.channelBufferStart = this.channelBufferEnd = 0;
			return 0;
		}
		var len = this.finishFrame(result);
		this.channelBufferStart = result.left;
		this.channelBufferEnd = result.left + len;
		return len;
	}
	,pumpFirstFrame: function() {
		this.finishFrame(this.decodePacket());
	}
	,finishFrame: function(r) {
		var len = r.len;
		var right = r.right;
		var left = r.left;
		if(this.previousLength != 0) {
			var n = this.previousLength;
			var w = this.getWindow(n);
			var _g = 0;
			var _g1 = this.header.channel;
			while(_g < _g1) {
				var i = _g++;
				var cb = this.channelBuffers[i];
				var pw = this.previousWindow[i];
				var _g2 = 0;
				var _g3 = n;
				while(_g2 < _g3) {
					var j = _g2++;
					cb[left + j] = cb[left + j] * w[j] + pw[j] * w[n - 1 - j];
				}
			}
		}
		var prev = this.previousLength;
		this.previousLength = len - right;
		var _g = 0;
		var _g1 = this.header.channel;
		while(_g < _g1) {
			var i = _g++;
			var pw = this.previousWindow[i];
			var cb = this.channelBuffers[i];
			var _g2 = 0;
			var _g3 = len - right;
			while(_g2 < _g3) {
				var j = _g2++;
				pw[j] = cb[right + j];
			}
		}
		if(prev == 0) {
			return 0;
		}
		if(len < right) {
			right = len;
		}
		return right - left;
	}
	,getWindow: function(len) {
		len <<= 1;
		if(len == this.header.blocksize0) {
			return this.window[0];
		} else if(len == this.header.blocksize1) {
			return this.window[1];
		} else {
			return null;
		}
	}
	,initBlocksize: function(bs,n) {
		var n2 = n >> 1;
		var n4 = n >> 2;
		var n8 = n >> 3;
		var this1 = this.a;
		var this2 = new Array(n2);
		this1[bs] = this2;
		var this1 = this.b;
		var this2 = new Array(n2);
		this1[bs] = this2;
		var this1 = this.c;
		var this2 = new Array(n4);
		this1[bs] = this2;
		var this1 = this.window;
		var this2 = new Array(n2);
		this1[bs] = this2;
		var this1 = this.bitReverseData;
		var this2 = new Array(n8);
		this1[bs] = this2;
		stb_format_vorbis_VorbisTools.computeTwiddleFactors(n,this.a[bs],this.b[bs],this.c[bs]);
		stb_format_vorbis_VorbisTools.computeWindow(n,this.window[bs]);
		stb_format_vorbis_VorbisTools.computeBitReverse(n,this.bitReverseData[bs]);
	}
	,inverseMdct: function(buffer,n,blocktype) {
		var bt = blocktype ? 1 : 0;
		var a = this.a[bt];
		var b = this.b[bt];
		var c = this.c[bt];
		var bitReverse = this.bitReverseData[bt];
		var n2 = n >> 1;
		var n4 = n >> 2;
		var n8 = n >> 3;
		var this1 = new Array(n2);
		var buf2 = this1;
		var dOffset = n2 - 2;
		var aaOffset = 0;
		var eOffset = 0;
		var eStopOffset = n2;
		while(eOffset != eStopOffset) {
			buf2[dOffset + 1] = buffer[eOffset] * a[aaOffset] - buffer[eOffset + 2] * a[aaOffset + 1];
			buf2[dOffset] = buffer[eOffset] * a[aaOffset + 1] + buffer[eOffset + 2] * a[aaOffset];
			dOffset -= 2;
			aaOffset += 2;
			eOffset += 4;
		}
		eOffset = n2 - 3;
		while(dOffset >= 0) {
			buf2[dOffset + 1] = -buffer[eOffset + 2] * a[aaOffset] - -buffer[eOffset] * a[aaOffset + 1];
			buf2[dOffset] = -buffer[eOffset + 2] * a[aaOffset + 1] + -buffer[eOffset] * a[aaOffset];
			dOffset -= 2;
			aaOffset += 2;
			eOffset -= 4;
		}
		var u = buffer;
		var v = buf2;
		var aaOffset = n2 - 8;
		var eOffset0 = n4;
		var eOffset1 = 0;
		var dOffset0 = n4;
		var dOffset1 = 0;
		while(aaOffset >= 0) {
			var v41_21 = v[eOffset0 + 1] - v[eOffset1 + 1];
			var v40_20 = v[eOffset0] - v[eOffset1];
			u[dOffset0 + 1] = v[eOffset0 + 1] + v[eOffset1 + 1];
			u[dOffset0] = v[eOffset0] + v[eOffset1];
			u[dOffset1 + 1] = v41_21 * a[aaOffset + 4] - v40_20 * a[aaOffset + 5];
			u[dOffset1] = v40_20 * a[aaOffset + 4] + v41_21 * a[aaOffset + 5];
			v41_21 = v[eOffset0 + 3] - v[eOffset1 + 3];
			v40_20 = v[eOffset0 + 2] - v[eOffset1 + 2];
			u[dOffset0 + 3] = v[eOffset0 + 3] + v[eOffset1 + 3];
			u[dOffset0 + 2] = v[eOffset0 + 2] + v[eOffset1 + 2];
			u[dOffset1 + 3] = v41_21 * a[aaOffset] - v40_20 * a[aaOffset + 1];
			u[dOffset1 + 2] = v40_20 * a[aaOffset] + v41_21 * a[aaOffset + 1];
			aaOffset -= 8;
			dOffset0 += 4;
			dOffset1 += 4;
			eOffset0 += 4;
			eOffset1 += 4;
		}
		var log2_4 = [0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4];
		var ld = (n < 16384 ? n < 16 ? log2_4[n] : n < 512 ? 5 + log2_4[n >> 5] : 10 + log2_4[n >> 10] : n < 16777216 ? n < 524288 ? 15 + log2_4[n >> 15] : 20 + log2_4[n >> 20] : n < 536870912 ? 25 + log2_4[n >> 25] : n < -2147483648 ? 30 + log2_4[n >> 30] : 0) - 1;
		var i_off = n2 - 1 - n4 * 0;
		var eeOffset0 = i_off;
		var eeOffset2 = i_off + -(n >> 3);
		var aOffset = 0;
		var i = (n >> 4 >> 2) + 1;
		while(--i > 0) {
			var k00_20 = u[eeOffset0] - u[eeOffset2];
			var k01_21 = u[eeOffset0 + (-1)] - u[eeOffset2 + (-1)];
			u[eeOffset0] += u[eeOffset2];
			u[eeOffset0 + (-1)] += u[eeOffset2 + (-1)];
			u[eeOffset2] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
			u[eeOffset2 + (-1)] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
			aOffset += 8;
			k00_20 = u[eeOffset0 + (-2)] - u[eeOffset2 + (-2)];
			k01_21 = u[eeOffset0 + (-3)] - u[eeOffset2 + (-3)];
			u[eeOffset0 + (-2)] += u[eeOffset2 + (-2)];
			u[eeOffset0 + (-3)] += u[eeOffset2 + (-3)];
			u[eeOffset2 + (-2)] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
			u[eeOffset2 + (-3)] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
			aOffset += 8;
			k00_20 = u[eeOffset0 + (-4)] - u[eeOffset2 + (-4)];
			k01_21 = u[eeOffset0 + (-5)] - u[eeOffset2 + (-5)];
			u[eeOffset0 + (-4)] += u[eeOffset2 + (-4)];
			u[eeOffset0 + (-5)] += u[eeOffset2 + (-5)];
			u[eeOffset2 + (-4)] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
			u[eeOffset2 + (-5)] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
			aOffset += 8;
			k00_20 = u[eeOffset0 + (-6)] - u[eeOffset2 + (-6)];
			k01_21 = u[eeOffset0 + (-7)] - u[eeOffset2 + (-7)];
			u[eeOffset0 + (-6)] += u[eeOffset2 + (-6)];
			u[eeOffset0 + (-7)] += u[eeOffset2 + (-7)];
			u[eeOffset2 + (-6)] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
			u[eeOffset2 + (-7)] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
			aOffset += 8;
			eeOffset0 -= 8;
			eeOffset2 -= 8;
		}
		var i_off = n2 - 1 - n4;
		var eeOffset0 = i_off;
		var eeOffset2 = i_off + -(n >> 3);
		var aOffset = 0;
		var i = (n >> 4 >> 2) + 1;
		while(--i > 0) {
			var k00_20 = u[eeOffset0] - u[eeOffset2];
			var k01_21 = u[eeOffset0 + (-1)] - u[eeOffset2 + (-1)];
			u[eeOffset0] += u[eeOffset2];
			u[eeOffset0 + (-1)] += u[eeOffset2 + (-1)];
			u[eeOffset2] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
			u[eeOffset2 + (-1)] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
			aOffset += 8;
			k00_20 = u[eeOffset0 + (-2)] - u[eeOffset2 + (-2)];
			k01_21 = u[eeOffset0 + (-3)] - u[eeOffset2 + (-3)];
			u[eeOffset0 + (-2)] += u[eeOffset2 + (-2)];
			u[eeOffset0 + (-3)] += u[eeOffset2 + (-3)];
			u[eeOffset2 + (-2)] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
			u[eeOffset2 + (-3)] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
			aOffset += 8;
			k00_20 = u[eeOffset0 + (-4)] - u[eeOffset2 + (-4)];
			k01_21 = u[eeOffset0 + (-5)] - u[eeOffset2 + (-5)];
			u[eeOffset0 + (-4)] += u[eeOffset2 + (-4)];
			u[eeOffset0 + (-5)] += u[eeOffset2 + (-5)];
			u[eeOffset2 + (-4)] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
			u[eeOffset2 + (-5)] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
			aOffset += 8;
			k00_20 = u[eeOffset0 + (-6)] - u[eeOffset2 + (-6)];
			k01_21 = u[eeOffset0 + (-7)] - u[eeOffset2 + (-7)];
			u[eeOffset0 + (-6)] += u[eeOffset2 + (-6)];
			u[eeOffset0 + (-7)] += u[eeOffset2 + (-7)];
			u[eeOffset2 + (-6)] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
			u[eeOffset2 + (-7)] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
			aOffset += 8;
			eeOffset0 -= 8;
			eeOffset2 -= 8;
		}
		var d0 = n2 - 1 - n8 * 0;
		var aOffset = 0;
		var eOffset0 = d0;
		var eOffset2 = d0 + -(n >> 4);
		var i = (n >> 5 >> 2) + 1;
		while(--i > 0) {
			var k00_20 = u[eOffset0] - u[eOffset2];
			var k01_21 = u[eOffset0 + (-1)] - u[eOffset2 + (-1)];
			u[eOffset0] += u[eOffset2];
			u[eOffset0 + (-1)] += u[eOffset2 + (-1)];
			u[eOffset2] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
			u[eOffset2 + (-1)] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
			aOffset += 16;
			k00_20 = u[eOffset0 + (-2)] - u[eOffset2 + (-2)];
			k01_21 = u[eOffset0 + (-3)] - u[eOffset2 + (-3)];
			u[eOffset0 + (-2)] += u[eOffset2 + (-2)];
			u[eOffset0 + (-3)] += u[eOffset2 + (-3)];
			u[eOffset2 + (-2)] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
			u[eOffset2 + (-3)] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
			aOffset += 16;
			k00_20 = u[eOffset0 + (-4)] - u[eOffset2 + (-4)];
			k01_21 = u[eOffset0 + (-5)] - u[eOffset2 + (-5)];
			u[eOffset0 + (-4)] += u[eOffset2 + (-4)];
			u[eOffset0 + (-5)] += u[eOffset2 + (-5)];
			u[eOffset2 + (-4)] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
			u[eOffset2 + (-5)] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
			aOffset += 16;
			k00_20 = u[eOffset0 + (-6)] - u[eOffset2 + (-6)];
			k01_21 = u[eOffset0 + (-7)] - u[eOffset2 + (-7)];
			u[eOffset0 + (-6)] += u[eOffset2 + (-6)];
			u[eOffset0 + (-7)] += u[eOffset2 + (-7)];
			u[eOffset2 + (-6)] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
			u[eOffset2 + (-7)] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
			eOffset0 -= 8;
			eOffset2 -= 8;
			aOffset += 16;
		}
		var d0 = n2 - 1 - n8;
		var aOffset = 0;
		var eOffset0 = d0;
		var eOffset2 = d0 + -(n >> 4);
		var i = (n >> 5 >> 2) + 1;
		while(--i > 0) {
			var k00_20 = u[eOffset0] - u[eOffset2];
			var k01_21 = u[eOffset0 + (-1)] - u[eOffset2 + (-1)];
			u[eOffset0] += u[eOffset2];
			u[eOffset0 + (-1)] += u[eOffset2 + (-1)];
			u[eOffset2] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
			u[eOffset2 + (-1)] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
			aOffset += 16;
			k00_20 = u[eOffset0 + (-2)] - u[eOffset2 + (-2)];
			k01_21 = u[eOffset0 + (-3)] - u[eOffset2 + (-3)];
			u[eOffset0 + (-2)] += u[eOffset2 + (-2)];
			u[eOffset0 + (-3)] += u[eOffset2 + (-3)];
			u[eOffset2 + (-2)] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
			u[eOffset2 + (-3)] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
			aOffset += 16;
			k00_20 = u[eOffset0 + (-4)] - u[eOffset2 + (-4)];
			k01_21 = u[eOffset0 + (-5)] - u[eOffset2 + (-5)];
			u[eOffset0 + (-4)] += u[eOffset2 + (-4)];
			u[eOffset0 + (-5)] += u[eOffset2 + (-5)];
			u[eOffset2 + (-4)] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
			u[eOffset2 + (-5)] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
			aOffset += 16;
			k00_20 = u[eOffset0 + (-6)] - u[eOffset2 + (-6)];
			k01_21 = u[eOffset0 + (-7)] - u[eOffset2 + (-7)];
			u[eOffset0 + (-6)] += u[eOffset2 + (-6)];
			u[eOffset0 + (-7)] += u[eOffset2 + (-7)];
			u[eOffset2 + (-6)] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
			u[eOffset2 + (-7)] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
			eOffset0 -= 8;
			eOffset2 -= 8;
			aOffset += 16;
		}
		var d0 = n2 - 1 - n8 * 2;
		var aOffset = 0;
		var eOffset0 = d0;
		var eOffset2 = d0 + -(n >> 4);
		var i = (n >> 5 >> 2) + 1;
		while(--i > 0) {
			var k00_20 = u[eOffset0] - u[eOffset2];
			var k01_21 = u[eOffset0 + (-1)] - u[eOffset2 + (-1)];
			u[eOffset0] += u[eOffset2];
			u[eOffset0 + (-1)] += u[eOffset2 + (-1)];
			u[eOffset2] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
			u[eOffset2 + (-1)] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
			aOffset += 16;
			k00_20 = u[eOffset0 + (-2)] - u[eOffset2 + (-2)];
			k01_21 = u[eOffset0 + (-3)] - u[eOffset2 + (-3)];
			u[eOffset0 + (-2)] += u[eOffset2 + (-2)];
			u[eOffset0 + (-3)] += u[eOffset2 + (-3)];
			u[eOffset2 + (-2)] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
			u[eOffset2 + (-3)] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
			aOffset += 16;
			k00_20 = u[eOffset0 + (-4)] - u[eOffset2 + (-4)];
			k01_21 = u[eOffset0 + (-5)] - u[eOffset2 + (-5)];
			u[eOffset0 + (-4)] += u[eOffset2 + (-4)];
			u[eOffset0 + (-5)] += u[eOffset2 + (-5)];
			u[eOffset2 + (-4)] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
			u[eOffset2 + (-5)] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
			aOffset += 16;
			k00_20 = u[eOffset0 + (-6)] - u[eOffset2 + (-6)];
			k01_21 = u[eOffset0 + (-7)] - u[eOffset2 + (-7)];
			u[eOffset0 + (-6)] += u[eOffset2 + (-6)];
			u[eOffset0 + (-7)] += u[eOffset2 + (-7)];
			u[eOffset2 + (-6)] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
			u[eOffset2 + (-7)] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
			eOffset0 -= 8;
			eOffset2 -= 8;
			aOffset += 16;
		}
		var d0 = n2 - 1 - n8 * 3;
		var aOffset = 0;
		var eOffset0 = d0;
		var eOffset2 = d0 + -(n >> 4);
		var i = (n >> 5 >> 2) + 1;
		while(--i > 0) {
			var k00_20 = u[eOffset0] - u[eOffset2];
			var k01_21 = u[eOffset0 + (-1)] - u[eOffset2 + (-1)];
			u[eOffset0] += u[eOffset2];
			u[eOffset0 + (-1)] += u[eOffset2 + (-1)];
			u[eOffset2] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
			u[eOffset2 + (-1)] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
			aOffset += 16;
			k00_20 = u[eOffset0 + (-2)] - u[eOffset2 + (-2)];
			k01_21 = u[eOffset0 + (-3)] - u[eOffset2 + (-3)];
			u[eOffset0 + (-2)] += u[eOffset2 + (-2)];
			u[eOffset0 + (-3)] += u[eOffset2 + (-3)];
			u[eOffset2 + (-2)] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
			u[eOffset2 + (-3)] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
			aOffset += 16;
			k00_20 = u[eOffset0 + (-4)] - u[eOffset2 + (-4)];
			k01_21 = u[eOffset0 + (-5)] - u[eOffset2 + (-5)];
			u[eOffset0 + (-4)] += u[eOffset2 + (-4)];
			u[eOffset0 + (-5)] += u[eOffset2 + (-5)];
			u[eOffset2 + (-4)] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
			u[eOffset2 + (-5)] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
			aOffset += 16;
			k00_20 = u[eOffset0 + (-6)] - u[eOffset2 + (-6)];
			k01_21 = u[eOffset0 + (-7)] - u[eOffset2 + (-7)];
			u[eOffset0 + (-6)] += u[eOffset2 + (-6)];
			u[eOffset0 + (-7)] += u[eOffset2 + (-7)];
			u[eOffset2 + (-6)] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
			u[eOffset2 + (-7)] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
			eOffset0 -= 8;
			eOffset2 -= 8;
			aOffset += 16;
		}
		var _g = 2;
		var _g1 = ld - 3 >> 1;
		while(_g < _g1) {
			var l = _g++;
			var k0 = n >> l + 2;
			var k0_2 = k0 >> 1;
			var lim = 1 << l + 1;
			var _g2 = 0;
			var _g3 = lim;
			while(_g2 < _g3) {
				var i = _g2++;
				var d0 = n2 - 1 - k0 * i;
				var k1 = 1 << l + 3;
				var aOffset = 0;
				var eOffset0 = d0;
				var eOffset2 = d0 + -k0_2;
				var i1 = (n >> l + 4 >> 2) + 1;
				while(--i1 > 0) {
					var k00_20 = u[eOffset0] - u[eOffset2];
					var k01_21 = u[eOffset0 + (-1)] - u[eOffset2 + (-1)];
					u[eOffset0] += u[eOffset2];
					u[eOffset0 + (-1)] += u[eOffset2 + (-1)];
					u[eOffset2] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
					u[eOffset2 + (-1)] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
					aOffset += k1;
					k00_20 = u[eOffset0 + (-2)] - u[eOffset2 + (-2)];
					k01_21 = u[eOffset0 + (-3)] - u[eOffset2 + (-3)];
					u[eOffset0 + (-2)] += u[eOffset2 + (-2)];
					u[eOffset0 + (-3)] += u[eOffset2 + (-3)];
					u[eOffset2 + (-2)] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
					u[eOffset2 + (-3)] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
					aOffset += k1;
					k00_20 = u[eOffset0 + (-4)] - u[eOffset2 + (-4)];
					k01_21 = u[eOffset0 + (-5)] - u[eOffset2 + (-5)];
					u[eOffset0 + (-4)] += u[eOffset2 + (-4)];
					u[eOffset0 + (-5)] += u[eOffset2 + (-5)];
					u[eOffset2 + (-4)] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
					u[eOffset2 + (-5)] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
					aOffset += k1;
					k00_20 = u[eOffset0 + (-6)] - u[eOffset2 + (-6)];
					k01_21 = u[eOffset0 + (-7)] - u[eOffset2 + (-7)];
					u[eOffset0 + (-6)] += u[eOffset2 + (-6)];
					u[eOffset0 + (-7)] += u[eOffset2 + (-7)];
					u[eOffset2 + (-6)] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
					u[eOffset2 + (-7)] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
					eOffset0 -= 8;
					eOffset2 -= 8;
					aOffset += k1;
				}
			}
		}
		var _g = ld - 3 >> 1;
		var _g1 = ld - 6;
		while(_g < _g1) {
			var l = _g++;
			var k0 = n >> l + 2;
			var k1 = 1 << l + 3;
			var k0_2 = k0 >> 1;
			var rlim = n >> l + 6;
			var lim = 1 << l + 1;
			var aOffset = 0;
			var i_off = n2 - 1;
			var r = rlim + 1;
			while(--r > 0) {
				var A0 = a[aOffset];
				var A1 = a[aOffset + 1];
				var A2 = a[aOffset + k1];
				var A3 = a[aOffset + k1 + 1];
				var A4 = a[aOffset + k1 * 2];
				var A5 = a[aOffset + k1 * 2 + 1];
				var A6 = a[aOffset + k1 * 3];
				var A7 = a[aOffset + k1 * 3 + 1];
				var eeOffset0 = i_off;
				var eeOffset2 = i_off + -k0_2;
				var i = lim + 1;
				while(--i > 0) {
					var k00 = u[eeOffset0] - u[eeOffset2];
					var k11 = u[eeOffset0 + (-1)] - u[eeOffset2 + (-1)];
					u[eeOffset0] += u[eeOffset2];
					u[eeOffset0 + (-1)] += u[eeOffset2 + (-1)];
					u[eeOffset2] = k00 * A0 - k11 * A1;
					u[eeOffset2 + (-1)] = k11 * A0 + k00 * A1;
					k00 = u[eeOffset0 + (-2)] - u[eeOffset2 + (-2)];
					k11 = u[eeOffset0 + (-3)] - u[eeOffset2 + (-3)];
					u[eeOffset0 + (-2)] += u[eeOffset2 + (-2)];
					u[eeOffset0 + (-3)] += u[eeOffset2 + (-3)];
					u[eeOffset2 + (-2)] = k00 * A2 - k11 * A3;
					u[eeOffset2 + (-3)] = k11 * A2 + k00 * A3;
					k00 = u[eeOffset0 + (-4)] - u[eeOffset2 + (-4)];
					k11 = u[eeOffset0 + (-5)] - u[eeOffset2 + (-5)];
					u[eeOffset0 + (-4)] += u[eeOffset2 + (-4)];
					u[eeOffset0 + (-5)] += u[eeOffset2 + (-5)];
					u[eeOffset2 + (-4)] = k00 * A4 - k11 * A5;
					u[eeOffset2 + (-5)] = k11 * A4 + k00 * A5;
					k00 = u[eeOffset0 + (-6)] - u[eeOffset2 + (-6)];
					k11 = u[eeOffset0 + (-7)] - u[eeOffset2 + (-7)];
					u[eeOffset0 + (-6)] += u[eeOffset2 + (-6)];
					u[eeOffset0 + (-7)] += u[eeOffset2 + (-7)];
					u[eeOffset2 + (-6)] = k00 * A6 - k11 * A7;
					u[eeOffset2 + (-7)] = k11 * A6 + k00 * A7;
					eeOffset0 -= k0;
					eeOffset2 -= k0;
				}
				aOffset += k1 * 4;
				i_off -= 8;
			}
		}
		var i_off = n2 - 1;
		var A2 = a[n >> 3];
		var zOffset = i_off;
		var baseOffset = i_off - 16 * (n >> 5);
		while(zOffset > baseOffset) {
			var t0 = u[zOffset];
			var t1 = u[zOffset + (-8)];
			u[zOffset + (-8)] = t0 - t1;
			u[zOffset] = t0 + t1;
			t0 = u[zOffset + (-1)];
			t1 = u[zOffset + (-9)];
			u[zOffset + (-9)] = t0 - t1;
			u[zOffset + (-1)] = t0 + t1;
			t0 = u[zOffset + (-2)];
			t1 = u[zOffset + (-10)];
			var k00 = t0 - t1;
			u[zOffset + (-2)] = t0 + t1;
			t0 = u[zOffset + (-3)];
			t1 = u[zOffset + (-11)];
			var k11 = t0 - t1;
			u[zOffset + (-3)] = t0 + t1;
			u[zOffset + (-10)] = (k00 + k11) * A2;
			u[zOffset + (-11)] = (k11 - k00) * A2;
			t0 = u[zOffset + (-4)];
			t1 = u[zOffset + (-12)];
			k00 = t1 - t0;
			u[zOffset + (-4)] = t0 + t1;
			t0 = u[zOffset + (-5)];
			t1 = u[zOffset + (-13)];
			k11 = t0 - t1;
			u[zOffset + (-5)] = t0 + t1;
			u[zOffset + (-12)] = k11;
			u[zOffset + (-13)] = k00;
			t0 = u[zOffset + (-6)];
			t1 = u[zOffset + (-14)];
			k00 = t1 - t0;
			u[zOffset + (-6)] = t0 + t1;
			t0 = u[zOffset + (-7)];
			t1 = u[zOffset + (-15)];
			k11 = t0 - t1;
			u[zOffset + (-7)] = t0 + t1;
			u[zOffset + (-14)] = (k00 + k11) * A2;
			u[zOffset + (-15)] = (k00 - k11) * A2;
			var t01 = u[zOffset];
			var t11 = u[zOffset + (-4)];
			var k001 = t01 - t11;
			var y0 = t01 + t11;
			t01 = u[zOffset + (-2)];
			t11 = u[zOffset + (-6)];
			var y2 = t01 + t11;
			var k22 = t01 - t11;
			u[zOffset] = y0 + y2;
			u[zOffset + (-2)] = y0 - y2;
			var k33 = u[zOffset + (-3)] - u[zOffset + (-7)];
			u[zOffset + (-4)] = k001 + k33;
			u[zOffset + (-6)] = k001 - k33;
			t01 = u[zOffset + (-1)];
			t11 = u[zOffset + (-5)];
			var k111 = t01 - t11;
			var y1 = t01 + t11;
			var y3 = u[zOffset + (-3)] + u[zOffset + (-7)];
			u[zOffset + (-1)] = y1 + y3;
			u[zOffset + (-3)] = y1 - y3;
			u[zOffset + (-5)] = k111 - k22;
			u[zOffset + (-7)] = k111 + k22;
			var zOffset1 = zOffset - 8;
			var t02 = u[zOffset1];
			var t12 = u[zOffset1 + (-4)];
			var k002 = t02 - t12;
			var y01 = t02 + t12;
			t02 = u[zOffset1 + (-2)];
			t12 = u[zOffset1 + (-6)];
			var y21 = t02 + t12;
			var k221 = t02 - t12;
			u[zOffset1] = y01 + y21;
			u[zOffset1 + (-2)] = y01 - y21;
			var k331 = u[zOffset1 + (-3)] - u[zOffset1 + (-7)];
			u[zOffset1 + (-4)] = k002 + k331;
			u[zOffset1 + (-6)] = k002 - k331;
			t02 = u[zOffset1 + (-1)];
			t12 = u[zOffset1 + (-5)];
			var k112 = t02 - t12;
			var y11 = t02 + t12;
			var y31 = u[zOffset1 + (-3)] + u[zOffset1 + (-7)];
			u[zOffset1 + (-1)] = y11 + y31;
			u[zOffset1 + (-3)] = y11 - y31;
			u[zOffset1 + (-5)] = k112 - k221;
			u[zOffset1 + (-7)] = k112 + k221;
			zOffset -= 16;
		}
		var brOffset = 0;
		var dOffset0 = n4 - 4;
		var dOffset1 = n2 - 4;
		while(dOffset0 >= 0) {
			var k4 = bitReverse[brOffset];
			v[dOffset1 + 3] = u[k4];
			v[dOffset1 + 2] = u[k4 + 1];
			v[dOffset0 + 3] = u[k4 + 2];
			v[dOffset0 + 2] = u[k4 + 3];
			k4 = bitReverse[brOffset + 1];
			v[dOffset1 + 1] = u[k4];
			v[dOffset1] = u[k4 + 1];
			v[dOffset0 + 1] = u[k4 + 2];
			v[dOffset0] = u[k4 + 3];
			dOffset0 -= 4;
			dOffset1 -= 4;
			brOffset += 2;
		}
		var cOffset = 0;
		var dOffset = 0;
		var eOffset = n2 - 4;
		while(dOffset < eOffset) {
			var a02 = v[dOffset] - v[eOffset + 2];
			var a11 = v[dOffset + 1] + v[eOffset + 3];
			var b0 = c[cOffset + 1] * a02 + c[cOffset] * a11;
			var b1 = c[cOffset + 1] * a11 - c[cOffset] * a02;
			var b2 = v[dOffset] + v[eOffset + 2];
			var b3 = v[dOffset + 1] - v[eOffset + 3];
			v[dOffset] = b2 + b0;
			v[dOffset + 1] = b3 + b1;
			v[eOffset + 2] = b2 - b0;
			v[eOffset + 3] = b1 - b3;
			a02 = v[dOffset + 2] - v[eOffset];
			a11 = v[dOffset + 3] + v[eOffset + 1];
			b0 = c[cOffset + 3] * a02 + c[cOffset + 2] * a11;
			b1 = c[cOffset + 3] * a11 - c[cOffset + 2] * a02;
			b2 = v[dOffset + 2] + v[eOffset];
			b3 = v[dOffset + 3] - v[eOffset + 1];
			v[dOffset + 2] = b2 + b0;
			v[dOffset + 3] = b3 + b1;
			v[eOffset] = b2 - b0;
			v[eOffset + 1] = b1 - b3;
			cOffset += 4;
			dOffset += 4;
			eOffset -= 4;
		}
		var bOffset = n2 - 8;
		var eOffset = n2 - 8;
		var dOffset0 = 0;
		var dOffset1 = n2 - 4;
		var dOffset2 = n2;
		var dOffset3 = n - 4;
		while(eOffset >= 0) {
			var p3 = buf2[eOffset + 6] * b[bOffset + 7] - buf2[eOffset + 7] * b[bOffset + 6];
			var p2 = -buf2[eOffset + 6] * b[bOffset + 6] - buf2[eOffset + 7] * b[bOffset + 7];
			buffer[dOffset0] = p3;
			buffer[dOffset1 + 3] = -p3;
			buffer[dOffset2] = p2;
			buffer[dOffset3 + 3] = p2;
			var p1 = buf2[eOffset + 4] * b[bOffset + 5] - buf2[eOffset + 5] * b[bOffset + 4];
			var p0 = -buf2[eOffset + 4] * b[bOffset + 4] - buf2[eOffset + 5] * b[bOffset + 5];
			buffer[dOffset0 + 1] = p1;
			buffer[dOffset1 + 2] = -p1;
			buffer[dOffset2 + 1] = p0;
			buffer[dOffset3 + 2] = p0;
			p3 = buf2[eOffset + 2] * b[bOffset + 3] - buf2[eOffset + 3] * b[bOffset + 2];
			p2 = -buf2[eOffset + 2] * b[bOffset + 2] - buf2[eOffset + 3] * b[bOffset + 3];
			buffer[dOffset0 + 2] = p3;
			buffer[dOffset1 + 1] = -p3;
			buffer[dOffset2 + 2] = p2;
			buffer[dOffset3 + 1] = p2;
			p1 = buf2[eOffset] * b[bOffset + 1] - buf2[eOffset + 1] * b[bOffset];
			p0 = -buf2[eOffset] * b[bOffset] - buf2[eOffset + 1] * b[bOffset + 1];
			buffer[dOffset0 + 3] = p1;
			buffer[dOffset1] = -p1;
			buffer[dOffset2 + 3] = p0;
			buffer[dOffset3] = p0;
			bOffset -= 8;
			eOffset -= 8;
			dOffset0 += 4;
			dOffset2 += 4;
			dOffset1 -= 4;
			dOffset3 -= 4;
		}
	}
	,decodePacket: function() {
		var result = this.decodeInitial();
		if(result == null) {
			return null;
		}
		var rest = this.decodePacketRest(result);
		return rest;
	}
	,decodeInitial: function() {
		this.channelBufferStart = this.channelBufferEnd = 0;
		while(true) {
			if(!this.decodeState.maybeStartPacket()) {
				return null;
			}
			var _this = this.decodeState;
			var tmp;
			if(_this.validBits < 0) {
				tmp = 0;
			} else if(_this.validBits < 1) {
				if(_this.validBits == 0) {
					_this.acc = 0;
				}
				while(true) {
					if(_this.bytesInSeg == 0 && (_this.lastSeg || _this.next() == 0)) {
						_this.validBits = -1;
						break;
					} else {
						_this.bytesInSeg--;
						_this.inputPosition += 1;
						_this.acc = _this.acc + (_this.input.readByte() << _this.validBits);
						_this.validBits += 8;
					}
					if(!(_this.validBits < 1)) {
						break;
					}
				}
				if(_this.validBits < 0) {
					tmp = 0;
				} else {
					var z = _this.acc & 1;
					_this.acc = _this.acc >>> 1;
					_this.validBits -= 1;
					tmp = z;
				}
			} else {
				var z1 = _this.acc & 1;
				_this.acc = _this.acc >>> 1;
				_this.validBits -= 1;
				tmp = z1;
			}
			if(tmp != 0) {
				while(true) {
					var _this1 = this.decodeState;
					var x;
					if(_this1.bytesInSeg == 0 && (_this1.lastSeg || _this1.next() == 0)) {
						x = -1;
					} else {
						_this1.bytesInSeg--;
						_this1.inputPosition += 1;
						x = _this1.input.readByte();
					}
					_this1.validBits = 0;
					if(!(-1 != x)) {
						break;
					}
				}
				continue;
			}
			break;
		}
		var _this = this.decodeState;
		var n = this.header.modes.length - 1;
		var log2_4 = [0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4];
		var n1 = n < 16384 ? n < 16 ? log2_4[n] : n < 512 ? 5 + log2_4[n >> 5] : 10 + log2_4[n >> 10] : n < 16777216 ? n < 524288 ? 15 + log2_4[n >> 15] : 20 + log2_4[n >> 20] : n < 536870912 ? 25 + log2_4[n >> 25] : n < -2147483648 ? 30 + log2_4[n >> 30] : 0;
		var i;
		if(_this.validBits < 0) {
			i = 0;
		} else if(_this.validBits < n1) {
			if(n1 > 24) {
				var i1;
				if(_this.validBits < 0) {
					i1 = 0;
				} else if(_this.validBits < 24) {
					if(_this.validBits == 0) {
						_this.acc = 0;
					}
					while(true) {
						if(_this.bytesInSeg == 0 && (_this.lastSeg || _this.next() == 0)) {
							_this.validBits = -1;
							break;
						} else {
							_this.bytesInSeg--;
							_this.inputPosition += 1;
							_this.acc = _this.acc + (_this.input.readByte() << _this.validBits);
							_this.validBits += 8;
						}
						if(!(_this.validBits < 24)) {
							break;
						}
					}
					if(_this.validBits < 0) {
						i1 = 0;
					} else {
						var z = _this.acc & 16777215;
						_this.acc = _this.acc >>> 24;
						_this.validBits -= 24;
						i1 = z;
					}
				} else {
					var z = _this.acc & 16777215;
					_this.acc = _this.acc >>> 24;
					_this.validBits -= 24;
					i1 = z;
				}
				var n = n1 - 24;
				var i2;
				if(_this.validBits < 0) {
					i2 = 0;
				} else if(_this.validBits < n) {
					if(n > 24) {
						i2 = _this.readBits(24) + (_this.readBits(n - 24) << 24);
					} else {
						if(_this.validBits == 0) {
							_this.acc = 0;
						}
						while(true) {
							if(_this.bytesInSeg == 0 && (_this.lastSeg || _this.next() == 0)) {
								_this.validBits = -1;
								break;
							} else {
								_this.bytesInSeg--;
								_this.inputPosition += 1;
								_this.acc = _this.acc + (_this.input.readByte() << _this.validBits);
								_this.validBits += 8;
							}
							if(!(_this.validBits < n)) {
								break;
							}
						}
						if(_this.validBits < 0) {
							i2 = 0;
						} else {
							var z = _this.acc & (1 << n) - 1;
							_this.acc = _this.acc >>> n;
							_this.validBits -= n;
							i2 = z;
						}
					}
				} else {
					var z = _this.acc & (1 << n) - 1;
					_this.acc = _this.acc >>> n;
					_this.validBits -= n;
					i2 = z;
				}
				i = i1 + (i2 << 24);
			} else {
				if(_this.validBits == 0) {
					_this.acc = 0;
				}
				while(true) {
					if(_this.bytesInSeg == 0 && (_this.lastSeg || _this.next() == 0)) {
						_this.validBits = -1;
						break;
					} else {
						_this.bytesInSeg--;
						_this.inputPosition += 1;
						_this.acc = _this.acc + (_this.input.readByte() << _this.validBits);
						_this.validBits += 8;
					}
					if(!(_this.validBits < n1)) {
						break;
					}
				}
				if(_this.validBits < 0) {
					i = 0;
				} else {
					var z = _this.acc & (1 << n1) - 1;
					_this.acc = _this.acc >>> n1;
					_this.validBits -= n1;
					i = z;
				}
			}
		} else {
			var z = _this.acc & (1 << n1) - 1;
			_this.acc = _this.acc >>> n1;
			_this.validBits -= n1;
			i = z;
		}
		if(i == -1 || i >= this.header.modes.length) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.SEEK_FAILED,null,{ fileName : "stb/format/vorbis/VorbisDecoder.hx", lineNumber : 514, className : "stb.format.vorbis.VorbisDecoder", methodName : "decodeInitial"}));
		}
		var m = this.header.modes[i];
		var n;
		var prev;
		var next;
		if(m.blockflag) {
			n = this.header.blocksize1;
			var _this = this.decodeState;
			if(_this.validBits < 0) {
				prev = 0;
			} else if(_this.validBits < 1) {
				if(_this.validBits == 0) {
					_this.acc = 0;
				}
				while(true) {
					if(_this.bytesInSeg == 0 && (_this.lastSeg || _this.next() == 0)) {
						_this.validBits = -1;
						break;
					} else {
						_this.bytesInSeg--;
						_this.inputPosition += 1;
						_this.acc = _this.acc + (_this.input.readByte() << _this.validBits);
						_this.validBits += 8;
					}
					if(!(_this.validBits < 1)) {
						break;
					}
				}
				if(_this.validBits < 0) {
					prev = 0;
				} else {
					var z = _this.acc & 1;
					_this.acc = _this.acc >>> 1;
					_this.validBits -= 1;
					prev = z;
				}
			} else {
				var z = _this.acc & 1;
				_this.acc = _this.acc >>> 1;
				_this.validBits -= 1;
				prev = z;
			}
			var _this = this.decodeState;
			if(_this.validBits < 0) {
				next = 0;
			} else if(_this.validBits < 1) {
				if(_this.validBits == 0) {
					_this.acc = 0;
				}
				while(true) {
					if(_this.bytesInSeg == 0 && (_this.lastSeg || _this.next() == 0)) {
						_this.validBits = -1;
						break;
					} else {
						_this.bytesInSeg--;
						_this.inputPosition += 1;
						_this.acc = _this.acc + (_this.input.readByte() << _this.validBits);
						_this.validBits += 8;
					}
					if(!(_this.validBits < 1)) {
						break;
					}
				}
				if(_this.validBits < 0) {
					next = 0;
				} else {
					var z = _this.acc & 1;
					_this.acc = _this.acc >>> 1;
					_this.validBits -= 1;
					next = z;
				}
			} else {
				var z = _this.acc & 1;
				_this.acc = _this.acc >>> 1;
				_this.validBits -= 1;
				next = z;
			}
		} else {
			next = 0;
			prev = next;
			n = this.header.blocksize0;
		}
		var windowCenter = n >> 1;
		return { mode : i, left : m.blockflag && prev == 0 ? { start : n - this.header.blocksize0 >> 2, end : n + this.header.blocksize0 >> 2} : { start : 0, end : windowCenter}, right : m.blockflag && next == 0 ? { start : n * 3 - this.header.blocksize0 >> 2, end : n * 3 + this.header.blocksize0 >> 2} : { start : windowCenter, end : n}};
	}
	,decodePacketRest: function(r) {
		var len = 0;
		var m = this.header.modes[r.mode];
		var this1 = new Array(256);
		var zeroChannel = this1;
		var this1 = new Array(256);
		var reallyZeroChannel = this1;
		var n = m.blockflag ? this.header.blocksize1 : this.header.blocksize0;
		var map = this.header.mapping[m.mapping];
		var n2 = n >> 1;
		var rangeList = [256,128,86,64];
		var codebooks = this.header.codebooks;
		var _g = 0;
		var _g1 = this.header.channel;
		while(_g < _g1) {
			var i = _g++;
			var s = map.chan[i].mux;
			zeroChannel[i] = false;
			var floor = this.header.floorConfig[map.submapFloor[s]];
			if(floor.type == 0) {
				throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_STREAM,null,{ fileName : "stb/format/vorbis/VorbisDecoder.hx", lineNumber : 576, className : "stb.format.vorbis.VorbisDecoder", methodName : "decodePacketRest"}));
			} else {
				var g = floor.floor1;
				var _this = this.decodeState;
				var tmp;
				if(_this.validBits < 0) {
					tmp = 0;
				} else if(_this.validBits < 1) {
					if(_this.validBits == 0) {
						_this.acc = 0;
					}
					while(true) {
						if(_this.bytesInSeg == 0 && (_this.lastSeg || _this.next() == 0)) {
							_this.validBits = -1;
							break;
						} else {
							_this.bytesInSeg--;
							_this.inputPosition += 1;
							_this.acc = _this.acc + (_this.input.readByte() << _this.validBits);
							_this.validBits += 8;
						}
						if(!(_this.validBits < 1)) {
							break;
						}
					}
					if(_this.validBits < 0) {
						tmp = 0;
					} else {
						var z = _this.acc & 1;
						_this.acc = _this.acc >>> 1;
						_this.validBits -= 1;
						tmp = z;
					}
				} else {
					var z1 = _this.acc & 1;
					_this.acc = _this.acc >>> 1;
					_this.validBits -= 1;
					tmp = z1;
				}
				if(tmp != 0) {
					var fy = [];
					var this1 = new Array(256);
					var step2Flag = this1;
					var range = rangeList[g.floor1Multiplier - 1];
					var offset = 2;
					fy = this.finalY[i];
					var _this1 = this.decodeState;
					var log2_4 = [0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4];
					var n1 = (range < 16384 ? range < 16 ? log2_4[range] : range < 512 ? 5 + log2_4[range >> 5] : 10 + log2_4[range >> 10] : range < 16777216 ? range < 524288 ? 15 + log2_4[range >> 15] : 20 + log2_4[range >> 20] : range < 536870912 ? 25 + log2_4[range >> 25] : range < -2147483648 ? 30 + log2_4[range >> 30] : 0) - 1;
					var tmp1;
					if(_this1.validBits < 0) {
						tmp1 = 0;
					} else if(_this1.validBits < n1) {
						if(n1 > 24) {
							var tmp2;
							if(_this1.validBits < 0) {
								tmp2 = 0;
							} else if(_this1.validBits < 24) {
								if(_this1.validBits == 0) {
									_this1.acc = 0;
								}
								while(true) {
									if(_this1.bytesInSeg == 0 && (_this1.lastSeg || _this1.next() == 0)) {
										_this1.validBits = -1;
										break;
									} else {
										_this1.bytesInSeg--;
										_this1.inputPosition += 1;
										_this1.acc = _this1.acc + (_this1.input.readByte() << _this1.validBits);
										_this1.validBits += 8;
									}
									if(!(_this1.validBits < 24)) {
										break;
									}
								}
								if(_this1.validBits < 0) {
									tmp2 = 0;
								} else {
									var z2 = _this1.acc & 16777215;
									_this1.acc = _this1.acc >>> 24;
									_this1.validBits -= 24;
									tmp2 = z2;
								}
							} else {
								var z3 = _this1.acc & 16777215;
								_this1.acc = _this1.acc >>> 24;
								_this1.validBits -= 24;
								tmp2 = z3;
							}
							var n3 = n1 - 24;
							var tmp3;
							if(_this1.validBits < 0) {
								tmp3 = 0;
							} else if(_this1.validBits < n3) {
								if(n3 > 24) {
									tmp3 = _this1.readBits(24) + (_this1.readBits(n3 - 24) << 24);
								} else {
									if(_this1.validBits == 0) {
										_this1.acc = 0;
									}
									while(true) {
										if(_this1.bytesInSeg == 0 && (_this1.lastSeg || _this1.next() == 0)) {
											_this1.validBits = -1;
											break;
										} else {
											_this1.bytesInSeg--;
											_this1.inputPosition += 1;
											_this1.acc = _this1.acc + (_this1.input.readByte() << _this1.validBits);
											_this1.validBits += 8;
										}
										if(!(_this1.validBits < n3)) {
											break;
										}
									}
									if(_this1.validBits < 0) {
										tmp3 = 0;
									} else {
										var z4 = _this1.acc & (1 << n3) - 1;
										_this1.acc = _this1.acc >>> n3;
										_this1.validBits -= n3;
										tmp3 = z4;
									}
								}
							} else {
								var z5 = _this1.acc & (1 << n3) - 1;
								_this1.acc = _this1.acc >>> n3;
								_this1.validBits -= n3;
								tmp3 = z5;
							}
							tmp1 = tmp2 + (tmp3 << 24);
						} else {
							if(_this1.validBits == 0) {
								_this1.acc = 0;
							}
							while(true) {
								if(_this1.bytesInSeg == 0 && (_this1.lastSeg || _this1.next() == 0)) {
									_this1.validBits = -1;
									break;
								} else {
									_this1.bytesInSeg--;
									_this1.inputPosition += 1;
									_this1.acc = _this1.acc + (_this1.input.readByte() << _this1.validBits);
									_this1.validBits += 8;
								}
								if(!(_this1.validBits < n1)) {
									break;
								}
							}
							if(_this1.validBits < 0) {
								tmp1 = 0;
							} else {
								var z6 = _this1.acc & (1 << n1) - 1;
								_this1.acc = _this1.acc >>> n1;
								_this1.validBits -= n1;
								tmp1 = z6;
							}
						}
					} else {
						var z7 = _this1.acc & (1 << n1) - 1;
						_this1.acc = _this1.acc >>> n1;
						_this1.validBits -= n1;
						tmp1 = z7;
					}
					fy[0] = tmp1;
					var _this2 = this.decodeState;
					var log2_41 = [0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4];
					var n4 = (range < 16384 ? range < 16 ? log2_41[range] : range < 512 ? 5 + log2_41[range >> 5] : 10 + log2_41[range >> 10] : range < 16777216 ? range < 524288 ? 15 + log2_41[range >> 15] : 20 + log2_41[range >> 20] : range < 536870912 ? 25 + log2_41[range >> 25] : range < -2147483648 ? 30 + log2_41[range >> 30] : 0) - 1;
					var tmp4;
					if(_this2.validBits < 0) {
						tmp4 = 0;
					} else if(_this2.validBits < n4) {
						if(n4 > 24) {
							var tmp5;
							if(_this2.validBits < 0) {
								tmp5 = 0;
							} else if(_this2.validBits < 24) {
								if(_this2.validBits == 0) {
									_this2.acc = 0;
								}
								while(true) {
									if(_this2.bytesInSeg == 0 && (_this2.lastSeg || _this2.next() == 0)) {
										_this2.validBits = -1;
										break;
									} else {
										_this2.bytesInSeg--;
										_this2.inputPosition += 1;
										_this2.acc = _this2.acc + (_this2.input.readByte() << _this2.validBits);
										_this2.validBits += 8;
									}
									if(!(_this2.validBits < 24)) {
										break;
									}
								}
								if(_this2.validBits < 0) {
									tmp5 = 0;
								} else {
									var z8 = _this2.acc & 16777215;
									_this2.acc = _this2.acc >>> 24;
									_this2.validBits -= 24;
									tmp5 = z8;
								}
							} else {
								var z9 = _this2.acc & 16777215;
								_this2.acc = _this2.acc >>> 24;
								_this2.validBits -= 24;
								tmp5 = z9;
							}
							var n5 = n4 - 24;
							var tmp6;
							if(_this2.validBits < 0) {
								tmp6 = 0;
							} else if(_this2.validBits < n5) {
								if(n5 > 24) {
									tmp6 = _this2.readBits(24) + (_this2.readBits(n5 - 24) << 24);
								} else {
									if(_this2.validBits == 0) {
										_this2.acc = 0;
									}
									while(true) {
										if(_this2.bytesInSeg == 0 && (_this2.lastSeg || _this2.next() == 0)) {
											_this2.validBits = -1;
											break;
										} else {
											_this2.bytesInSeg--;
											_this2.inputPosition += 1;
											_this2.acc = _this2.acc + (_this2.input.readByte() << _this2.validBits);
											_this2.validBits += 8;
										}
										if(!(_this2.validBits < n5)) {
											break;
										}
									}
									if(_this2.validBits < 0) {
										tmp6 = 0;
									} else {
										var z10 = _this2.acc & (1 << n5) - 1;
										_this2.acc = _this2.acc >>> n5;
										_this2.validBits -= n5;
										tmp6 = z10;
									}
								}
							} else {
								var z11 = _this2.acc & (1 << n5) - 1;
								_this2.acc = _this2.acc >>> n5;
								_this2.validBits -= n5;
								tmp6 = z11;
							}
							tmp4 = tmp5 + (tmp6 << 24);
						} else {
							if(_this2.validBits == 0) {
								_this2.acc = 0;
							}
							while(true) {
								if(_this2.bytesInSeg == 0 && (_this2.lastSeg || _this2.next() == 0)) {
									_this2.validBits = -1;
									break;
								} else {
									_this2.bytesInSeg--;
									_this2.inputPosition += 1;
									_this2.acc = _this2.acc + (_this2.input.readByte() << _this2.validBits);
									_this2.validBits += 8;
								}
								if(!(_this2.validBits < n4)) {
									break;
								}
							}
							if(_this2.validBits < 0) {
								tmp4 = 0;
							} else {
								var z12 = _this2.acc & (1 << n4) - 1;
								_this2.acc = _this2.acc >>> n4;
								_this2.validBits -= n4;
								tmp4 = z12;
							}
						}
					} else {
						var z13 = _this2.acc & (1 << n4) - 1;
						_this2.acc = _this2.acc >>> n4;
						_this2.validBits -= n4;
						tmp4 = z13;
					}
					fy[1] = tmp4;
					var _g2 = 0;
					var _g3 = g.partitions;
					while(_g2 < _g3) {
						var j = _g2++;
						var pclass = g.partitionClassList[j];
						var cdim = g.classDimensions[pclass];
						var cbits = g.classSubclasses[pclass];
						var csub = (1 << cbits) - 1;
						var cval = 0;
						if(cbits != 0) {
							var c = codebooks[g.classMasterbooks[pclass]];
							var _this3 = this.decodeState;
							if(_this3.validBits < 10) {
								_this3.prepHuffman();
							}
							var i1 = c.fastHuffman[_this3.acc & 1023];
							var val;
							if(i1 >= 0) {
								var l = c.codewordLengths[i1];
								_this3.acc = _this3.acc >>> l;
								_this3.validBits -= l;
								if(_this3.validBits < 0) {
									_this3.validBits = 0;
									val = -1;
								} else {
									val = i1;
								}
							} else {
								val = _this3.decodeScalarRaw(c);
							}
							if(c.sparse) {
								val = c.sortedValues[val];
							}
							cval = val;
						}
						var books = g.subclassBooks[pclass];
						var _g4 = 0;
						var _g5 = cdim;
						while(_g4 < _g5) {
							var k = _g4++;
							var book = books[cval & csub];
							cval >>= cbits;
							var tmp7 = offset++;
							var tmp8;
							if(book >= 0) {
								var _this4 = this.decodeState;
								var c1 = codebooks[book];
								if(_this4.validBits < 10) {
									_this4.prepHuffman();
								}
								var i2 = c1.fastHuffman[_this4.acc & 1023];
								var val1;
								if(i2 >= 0) {
									var l1 = c1.codewordLengths[i2];
									_this4.acc = _this4.acc >>> l1;
									_this4.validBits -= l1;
									if(_this4.validBits < 0) {
										_this4.validBits = 0;
										val1 = -1;
									} else {
										val1 = i2;
									}
								} else {
									val1 = _this4.decodeScalarRaw(c1);
								}
								if(c1.sparse) {
									val1 = c1.sortedValues[val1];
								}
								tmp8 = val1;
							} else {
								tmp8 = 0;
							}
							fy[tmp7] = tmp8;
						}
					}
					if(this.decodeState.validBits == -1) {
						zeroChannel[i] = true;
						continue;
					}
					step2Flag[0] = step2Flag[1] = true;
					var naighbors = g.neighbors;
					var xlist = g.xlist;
					var _g6 = 2;
					var _g7 = g.values;
					while(_g6 < _g7) {
						var j1 = _g6++;
						var low = naighbors[j1][0];
						var high = naighbors[j1][1];
						var x0 = xlist[low];
						var y0 = fy[low];
						var dy = fy[high] - y0;
						var adx = xlist[high] - x0;
						var err = Math.abs(dy) * (xlist[j1] - x0);
						var off = err / adx | 0;
						var lowroom = dy < 0 ? y0 - off : y0 + off;
						var val2 = fy[j1];
						var highroom = range - lowroom;
						var room = highroom < lowroom ? highroom * 2 : lowroom * 2;
						if(val2 != 0) {
							step2Flag[low] = step2Flag[high] = true;
							step2Flag[j1] = true;
							if(val2 >= room) {
								if(highroom > lowroom) {
									fy[j1] = val2 - lowroom + lowroom;
								} else {
									fy[j1] = lowroom - val2 + highroom - 1;
								}
							} else if((val2 & 1) != 0) {
								fy[j1] = lowroom - (val2 + 1 >> 1);
							} else {
								fy[j1] = lowroom + (val2 >> 1);
							}
						} else {
							step2Flag[j1] = false;
							fy[j1] = lowroom;
						}
					}
					var _g8 = 0;
					var _g9 = g.values;
					while(_g8 < _g9) {
						var j2 = _g8++;
						if(!step2Flag[j2]) {
							fy[j2] = -1;
						}
					}
				} else {
					zeroChannel[i] = true;
				}
			}
		}
		var _g = 0;
		var _g1 = this.header.channel;
		while(_g < _g1) {
			var i = _g++;
			reallyZeroChannel[i] = zeroChannel[i];
		}
		var _g = 0;
		var _g1 = map.couplingSteps;
		while(_g < _g1) {
			var i = _g++;
			if(!zeroChannel[map.chan[i].magnitude] || !zeroChannel[map.chan[i].angle]) {
				zeroChannel[map.chan[i].magnitude] = zeroChannel[map.chan[i].angle] = false;
			}
		}
		var _g = 0;
		var _g1 = map.submaps;
		while(_g < _g1) {
			var i = _g++;
			var this1 = new Array(this.header.channel);
			var residueBuffers = this1;
			var this2 = new Array(256);
			var doNotDecode = this2;
			var ch = 0;
			var _g2 = 0;
			var _g3 = this.header.channel;
			while(_g2 < _g3) {
				var j = _g2++;
				if(map.chan[j].mux == i) {
					if(zeroChannel[j]) {
						doNotDecode[ch] = true;
						residueBuffers[ch] = null;
					} else {
						doNotDecode[ch] = false;
						residueBuffers[ch] = this.channelBuffers[j];
					}
					++ch;
				}
			}
			var r1 = map.submapResidue[i];
			var residue = this.header.residueConfig[r1];
			residue.decode(this.decodeState,this.header,residueBuffers,ch,n2,doNotDecode,this.channelBuffers);
		}
		var i = map.couplingSteps;
		var n2 = n >> 1;
		while(--i >= 0) {
			var m1 = this.channelBuffers[map.chan[i].magnitude];
			var a = this.channelBuffers[map.chan[i].angle];
			var _g = 0;
			var _g1 = n2;
			while(_g < _g1) {
				var j = _g++;
				var a2;
				var m2;
				if(m1[j] > 0) {
					if(a[j] > 0) {
						m2 = m1[j];
						a2 = m1[j] - a[j];
					} else {
						a2 = m1[j];
						m2 = m1[j] + a[j];
					}
				} else if(a[j] > 0) {
					m2 = m1[j];
					a2 = m1[j] + a[j];
				} else {
					a2 = m1[j];
					m2 = m1[j] - a[j];
				}
				m1[j] = m2;
				a[j] = a2;
			}
		}
		var _g = 0;
		var _g1 = this.header.channel;
		while(_g < _g1) {
			var i = _g++;
			if(reallyZeroChannel[i]) {
				var _g2 = 0;
				var _g3 = n2;
				while(_g2 < _g3) {
					var j = _g2++;
					this.channelBuffers[i][j] = 0;
				}
			} else {
				map.doFloor(this.header.floorConfig,i,n,this.channelBuffers[i],this.finalY[i],null);
			}
		}
		var _g = 0;
		var _g1 = this.header.channel;
		while(_g < _g1) {
			var i = _g++;
			this.inverseMdct(this.channelBuffers[i],n,m.blockflag);
		}
		var _this = this.decodeState;
		while(_this.bytesInSeg != 0 || !_this.lastSeg && _this.next() != 0) {
			_this.bytesInSeg--;
			_this.inputPosition += 1;
			_this.input.readByte();
		}
		return this.decodeState.finishDecodePacket(this.previousLength,n,r);
	}
	,__class__: stb_format_vorbis_VorbisDecoder
};
var stb_format_vorbis_VorbisTools = function() { };
$hxClasses["stb.format.vorbis.VorbisTools"] = stb_format_vorbis_VorbisTools;
stb_format_vorbis_VorbisTools.__name__ = "stb.format.vorbis.VorbisTools";
stb_format_vorbis_VorbisTools.pointCompare = function(a,b) {
	if(a.x < b.x) {
		return -1;
	} else if(a.x > b.x) {
		return 1;
	} else {
		return 0;
	}
};
stb_format_vorbis_VorbisTools.uintAsc = function(a,b) {
	if(UInt.gt(b,a)) {
		return -1;
	} else if(a == b) {
		return 0;
	} else {
		return 1;
	}
};
stb_format_vorbis_VorbisTools.lookup1Values = function(entries,dim) {
	var r = Math.exp(Math.log(entries) / dim) | 0;
	if((Math.pow(r + 1,dim) | 0) <= entries) {
		++r;
	}
	return r;
};
stb_format_vorbis_VorbisTools.computeWindow = function(n,$window) {
	var n2 = n >> 1;
	var _g = 0;
	var _g1 = n2;
	while(_g < _g1) {
		var i = _g++;
		$window[i] = Math.sin(1.5707963267948966 * stb_format_vorbis_VorbisTools.square(Math.sin((i + 0.5) / n2 * 0.5 * 3.14159265358979323846264)));
	}
};
stb_format_vorbis_VorbisTools.square = function(f) {
	return f * f;
};
stb_format_vorbis_VorbisTools.computeBitReverse = function(n,rev) {
	var log2_4 = [0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4];
	var ld = (n < 16384 ? n < 16 ? log2_4[n] : n < 512 ? 5 + log2_4[n >> 5] : 10 + log2_4[n >> 10] : n < 16777216 ? n < 524288 ? 15 + log2_4[n >> 15] : 20 + log2_4[n >> 20] : n < 536870912 ? 25 + log2_4[n >> 25] : n < -2147483648 ? 30 + log2_4[n >> 30] : 0) - 1;
	var n8 = n >> 3;
	var _g = 0;
	var _g1 = n8;
	while(_g < _g1) {
		var i = _g++;
		var n = i;
		n = (n & -1431655766) >>> 1 | (n & 1431655765) << 1;
		n = (n & -858993460) >>> 2 | (n & 858993459) << 2;
		n = (n & -252645136) >>> 4 | (n & 252645135) << 4;
		n = (n & -16711936) >>> 8 | (n & 16711935) << 8;
		rev[i] = (n >>> 16 | n << 16) >>> 32 - ld + 3 << 2;
	}
};
stb_format_vorbis_VorbisTools.computeTwiddleFactors = function(n,af,bf,cf) {
	var n4 = n >> 2;
	var n8 = n >> 3;
	var k2 = 0;
	var _g = 0;
	var _g1 = n4;
	while(_g < _g1) {
		var k = _g++;
		af[k2] = Math.cos(4 * k * 3.14159265358979323846264 / n);
		af[k2 + 1] = -Math.sin(4 * k * 3.14159265358979323846264 / n);
		bf[k2] = Math.cos((k2 + 1) * 3.14159265358979323846264 / n / 2) * 0.5;
		bf[k2 + 1] = Math.sin((k2 + 1) * 3.14159265358979323846264 / n / 2) * 0.5;
		k2 += 2;
	}
	var k2 = 0;
	var _g = 0;
	var _g1 = n8;
	while(_g < _g1) {
		var k = _g++;
		cf[k2] = Math.cos(2 * (k2 + 1) * 3.14159265358979323846264 / n);
		cf[k2 + 1] = -Math.sin(2 * (k2 + 1) * 3.14159265358979323846264 / n);
		k2 += 2;
	}
};
stb_format_vorbis_VorbisTools.drawLine = function(output,x0,y0,x1,y1,n) {
	if(stb_format_vorbis_VorbisTools.integerDivideTable == null) {
		var this1 = new Array(32);
		stb_format_vorbis_VorbisTools.integerDivideTable = this1;
		var _g = 0;
		while(_g < 32) {
			var i = _g++;
			var this1 = stb_format_vorbis_VorbisTools.integerDivideTable;
			var this2 = new Array(64);
			this1[i] = this2;
			var _g1 = 1;
			while(_g1 < 64) {
				var j = _g1++;
				stb_format_vorbis_VorbisTools.integerDivideTable[i][j] = i / j | 0;
			}
		}
	}
	var dy = y1 - y0;
	var adx = x1 - x0;
	var ady = dy < 0 ? -dy : dy;
	var base;
	var x = x0;
	var y = y0;
	var err = 0;
	var sy;
	if(adx < 64 && ady < 32) {
		if(dy < 0) {
			base = -stb_format_vorbis_VorbisTools.integerDivideTable[ady][adx];
			sy = base - 1;
		} else {
			base = stb_format_vorbis_VorbisTools.integerDivideTable[ady][adx];
			sy = base + 1;
		}
	} else {
		base = dy / adx | 0;
		sy = dy < 0 ? base - 1 : base + 1;
	}
	ady -= (base < 0 ? -base : base) * adx;
	if(x1 > n) {
		x1 = n;
	}
	output[x] *= stb_format_vorbis_VorbisTools.INVERSE_DB_TABLE[y];
	var _g = x + 1;
	var _g1 = x1;
	while(_g < _g1) {
		var i = _g++;
		err += ady;
		if(err >= adx) {
			err -= adx;
			y += sy;
		} else {
			y += base;
		}
		output[i] *= stb_format_vorbis_VorbisTools.INVERSE_DB_TABLE[y];
	}
};
var stb_format_vorbis_data_Codebook = function() {
};
$hxClasses["stb.format.vorbis.data.Codebook"] = stb_format_vorbis_data_Codebook;
stb_format_vorbis_data_Codebook.__name__ = "stb.format.vorbis.data.Codebook";
stb_format_vorbis_data_Codebook.read = function(decodeState) {
	var c = new stb_format_vorbis_data_Codebook();
	var tmp;
	var tmp1;
	var tmp2;
	if(decodeState.validBits < 0) {
		tmp2 = 0;
	} else if(decodeState.validBits < 8) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 8)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			tmp2 = 0;
		} else {
			var z = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			tmp2 = z;
		}
	} else {
		var z = decodeState.acc & 255;
		decodeState.acc = decodeState.acc >>> 8;
		decodeState.validBits -= 8;
		tmp2 = z;
	}
	if(tmp2 == 66) {
		var tmp2;
		if(decodeState.validBits < 0) {
			tmp2 = 0;
		} else if(decodeState.validBits < 8) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 8)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				tmp2 = 0;
			} else {
				var z = decodeState.acc & 255;
				decodeState.acc = decodeState.acc >>> 8;
				decodeState.validBits -= 8;
				tmp2 = z;
			}
		} else {
			var z = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			tmp2 = z;
		}
		tmp1 = tmp2 != 67;
	} else {
		tmp1 = true;
	}
	if(!tmp1) {
		var tmp1;
		if(decodeState.validBits < 0) {
			tmp1 = 0;
		} else if(decodeState.validBits < 8) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 8)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				tmp1 = 0;
			} else {
				var z = decodeState.acc & 255;
				decodeState.acc = decodeState.acc >>> 8;
				decodeState.validBits -= 8;
				tmp1 = z;
			}
		} else {
			var z = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			tmp1 = z;
		}
		tmp = tmp1 != 86;
	} else {
		tmp = true;
	}
	if(tmp) {
		throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Codebook.hx", lineNumber : 40, className : "stb.format.vorbis.data.Codebook", methodName : "read"}));
	}
	var x;
	if(decodeState.validBits < 0) {
		x = 0;
	} else if(decodeState.validBits < 8) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 8)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			x = 0;
		} else {
			var z = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			x = z;
		}
	} else {
		var z = decodeState.acc & 255;
		decodeState.acc = decodeState.acc >>> 8;
		decodeState.validBits -= 8;
		x = z;
	}
	var tmp;
	if(decodeState.validBits < 0) {
		tmp = 0;
	} else if(decodeState.validBits < 8) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 8)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else {
			var z = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			tmp = z;
		}
	} else {
		var z = decodeState.acc & 255;
		decodeState.acc = decodeState.acc >>> 8;
		decodeState.validBits -= 8;
		tmp = z;
	}
	c.dimensions = (tmp << 8) + x;
	var x;
	if(decodeState.validBits < 0) {
		x = 0;
	} else if(decodeState.validBits < 8) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 8)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			x = 0;
		} else {
			var z = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			x = z;
		}
	} else {
		var z = decodeState.acc & 255;
		decodeState.acc = decodeState.acc >>> 8;
		decodeState.validBits -= 8;
		x = z;
	}
	var y;
	if(decodeState.validBits < 0) {
		y = 0;
	} else if(decodeState.validBits < 8) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 8)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			y = 0;
		} else {
			var z = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			y = z;
		}
	} else {
		var z = decodeState.acc & 255;
		decodeState.acc = decodeState.acc >>> 8;
		decodeState.validBits -= 8;
		y = z;
	}
	var tmp;
	if(decodeState.validBits < 0) {
		tmp = 0;
	} else if(decodeState.validBits < 8) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 8)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else {
			var z = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			tmp = z;
		}
	} else {
		var z = decodeState.acc & 255;
		decodeState.acc = decodeState.acc >>> 8;
		decodeState.validBits -= 8;
		tmp = z;
	}
	c.entries = (tmp << 16) + (y << 8) + x;
	var ordered;
	if(decodeState.validBits < 0) {
		ordered = 0;
	} else if(decodeState.validBits < 1) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 1)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			ordered = 0;
		} else {
			var z = decodeState.acc & 1;
			decodeState.acc = decodeState.acc >>> 1;
			decodeState.validBits -= 1;
			ordered = z;
		}
	} else {
		var z = decodeState.acc & 1;
		decodeState.acc = decodeState.acc >>> 1;
		decodeState.validBits -= 1;
		ordered = z;
	}
	var tmp;
	if(ordered != 0) {
		tmp = false;
	} else {
		var tmp1;
		if(decodeState.validBits < 0) {
			tmp1 = 0;
		} else if(decodeState.validBits < 1) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 1)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				tmp1 = 0;
			} else {
				var z = decodeState.acc & 1;
				decodeState.acc = decodeState.acc >>> 1;
				decodeState.validBits -= 1;
				tmp1 = z;
			}
		} else {
			var z = decodeState.acc & 1;
			decodeState.acc = decodeState.acc >>> 1;
			decodeState.validBits -= 1;
			tmp1 = z;
		}
		tmp = tmp1 != 0;
	}
	c.sparse = tmp;
	var this1 = new Array(c.entries);
	var lengths = this1;
	if(!c.sparse) {
		c.codewordLengths = lengths;
	}
	var total = 0;
	if(ordered != 0) {
		var currentEntry = 0;
		var currentLength;
		if(decodeState.validBits < 0) {
			currentLength = 0;
		} else if(decodeState.validBits < 5) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 5)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				currentLength = 0;
			} else {
				var z = decodeState.acc & 31;
				decodeState.acc = decodeState.acc >>> 5;
				decodeState.validBits -= 5;
				currentLength = z;
			}
		} else {
			var z = decodeState.acc & 31;
			decodeState.acc = decodeState.acc >>> 5;
			decodeState.validBits -= 5;
			currentLength = z;
		}
		var currentLength1 = currentLength + 1;
		while(currentEntry < c.entries) {
			var limit = c.entries - currentEntry;
			var log2_4 = [0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4];
			var n = limit < 16384 ? limit < 16 ? log2_4[limit] : limit < 512 ? 5 + log2_4[limit >> 5] : 10 + log2_4[limit >> 10] : limit < 16777216 ? limit < 524288 ? 15 + log2_4[limit >> 15] : 20 + log2_4[limit >> 20] : limit < 536870912 ? 25 + log2_4[limit >> 25] : limit < -2147483648 ? 30 + log2_4[limit >> 30] : 0;
			var n1;
			if(decodeState.validBits < 0) {
				n1 = 0;
			} else if(decodeState.validBits < n) {
				if(n > 24) {
					var n2;
					if(decodeState.validBits < 0) {
						n2 = 0;
					} else if(decodeState.validBits < 24) {
						if(decodeState.validBits == 0) {
							decodeState.acc = 0;
						}
						while(true) {
							if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
								decodeState.validBits = -1;
								break;
							} else {
								decodeState.bytesInSeg--;
								decodeState.inputPosition += 1;
								decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
								decodeState.validBits += 8;
							}
							if(!(decodeState.validBits < 24)) {
								break;
							}
						}
						if(decodeState.validBits < 0) {
							n2 = 0;
						} else {
							var z = decodeState.acc & 16777215;
							decodeState.acc = decodeState.acc >>> 24;
							decodeState.validBits -= 24;
							n2 = z;
						}
					} else {
						var z1 = decodeState.acc & 16777215;
						decodeState.acc = decodeState.acc >>> 24;
						decodeState.validBits -= 24;
						n2 = z1;
					}
					var n3 = n - 24;
					var n4;
					if(decodeState.validBits < 0) {
						n4 = 0;
					} else if(decodeState.validBits < n3) {
						if(n3 > 24) {
							n4 = decodeState.readBits(24) + (decodeState.readBits(n3 - 24) << 24);
						} else {
							if(decodeState.validBits == 0) {
								decodeState.acc = 0;
							}
							while(true) {
								if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
									decodeState.validBits = -1;
									break;
								} else {
									decodeState.bytesInSeg--;
									decodeState.inputPosition += 1;
									decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
									decodeState.validBits += 8;
								}
								if(!(decodeState.validBits < n3)) {
									break;
								}
							}
							if(decodeState.validBits < 0) {
								n4 = 0;
							} else {
								var z2 = decodeState.acc & (1 << n3) - 1;
								decodeState.acc = decodeState.acc >>> n3;
								decodeState.validBits -= n3;
								n4 = z2;
							}
						}
					} else {
						var z3 = decodeState.acc & (1 << n3) - 1;
						decodeState.acc = decodeState.acc >>> n3;
						decodeState.validBits -= n3;
						n4 = z3;
					}
					n1 = n2 + (n4 << 24);
				} else {
					if(decodeState.validBits == 0) {
						decodeState.acc = 0;
					}
					while(true) {
						if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
							decodeState.validBits = -1;
							break;
						} else {
							decodeState.bytesInSeg--;
							decodeState.inputPosition += 1;
							decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
							decodeState.validBits += 8;
						}
						if(!(decodeState.validBits < n)) {
							break;
						}
					}
					if(decodeState.validBits < 0) {
						n1 = 0;
					} else {
						var z4 = decodeState.acc & (1 << n) - 1;
						decodeState.acc = decodeState.acc >>> n;
						decodeState.validBits -= n;
						n1 = z4;
					}
				}
			} else {
				var z5 = decodeState.acc & (1 << n) - 1;
				decodeState.acc = decodeState.acc >>> n;
				decodeState.validBits -= n;
				n1 = z5;
			}
			if(currentEntry + n1 > c.entries) {
				throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,"codebook entrys",{ fileName : "stb/format/vorbis/data/Codebook.hx", lineNumber : 67, className : "stb.format.vorbis.data.Codebook", methodName : "read"}));
			}
			var _g = 0;
			var _g1 = n1;
			while(_g < _g1) {
				var i = _g++;
				lengths[currentEntry + i] = currentLength1;
			}
			currentEntry += n1;
			++currentLength1;
		}
	} else {
		var _g = 0;
		var _g1 = c.entries;
		while(_g < _g1) {
			var j = _g++;
			var present;
			if(c.sparse) {
				if(decodeState.validBits < 0) {
					present = 0;
				} else if(decodeState.validBits < 1) {
					if(decodeState.validBits == 0) {
						decodeState.acc = 0;
					}
					while(true) {
						if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
							decodeState.validBits = -1;
							break;
						} else {
							decodeState.bytesInSeg--;
							decodeState.inputPosition += 1;
							decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
							decodeState.validBits += 8;
						}
						if(!(decodeState.validBits < 1)) {
							break;
						}
					}
					if(decodeState.validBits < 0) {
						present = 0;
					} else {
						var z = decodeState.acc & 1;
						decodeState.acc = decodeState.acc >>> 1;
						decodeState.validBits -= 1;
						present = z;
					}
				} else {
					var z1 = decodeState.acc & 1;
					decodeState.acc = decodeState.acc >>> 1;
					decodeState.validBits -= 1;
					present = z1;
				}
			} else {
				present = 1;
			}
			if(present != 0) {
				var val;
				if(decodeState.validBits < 0) {
					val = 0;
				} else if(decodeState.validBits < 5) {
					if(decodeState.validBits == 0) {
						decodeState.acc = 0;
					}
					while(true) {
						if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
							decodeState.validBits = -1;
							break;
						} else {
							decodeState.bytesInSeg--;
							decodeState.inputPosition += 1;
							decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
							decodeState.validBits += 8;
						}
						if(!(decodeState.validBits < 5)) {
							break;
						}
					}
					if(decodeState.validBits < 0) {
						val = 0;
					} else {
						var z2 = decodeState.acc & 31;
						decodeState.acc = decodeState.acc >>> 5;
						decodeState.validBits -= 5;
						val = z2;
					}
				} else {
					var z3 = decodeState.acc & 31;
					decodeState.acc = decodeState.acc >>> 5;
					decodeState.validBits -= 5;
					val = z3;
				}
				lengths[j] = val + 1;
				++total;
			} else {
				lengths[j] = 255;
			}
		}
	}
	if(c.sparse && total >= c.entries >> 2) {
		c.codewordLengths = lengths;
		c.sparse = false;
	}
	var tmp;
	if(c.sparse) {
		tmp = total;
	} else {
		var sortedCount = 0;
		var _g = 0;
		var _g1 = c.entries;
		while(_g < _g1) {
			var j = _g++;
			var l = lengths[j];
			if(l > 10 && l != 255) {
				++sortedCount;
			}
		}
		tmp = sortedCount;
	}
	c.sortedEntries = tmp;
	var values = null;
	if(!c.sparse) {
		var this1 = new Array(c.entries);
		c.codewords = this1;
	} else {
		if(c.sortedEntries != 0) {
			var this1 = new Array(c.sortedEntries);
			c.codewordLengths = this1;
			var this1 = new Array(c.entries);
			c.codewords = this1;
			var this1 = new Array(c.entries);
			values = this1;
		}
		var size = c.entries + 64 * c.sortedEntries;
	}
	if(!c.computeCodewords(lengths,c.entries,values)) {
		throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,"compute codewords",{ fileName : "stb/format/vorbis/data/Codebook.hx", lineNumber : 120, className : "stb.format.vorbis.data.Codebook", methodName : "read"}));
	}
	if(c.sortedEntries != 0) {
		c.sortedCodewords = [];
		var this1 = new Array(c.sortedEntries);
		c.sortedValues = this1;
		c.computeSortedHuffman(lengths,values);
	}
	if(c.sparse) {
		values = null;
		c.codewords = null;
		lengths = null;
	}
	c.computeAcceleratedHuffman();
	var tmp;
	if(decodeState.validBits < 0) {
		tmp = 0;
	} else if(decodeState.validBits < 4) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 4)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else {
			var z = decodeState.acc & 15;
			decodeState.acc = decodeState.acc >>> 4;
			decodeState.validBits -= 4;
			tmp = z;
		}
	} else {
		var z = decodeState.acc & 15;
		decodeState.acc = decodeState.acc >>> 4;
		decodeState.validBits -= 4;
		tmp = z;
	}
	c.lookupType = tmp;
	if(c.lookupType > 2) {
		throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,"codebook lookup type",{ fileName : "stb/format/vorbis/data/Codebook.hx", lineNumber : 143, className : "stb.format.vorbis.data.Codebook", methodName : "read"}));
	}
	if(c.lookupType > 0) {
		var x;
		if(decodeState.validBits < 0) {
			x = 0;
		} else if(decodeState.validBits < 32) {
			var x1;
			if(decodeState.validBits < 0) {
				x1 = 0;
			} else if(decodeState.validBits < 24) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				while(true) {
					if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
						decodeState.validBits = -1;
						break;
					} else {
						decodeState.bytesInSeg--;
						decodeState.inputPosition += 1;
						decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
						decodeState.validBits += 8;
					}
					if(!(decodeState.validBits < 24)) {
						break;
					}
				}
				if(decodeState.validBits < 0) {
					x1 = 0;
				} else {
					var z = decodeState.acc & 16777215;
					decodeState.acc = decodeState.acc >>> 24;
					decodeState.validBits -= 24;
					x1 = z;
				}
			} else {
				var z = decodeState.acc & 16777215;
				decodeState.acc = decodeState.acc >>> 24;
				decodeState.validBits -= 24;
				x1 = z;
			}
			var x2;
			if(decodeState.validBits < 0) {
				x2 = 0;
			} else if(decodeState.validBits < 8) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				while(true) {
					if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
						decodeState.validBits = -1;
						break;
					} else {
						decodeState.bytesInSeg--;
						decodeState.inputPosition += 1;
						decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
						decodeState.validBits += 8;
					}
					if(!(decodeState.validBits < 8)) {
						break;
					}
				}
				if(decodeState.validBits < 0) {
					x2 = 0;
				} else {
					var z = decodeState.acc & 255;
					decodeState.acc = decodeState.acc >>> 8;
					decodeState.validBits -= 8;
					x2 = z;
				}
			} else {
				var z = decodeState.acc & 255;
				decodeState.acc = decodeState.acc >>> 8;
				decodeState.validBits -= 8;
				x2 = z;
			}
			x = x1 + (x2 << 24);
		} else {
			var z = decodeState.acc & -1;
			decodeState.acc = decodeState.acc >>> 32;
			decodeState.validBits -= 32;
			x = z;
		}
		var mantissa = UInt.toFloat(x & 2097151);
		var sign = x & -2147483648;
		var exp = (x & 2145386496) >>> 21;
		var res = sign != 0 ? -mantissa : mantissa;
		c.minimumValue = res * Math.pow(2,exp - 788);
		var x;
		if(decodeState.validBits < 0) {
			x = 0;
		} else if(decodeState.validBits < 32) {
			var x1;
			if(decodeState.validBits < 0) {
				x1 = 0;
			} else if(decodeState.validBits < 24) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				while(true) {
					if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
						decodeState.validBits = -1;
						break;
					} else {
						decodeState.bytesInSeg--;
						decodeState.inputPosition += 1;
						decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
						decodeState.validBits += 8;
					}
					if(!(decodeState.validBits < 24)) {
						break;
					}
				}
				if(decodeState.validBits < 0) {
					x1 = 0;
				} else {
					var z = decodeState.acc & 16777215;
					decodeState.acc = decodeState.acc >>> 24;
					decodeState.validBits -= 24;
					x1 = z;
				}
			} else {
				var z = decodeState.acc & 16777215;
				decodeState.acc = decodeState.acc >>> 24;
				decodeState.validBits -= 24;
				x1 = z;
			}
			var x2;
			if(decodeState.validBits < 0) {
				x2 = 0;
			} else if(decodeState.validBits < 8) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				while(true) {
					if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
						decodeState.validBits = -1;
						break;
					} else {
						decodeState.bytesInSeg--;
						decodeState.inputPosition += 1;
						decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
						decodeState.validBits += 8;
					}
					if(!(decodeState.validBits < 8)) {
						break;
					}
				}
				if(decodeState.validBits < 0) {
					x2 = 0;
				} else {
					var z = decodeState.acc & 255;
					decodeState.acc = decodeState.acc >>> 8;
					decodeState.validBits -= 8;
					x2 = z;
				}
			} else {
				var z = decodeState.acc & 255;
				decodeState.acc = decodeState.acc >>> 8;
				decodeState.validBits -= 8;
				x2 = z;
			}
			x = x1 + (x2 << 24);
		} else {
			var z = decodeState.acc & -1;
			decodeState.acc = decodeState.acc >>> 32;
			decodeState.validBits -= 32;
			x = z;
		}
		var mantissa = UInt.toFloat(x & 2097151);
		var sign = x & -2147483648;
		var exp = (x & 2145386496) >>> 21;
		var res = sign != 0 ? -mantissa : mantissa;
		c.deltaValue = res * Math.pow(2,exp - 788);
		var tmp;
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else if(decodeState.validBits < 4) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 4)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				tmp = 0;
			} else {
				var z = decodeState.acc & 15;
				decodeState.acc = decodeState.acc >>> 4;
				decodeState.validBits -= 4;
				tmp = z;
			}
		} else {
			var z = decodeState.acc & 15;
			decodeState.acc = decodeState.acc >>> 4;
			decodeState.validBits -= 4;
			tmp = z;
		}
		c.valueBits = tmp + 1;
		var tmp;
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else if(decodeState.validBits < 1) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 1)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				tmp = 0;
			} else {
				var z = decodeState.acc & 1;
				decodeState.acc = decodeState.acc >>> 1;
				decodeState.validBits -= 1;
				tmp = z;
			}
		} else {
			var z = decodeState.acc & 1;
			decodeState.acc = decodeState.acc >>> 1;
			decodeState.validBits -= 1;
			tmp = z;
		}
		c.sequenceP = tmp != 0;
		if(c.lookupType == 1) {
			c.lookupValues = stb_format_vorbis_VorbisTools.lookup1Values(c.entries,c.dimensions);
		} else {
			c.lookupValues = c.entries * c.dimensions;
		}
		var this1 = new Array(c.lookupValues);
		var mults = this1;
		var _g = 0;
		var _g1 = c.lookupValues;
		while(_g < _g1) {
			var j = _g++;
			var n = c.valueBits;
			var q;
			if(decodeState.validBits < 0) {
				q = 0;
			} else if(decodeState.validBits < n) {
				if(n > 24) {
					var q1;
					if(decodeState.validBits < 0) {
						q1 = 0;
					} else if(decodeState.validBits < 24) {
						if(decodeState.validBits == 0) {
							decodeState.acc = 0;
						}
						while(true) {
							if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
								decodeState.validBits = -1;
								break;
							} else {
								decodeState.bytesInSeg--;
								decodeState.inputPosition += 1;
								decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
								decodeState.validBits += 8;
							}
							if(!(decodeState.validBits < 24)) {
								break;
							}
						}
						if(decodeState.validBits < 0) {
							q1 = 0;
						} else {
							var z = decodeState.acc & 16777215;
							decodeState.acc = decodeState.acc >>> 24;
							decodeState.validBits -= 24;
							q1 = z;
						}
					} else {
						var z1 = decodeState.acc & 16777215;
						decodeState.acc = decodeState.acc >>> 24;
						decodeState.validBits -= 24;
						q1 = z1;
					}
					var n1 = n - 24;
					var q2;
					if(decodeState.validBits < 0) {
						q2 = 0;
					} else if(decodeState.validBits < n1) {
						if(n1 > 24) {
							q2 = decodeState.readBits(24) + (decodeState.readBits(n1 - 24) << 24);
						} else {
							if(decodeState.validBits == 0) {
								decodeState.acc = 0;
							}
							while(true) {
								if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
									decodeState.validBits = -1;
									break;
								} else {
									decodeState.bytesInSeg--;
									decodeState.inputPosition += 1;
									decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
									decodeState.validBits += 8;
								}
								if(!(decodeState.validBits < n1)) {
									break;
								}
							}
							if(decodeState.validBits < 0) {
								q2 = 0;
							} else {
								var z2 = decodeState.acc & (1 << n1) - 1;
								decodeState.acc = decodeState.acc >>> n1;
								decodeState.validBits -= n1;
								q2 = z2;
							}
						}
					} else {
						var z3 = decodeState.acc & (1 << n1) - 1;
						decodeState.acc = decodeState.acc >>> n1;
						decodeState.validBits -= n1;
						q2 = z3;
					}
					q = q1 + (q2 << 24);
				} else {
					if(decodeState.validBits == 0) {
						decodeState.acc = 0;
					}
					while(true) {
						if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
							decodeState.validBits = -1;
							break;
						} else {
							decodeState.bytesInSeg--;
							decodeState.inputPosition += 1;
							decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
							decodeState.validBits += 8;
						}
						if(!(decodeState.validBits < n)) {
							break;
						}
					}
					if(decodeState.validBits < 0) {
						q = 0;
					} else {
						var z4 = decodeState.acc & (1 << n) - 1;
						decodeState.acc = decodeState.acc >>> n;
						decodeState.validBits -= n;
						q = z4;
					}
				}
			} else {
				var z5 = decodeState.acc & (1 << n) - 1;
				decodeState.acc = decodeState.acc >>> n;
				decodeState.validBits -= n;
				q = z5;
			}
			if(q == -1) {
				throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,"fail lookup",{ fileName : "stb/format/vorbis/data/Codebook.hx", lineNumber : 161, className : "stb.format.vorbis.data.Codebook", methodName : "read"}));
			}
			mults[j] = q;
		}
		var this1 = new Array(c.lookupValues);
		c.multiplicands = this1;
		var _g = 0;
		var _g1 = c.lookupValues;
		while(_g < _g1) {
			var j = _g++;
			c.multiplicands[j] = mults[j] * c.deltaValue + c.minimumValue;
		}
		if(c.lookupType == 2 && c.sequenceP) {
			var _g = 1;
			var _g1 = c.lookupValues;
			while(_g < _g1) {
				var j = _g++;
				c.multiplicands[j] = c.multiplicands[j - 1];
			}
			c.sequenceP = false;
		}
	}
	return c;
};
stb_format_vorbis_data_Codebook.prototype = {
	computeCodewords: function(len,n,values) {
		var this1 = new Array(32);
		var available = this1;
		available[0] = 0;
		available[1] = 0;
		available[2] = 0;
		available[3] = 0;
		available[4] = 0;
		available[5] = 0;
		available[6] = 0;
		available[7] = 0;
		available[8] = 0;
		available[9] = 0;
		available[10] = 0;
		available[11] = 0;
		available[12] = 0;
		available[13] = 0;
		available[14] = 0;
		available[15] = 0;
		available[16] = 0;
		available[17] = 0;
		available[18] = 0;
		available[19] = 0;
		available[20] = 0;
		available[21] = 0;
		available[22] = 0;
		available[23] = 0;
		available[24] = 0;
		available[25] = 0;
		available[26] = 0;
		available[27] = 0;
		available[28] = 0;
		available[29] = 0;
		available[30] = 0;
		available[31] = 0;
		var k = 0;
		while(k < n) {
			if(len[k] < 255) {
				break;
			}
			++k;
		}
		if(k == n) {
			return true;
		}
		var m = 0;
		var count = m++;
		if(!this.sparse) {
			this.codewords[k] = 0;
		} else {
			this.codewords[count] = 0;
			this.codewordLengths[count] = len[k];
			values[count] = k;
		}
		var i = 0;
		while(++i <= len[k]) available[i] = 1 << 32 - i;
		i = k;
		while(++i < n) {
			var z = len[i];
			if(z == 255) {
				continue;
			}
			while(z > 0 && available[z] == 0) --z;
			if(z == 0) {
				return false;
			}
			var res = available[z];
			available[z] = 0;
			var n1 = res;
			n1 = (n1 & -1431655766) >>> 1 | (n1 & 1431655765) << 1;
			n1 = (n1 & -858993460) >>> 2 | (n1 & 858993459) << 2;
			n1 = (n1 & -252645136) >>> 4 | (n1 & 252645135) << 4;
			n1 = (n1 & -16711936) >>> 8 | (n1 & 16711935) << 8;
			var huffCode = n1 >>> 16 | n1 << 16;
			var count = m++;
			if(!this.sparse) {
				this.codewords[i] = huffCode;
			} else {
				this.codewords[count] = huffCode;
				this.codewordLengths[count] = len[i];
				values[count] = i;
			}
			if(z != len[i]) {
				var y = len[i];
				while(y > z) {
					available[y] = res + (1 << 32 - y);
					--y;
				}
			}
		}
		return true;
	}
	,computeSortedHuffman: function(lengths,values) {
		if(!this.sparse) {
			var k = 0;
			var _g = 0;
			var _g1 = this.entries;
			while(_g < _g1) {
				var i = _g++;
				var len = lengths[i];
				if(this.sparse ? true : len == 255 ? false : len > 10) {
					var n = this.codewords[i];
					n = (n & -1431655766) >>> 1 | (n & 1431655765) << 1;
					n = (n & -858993460) >>> 2 | (n & 858993459) << 2;
					n = (n & -252645136) >>> 4 | (n & 252645135) << 4;
					n = (n & -16711936) >>> 8 | (n & 16711935) << 8;
					this.sortedCodewords[k++] = n >>> 16 | n << 16;
				}
			}
		} else {
			var _g = 0;
			var _g1 = this.sortedEntries;
			while(_g < _g1) {
				var i = _g++;
				var n = this.codewords[i];
				n = (n & -1431655766) >>> 1 | (n & 1431655765) << 1;
				n = (n & -858993460) >>> 2 | (n & 858993459) << 2;
				n = (n & -252645136) >>> 4 | (n & 252645135) << 4;
				n = (n & -16711936) >>> 8 | (n & 16711935) << 8;
				this.sortedCodewords[i] = n >>> 16 | n << 16;
			}
		}
		this.sortedCodewords[this.sortedEntries] = -1;
		this.sortedCodewords.sort(stb_format_vorbis_VorbisTools.uintAsc);
		var len = this.sparse ? this.sortedEntries : this.entries;
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			var huffLen = this.sparse ? lengths[values[i]] : lengths[i];
			if(this.sparse ? true : huffLen == 255 ? false : huffLen > 10) {
				var n = this.codewords[i];
				n = (n & -1431655766) >>> 1 | (n & 1431655765) << 1;
				n = (n & -858993460) >>> 2 | (n & 858993459) << 2;
				n = (n & -252645136) >>> 4 | (n & 252645135) << 4;
				n = (n & -16711936) >>> 8 | (n & 16711935) << 8;
				var code = n >>> 16 | n << 16;
				var x = 0;
				var n1 = this.sortedEntries;
				while(n1 > 1) {
					var m = x + (n1 >> 1);
					if(UInt.gte(code,this.sortedCodewords[m])) {
						x = m;
						n1 -= n1 >> 1;
					} else {
						n1 >>= 1;
					}
				}
				if(this.sparse) {
					this.sortedValues[x] = values[i];
					this.codewordLengths[x] = huffLen;
				} else {
					this.sortedValues[x] = i;
				}
			}
		}
	}
	,computeAcceleratedHuffman: function() {
		var this1 = new Array(1024);
		this.fastHuffman = this1;
		this.fastHuffman[0] = -1;
		var _g = 0;
		var _g1 = 1024;
		while(_g < _g1) {
			var i = _g++;
			this.fastHuffman[i] = -1;
		}
		var len = this.sparse ? this.sortedEntries : this.entries;
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			if(this.codewordLengths[i] <= 10) {
				var z;
				if(this.sparse) {
					var n = this.sortedCodewords[i];
					n = (n & -1431655766) >>> 1 | (n & 1431655765) << 1;
					n = (n & -858993460) >>> 2 | (n & 858993459) << 2;
					n = (n & -252645136) >>> 4 | (n & 252645135) << 4;
					n = (n & -16711936) >>> 8 | (n & 16711935) << 8;
					z = n >>> 16 | n << 16;
				} else {
					z = this.codewords[i];
				}
				while(z < 1024) {
					this.fastHuffman[z] = i;
					z += 1 << this.codewordLengths[i];
				}
			}
		}
	}
	,codebookDecode: function(decodeState,output,offset,len) {
		if(decodeState.validBits < 10) {
			decodeState.prepHuffman();
		}
		var i = this.fastHuffman[decodeState.acc & 1023];
		var val;
		if(i >= 0) {
			var l = this.codewordLengths[i];
			decodeState.acc = decodeState.acc >>> l;
			decodeState.validBits -= l;
			if(decodeState.validBits < 0) {
				decodeState.validBits = 0;
				val = -1;
			} else {
				val = i;
			}
		} else {
			val = decodeState.decodeScalarRaw(this);
		}
		if(this.sparse) {
			val = this.sortedValues[val];
		}
		var z = val;
		var lookupValues = this.lookupValues;
		var sequenceP = this.sequenceP;
		var multiplicands = this.multiplicands;
		var minimumValue = this.minimumValue;
		if(z < 0) {
			return false;
		}
		if(len > this.dimensions) {
			len = this.dimensions;
		}
		if(this.lookupType == 1) {
			var div = 1;
			var last = 0.0;
			var _g = 0;
			var _g1 = len;
			while(_g < _g1) {
				var i = _g++;
				var off = UInt.toFloat(z / div | 0) % UInt.toFloat(lookupValues) | 0;
				var val = multiplicands[off] + last;
				output[offset + i] += val;
				if(sequenceP) {
					last = val + minimumValue;
				}
				div = div * lookupValues;
			}
			return true;
		}
		z *= this.dimensions;
		if(sequenceP) {
			var last = 0.0;
			var _g = 0;
			var _g1 = len;
			while(_g < _g1) {
				var i = _g++;
				var val = multiplicands[z + i] + last;
				output[offset + i] += val;
				last = val + minimumValue;
			}
		} else {
			var last = 0.0;
			var _g = 0;
			var _g1 = len;
			while(_g < _g1) {
				var i = _g++;
				output[offset + i] += multiplicands[z + i] + last;
			}
		}
		return true;
	}
	,codebookDecodeStep: function(decodeState,output,offset,len,step) {
		if(decodeState.validBits < 10) {
			decodeState.prepHuffman();
		}
		var i = this.fastHuffman[decodeState.acc & 1023];
		var val;
		if(i >= 0) {
			var l = this.codewordLengths[i];
			decodeState.acc = decodeState.acc >>> l;
			decodeState.validBits -= l;
			if(decodeState.validBits < 0) {
				decodeState.validBits = 0;
				val = -1;
			} else {
				val = i;
			}
		} else {
			val = decodeState.decodeScalarRaw(this);
		}
		if(this.sparse) {
			val = this.sortedValues[val];
		}
		var z = val;
		var last = 0.0;
		if(z < 0) {
			return false;
		}
		if(len > this.dimensions) {
			len = this.dimensions;
		}
		var lookupValues = this.lookupValues;
		var sequenceP = this.sequenceP;
		var multiplicands = this.multiplicands;
		if(this.lookupType == 1) {
			var div = 1;
			var _g = 0;
			var _g1 = len;
			while(_g < _g1) {
				var i = _g++;
				var off = UInt.toFloat(z / div | 0) % UInt.toFloat(lookupValues) | 0;
				var val = multiplicands[off] + last;
				output[offset + i * step] += val;
				if(sequenceP) {
					last = val;
				}
				div = div * lookupValues;
			}
			return true;
		}
		z *= this.dimensions;
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			var val = multiplicands[z + i] + last;
			output[offset + i * step] += val;
			if(sequenceP) {
				last = val;
			}
		}
		return true;
	}
	,decodeDeinterleaveRepeat: function(decodeState,residueBuffers,ch,cInter,pInter,len,totalDecode) {
		var effective = this.dimensions;
		if(this.lookupType == 0) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_STREAM,null,{ fileName : "stb/format/vorbis/data/Codebook.hx", lineNumber : 488, className : "stb.format.vorbis.data.Codebook", methodName : "decodeDeinterleaveRepeat"}));
		}
		var multiplicands = this.multiplicands;
		var sequenceP = this.sequenceP;
		var lookupValues = this.lookupValues;
		while(totalDecode > 0) {
			var last = 0.0;
			if(decodeState.validBits < 10) {
				decodeState.prepHuffman();
			}
			var i = this.fastHuffman[decodeState.acc & 1023];
			var val;
			if(i >= 0) {
				var l = this.codewordLengths[i];
				decodeState.acc = decodeState.acc >>> l;
				decodeState.validBits -= l;
				if(decodeState.validBits < 0) {
					decodeState.validBits = 0;
					val = -1;
				} else {
					val = i;
				}
			} else {
				val = decodeState.decodeScalarRaw(this);
			}
			if(this.sparse) {
				val = this.sortedValues[val];
			}
			var z = val;
			if(z < 0) {
				if(decodeState.bytesInSeg == 0 && decodeState.lastSeg) {
					return null;
				}
				throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_STREAM,null,{ fileName : "stb/format/vorbis/data/Codebook.hx", lineNumber : 503, className : "stb.format.vorbis.data.Codebook", methodName : "decodeDeinterleaveRepeat"}));
			}
			if(cInter + pInter * ch + effective > len * ch) {
				effective = len * ch - (pInter * ch - cInter);
			}
			if(this.lookupType == 1) {
				var div = 1;
				if(sequenceP) {
					var _g = 0;
					var _g1 = effective;
					while(_g < _g1) {
						var i1 = _g++;
						var off = UInt.toFloat(z / div | 0) % UInt.toFloat(lookupValues) | 0;
						var val1 = multiplicands[off] + last;
						residueBuffers[cInter][pInter] += val1;
						if(++cInter == ch) {
							cInter = 0;
							++pInter;
						}
						last = val1;
						div = div * lookupValues;
					}
				} else {
					var _g2 = 0;
					var _g3 = effective;
					while(_g2 < _g3) {
						var i2 = _g2++;
						var off1 = UInt.toFloat(z / div | 0) % UInt.toFloat(lookupValues) | 0;
						var val2 = multiplicands[off1] + last;
						residueBuffers[cInter][pInter] += val2;
						if(++cInter == ch) {
							cInter = 0;
							++pInter;
						}
						div = div * lookupValues;
					}
				}
			} else {
				z *= this.dimensions;
				if(sequenceP) {
					var _g4 = 0;
					var _g5 = effective;
					while(_g4 < _g5) {
						var i3 = _g4++;
						var val3 = multiplicands[z + i3] + last;
						residueBuffers[cInter][pInter] += val3;
						if(++cInter == ch) {
							cInter = 0;
							++pInter;
						}
						last = val3;
					}
				} else {
					var _g6 = 0;
					var _g7 = effective;
					while(_g6 < _g7) {
						var i4 = _g6++;
						var val4 = multiplicands[z + i4] + last;
						residueBuffers[cInter][pInter] += val4;
						if(++cInter == ch) {
							cInter = 0;
							++pInter;
						}
					}
				}
			}
			totalDecode -= effective;
		}
		return { cInter : cInter, pInter : pInter};
	}
	,residueDecode: function(decodeState,target,offset,n,rtype) {
		if(rtype == 0) {
			var step = n / this.dimensions | 0;
			var _g = 0;
			var _g1 = step;
			while(_g < _g1) {
				var k = _g++;
				if(!this.codebookDecodeStep(decodeState,target,offset + k,n - offset - k,step)) {
					return false;
				}
			}
		} else {
			var k = 0;
			while(k < n) {
				if(!this.codebookDecode(decodeState,target,offset,n - k)) {
					return false;
				}
				k += this.dimensions;
				offset += this.dimensions;
			}
		}
		return true;
	}
	,__class__: stb_format_vorbis_data_Codebook
};
var stb_format_vorbis_data_Comment = function() {
	this.data = new haxe_ds_StringMap();
};
$hxClasses["stb.format.vorbis.data.Comment"] = stb_format_vorbis_data_Comment;
stb_format_vorbis_data_Comment.__name__ = "stb.format.vorbis.data.Comment";
stb_format_vorbis_data_Comment.prototype = {
	get_loopStart: function() {
		return Std.parseInt(this.getString("loopstart"));
	}
	,get_loopLength: function() {
		return Std.parseInt(this.getString("looplength"));
	}
	,add: function(key,value) {
		key = key.toLowerCase();
		if(Object.prototype.hasOwnProperty.call(this.data.h,key)) {
			this.data.h[key].push(value);
		} else {
			var v = [value];
			this.data.h[key] = v;
		}
	}
	,getString: function(key) {
		key = key.toLowerCase();
		if(Object.prototype.hasOwnProperty.call(this.data.h,key)) {
			return this.data.h[key][0];
		} else {
			return null;
		}
	}
	,__class__: stb_format_vorbis_data_Comment
};
var stb_format_vorbis_data_Floor = function() {
};
$hxClasses["stb.format.vorbis.data.Floor"] = stb_format_vorbis_data_Floor;
stb_format_vorbis_data_Floor.__name__ = "stb.format.vorbis.data.Floor";
stb_format_vorbis_data_Floor.read = function(decodeState,codebooks) {
	var floor = new stb_format_vorbis_data_Floor();
	var tmp;
	if(decodeState.validBits < 0) {
		tmp = 0;
	} else if(decodeState.validBits < 16) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 16)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else {
			var z = decodeState.acc & 65535;
			decodeState.acc = decodeState.acc >>> 16;
			decodeState.validBits -= 16;
			tmp = z;
		}
	} else {
		var z = decodeState.acc & 65535;
		decodeState.acc = decodeState.acc >>> 16;
		decodeState.validBits -= 16;
		tmp = z;
	}
	floor.type = tmp;
	if(floor.type > 1) {
		throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Floor.hx", lineNumber : 28, className : "stb.format.vorbis.data.Floor", methodName : "read"}));
	}
	if(floor.type == 0) {
		var g = floor.floor0 = new stb_format_vorbis_data_Floor0();
		var tmp;
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else if(decodeState.validBits < 8) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 8)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				tmp = 0;
			} else {
				var z = decodeState.acc & 255;
				decodeState.acc = decodeState.acc >>> 8;
				decodeState.validBits -= 8;
				tmp = z;
			}
		} else {
			var z = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			tmp = z;
		}
		g.order = tmp;
		var tmp;
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else if(decodeState.validBits < 16) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 16)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				tmp = 0;
			} else {
				var z = decodeState.acc & 65535;
				decodeState.acc = decodeState.acc >>> 16;
				decodeState.validBits -= 16;
				tmp = z;
			}
		} else {
			var z = decodeState.acc & 65535;
			decodeState.acc = decodeState.acc >>> 16;
			decodeState.validBits -= 16;
			tmp = z;
		}
		g.rate = tmp;
		var tmp;
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else if(decodeState.validBits < 16) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 16)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				tmp = 0;
			} else {
				var z = decodeState.acc & 65535;
				decodeState.acc = decodeState.acc >>> 16;
				decodeState.validBits -= 16;
				tmp = z;
			}
		} else {
			var z = decodeState.acc & 65535;
			decodeState.acc = decodeState.acc >>> 16;
			decodeState.validBits -= 16;
			tmp = z;
		}
		g.barkMapSize = tmp;
		var tmp;
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else if(decodeState.validBits < 6) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 6)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				tmp = 0;
			} else {
				var z = decodeState.acc & 63;
				decodeState.acc = decodeState.acc >>> 6;
				decodeState.validBits -= 6;
				tmp = z;
			}
		} else {
			var z = decodeState.acc & 63;
			decodeState.acc = decodeState.acc >>> 6;
			decodeState.validBits -= 6;
			tmp = z;
		}
		g.amplitudeBits = tmp;
		var tmp;
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else if(decodeState.validBits < 8) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 8)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				tmp = 0;
			} else {
				var z = decodeState.acc & 255;
				decodeState.acc = decodeState.acc >>> 8;
				decodeState.validBits -= 8;
				tmp = z;
			}
		} else {
			var z = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			tmp = z;
		}
		g.amplitudeOffset = tmp;
		var tmp;
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else if(decodeState.validBits < 4) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 4)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				tmp = 0;
			} else {
				var z = decodeState.acc & 15;
				decodeState.acc = decodeState.acc >>> 4;
				decodeState.validBits -= 4;
				tmp = z;
			}
		} else {
			var z = decodeState.acc & 15;
			decodeState.acc = decodeState.acc >>> 4;
			decodeState.validBits -= 4;
			tmp = z;
		}
		g.numberOfBooks = tmp + 1;
		var _g = 0;
		var _g1 = g.numberOfBooks;
		while(_g < _g1) {
			var j = _g++;
			var this1 = g.bookList;
			var val;
			if(decodeState.validBits < 0) {
				val = 0;
			} else if(decodeState.validBits < 8) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				while(true) {
					if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
						decodeState.validBits = -1;
						break;
					} else {
						decodeState.bytesInSeg--;
						decodeState.inputPosition += 1;
						decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
						decodeState.validBits += 8;
					}
					if(!(decodeState.validBits < 8)) {
						break;
					}
				}
				if(decodeState.validBits < 0) {
					val = 0;
				} else {
					var z = decodeState.acc & 255;
					decodeState.acc = decodeState.acc >>> 8;
					decodeState.validBits -= 8;
					val = z;
				}
			} else {
				var z1 = decodeState.acc & 255;
				decodeState.acc = decodeState.acc >>> 8;
				decodeState.validBits -= 8;
				val = z1;
			}
			this1[j] = val;
		}
		throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.FEATURE_NOT_SUPPORTED,null,{ fileName : "stb/format/vorbis/data/Floor.hx", lineNumber : 41, className : "stb.format.vorbis.data.Floor", methodName : "read"}));
	} else {
		var p = [];
		var g = floor.floor1 = new stb_format_vorbis_data_Floor1();
		var maxClass = -1;
		var tmp;
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else if(decodeState.validBits < 5) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 5)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				tmp = 0;
			} else {
				var z = decodeState.acc & 31;
				decodeState.acc = decodeState.acc >>> 5;
				decodeState.validBits -= 5;
				tmp = z;
			}
		} else {
			var z = decodeState.acc & 31;
			decodeState.acc = decodeState.acc >>> 5;
			decodeState.validBits -= 5;
			tmp = z;
		}
		g.partitions = tmp;
		var this1 = new Array(g.partitions);
		g.partitionClassList = this1;
		var _g = 0;
		var _g1 = g.partitions;
		while(_g < _g1) {
			var j = _g++;
			var this1 = g.partitionClassList;
			var val;
			if(decodeState.validBits < 0) {
				val = 0;
			} else if(decodeState.validBits < 4) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				while(true) {
					if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
						decodeState.validBits = -1;
						break;
					} else {
						decodeState.bytesInSeg--;
						decodeState.inputPosition += 1;
						decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
						decodeState.validBits += 8;
					}
					if(!(decodeState.validBits < 4)) {
						break;
					}
				}
				if(decodeState.validBits < 0) {
					val = 0;
				} else {
					var z = decodeState.acc & 15;
					decodeState.acc = decodeState.acc >>> 4;
					decodeState.validBits -= 4;
					val = z;
				}
			} else {
				var z1 = decodeState.acc & 15;
				decodeState.acc = decodeState.acc >>> 4;
				decodeState.validBits -= 4;
				val = z1;
			}
			this1[j] = val;
			if(g.partitionClassList[j] > maxClass) {
				maxClass = g.partitionClassList[j];
			}
		}
		var this1 = new Array(maxClass + 1);
		g.classDimensions = this1;
		var this1 = new Array(maxClass + 1);
		g.classMasterbooks = this1;
		var this1 = new Array(maxClass + 1);
		g.classSubclasses = this1;
		var this1 = new Array(maxClass + 1);
		g.subclassBooks = this1;
		var _g = 0;
		var _g1 = maxClass + 1;
		while(_g < _g1) {
			var j = _g++;
			var this1 = g.classDimensions;
			var val;
			if(decodeState.validBits < 0) {
				val = 0;
			} else if(decodeState.validBits < 3) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				while(true) {
					if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
						decodeState.validBits = -1;
						break;
					} else {
						decodeState.bytesInSeg--;
						decodeState.inputPosition += 1;
						decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
						decodeState.validBits += 8;
					}
					if(!(decodeState.validBits < 3)) {
						break;
					}
				}
				if(decodeState.validBits < 0) {
					val = 0;
				} else {
					var z = decodeState.acc & 7;
					decodeState.acc = decodeState.acc >>> 3;
					decodeState.validBits -= 3;
					val = z;
				}
			} else {
				var z1 = decodeState.acc & 7;
				decodeState.acc = decodeState.acc >>> 3;
				decodeState.validBits -= 3;
				val = z1;
			}
			this1[j] = val + 1;
			var this2 = g.classSubclasses;
			var val1;
			if(decodeState.validBits < 0) {
				val1 = 0;
			} else if(decodeState.validBits < 2) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				while(true) {
					if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
						decodeState.validBits = -1;
						break;
					} else {
						decodeState.bytesInSeg--;
						decodeState.inputPosition += 1;
						decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
						decodeState.validBits += 8;
					}
					if(!(decodeState.validBits < 2)) {
						break;
					}
				}
				if(decodeState.validBits < 0) {
					val1 = 0;
				} else {
					var z2 = decodeState.acc & 3;
					decodeState.acc = decodeState.acc >>> 2;
					decodeState.validBits -= 2;
					val1 = z2;
				}
			} else {
				var z3 = decodeState.acc & 3;
				decodeState.acc = decodeState.acc >>> 2;
				decodeState.validBits -= 2;
				val1 = z3;
			}
			this2[j] = val1;
			if(g.classSubclasses[j] != 0) {
				var this3 = g.classMasterbooks;
				var val2;
				if(decodeState.validBits < 0) {
					val2 = 0;
				} else if(decodeState.validBits < 8) {
					if(decodeState.validBits == 0) {
						decodeState.acc = 0;
					}
					while(true) {
						if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
							decodeState.validBits = -1;
							break;
						} else {
							decodeState.bytesInSeg--;
							decodeState.inputPosition += 1;
							decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
							decodeState.validBits += 8;
						}
						if(!(decodeState.validBits < 8)) {
							break;
						}
					}
					if(decodeState.validBits < 0) {
						val2 = 0;
					} else {
						var z4 = decodeState.acc & 255;
						decodeState.acc = decodeState.acc >>> 8;
						decodeState.validBits -= 8;
						val2 = z4;
					}
				} else {
					var z5 = decodeState.acc & 255;
					decodeState.acc = decodeState.acc >>> 8;
					decodeState.validBits -= 8;
					val2 = z5;
				}
				this3[j] = val2;
				if(g.classMasterbooks[j] >= codebooks.length) {
					throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Floor.hx", lineNumber : 64, className : "stb.format.vorbis.data.Floor", methodName : "read"}));
				}
			}
			var kl = 1 << g.classSubclasses[j];
			var this4 = g.subclassBooks;
			var this5 = new Array(kl);
			this4[j] = this5;
			var _g2 = 0;
			var _g3 = kl;
			while(_g2 < _g3) {
				var k = _g2++;
				var this6 = g.subclassBooks[j];
				var val3;
				if(decodeState.validBits < 0) {
					val3 = 0;
				} else if(decodeState.validBits < 8) {
					if(decodeState.validBits == 0) {
						decodeState.acc = 0;
					}
					while(true) {
						if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
							decodeState.validBits = -1;
							break;
						} else {
							decodeState.bytesInSeg--;
							decodeState.inputPosition += 1;
							decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
							decodeState.validBits += 8;
						}
						if(!(decodeState.validBits < 8)) {
							break;
						}
					}
					if(decodeState.validBits < 0) {
						val3 = 0;
					} else {
						var z6 = decodeState.acc & 255;
						decodeState.acc = decodeState.acc >>> 8;
						decodeState.validBits -= 8;
						val3 = z6;
					}
				} else {
					var z7 = decodeState.acc & 255;
					decodeState.acc = decodeState.acc >>> 8;
					decodeState.validBits -= 8;
					val3 = z7;
				}
				this6[k] = val3 - 1;
				if(g.subclassBooks[j][k] >= codebooks.length) {
					throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Floor.hx", lineNumber : 73, className : "stb.format.vorbis.data.Floor", methodName : "read"}));
				}
			}
		}
		var tmp;
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else if(decodeState.validBits < 2) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 2)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				tmp = 0;
			} else {
				var z = decodeState.acc & 3;
				decodeState.acc = decodeState.acc >>> 2;
				decodeState.validBits -= 2;
				tmp = z;
			}
		} else {
			var z = decodeState.acc & 3;
			decodeState.acc = decodeState.acc >>> 2;
			decodeState.validBits -= 2;
			tmp = z;
		}
		g.floor1Multiplier = tmp + 1;
		var tmp;
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else if(decodeState.validBits < 4) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 4)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				tmp = 0;
			} else {
				var z = decodeState.acc & 15;
				decodeState.acc = decodeState.acc >>> 4;
				decodeState.validBits -= 4;
				tmp = z;
			}
		} else {
			var z = decodeState.acc & 15;
			decodeState.acc = decodeState.acc >>> 4;
			decodeState.validBits -= 4;
			tmp = z;
		}
		g.rangebits = tmp;
		var this1 = new Array(250);
		g.xlist = this1;
		g.xlist[0] = 0;
		g.xlist[1] = 1 << g.rangebits;
		g.values = 2;
		var _g = 0;
		var _g1 = g.partitions;
		while(_g < _g1) {
			var j = _g++;
			var c = g.partitionClassList[j];
			var _g2 = 0;
			var _g3 = g.classDimensions[c];
			while(_g2 < _g3) {
				var k = _g2++;
				var this1 = g.xlist;
				var index = g.values;
				var n = g.rangebits;
				var val;
				if(decodeState.validBits < 0) {
					val = 0;
				} else if(decodeState.validBits < n) {
					if(n > 24) {
						var val1;
						if(decodeState.validBits < 0) {
							val1 = 0;
						} else if(decodeState.validBits < 24) {
							if(decodeState.validBits == 0) {
								decodeState.acc = 0;
							}
							while(true) {
								if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
									decodeState.validBits = -1;
									break;
								} else {
									decodeState.bytesInSeg--;
									decodeState.inputPosition += 1;
									decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
									decodeState.validBits += 8;
								}
								if(!(decodeState.validBits < 24)) {
									break;
								}
							}
							if(decodeState.validBits < 0) {
								val1 = 0;
							} else {
								var z = decodeState.acc & 16777215;
								decodeState.acc = decodeState.acc >>> 24;
								decodeState.validBits -= 24;
								val1 = z;
							}
						} else {
							var z1 = decodeState.acc & 16777215;
							decodeState.acc = decodeState.acc >>> 24;
							decodeState.validBits -= 24;
							val1 = z1;
						}
						var n1 = n - 24;
						var val2;
						if(decodeState.validBits < 0) {
							val2 = 0;
						} else if(decodeState.validBits < n1) {
							if(n1 > 24) {
								var val3;
								if(decodeState.validBits < 0) {
									val3 = 0;
								} else if(decodeState.validBits < 24) {
									if(decodeState.validBits == 0) {
										decodeState.acc = 0;
									}
									while(true) {
										if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
											decodeState.validBits = -1;
											break;
										} else {
											decodeState.bytesInSeg--;
											decodeState.inputPosition += 1;
											decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
											decodeState.validBits += 8;
										}
										if(!(decodeState.validBits < 24)) {
											break;
										}
									}
									if(decodeState.validBits < 0) {
										val3 = 0;
									} else {
										var z2 = decodeState.acc & 16777215;
										decodeState.acc = decodeState.acc >>> 24;
										decodeState.validBits -= 24;
										val3 = z2;
									}
								} else {
									var z3 = decodeState.acc & 16777215;
									decodeState.acc = decodeState.acc >>> 24;
									decodeState.validBits -= 24;
									val3 = z3;
								}
								var n2 = n1 - 24;
								var val4;
								if(decodeState.validBits < 0) {
									val4 = 0;
								} else if(decodeState.validBits < n2) {
									if(n2 > 24) {
										val4 = decodeState.readBits(24) + (decodeState.readBits(n2 - 24) << 24);
									} else {
										if(decodeState.validBits == 0) {
											decodeState.acc = 0;
										}
										while(true) {
											if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
												decodeState.validBits = -1;
												break;
											} else {
												decodeState.bytesInSeg--;
												decodeState.inputPosition += 1;
												decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
												decodeState.validBits += 8;
											}
											if(!(decodeState.validBits < n2)) {
												break;
											}
										}
										if(decodeState.validBits < 0) {
											val4 = 0;
										} else {
											var z4 = decodeState.acc & (1 << n2) - 1;
											decodeState.acc = decodeState.acc >>> n2;
											decodeState.validBits -= n2;
											val4 = z4;
										}
									}
								} else {
									var z5 = decodeState.acc & (1 << n2) - 1;
									decodeState.acc = decodeState.acc >>> n2;
									decodeState.validBits -= n2;
									val4 = z5;
								}
								val2 = val3 + (val4 << 24);
							} else {
								if(decodeState.validBits == 0) {
									decodeState.acc = 0;
								}
								while(true) {
									if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
										decodeState.validBits = -1;
										break;
									} else {
										decodeState.bytesInSeg--;
										decodeState.inputPosition += 1;
										decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
										decodeState.validBits += 8;
									}
									if(!(decodeState.validBits < n1)) {
										break;
									}
								}
								if(decodeState.validBits < 0) {
									val2 = 0;
								} else {
									var z6 = decodeState.acc & (1 << n1) - 1;
									decodeState.acc = decodeState.acc >>> n1;
									decodeState.validBits -= n1;
									val2 = z6;
								}
							}
						} else {
							var z7 = decodeState.acc & (1 << n1) - 1;
							decodeState.acc = decodeState.acc >>> n1;
							decodeState.validBits -= n1;
							val2 = z7;
						}
						val = val1 + (val2 << 24);
					} else {
						if(decodeState.validBits == 0) {
							decodeState.acc = 0;
						}
						while(true) {
							if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
								decodeState.validBits = -1;
								break;
							} else {
								decodeState.bytesInSeg--;
								decodeState.inputPosition += 1;
								decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
								decodeState.validBits += 8;
							}
							if(!(decodeState.validBits < n)) {
								break;
							}
						}
						if(decodeState.validBits < 0) {
							val = 0;
						} else {
							var z8 = decodeState.acc & (1 << n) - 1;
							decodeState.acc = decodeState.acc >>> n;
							decodeState.validBits -= n;
							val = z8;
						}
					}
				} else {
					var z9 = decodeState.acc & (1 << n) - 1;
					decodeState.acc = decodeState.acc >>> n;
					decodeState.validBits -= n;
					val = z9;
				}
				this1[index] = val;
				g.values++;
			}
		}
		var _g = 0;
		var _g1 = g.values;
		while(_g < _g1) {
			var j = _g++;
			p.push(new stb_format_vorbis_data_IntPoint());
			p[j].x = g.xlist[j];
			p[j].y = j;
		}
		p.sort(stb_format_vorbis_VorbisTools.pointCompare);
		var this1 = new Array(g.values);
		g.sortedOrder = this1;
		var _g = 0;
		var _g1 = g.values;
		while(_g < _g1) {
			var j = _g++;
			g.sortedOrder[j] = p[j].y;
		}
		var this1 = new Array(g.values);
		g.neighbors = this1;
		var _g = 2;
		var _g1 = g.values;
		while(_g < _g1) {
			var j = _g++;
			var x = g.xlist;
			var low = -1;
			var high = 65536;
			var plow = 0;
			var phigh = 0;
			var _g2 = 0;
			var _g3 = j;
			while(_g2 < _g3) {
				var i = _g2++;
				if(x[i] > low && x[i] < x[j]) {
					plow = i;
					low = x[i];
				}
				if(x[i] < high && x[i] > x[j]) {
					phigh = i;
					high = x[i];
				}
			}
			var ne_low = plow;
			var ne_high = phigh;
			var this1 = g.neighbors;
			var this2 = new Array(g.values);
			this1[j] = this2;
			g.neighbors[j][0] = ne_low;
			g.neighbors[j][1] = ne_high;
		}
	}
	return floor;
};
stb_format_vorbis_data_Floor.prototype = {
	__class__: stb_format_vorbis_data_Floor
};
var stb_format_vorbis_data_Floor0 = function() {
};
$hxClasses["stb.format.vorbis.data.Floor0"] = stb_format_vorbis_data_Floor0;
stb_format_vorbis_data_Floor0.__name__ = "stb.format.vorbis.data.Floor0";
stb_format_vorbis_data_Floor0.prototype = {
	__class__: stb_format_vorbis_data_Floor0
};
var stb_format_vorbis_data_Floor1 = function() {
};
$hxClasses["stb.format.vorbis.data.Floor1"] = stb_format_vorbis_data_Floor1;
stb_format_vorbis_data_Floor1.__name__ = "stb.format.vorbis.data.Floor1";
stb_format_vorbis_data_Floor1.prototype = {
	__class__: stb_format_vorbis_data_Floor1
};
var stb_format_vorbis_data_Header = function() {
};
$hxClasses["stb.format.vorbis.data.Header"] = stb_format_vorbis_data_Header;
stb_format_vorbis_data_Header.__name__ = "stb.format.vorbis.data.Header";
stb_format_vorbis_data_Header.read = function(decodeState) {
	var page = decodeState.page;
	page.start(decodeState);
	if((page.flag & 2) == 0) {
		throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_FIRST_PAGE,"not firstPage",{ fileName : "stb/format/vorbis/data/Header.hx", lineNumber : 46, className : "stb.format.vorbis.data.Header", methodName : "read"}));
	}
	if((page.flag & 4) != 0) {
		throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_FIRST_PAGE,"lastPage",{ fileName : "stb/format/vorbis/data/Header.hx", lineNumber : 49, className : "stb.format.vorbis.data.Header", methodName : "read"}));
	}
	if((page.flag & 1) != 0) {
		throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_FIRST_PAGE,"continuedPacket",{ fileName : "stb/format/vorbis/data/Header.hx", lineNumber : 52, className : "stb.format.vorbis.data.Header", methodName : "read"}));
	}
	decodeState.firstPageValidate();
	decodeState.inputPosition += 1;
	if(decodeState.input.readByte() != 1) {
		throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_FIRST_PAGE,"decodeState head",{ fileName : "stb/format/vorbis/data/Header.hx", lineNumber : 57, className : "stb.format.vorbis.data.Header", methodName : "read"}));
	}
	var header = new haxe_io_Bytes(new ArrayBuffer(6));
	var x;
	if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
		x = -1;
	} else {
		decodeState.bytesInSeg--;
		decodeState.inputPosition += 1;
		x = decodeState.input.readByte();
	}
	decodeState.validBits = 0;
	header.b[0] = x;
	var x;
	if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
		x = -1;
	} else {
		decodeState.bytesInSeg--;
		decodeState.inputPosition += 1;
		x = decodeState.input.readByte();
	}
	decodeState.validBits = 0;
	header.b[1] = x;
	var x;
	if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
		x = -1;
	} else {
		decodeState.bytesInSeg--;
		decodeState.inputPosition += 1;
		x = decodeState.input.readByte();
	}
	decodeState.validBits = 0;
	header.b[2] = x;
	var x;
	if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
		x = -1;
	} else {
		decodeState.bytesInSeg--;
		decodeState.inputPosition += 1;
		x = decodeState.input.readByte();
	}
	decodeState.validBits = 0;
	header.b[3] = x;
	var x;
	if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
		x = -1;
	} else {
		decodeState.bytesInSeg--;
		decodeState.inputPosition += 1;
		x = decodeState.input.readByte();
	}
	decodeState.validBits = 0;
	header.b[4] = x;
	var x;
	if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
		x = -1;
	} else {
		decodeState.bytesInSeg--;
		decodeState.inputPosition += 1;
		x = decodeState.input.readByte();
	}
	decodeState.validBits = 0;
	header.b[5] = x;
	if(header.toString() != "vorbis") {
		throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,"vorbis header",{ fileName : "stb/format/vorbis/VorbisDecodeState.hx", lineNumber : 300, className : "stb.format.vorbis.VorbisDecodeState", methodName : "vorbisValidate"}));
	}
	decodeState.inputPosition += 4;
	var version = decodeState.input.readInt32();
	if(version != 0) {
		throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_FIRST_PAGE,"vorbis version : " + version,{ fileName : "stb/format/vorbis/data/Header.hx", lineNumber : 66, className : "stb.format.vorbis.data.Header", methodName : "read"}));
	}
	var header = new stb_format_vorbis_data_Header();
	decodeState.inputPosition += 1;
	header.channel = decodeState.input.readByte();
	if(header.channel == 0) {
		throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_FIRST_PAGE,"no channel",{ fileName : "stb/format/vorbis/data/Header.hx", lineNumber : 73, className : "stb.format.vorbis.data.Header", methodName : "read"}));
	} else if(header.channel > 16) {
		throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.TOO_MANY_CHANNELS,"too many channels",{ fileName : "stb/format/vorbis/data/Header.hx", lineNumber : 75, className : "stb.format.vorbis.data.Header", methodName : "read"}));
	}
	decodeState.inputPosition += 4;
	header.sampleRate = decodeState.input.readInt32();
	if(header.sampleRate == 0) {
		throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_FIRST_PAGE,"no sampling rate",{ fileName : "stb/format/vorbis/data/Header.hx", lineNumber : 80, className : "stb.format.vorbis.data.Header", methodName : "read"}));
	}
	decodeState.inputPosition += 4;
	header.maximumBitRate = decodeState.input.readInt32();
	decodeState.inputPosition += 4;
	header.nominalBitRate = decodeState.input.readInt32();
	decodeState.inputPosition += 4;
	header.minimumBitRate = decodeState.input.readInt32();
	decodeState.inputPosition += 1;
	var x = decodeState.input.readByte();
	var log0 = x & 15;
	var log1 = x >> 4;
	header.blocksize0 = 1 << log0;
	header.blocksize1 = 1 << log1;
	if(log0 < 6 || log0 > 13) {
		throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Header.hx", lineNumber : 93, className : "stb.format.vorbis.data.Header", methodName : "read"}));
	}
	if(log1 < 6 || log1 > 13) {
		throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Header.hx", lineNumber : 96, className : "stb.format.vorbis.data.Header", methodName : "read"}));
	}
	if(log0 > log1) {
		throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Header.hx", lineNumber : 99, className : "stb.format.vorbis.data.Header", methodName : "read"}));
	}
	decodeState.inputPosition += 1;
	var x = decodeState.input.readByte();
	if((x & 1) == 0) {
		throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_FIRST_PAGE,null,{ fileName : "stb/format/vorbis/data/Header.hx", lineNumber : 105, className : "stb.format.vorbis.data.Header", methodName : "read"}));
	}
	decodeState.page.start(decodeState);
	decodeState.startPacket();
	var len = 0;
	var output = new haxe_io_BytesOutput();
	while(true) {
		len = decodeState.next();
		if(!(len != 0)) {
			break;
		}
		decodeState.inputPosition += len;
		output.write(decodeState.input.read(len));
		decodeState.bytesInSeg = 0;
	}
	var packetInput = new haxe_io_BytesInput(output.getBytes());
	packetInput.readByte();
	packetInput.read(6);
	var vendorLength = packetInput.readInt32();
	header.vendor = packetInput.readString(vendorLength);
	header.comment = new stb_format_vorbis_data_Comment();
	var commentCount = packetInput.readInt32();
	var _g = 0;
	var _g1 = commentCount;
	while(_g < _g1) {
		var i = _g++;
		var n = packetInput.readInt32();
		var str = packetInput.readString(n);
		var splitter = str.indexOf("=");
		if(splitter != -1) {
			header.comment.add(str.substring(0,splitter),str.substring(splitter + 1));
		}
	}
	var x1 = packetInput.readByte();
	if((x1 & 1) == 0) {
		throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Header.hx", lineNumber : 141, className : "stb.format.vorbis.data.Header", methodName : "read"}));
	}
	decodeState.startPacket();
	var x1;
	if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
		x1 = -1;
	} else {
		decodeState.bytesInSeg--;
		decodeState.inputPosition += 1;
		x1 = decodeState.input.readByte();
	}
	decodeState.validBits = 0;
	if(x1 != 5) {
		throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,"setup packet",{ fileName : "stb/format/vorbis/data/Header.hx", lineNumber : 149, className : "stb.format.vorbis.data.Header", methodName : "read"}));
	}
	var header1 = new haxe_io_Bytes(new ArrayBuffer(6));
	var x1;
	if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
		x1 = -1;
	} else {
		decodeState.bytesInSeg--;
		decodeState.inputPosition += 1;
		x1 = decodeState.input.readByte();
	}
	decodeState.validBits = 0;
	header1.b[0] = x1;
	var x1;
	if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
		x1 = -1;
	} else {
		decodeState.bytesInSeg--;
		decodeState.inputPosition += 1;
		x1 = decodeState.input.readByte();
	}
	decodeState.validBits = 0;
	header1.b[1] = x1;
	var x1;
	if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
		x1 = -1;
	} else {
		decodeState.bytesInSeg--;
		decodeState.inputPosition += 1;
		x1 = decodeState.input.readByte();
	}
	decodeState.validBits = 0;
	header1.b[2] = x1;
	var x1;
	if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
		x1 = -1;
	} else {
		decodeState.bytesInSeg--;
		decodeState.inputPosition += 1;
		x1 = decodeState.input.readByte();
	}
	decodeState.validBits = 0;
	header1.b[3] = x1;
	var x1;
	if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
		x1 = -1;
	} else {
		decodeState.bytesInSeg--;
		decodeState.inputPosition += 1;
		x1 = decodeState.input.readByte();
	}
	decodeState.validBits = 0;
	header1.b[4] = x1;
	var x1;
	if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
		x1 = -1;
	} else {
		decodeState.bytesInSeg--;
		decodeState.inputPosition += 1;
		x1 = decodeState.input.readByte();
	}
	decodeState.validBits = 0;
	header1.b[5] = x1;
	if(header1.toString() != "vorbis") {
		throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,"vorbis header",{ fileName : "stb/format/vorbis/VorbisDecodeState.hx", lineNumber : 300, className : "stb.format.vorbis.VorbisDecodeState", methodName : "vorbisValidate"}));
	}
	var codebookCount;
	if(decodeState.validBits < 0) {
		codebookCount = 0;
	} else if(decodeState.validBits < 8) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 8)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			codebookCount = 0;
		} else {
			var z = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			codebookCount = z;
		}
	} else {
		var z = decodeState.acc & 255;
		decodeState.acc = decodeState.acc >>> 8;
		decodeState.validBits -= 8;
		codebookCount = z;
	}
	var codebookCount1 = codebookCount + 1;
	var this1 = new Array(codebookCount1);
	header.codebooks = this1;
	var _g = 0;
	var _g1 = codebookCount1;
	while(_g < _g1) {
		var i = _g++;
		header.codebooks[i] = stb_format_vorbis_data_Codebook.read(decodeState);
	}
	var x1;
	if(decodeState.validBits < 0) {
		x1 = 0;
	} else if(decodeState.validBits < 6) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 6)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			x1 = 0;
		} else {
			var z = decodeState.acc & 63;
			decodeState.acc = decodeState.acc >>> 6;
			decodeState.validBits -= 6;
			x1 = z;
		}
	} else {
		var z = decodeState.acc & 63;
		decodeState.acc = decodeState.acc >>> 6;
		decodeState.validBits -= 6;
		x1 = z;
	}
	x = x1 + 1;
	var _g = 0;
	var _g1 = x;
	while(_g < _g1) {
		var i = _g++;
		var tmp;
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else if(decodeState.validBits < 16) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 16)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				tmp = 0;
			} else {
				var z = decodeState.acc & 65535;
				decodeState.acc = decodeState.acc >>> 16;
				decodeState.validBits -= 16;
				tmp = z;
			}
		} else {
			var z1 = decodeState.acc & 65535;
			decodeState.acc = decodeState.acc >>> 16;
			decodeState.validBits -= 16;
			tmp = z1;
		}
		if(tmp != 0) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Header.hx", lineNumber : 165, className : "stb.format.vorbis.data.Header", methodName : "read"}));
		}
	}
	var floorCount;
	if(decodeState.validBits < 0) {
		floorCount = 0;
	} else if(decodeState.validBits < 6) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 6)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			floorCount = 0;
		} else {
			var z = decodeState.acc & 63;
			decodeState.acc = decodeState.acc >>> 6;
			decodeState.validBits -= 6;
			floorCount = z;
		}
	} else {
		var z = decodeState.acc & 63;
		decodeState.acc = decodeState.acc >>> 6;
		decodeState.validBits -= 6;
		floorCount = z;
	}
	var floorCount1 = floorCount + 1;
	var this1 = new Array(floorCount1);
	header.floorConfig = this1;
	var _g = 0;
	var _g1 = floorCount1;
	while(_g < _g1) {
		var i = _g++;
		header.floorConfig[i] = stb_format_vorbis_data_Floor.read(decodeState,header.codebooks);
	}
	var residueCount;
	if(decodeState.validBits < 0) {
		residueCount = 0;
	} else if(decodeState.validBits < 6) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 6)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			residueCount = 0;
		} else {
			var z = decodeState.acc & 63;
			decodeState.acc = decodeState.acc >>> 6;
			decodeState.validBits -= 6;
			residueCount = z;
		}
	} else {
		var z = decodeState.acc & 63;
		decodeState.acc = decodeState.acc >>> 6;
		decodeState.validBits -= 6;
		residueCount = z;
	}
	var residueCount1 = residueCount + 1;
	var this1 = new Array(residueCount1);
	header.residueConfig = this1;
	var _g = 0;
	var _g1 = residueCount1;
	while(_g < _g1) {
		var i = _g++;
		header.residueConfig[i] = stb_format_vorbis_data_Residue.read(decodeState,header.codebooks);
	}
	var mappingCount;
	if(decodeState.validBits < 0) {
		mappingCount = 0;
	} else if(decodeState.validBits < 6) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 6)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			mappingCount = 0;
		} else {
			var z = decodeState.acc & 63;
			decodeState.acc = decodeState.acc >>> 6;
			decodeState.validBits -= 6;
			mappingCount = z;
		}
	} else {
		var z = decodeState.acc & 63;
		decodeState.acc = decodeState.acc >>> 6;
		decodeState.validBits -= 6;
		mappingCount = z;
	}
	var mappingCount1 = mappingCount + 1;
	var this1 = new Array(mappingCount1);
	header.mapping = this1;
	var _g = 0;
	var _g1 = mappingCount1;
	while(_g < _g1) {
		var i = _g++;
		var map = stb_format_vorbis_data_Mapping.read(decodeState,header.channel);
		header.mapping[i] = map;
		var _g2 = 0;
		var _g3 = map.submaps;
		while(_g2 < _g3) {
			var j = _g2++;
			if(map.submapFloor[j] >= header.floorConfig.length) {
				throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Header.hx", lineNumber : 191, className : "stb.format.vorbis.data.Header", methodName : "read"}));
			}
			if(map.submapResidue[j] >= header.residueConfig.length) {
				throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Header.hx", lineNumber : 194, className : "stb.format.vorbis.data.Header", methodName : "read"}));
			}
		}
	}
	var modeCount;
	if(decodeState.validBits < 0) {
		modeCount = 0;
	} else if(decodeState.validBits < 6) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 6)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			modeCount = 0;
		} else {
			var z = decodeState.acc & 63;
			decodeState.acc = decodeState.acc >>> 6;
			decodeState.validBits -= 6;
			modeCount = z;
		}
	} else {
		var z = decodeState.acc & 63;
		decodeState.acc = decodeState.acc >>> 6;
		decodeState.validBits -= 6;
		modeCount = z;
	}
	var modeCount1 = modeCount + 1;
	var this1 = new Array(modeCount1);
	header.modes = this1;
	var _g = 0;
	var _g1 = modeCount1;
	while(_g < _g1) {
		var i = _g++;
		var mode = stb_format_vorbis_data_Mode.read(decodeState);
		header.modes[i] = mode;
		if(mode.mapping >= header.mapping.length) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Header.hx", lineNumber : 205, className : "stb.format.vorbis.data.Header", methodName : "read"}));
		}
	}
	while(decodeState.bytesInSeg != 0 || !decodeState.lastSeg && decodeState.next() != 0) {
		decodeState.bytesInSeg--;
		decodeState.inputPosition += 1;
		decodeState.input.readByte();
	}
	return header;
};
stb_format_vorbis_data_Header.prototype = {
	__class__: stb_format_vorbis_data_Header
};
var stb_format_vorbis_data_IntPoint = function() {
};
$hxClasses["stb.format.vorbis.data.IntPoint"] = stb_format_vorbis_data_IntPoint;
stb_format_vorbis_data_IntPoint.__name__ = "stb.format.vorbis.data.IntPoint";
stb_format_vorbis_data_IntPoint.prototype = {
	__class__: stb_format_vorbis_data_IntPoint
};
var stb_format_vorbis_data_Mapping = function() {
};
$hxClasses["stb.format.vorbis.data.Mapping"] = stb_format_vorbis_data_Mapping;
stb_format_vorbis_data_Mapping.__name__ = "stb.format.vorbis.data.Mapping";
stb_format_vorbis_data_Mapping.read = function(decodeState,channels) {
	var m = new stb_format_vorbis_data_Mapping();
	var mappingType;
	if(decodeState.validBits < 0) {
		mappingType = 0;
	} else if(decodeState.validBits < 16) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 16)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			mappingType = 0;
		} else {
			var z = decodeState.acc & 65535;
			decodeState.acc = decodeState.acc >>> 16;
			decodeState.validBits -= 16;
			mappingType = z;
		}
	} else {
		var z = decodeState.acc & 65535;
		decodeState.acc = decodeState.acc >>> 16;
		decodeState.validBits -= 16;
		mappingType = z;
	}
	if(mappingType != 0) {
		throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,"mapping type " + mappingType,{ fileName : "stb/format/vorbis/data/Mapping.hx", lineNumber : 22, className : "stb.format.vorbis.data.Mapping", methodName : "read"}));
	}
	var this1 = new Array(channels);
	m.chan = this1;
	var _g = 0;
	var _g1 = channels;
	while(_g < _g1) {
		var j = _g++;
		m.chan[j] = new stb_format_vorbis_data_MappingChannel();
	}
	var tmp;
	if(decodeState.validBits < 0) {
		tmp = 0;
	} else if(decodeState.validBits < 1) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 1)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else {
			var z = decodeState.acc & 1;
			decodeState.acc = decodeState.acc >>> 1;
			decodeState.validBits -= 1;
			tmp = z;
		}
	} else {
		var z = decodeState.acc & 1;
		decodeState.acc = decodeState.acc >>> 1;
		decodeState.validBits -= 1;
		tmp = z;
	}
	if(tmp != 0) {
		var tmp;
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else if(decodeState.validBits < 4) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 4)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				tmp = 0;
			} else {
				var z = decodeState.acc & 15;
				decodeState.acc = decodeState.acc >>> 4;
				decodeState.validBits -= 4;
				tmp = z;
			}
		} else {
			var z = decodeState.acc & 15;
			decodeState.acc = decodeState.acc >>> 4;
			decodeState.validBits -= 4;
			tmp = z;
		}
		m.submaps = tmp + 1;
	} else {
		m.submaps = 1;
	}
	var tmp;
	if(decodeState.validBits < 0) {
		tmp = 0;
	} else if(decodeState.validBits < 1) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 1)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else {
			var z = decodeState.acc & 1;
			decodeState.acc = decodeState.acc >>> 1;
			decodeState.validBits -= 1;
			tmp = z;
		}
	} else {
		var z = decodeState.acc & 1;
		decodeState.acc = decodeState.acc >>> 1;
		decodeState.validBits -= 1;
		tmp = z;
	}
	if(tmp != 0) {
		var tmp;
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else if(decodeState.validBits < 8) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 8)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				tmp = 0;
			} else {
				var z = decodeState.acc & 255;
				decodeState.acc = decodeState.acc >>> 8;
				decodeState.validBits -= 8;
				tmp = z;
			}
		} else {
			var z = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			tmp = z;
		}
		m.couplingSteps = tmp + 1;
		var _g = 0;
		var _g1 = m.couplingSteps;
		while(_g < _g1) {
			var k = _g++;
			var n = channels - 1;
			var log2_4 = [0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4];
			var n1 = n < 16384 ? n < 16 ? log2_4[n] : n < 512 ? 5 + log2_4[n >> 5] : 10 + log2_4[n >> 10] : n < 16777216 ? n < 524288 ? 15 + log2_4[n >> 15] : 20 + log2_4[n >> 20] : n < 536870912 ? 25 + log2_4[n >> 25] : n < -2147483648 ? 30 + log2_4[n >> 30] : 0;
			var tmp;
			if(decodeState.validBits < 0) {
				tmp = 0;
			} else if(decodeState.validBits < n1) {
				if(n1 > 24) {
					var tmp1;
					if(decodeState.validBits < 0) {
						tmp1 = 0;
					} else if(decodeState.validBits < 24) {
						if(decodeState.validBits == 0) {
							decodeState.acc = 0;
						}
						while(true) {
							if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
								decodeState.validBits = -1;
								break;
							} else {
								decodeState.bytesInSeg--;
								decodeState.inputPosition += 1;
								decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
								decodeState.validBits += 8;
							}
							if(!(decodeState.validBits < 24)) {
								break;
							}
						}
						if(decodeState.validBits < 0) {
							tmp1 = 0;
						} else {
							var z = decodeState.acc & 16777215;
							decodeState.acc = decodeState.acc >>> 24;
							decodeState.validBits -= 24;
							tmp1 = z;
						}
					} else {
						var z1 = decodeState.acc & 16777215;
						decodeState.acc = decodeState.acc >>> 24;
						decodeState.validBits -= 24;
						tmp1 = z1;
					}
					var n2 = n1 - 24;
					var tmp2;
					if(decodeState.validBits < 0) {
						tmp2 = 0;
					} else if(decodeState.validBits < n2) {
						if(n2 > 24) {
							tmp2 = decodeState.readBits(24) + (decodeState.readBits(n2 - 24) << 24);
						} else {
							if(decodeState.validBits == 0) {
								decodeState.acc = 0;
							}
							while(true) {
								if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
									decodeState.validBits = -1;
									break;
								} else {
									decodeState.bytesInSeg--;
									decodeState.inputPosition += 1;
									decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
									decodeState.validBits += 8;
								}
								if(!(decodeState.validBits < n2)) {
									break;
								}
							}
							if(decodeState.validBits < 0) {
								tmp2 = 0;
							} else {
								var z2 = decodeState.acc & (1 << n2) - 1;
								decodeState.acc = decodeState.acc >>> n2;
								decodeState.validBits -= n2;
								tmp2 = z2;
							}
						}
					} else {
						var z3 = decodeState.acc & (1 << n2) - 1;
						decodeState.acc = decodeState.acc >>> n2;
						decodeState.validBits -= n2;
						tmp2 = z3;
					}
					tmp = tmp1 + (tmp2 << 24);
				} else {
					if(decodeState.validBits == 0) {
						decodeState.acc = 0;
					}
					while(true) {
						if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
							decodeState.validBits = -1;
							break;
						} else {
							decodeState.bytesInSeg--;
							decodeState.inputPosition += 1;
							decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
							decodeState.validBits += 8;
						}
						if(!(decodeState.validBits < n1)) {
							break;
						}
					}
					if(decodeState.validBits < 0) {
						tmp = 0;
					} else {
						var z4 = decodeState.acc & (1 << n1) - 1;
						decodeState.acc = decodeState.acc >>> n1;
						decodeState.validBits -= n1;
						tmp = z4;
					}
				}
			} else {
				var z5 = decodeState.acc & (1 << n1) - 1;
				decodeState.acc = decodeState.acc >>> n1;
				decodeState.validBits -= n1;
				tmp = z5;
			}
			m.chan[k].magnitude = tmp;
			var n3 = channels - 1;
			var log2_41 = [0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4];
			var n4 = n3 < 16384 ? n3 < 16 ? log2_41[n3] : n3 < 512 ? 5 + log2_41[n3 >> 5] : 10 + log2_41[n3 >> 10] : n3 < 16777216 ? n3 < 524288 ? 15 + log2_41[n3 >> 15] : 20 + log2_41[n3 >> 20] : n3 < 536870912 ? 25 + log2_41[n3 >> 25] : n3 < -2147483648 ? 30 + log2_41[n3 >> 30] : 0;
			var tmp3;
			if(decodeState.validBits < 0) {
				tmp3 = 0;
			} else if(decodeState.validBits < n4) {
				if(n4 > 24) {
					var tmp4;
					if(decodeState.validBits < 0) {
						tmp4 = 0;
					} else if(decodeState.validBits < 24) {
						if(decodeState.validBits == 0) {
							decodeState.acc = 0;
						}
						while(true) {
							if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
								decodeState.validBits = -1;
								break;
							} else {
								decodeState.bytesInSeg--;
								decodeState.inputPosition += 1;
								decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
								decodeState.validBits += 8;
							}
							if(!(decodeState.validBits < 24)) {
								break;
							}
						}
						if(decodeState.validBits < 0) {
							tmp4 = 0;
						} else {
							var z6 = decodeState.acc & 16777215;
							decodeState.acc = decodeState.acc >>> 24;
							decodeState.validBits -= 24;
							tmp4 = z6;
						}
					} else {
						var z7 = decodeState.acc & 16777215;
						decodeState.acc = decodeState.acc >>> 24;
						decodeState.validBits -= 24;
						tmp4 = z7;
					}
					var n5 = n4 - 24;
					var tmp5;
					if(decodeState.validBits < 0) {
						tmp5 = 0;
					} else if(decodeState.validBits < n5) {
						if(n5 > 24) {
							tmp5 = decodeState.readBits(24) + (decodeState.readBits(n5 - 24) << 24);
						} else {
							if(decodeState.validBits == 0) {
								decodeState.acc = 0;
							}
							while(true) {
								if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
									decodeState.validBits = -1;
									break;
								} else {
									decodeState.bytesInSeg--;
									decodeState.inputPosition += 1;
									decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
									decodeState.validBits += 8;
								}
								if(!(decodeState.validBits < n5)) {
									break;
								}
							}
							if(decodeState.validBits < 0) {
								tmp5 = 0;
							} else {
								var z8 = decodeState.acc & (1 << n5) - 1;
								decodeState.acc = decodeState.acc >>> n5;
								decodeState.validBits -= n5;
								tmp5 = z8;
							}
						}
					} else {
						var z9 = decodeState.acc & (1 << n5) - 1;
						decodeState.acc = decodeState.acc >>> n5;
						decodeState.validBits -= n5;
						tmp5 = z9;
					}
					tmp3 = tmp4 + (tmp5 << 24);
				} else {
					if(decodeState.validBits == 0) {
						decodeState.acc = 0;
					}
					while(true) {
						if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
							decodeState.validBits = -1;
							break;
						} else {
							decodeState.bytesInSeg--;
							decodeState.inputPosition += 1;
							decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
							decodeState.validBits += 8;
						}
						if(!(decodeState.validBits < n4)) {
							break;
						}
					}
					if(decodeState.validBits < 0) {
						tmp3 = 0;
					} else {
						var z10 = decodeState.acc & (1 << n4) - 1;
						decodeState.acc = decodeState.acc >>> n4;
						decodeState.validBits -= n4;
						tmp3 = z10;
					}
				}
			} else {
				var z11 = decodeState.acc & (1 << n4) - 1;
				decodeState.acc = decodeState.acc >>> n4;
				decodeState.validBits -= n4;
				tmp3 = z11;
			}
			m.chan[k].angle = tmp3;
			if(m.chan[k].magnitude >= channels) {
				throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Mapping.hx", lineNumber : 46, className : "stb.format.vorbis.data.Mapping", methodName : "read"}));
			}
			if(m.chan[k].angle >= channels) {
				throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Mapping.hx", lineNumber : 49, className : "stb.format.vorbis.data.Mapping", methodName : "read"}));
			}
			if(m.chan[k].magnitude == m.chan[k].angle) {
				throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Mapping.hx", lineNumber : 52, className : "stb.format.vorbis.data.Mapping", methodName : "read"}));
			}
		}
	} else {
		m.couplingSteps = 0;
	}
	var tmp;
	if(decodeState.validBits < 0) {
		tmp = 0;
	} else if(decodeState.validBits < 2) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 2)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else {
			var z = decodeState.acc & 3;
			decodeState.acc = decodeState.acc >>> 2;
			decodeState.validBits -= 2;
			tmp = z;
		}
	} else {
		var z = decodeState.acc & 3;
		decodeState.acc = decodeState.acc >>> 2;
		decodeState.validBits -= 2;
		tmp = z;
	}
	if(tmp != 0) {
		throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Mapping.hx", lineNumber : 61, className : "stb.format.vorbis.data.Mapping", methodName : "read"}));
	}
	if(m.submaps > 1) {
		var _g = 0;
		var _g1 = channels;
		while(_g < _g1) {
			var j = _g++;
			var tmp;
			if(decodeState.validBits < 0) {
				tmp = 0;
			} else if(decodeState.validBits < 4) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				while(true) {
					if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
						decodeState.validBits = -1;
						break;
					} else {
						decodeState.bytesInSeg--;
						decodeState.inputPosition += 1;
						decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
						decodeState.validBits += 8;
					}
					if(!(decodeState.validBits < 4)) {
						break;
					}
				}
				if(decodeState.validBits < 0) {
					tmp = 0;
				} else {
					var z = decodeState.acc & 15;
					decodeState.acc = decodeState.acc >>> 4;
					decodeState.validBits -= 4;
					tmp = z;
				}
			} else {
				var z1 = decodeState.acc & 15;
				decodeState.acc = decodeState.acc >>> 4;
				decodeState.validBits -= 4;
				tmp = z1;
			}
			m.chan[j].mux = tmp;
			if(m.chan[j].mux >= m.submaps) {
				throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Mapping.hx", lineNumber : 67, className : "stb.format.vorbis.data.Mapping", methodName : "read"}));
			}
		}
	} else {
		var _g = 0;
		var _g1 = channels;
		while(_g < _g1) {
			var j = _g++;
			m.chan[j].mux = 0;
		}
	}
	var this1 = new Array(m.submaps);
	m.submapFloor = this1;
	var this1 = new Array(m.submaps);
	m.submapResidue = this1;
	var _g = 0;
	var _g1 = m.submaps;
	while(_g < _g1) {
		var j = _g++;
		if(decodeState.validBits >= 0) {
			if(decodeState.validBits < 8) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				while(true) {
					if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
						decodeState.validBits = -1;
						break;
					} else {
						decodeState.bytesInSeg--;
						decodeState.inputPosition += 1;
						decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
						decodeState.validBits += 8;
					}
					if(!(decodeState.validBits < 8)) {
						break;
					}
				}
				if(decodeState.validBits >= 0) {
					var z = decodeState.acc & 255;
					decodeState.acc = decodeState.acc >>> 8;
					decodeState.validBits -= 8;
				}
			} else {
				var z1 = decodeState.acc & 255;
				decodeState.acc = decodeState.acc >>> 8;
				decodeState.validBits -= 8;
			}
		}
		var this1 = m.submapFloor;
		var val;
		if(decodeState.validBits < 0) {
			val = 0;
		} else if(decodeState.validBits < 8) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 8)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				val = 0;
			} else {
				var z2 = decodeState.acc & 255;
				decodeState.acc = decodeState.acc >>> 8;
				decodeState.validBits -= 8;
				val = z2;
			}
		} else {
			var z3 = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			val = z3;
		}
		this1[j] = val;
		var this2 = m.submapResidue;
		var val1;
		if(decodeState.validBits < 0) {
			val1 = 0;
		} else if(decodeState.validBits < 8) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 8)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				val1 = 0;
			} else {
				var z4 = decodeState.acc & 255;
				decodeState.acc = decodeState.acc >>> 8;
				decodeState.validBits -= 8;
				val1 = z4;
			}
		} else {
			var z5 = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			val1 = z5;
		}
		this2[j] = val1;
	}
	return m;
};
stb_format_vorbis_data_Mapping.prototype = {
	doFloor: function(floors,i,n,target,finalY,step2Flag) {
		var n2 = n >> 1;
		var s = this.chan[i].mux;
		var floor;
		var floor = floors[this.submapFloor[s]];
		if(floor.type == 0) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_STREAM,null,{ fileName : "stb/format/vorbis/data/Mapping.hx", lineNumber : 94, className : "stb.format.vorbis.data.Mapping", methodName : "doFloor"}));
		} else {
			var g = floor.floor1;
			var lx = 0;
			var ly = finalY[0] * g.floor1Multiplier;
			var _g = 1;
			var _g1 = g.values;
			while(_g < _g1) {
				var q = _g++;
				var j = g.sortedOrder[q];
				if(finalY[j] >= 0) {
					var hy = finalY[j] * g.floor1Multiplier;
					var hx = g.xlist[j];
					stb_format_vorbis_VorbisTools.drawLine(target,lx,ly,hx,hy,n2);
					lx = hx;
					ly = hy;
				}
			}
			if(lx < n2) {
				var _g = lx;
				var _g1 = n2;
				while(_g < _g1) {
					var j = _g++;
					target[j] *= stb_format_vorbis_VorbisTools.INVERSE_DB_TABLE[ly];
				}
			}
		}
	}
	,__class__: stb_format_vorbis_data_Mapping
};
var stb_format_vorbis_data_MappingChannel = function() {
};
$hxClasses["stb.format.vorbis.data.MappingChannel"] = stb_format_vorbis_data_MappingChannel;
stb_format_vorbis_data_MappingChannel.__name__ = "stb.format.vorbis.data.MappingChannel";
stb_format_vorbis_data_MappingChannel.prototype = {
	__class__: stb_format_vorbis_data_MappingChannel
};
var stb_format_vorbis_data_Mode = function() {
};
$hxClasses["stb.format.vorbis.data.Mode"] = stb_format_vorbis_data_Mode;
stb_format_vorbis_data_Mode.__name__ = "stb.format.vorbis.data.Mode";
stb_format_vorbis_data_Mode.read = function(decodeState) {
	var m = new stb_format_vorbis_data_Mode();
	var tmp;
	if(decodeState.validBits < 0) {
		tmp = 0;
	} else if(decodeState.validBits < 1) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 1)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else {
			var z = decodeState.acc & 1;
			decodeState.acc = decodeState.acc >>> 1;
			decodeState.validBits -= 1;
			tmp = z;
		}
	} else {
		var z = decodeState.acc & 1;
		decodeState.acc = decodeState.acc >>> 1;
		decodeState.validBits -= 1;
		tmp = z;
	}
	m.blockflag = tmp != 0;
	var tmp;
	if(decodeState.validBits < 0) {
		tmp = 0;
	} else if(decodeState.validBits < 16) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 16)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else {
			var z = decodeState.acc & 65535;
			decodeState.acc = decodeState.acc >>> 16;
			decodeState.validBits -= 16;
			tmp = z;
		}
	} else {
		var z = decodeState.acc & 65535;
		decodeState.acc = decodeState.acc >>> 16;
		decodeState.validBits -= 16;
		tmp = z;
	}
	m.windowtype = tmp;
	var tmp;
	if(decodeState.validBits < 0) {
		tmp = 0;
	} else if(decodeState.validBits < 16) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 16)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else {
			var z = decodeState.acc & 65535;
			decodeState.acc = decodeState.acc >>> 16;
			decodeState.validBits -= 16;
			tmp = z;
		}
	} else {
		var z = decodeState.acc & 65535;
		decodeState.acc = decodeState.acc >>> 16;
		decodeState.validBits -= 16;
		tmp = z;
	}
	m.transformtype = tmp;
	var tmp;
	if(decodeState.validBits < 0) {
		tmp = 0;
	} else if(decodeState.validBits < 8) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 8)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else {
			var z = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			tmp = z;
		}
	} else {
		var z = decodeState.acc & 255;
		decodeState.acc = decodeState.acc >>> 8;
		decodeState.validBits -= 8;
		tmp = z;
	}
	m.mapping = tmp;
	if(m.windowtype != 0) {
		throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Mode.hx", lineNumber : 22, className : "stb.format.vorbis.data.Mode", methodName : "read"}));
	}
	if(m.transformtype != 0) {
		throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Mode.hx", lineNumber : 25, className : "stb.format.vorbis.data.Mode", methodName : "read"}));
	}
	return m;
};
stb_format_vorbis_data_Mode.prototype = {
	__class__: stb_format_vorbis_data_Mode
};
var stb_format_vorbis_data_Page = function() {
};
$hxClasses["stb.format.vorbis.data.Page"] = stb_format_vorbis_data_Page;
stb_format_vorbis_data_Page.__name__ = "stb.format.vorbis.data.Page";
stb_format_vorbis_data_Page.prototype = {
	clone: function() {
		var page = new stb_format_vorbis_data_Page();
		page.flag = this.flag;
		return page;
	}
	,start: function(decodeState) {
		var tmp;
		var tmp1;
		var tmp2;
		decodeState.inputPosition += 1;
		if(decodeState.input.readByte() == 79) {
			decodeState.inputPosition += 1;
			tmp2 = decodeState.input.readByte() != 103;
		} else {
			tmp2 = true;
		}
		if(!tmp2) {
			decodeState.inputPosition += 1;
			tmp1 = decodeState.input.readByte() != 103;
		} else {
			tmp1 = true;
		}
		if(!tmp1) {
			decodeState.inputPosition += 1;
			tmp = decodeState.input.readByte() != 83;
		} else {
			tmp = true;
		}
		if(tmp) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.MISSING_CAPTURE_PATTERN,null,{ fileName : "stb/format/vorbis/VorbisDecodeState.hx", lineNumber : 323, className : "stb.format.vorbis.VorbisDecodeState", methodName : "capturePattern"}));
		}
		this.startWithoutCapturePattern(decodeState);
	}
	,startWithoutCapturePattern: function(decodeState) {
		decodeState.inputPosition += 1;
		var version = decodeState.input.readByte();
		if(version != 0) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_STREAM_STRUCTURE_VERSION,"" + version,{ fileName : "stb/format/vorbis/data/Page.hx", lineNumber : 34, className : "stb.format.vorbis.data.Page", methodName : "startWithoutCapturePattern"}));
		}
		decodeState.inputPosition += 1;
		this.flag = decodeState.input.readByte();
		decodeState.inputPosition += 4;
		var loc0 = decodeState.input.readInt32();
		decodeState.inputPosition += 4;
		var loc1 = decodeState.input.readInt32();
		decodeState.inputPosition += 4;
		decodeState.input.readInt32();
		decodeState.inputPosition += 4;
		decodeState.input.readInt32();
		decodeState.inputPosition += 4;
		decodeState.input.readInt32();
		decodeState.setup(loc0,loc1);
	}
	,__class__: stb_format_vorbis_data_Page
};
var stb_format_vorbis_data_ProbedPage = function() {
};
$hxClasses["stb.format.vorbis.data.ProbedPage"] = stb_format_vorbis_data_ProbedPage;
stb_format_vorbis_data_ProbedPage.__name__ = "stb.format.vorbis.data.ProbedPage";
stb_format_vorbis_data_ProbedPage.prototype = {
	__class__: stb_format_vorbis_data_ProbedPage
};
var stb_format_vorbis_data_ReaderError = function(type,message,posInfos) {
	if(message == null) {
		message = "";
	}
	this.type = type;
	this.message = message;
	this.posInfos = posInfos;
};
$hxClasses["stb.format.vorbis.data.ReaderError"] = stb_format_vorbis_data_ReaderError;
stb_format_vorbis_data_ReaderError.__name__ = "stb.format.vorbis.data.ReaderError";
stb_format_vorbis_data_ReaderError.prototype = {
	__class__: stb_format_vorbis_data_ReaderError
};
var stb_format_vorbis_data_ReaderErrorType = $hxEnums["stb.format.vorbis.data.ReaderErrorType"] = { __ename__:true,__constructs__:null
	,NEED_MORE_DATA: {_hx_name:"NEED_MORE_DATA",_hx_index:0,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,INVALID_API_MIXING: {_hx_name:"INVALID_API_MIXING",_hx_index:1,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,OUTOFMEM: {_hx_name:"OUTOFMEM",_hx_index:2,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,FEATURE_NOT_SUPPORTED: {_hx_name:"FEATURE_NOT_SUPPORTED",_hx_index:3,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,TOO_MANY_CHANNELS: {_hx_name:"TOO_MANY_CHANNELS",_hx_index:4,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,FILE_OPEN_FAILURE: {_hx_name:"FILE_OPEN_FAILURE",_hx_index:5,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,SEEK_WITHOUT_LENGTH: {_hx_name:"SEEK_WITHOUT_LENGTH",_hx_index:6,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,UNEXPECTED_EOF: {_hx_name:"UNEXPECTED_EOF",_hx_index:7,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,SEEK_INVALID: {_hx_name:"SEEK_INVALID",_hx_index:8,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,INVALID_SETUP: {_hx_name:"INVALID_SETUP",_hx_index:9,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,INVALID_STREAM: {_hx_name:"INVALID_STREAM",_hx_index:10,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,MISSING_CAPTURE_PATTERN: {_hx_name:"MISSING_CAPTURE_PATTERN",_hx_index:11,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,INVALID_STREAM_STRUCTURE_VERSION: {_hx_name:"INVALID_STREAM_STRUCTURE_VERSION",_hx_index:12,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,CONTINUED_PACKET_FLAG_INVALID: {_hx_name:"CONTINUED_PACKET_FLAG_INVALID",_hx_index:13,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,INCORRECT_STREAM_SERIAL_NUMBER: {_hx_name:"INCORRECT_STREAM_SERIAL_NUMBER",_hx_index:14,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,INVALID_FIRST_PAGE: {_hx_name:"INVALID_FIRST_PAGE",_hx_index:15,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,BAD_PACKET_TYPE: {_hx_name:"BAD_PACKET_TYPE",_hx_index:16,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,CANT_FIND_LAST_PAGE: {_hx_name:"CANT_FIND_LAST_PAGE",_hx_index:17,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,SEEK_FAILED: {_hx_name:"SEEK_FAILED",_hx_index:18,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,OTHER: {_hx_name:"OTHER",_hx_index:19,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
};
stb_format_vorbis_data_ReaderErrorType.__constructs__ = [stb_format_vorbis_data_ReaderErrorType.NEED_MORE_DATA,stb_format_vorbis_data_ReaderErrorType.INVALID_API_MIXING,stb_format_vorbis_data_ReaderErrorType.OUTOFMEM,stb_format_vorbis_data_ReaderErrorType.FEATURE_NOT_SUPPORTED,stb_format_vorbis_data_ReaderErrorType.TOO_MANY_CHANNELS,stb_format_vorbis_data_ReaderErrorType.FILE_OPEN_FAILURE,stb_format_vorbis_data_ReaderErrorType.SEEK_WITHOUT_LENGTH,stb_format_vorbis_data_ReaderErrorType.UNEXPECTED_EOF,stb_format_vorbis_data_ReaderErrorType.SEEK_INVALID,stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,stb_format_vorbis_data_ReaderErrorType.INVALID_STREAM,stb_format_vorbis_data_ReaderErrorType.MISSING_CAPTURE_PATTERN,stb_format_vorbis_data_ReaderErrorType.INVALID_STREAM_STRUCTURE_VERSION,stb_format_vorbis_data_ReaderErrorType.CONTINUED_PACKET_FLAG_INVALID,stb_format_vorbis_data_ReaderErrorType.INCORRECT_STREAM_SERIAL_NUMBER,stb_format_vorbis_data_ReaderErrorType.INVALID_FIRST_PAGE,stb_format_vorbis_data_ReaderErrorType.BAD_PACKET_TYPE,stb_format_vorbis_data_ReaderErrorType.CANT_FIND_LAST_PAGE,stb_format_vorbis_data_ReaderErrorType.SEEK_FAILED,stb_format_vorbis_data_ReaderErrorType.OTHER];
stb_format_vorbis_data_ReaderErrorType.__empty_constructs__ = [stb_format_vorbis_data_ReaderErrorType.NEED_MORE_DATA,stb_format_vorbis_data_ReaderErrorType.INVALID_API_MIXING,stb_format_vorbis_data_ReaderErrorType.OUTOFMEM,stb_format_vorbis_data_ReaderErrorType.FEATURE_NOT_SUPPORTED,stb_format_vorbis_data_ReaderErrorType.TOO_MANY_CHANNELS,stb_format_vorbis_data_ReaderErrorType.FILE_OPEN_FAILURE,stb_format_vorbis_data_ReaderErrorType.SEEK_WITHOUT_LENGTH,stb_format_vorbis_data_ReaderErrorType.UNEXPECTED_EOF,stb_format_vorbis_data_ReaderErrorType.SEEK_INVALID,stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,stb_format_vorbis_data_ReaderErrorType.INVALID_STREAM,stb_format_vorbis_data_ReaderErrorType.MISSING_CAPTURE_PATTERN,stb_format_vorbis_data_ReaderErrorType.INVALID_STREAM_STRUCTURE_VERSION,stb_format_vorbis_data_ReaderErrorType.CONTINUED_PACKET_FLAG_INVALID,stb_format_vorbis_data_ReaderErrorType.INCORRECT_STREAM_SERIAL_NUMBER,stb_format_vorbis_data_ReaderErrorType.INVALID_FIRST_PAGE,stb_format_vorbis_data_ReaderErrorType.BAD_PACKET_TYPE,stb_format_vorbis_data_ReaderErrorType.CANT_FIND_LAST_PAGE,stb_format_vorbis_data_ReaderErrorType.SEEK_FAILED,stb_format_vorbis_data_ReaderErrorType.OTHER];
var stb_format_vorbis_data_Residue = function() {
};
$hxClasses["stb.format.vorbis.data.Residue"] = stb_format_vorbis_data_Residue;
stb_format_vorbis_data_Residue.__name__ = "stb.format.vorbis.data.Residue";
stb_format_vorbis_data_Residue.read = function(decodeState,codebooks) {
	var r = new stb_format_vorbis_data_Residue();
	var tmp;
	if(decodeState.validBits < 0) {
		tmp = 0;
	} else if(decodeState.validBits < 16) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 16)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else {
			var z = decodeState.acc & 65535;
			decodeState.acc = decodeState.acc >>> 16;
			decodeState.validBits -= 16;
			tmp = z;
		}
	} else {
		var z = decodeState.acc & 65535;
		decodeState.acc = decodeState.acc >>> 16;
		decodeState.validBits -= 16;
		tmp = z;
	}
	r.type = tmp;
	if(r.type > 2) {
		throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Residue.hx", lineNumber : 29, className : "stb.format.vorbis.data.Residue", methodName : "read"}));
	}
	var this1 = new Array(64);
	var residueCascade = this1;
	var tmp;
	if(decodeState.validBits < 0) {
		tmp = 0;
	} else if(decodeState.validBits < 24) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 24)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else {
			var z = decodeState.acc & 16777215;
			decodeState.acc = decodeState.acc >>> 24;
			decodeState.validBits -= 24;
			tmp = z;
		}
	} else {
		var z = decodeState.acc & 16777215;
		decodeState.acc = decodeState.acc >>> 24;
		decodeState.validBits -= 24;
		tmp = z;
	}
	r.begin = tmp;
	var tmp;
	if(decodeState.validBits < 0) {
		tmp = 0;
	} else if(decodeState.validBits < 24) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 24)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else {
			var z = decodeState.acc & 16777215;
			decodeState.acc = decodeState.acc >>> 24;
			decodeState.validBits -= 24;
			tmp = z;
		}
	} else {
		var z = decodeState.acc & 16777215;
		decodeState.acc = decodeState.acc >>> 24;
		decodeState.validBits -= 24;
		tmp = z;
	}
	r.end = tmp;
	var tmp;
	if(decodeState.validBits < 0) {
		tmp = 0;
	} else if(decodeState.validBits < 24) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 24)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else {
			var z = decodeState.acc & 16777215;
			decodeState.acc = decodeState.acc >>> 24;
			decodeState.validBits -= 24;
			tmp = z;
		}
	} else {
		var z = decodeState.acc & 16777215;
		decodeState.acc = decodeState.acc >>> 24;
		decodeState.validBits -= 24;
		tmp = z;
	}
	r.partSize = tmp + 1;
	var classifications;
	if(decodeState.validBits < 0) {
		classifications = 0;
	} else if(decodeState.validBits < 6) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 6)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			classifications = 0;
		} else {
			var z = decodeState.acc & 63;
			decodeState.acc = decodeState.acc >>> 6;
			decodeState.validBits -= 6;
			classifications = z;
		}
	} else {
		var z = decodeState.acc & 63;
		decodeState.acc = decodeState.acc >>> 6;
		decodeState.validBits -= 6;
		classifications = z;
	}
	var classifications1 = r.classifications = classifications + 1;
	var tmp;
	if(decodeState.validBits < 0) {
		tmp = 0;
	} else if(decodeState.validBits < 8) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 8)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else {
			var z = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			tmp = z;
		}
	} else {
		var z = decodeState.acc & 255;
		decodeState.acc = decodeState.acc >>> 8;
		decodeState.validBits -= 8;
		tmp = z;
	}
	r.classbook = tmp;
	var _g = 0;
	var _g1 = r.classifications;
	while(_g < _g1) {
		var j = _g++;
		var highBits = 0;
		var lowBits;
		if(decodeState.validBits < 0) {
			lowBits = 0;
		} else if(decodeState.validBits < 3) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 3)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				lowBits = 0;
			} else {
				var z = decodeState.acc & 7;
				decodeState.acc = decodeState.acc >>> 3;
				decodeState.validBits -= 3;
				lowBits = z;
			}
		} else {
			var z1 = decodeState.acc & 7;
			decodeState.acc = decodeState.acc >>> 3;
			decodeState.validBits -= 3;
			lowBits = z1;
		}
		var tmp;
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else if(decodeState.validBits < 1) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 1)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				tmp = 0;
			} else {
				var z2 = decodeState.acc & 1;
				decodeState.acc = decodeState.acc >>> 1;
				decodeState.validBits -= 1;
				tmp = z2;
			}
		} else {
			var z3 = decodeState.acc & 1;
			decodeState.acc = decodeState.acc >>> 1;
			decodeState.validBits -= 1;
			tmp = z3;
		}
		if(tmp != 0) {
			if(decodeState.validBits < 0) {
				highBits = 0;
			} else if(decodeState.validBits < 5) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				while(true) {
					if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
						decodeState.validBits = -1;
						break;
					} else {
						decodeState.bytesInSeg--;
						decodeState.inputPosition += 1;
						decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
						decodeState.validBits += 8;
					}
					if(!(decodeState.validBits < 5)) {
						break;
					}
				}
				if(decodeState.validBits < 0) {
					highBits = 0;
				} else {
					var z4 = decodeState.acc & 31;
					decodeState.acc = decodeState.acc >>> 5;
					decodeState.validBits -= 5;
					highBits = z4;
				}
			} else {
				var z5 = decodeState.acc & 31;
				decodeState.acc = decodeState.acc >>> 5;
				decodeState.validBits -= 5;
				highBits = z5;
			}
		}
		residueCascade[j] = highBits * 8 + lowBits;
	}
	var this1 = new Array(r.classifications);
	r.residueBooks = this1;
	var _g = 0;
	var _g1 = r.classifications;
	while(_g < _g1) {
		var j = _g++;
		var this1 = r.residueBooks;
		var this2 = new Array(8);
		this1[j] = this2;
		var _g2 = 0;
		while(_g2 < 8) {
			var k = _g2++;
			if((residueCascade[j] & 1 << k) != 0) {
				var this3 = r.residueBooks[j];
				var val;
				if(decodeState.validBits < 0) {
					val = 0;
				} else if(decodeState.validBits < 8) {
					if(decodeState.validBits == 0) {
						decodeState.acc = 0;
					}
					while(true) {
						if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
							decodeState.validBits = -1;
							break;
						} else {
							decodeState.bytesInSeg--;
							decodeState.inputPosition += 1;
							decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
							decodeState.validBits += 8;
						}
						if(!(decodeState.validBits < 8)) {
							break;
						}
					}
					if(decodeState.validBits < 0) {
						val = 0;
					} else {
						var z = decodeState.acc & 255;
						decodeState.acc = decodeState.acc >>> 8;
						decodeState.validBits -= 8;
						val = z;
					}
				} else {
					var z1 = decodeState.acc & 255;
					decodeState.acc = decodeState.acc >>> 8;
					decodeState.validBits -= 8;
					val = z1;
				}
				this3[k] = val;
				if(r.residueBooks[j][k] >= codebooks.length) {
					throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Residue.hx", lineNumber : 55, className : "stb.format.vorbis.data.Residue", methodName : "read"}));
				}
			} else {
				r.residueBooks[j][k] = -1;
			}
		}
	}
	var el = codebooks[r.classbook].entries;
	var classwords = codebooks[r.classbook].dimensions;
	var this1 = new Array(el);
	r.classdata = this1;
	var _g = 0;
	var _g1 = el;
	while(_g < _g1) {
		var j = _g++;
		var temp = j;
		var k = classwords;
		var this1 = r.classdata;
		var this2 = new Array(classwords);
		var cd = this1[j] = this2;
		while(--k >= 0) {
			cd[k] = temp % classifications1;
			temp = temp / classifications1 | 0;
		}
	}
	return r;
};
stb_format_vorbis_data_Residue.prototype = {
	decode: function(decodeState,header,residueBuffers,ch,n,doNotDecode,channelBuffers) {
		var codebooks = header.codebooks;
		var classwords = codebooks[this.classbook].dimensions;
		var nRead = this.end - this.begin;
		var partSize = this.partSize;
		var partRead = UInt.toFloat(nRead) / UInt.toFloat(partSize) | 0;
		var this1 = new Array(header.channel * partRead);
		var partClassdata = this1;
		var _g = 0;
		var _g1 = ch;
		while(_g < _g1) {
			var i = _g++;
			if(!doNotDecode[i]) {
				var buffer = residueBuffers[i];
				var _g2 = 0;
				var _g3 = buffer.length;
				while(_g2 < _g3) {
					var j = _g2++;
					buffer[j] = 0;
				}
			}
		}
		if(this.type == 2 && ch != 1) {
			var _g = 0;
			var _g1 = ch;
			while(_g < _g1) {
				var j = _g++;
				if(!doNotDecode[j]) {
					break;
				} else if(j == ch - 1) {
					return;
				}
			}
			var _g = 0;
			while(_g < 8) {
				var pass = _g++;
				var pcount = 0;
				var classSet = 0;
				if(ch == 2) {
					while(pcount < partRead) {
						var z = this.begin + pcount * partSize;
						var cInter = z & 1;
						var pInter = z >>> 1;
						if(pass == 0) {
							var c = codebooks[this.classbook];
							if(decodeState.validBits < 10) {
								decodeState.prepHuffman();
							}
							var i = c.fastHuffman[decodeState.acc & 1023];
							var val;
							if(i >= 0) {
								var l = c.codewordLengths[i];
								decodeState.acc = decodeState.acc >>> l;
								decodeState.validBits -= l;
								if(decodeState.validBits < 0) {
									decodeState.validBits = 0;
									val = -1;
								} else {
									val = i;
								}
							} else {
								val = decodeState.decodeScalarRaw(c);
							}
							if(c.sparse) {
								val = c.sortedValues[val];
							}
							var q = val;
							if(q == -1) {
								return;
							}
							partClassdata[classSet] = this.classdata[q];
						}
						var _g1 = 0;
						var _g2 = classwords;
						while(_g1 < _g2) {
							var i1 = _g1++;
							if(pcount >= partRead) {
								break;
							}
							var z1 = this.begin + pcount * partSize;
							var c1 = partClassdata[classSet][i1];
							var b = this.residueBooks[c1][pass];
							if(b >= 0) {
								var book = codebooks[b];
								var result = book.decodeDeinterleaveRepeat(decodeState,residueBuffers,ch,cInter,pInter,n,partSize);
								if(result == null) {
									return;
								} else {
									cInter = result.cInter;
									pInter = result.pInter;
								}
							} else {
								z1 = z1 + partSize;
								cInter = z1 & 1;
								pInter = z1 >>> 1;
							}
							++pcount;
						}
						++classSet;
					}
				} else if(ch == 1) {
					while(pcount < partRead) {
						var z2 = this.begin + pcount * partSize;
						var cInter1 = 0;
						var pInter1 = z2;
						if(pass == 0) {
							var c2 = codebooks[this.classbook];
							if(decodeState.validBits < 10) {
								decodeState.prepHuffman();
							}
							var i2 = c2.fastHuffman[decodeState.acc & 1023];
							var val1;
							if(i2 >= 0) {
								var l1 = c2.codewordLengths[i2];
								decodeState.acc = decodeState.acc >>> l1;
								decodeState.validBits -= l1;
								if(decodeState.validBits < 0) {
									decodeState.validBits = 0;
									val1 = -1;
								} else {
									val1 = i2;
								}
							} else {
								val1 = decodeState.decodeScalarRaw(c2);
							}
							if(c2.sparse) {
								val1 = c2.sortedValues[val1];
							}
							var q1 = val1;
							if(q1 == -1) {
								return;
							}
							partClassdata[classSet] = this.classdata[q1];
						}
						var _g3 = 0;
						var _g4 = classwords;
						while(_g3 < _g4) {
							var i3 = _g3++;
							if(pcount >= partRead) {
								break;
							}
							var z3 = this.begin + pcount * partSize;
							var c3 = partClassdata[classSet][i3];
							var b1 = this.residueBooks[c3][pass];
							if(b1 >= 0) {
								var book1 = codebooks[b1];
								var result1 = book1.decodeDeinterleaveRepeat(decodeState,residueBuffers,ch,cInter1,pInter1,n,partSize);
								if(result1 == null) {
									return;
								} else {
									cInter1 = result1.cInter;
									pInter1 = result1.pInter;
								}
							} else {
								z3 = z3 + partSize;
								cInter1 = 0;
								pInter1 = z3;
							}
							++pcount;
						}
						++classSet;
					}
				} else {
					while(pcount < partRead) {
						var z4 = this.begin + pcount * partSize;
						var cInter2 = UInt.toFloat(z4) % UInt.toFloat(ch) | 0;
						var pInter2 = UInt.toFloat(z4) / UInt.toFloat(ch) | 0;
						if(pass == 0) {
							var c4 = codebooks[this.classbook];
							if(decodeState.validBits < 10) {
								decodeState.prepHuffman();
							}
							var i4 = c4.fastHuffman[decodeState.acc & 1023];
							var val2;
							if(i4 >= 0) {
								var l2 = c4.codewordLengths[i4];
								decodeState.acc = decodeState.acc >>> l2;
								decodeState.validBits -= l2;
								if(decodeState.validBits < 0) {
									decodeState.validBits = 0;
									val2 = -1;
								} else {
									val2 = i4;
								}
							} else {
								val2 = decodeState.decodeScalarRaw(c4);
							}
							if(c4.sparse) {
								val2 = c4.sortedValues[val2];
							}
							var q2 = val2;
							if(q2 == -1) {
								return;
							}
							partClassdata[classSet] = this.classdata[q2];
						}
						var _g5 = 0;
						var _g6 = classwords;
						while(_g5 < _g6) {
							var i5 = _g5++;
							if(pcount >= partRead) {
								break;
							}
							var z5 = this.begin + pcount * partSize;
							var c5 = partClassdata[classSet][i5];
							var b2 = this.residueBooks[c5][pass];
							if(b2 >= 0) {
								var book2 = codebooks[b2];
								var result2 = book2.decodeDeinterleaveRepeat(decodeState,residueBuffers,ch,cInter2,pInter2,n,partSize);
								if(result2 == null) {
									return;
								} else {
									cInter2 = result2.cInter;
									pInter2 = result2.pInter;
								}
							} else {
								z5 = z5 + partSize;
								cInter2 = UInt.toFloat(z5) % UInt.toFloat(ch) | 0;
								pInter2 = UInt.toFloat(z5) / UInt.toFloat(ch) | 0;
							}
							++pcount;
						}
						++classSet;
					}
				}
			}
			return;
		}
		var _g = 0;
		while(_g < 8) {
			var pass = _g++;
			var pcount = 0;
			var classSet = 0;
			while(pcount < partRead) {
				if(pass == 0) {
					var _g1 = 0;
					var _g2 = ch;
					while(_g1 < _g2) {
						var j = _g1++;
						if(!doNotDecode[j]) {
							var c = codebooks[this.classbook];
							if(decodeState.validBits < 10) {
								decodeState.prepHuffman();
							}
							var i = c.fastHuffman[decodeState.acc & 1023];
							var val;
							if(i >= 0) {
								var l = c.codewordLengths[i];
								decodeState.acc = decodeState.acc >>> l;
								decodeState.validBits -= l;
								if(decodeState.validBits < 0) {
									decodeState.validBits = 0;
									val = -1;
								} else {
									val = i;
								}
							} else {
								val = decodeState.decodeScalarRaw(c);
							}
							if(c.sparse) {
								val = c.sortedValues[val];
							}
							var temp = val;
							if(temp == -1) {
								return;
							}
							partClassdata[j * partRead + classSet] = this.classdata[temp];
						}
					}
				}
				var _g3 = 0;
				var _g4 = classwords;
				while(_g3 < _g4) {
					var i1 = _g3++;
					if(pcount >= partRead) {
						break;
					}
					var _g5 = 0;
					var _g6 = ch;
					while(_g5 < _g6) {
						var j1 = _g5++;
						if(!doNotDecode[j1]) {
							var c1 = partClassdata[j1 * partRead + classSet][i1];
							var b = this.residueBooks[c1][pass];
							if(b >= 0) {
								var target = residueBuffers[j1];
								var offset = this.begin + pcount * partSize;
								var n = partSize;
								var book = codebooks[b];
								if(!book.residueDecode(decodeState,target,offset,n,this.type)) {
									return;
								}
							}
						}
					}
					++pcount;
				}
				++classSet;
			}
		}
	}
	,__class__: stb_format_vorbis_data_Residue
};
function $getIterator(o) { if( o instanceof Array ) return new haxe_iterators_ArrayIterator(o); else return o.iterator(); }
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
$hxClasses["Math"] = Math;
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.prototype.__class__ = $hxClasses["String"] = String;
String.__name__ = "String";
$hxClasses["Array"] = Array;
Array.__name__ = "Array";
Date.prototype.__class__ = $hxClasses["Date"] = Date;
Date.__name__ = "Date";
haxe_Resource.content = [{ name : "R_sfx_hit_wav", data : "UklGRsRCAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YaBCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP9jv2Z/Zp9ub1Y/Xg9F302vNY8yr0IfUY9g/3Bfj7+PD4HPhI93X2ofXO9CP0A/Ti88LzovOC82LzqPP68030oPTy9EX1nfX69Vf2tPYR9233nvch96T2J/aq9S31sPSa9JT0jvSI9IL0fPRn9Eb0JfQD9OLzwfPR88L0svWi9pL3gfhx+Qz5aPjE9yD3fPbY9Z31yvX29SL2TvZ79pD2LfbK9Wf1BfWj9G3wmvDt8D/xkvHl8TfyefKp8tnyCfM582nzp/NA9Nj0cPUI9qD2OPc89xv3+/ba9rr2mvZi9g72u/Vn9RT1wfR+9LL05vQa9U31gfW19RX1O/Rh84jyrvHV8I7w//Bw8eDxUfLB8iLz/vLa8rbykvJv8kvy8/Lb88L0qfWQ9nf3zvdi9/X2ifYd9rH1T/Vd9Wv1efWH9ZX1o/Ub9V/0o/Pn8izycPE68cjxVvLF/8j/yv/M/8v/yv/J/8j/x//G/8j/y//O/9H/1f/Y/9r/2f/Y/9f/1v/W/9X/0f/O/8v/x//E/8H/wP/B/8L/wv/D/8P/xf/H/8r/zP/P/9H/0//T/9L/0v/R/9D/0P/R/9L/1P/W/9f/2f/a/9r/2f/Z/9j/2P/Y/9f/1v/V/9T/0//S/9H/z//O/8z/y//J/8j/yf/J/8r/yv/L/8v/zP/N/87/zv/P/+rzOfSa9Pz0XfW+9R/2IfZG9Wz0k/O58uHxCPES8SXxOPFM8V/xcvGN8azxzPHr8QvyKvI38hPy7/HL8afxg/Ff8ZXxz/EK8kTyf/K58tzy8PIE8xjzK/M/83Dz8vN09Pb0ePX69Xv2xPXy9CH0UPN/8q/xWvFc8V/xYvFl8Wjxp/Gk8qDznPSX9ZL2jPfX9vL1DvUr9EfzZPJ18kTzEvTg9K71e/b79m323vUBAQ4BGwEoAS4BMwE4AT0BQgFHAT8BLgEdAQsB+gDoAN8A9QALASABNgFMAWEBVwFJAToBKwEdAQ4BCQEOARIBFwEcASABJAEmAScBKQErASwBLgEwATIBNAE3ATkBOwEyAR8BCwH3AOQA0ADCANMA5AD1AAYBFwEoASoBKgEpASkBKAEoASABEAEAAe8A3wDPAMQA2QDuAAIBFwErAUABNAEhAQ4B+wDnANQAVgBZAFwAXwBiAGUAaABoAGkAagBqAGsAawBqAGcAZQBiAGAAXgBeAGIAZQBpAG0AcABzAHEAbwBsAGoAaABlAGgAbABvAHMAdwB7AH0AfQB8AHwAfAB7AHsAewB6AHoAegB5AHkAeQB4AHgAdwB3AHcAdwB5AHsAfAB+AIAAgQB6AHMAbABmAF8AWABYAFoAXABfAGEAYwBlAGcAaABpAGsAbABtAGoAZgBjAMwHggc4BxsHEAcFB/oG7wbkBgYHdwfnB1YIxgg2CZ8JHgmcCBsImgcZB5gGagZhBlgGTwZGBj0GLgYUBvoF4AXGBawFkgUFBngG6gZcB84HQAhuCHoIhgiRCJ0IqQisCJ0Ijgh/CHAIYQhSCIwIxwgBCTwJdwmxCWgJ1ghECLMHIgeRBlcG5AZxB/4HiggWCaIJ/ghOCJ8H8AZBBpMFuQVeBgMHqAdNCPEIWQkjAR0BFwESAQwBBgH4AOoA2wDMAL4ArwCqAKwArQCuAK8AsQCxALAArwCuAKwAqwCqALUAwQDMANgA5ADwAPkAAQEJAREBGQEhASQBGQEOAQMB9wDsAOEA2ADQAMgAvwC3AK8AsgC+AMsA1wDjAO8A+AD1APIA7wDtAOoA5wDgANgAzwDHAL8AtwC4AMEAygDSANsA5ADoANoAzAC9AK8AoQCTAJgAoACoALAAbwF/AZIBpwG8AdIB5wH8AQcC4wHAAZwBeQFVATIBNAE+AUcBUAFaAWMBcQGDAZUBpwG5AcsB3AHnAfEB/AEGAhECGwIeAh4CHwIgAiECIQIVAvoB4AHFAasBkQF7AYABhgGLAZEBlgGbAZQBiQF+AXMBaQFeAV0BZgFvAXgBgQGKAZIBkwGTAZQBlAGVAZUBhgFyAV0BSQE1ASEBGgEjASwBNQE+AUYBTwFYAWABFgMoAzsDTQNoA4YDpAPCA+AD/QMFBO8D2gPEA68DmQOCA1QDJgP5AswC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6P/j/93/2P/S/83/zf/S/9f/3f/i/+f/7f/z//n///8FAAsAEAAVABkAHQAgACYAKwAmACAAGgAUAA4ABwABAPr/9P/u/+f/4f/a/9P/zf/G/7//t/+1/7b/t/+4/7n/vP+//8L/xf/I/8v/y//L/8z/zP/N/83/0P/S/9X/1//Z/9z/3f/d/97/3//g/+H/4v/k/+X/5//p/+r/7P/t/+3/7P/r/+v/6v/p/+j/5//l/+T/4//i/+H/4f/g/9//3v/e/+D/5P/n/+v/7v/w//L/9f/3//n//P/+/wEAAwAGAAgACwANABAAEwAWABgAGwAeACAAIgAjACUAJgAoACkAKgAqACsAKwArAC0ALwAuACwAKwApACcAJAAhAB8AHAAaABgAFgAVABQAEgARAA8ADQAMAA4AEAARABMAFAAVABYAFwAYABgAGgAbAB0AHgAgACEAIwAkACQAIgAhACAAIAAfAB8AHwAfAB4AHQAcABoAGAAWABUAEwASABAADgALAAgABgADAAAA/f/7//j/9v/z//H/7//u/+z/6v/p/+f/5v/m/+b/5v/m/+b/5f/l/+X/5P/k/+T/5P/k/+P/4//j/+L/4f/g/9//3v/e/97/3v/f/9//4P/g/+H/4f/i/+L/4//j/+T/5v/o/+z/8P/z//b/+f/7//7/AQAEAAcACgANABAAEgAVABcAGgAeAB8AHQAbABkAFgATABEADgALAAkABgAEAAEA///9//r/+P/2//T/9f/3//n/+//9/wAAAgAEAAYACAAKAAwADgAPABEAEwAVABcAGQAXABUAEwARAA4ADAAJAAcABQAEAAIAAQD///3//P/6//j/9//2//b/9//4//n/+f/6//r/+//7//z//P/9//7//v//////AAAAAAAAAAD///7//v/9//3//P/8//v/+v/6//n/+P/3//f/9v/2//b/9v/2//b/9//2//b/9v/2//b/9//3//j/+P/5//n/+f/5//r/+v/6//v/+//7//z//P/9//3//v/+/////////wAAAQABAAEAAAD///7//f/9//z/+//6//n/+P/5//n/+v/6//v//P/8//z//f/9//3//f/9//3//f/8//z//P/8//z//P/8//3//v/+//////8AAAAAAAABAAEAAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAA"},{ name : "R_fonts_alterebro_png", data : "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Z14oNeve7ea56t61rm9nSNpup4sVT8eOo2mHjTeVke2f4KQuO+sTOeho5l3BVx6xTi+CdN4UvtLGydu5+aot2yOo1dKVZWf1qbwYavsUoGzmHaFfLbvKFrhjrXRXbNTdjfMKl3bzreL7A0JUQES4n2+RLVoILrP9FmhvIBlOhNBG8atTnuzWTqDVNnJ2ERk7hq7YVjl3iOydQC2btfsn2xG0RQq23oWnZdadbl1lk86dpWUsCPEK22bG9qO+gDcE/1XnzhUl8NcAnT83AsDJ84dHAKbetunVES/ATz4FULwluqctA//sCFByBjn/KBL4lwnQkBL1vyMD/thTQPR/+oA/QACMAL9xEdiREg07iPBLdAAAUwAAAgAgAAACACAAAAIAIAAAAgAgAAACACAAAAIAIAAAAgAgAAACACAAAAIAIAAAAgAgAAACACAAAAIAIAAAAgAgAAACACAAAAIAIAAAAgAgAAACACAAAAIAIAAAAgAgAAACACAAAAIAIAAAAgAgAAACACAAAAIAIAAAAgAgAAACACAAAAIAIAAAAgAgAAACACAAAAIAIAAAAgAgADCH/wYAMwbidIeMXPYAAAAASUVORK5CYII"},{ name : "R_fonts_04b03_png", data : "iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAdhwAAHYcBj+XxZQAABOhJREFUeJztnG2P3CAMhLNV//9fTj/lRDnAY2xCsjOPVN1p45i3CVkGrp/zPA/By5/dFRB7kQDIQQTQe0ecxnU0xiqnvmblOsEY77Wsdu6iWbeVM0DdKZEO/DjK/Djie/f36jCq3+jeK/cuunWLCOBT/bSu9+LO4ro1cFYnXwORJSiUq16R2XKUG5nVRvd32/tZuApoJUaekJFQPAJB4r1lzOTMuHcWs8zIdwALzwxgDT5ap3IGGD2RPaynODKAiHhnCNV35QzgZccT8hS2tf1Jy0DWwT+OjW1/kgDEBiQAciQAciQAcv42PkPW473r5ZLCun8UU8YieZDyVudBY2aYXSWY99UCQIwUyxK1CkdirmsWUeewVR8rTy+nNwatJ9pHo7Hq9kFrBoiS8aSgRk7mU4nuA8zsFZQxns8R69tiKILs7wDoZswVE90gQvKgZSEWMFrWKI/nc6Te1j6BawZAlG5hTUvIdwDEz0fzZLyX0TzILDFbtvU67dVnGPMkK1hsQMtAciQAciQAciQAclpG0AW6nImu96N5MtzHrByIEWSVU8ZlG06/aC0DrST15xFn7ABiPG4eUo6Vo0XWgQ3TmaviRqTUaWYvoI6Lsso/95aT5WDeQdoJotZ3AMTJK2NHWC5VWd7qzrPahTqYkTIs0D5I66/eDGB11OmIveJ6eDz2lU/viKwOt/rN41xarxMoj5xAcrQMJEcCIEcCIEcCIKcWQP2NEDnAgBxYsK4jpkdmnlG7rOut3yMxmbnc7WrNANZJHKuw8nrGiZ0VeSy3cLUpdXHXEqzb5pYPUK4vrQ5/0xoy63QQSoZbh9QZHYdmfXqHQj1OYFQEWYOC5EH2DJ7EzH6Klec/VpwKvkCfOM/GSGRw0Z24aF2QDZ96lr1D/M2YtzmBb3lyX8PbloEa/GTeJgCRjARAjgRAjgRATssKRu3LHohtG2H3/SvyRXKgJlCT3pGwFqjpgxyujDTYuh/ZF8jcf4jkuGKsPovWpZvf+wrIGLzyZzRPTen3W/ej+waz5dQuXi/Gup7VniYz3wHetgewE2sA7958+sXModDjGFuYme8zb8d4NkZG+S3LFynniom4l8sftrdZwcwsscFXbgaJHJZuYUsAz2fp9wMZQeRIAORIAORIAOSMTgWjn3tjGHlsv3j2Akq8DTqrf0gcki8rz6xVm5Hj7Pw+G4PU+QfPDFBen/0T6+untXFx998JjBi1t1yjP9buHeH1AR47lS0EPYlsxWZgHQ13nzT2CuAJ5+rRY+Iev38W9Kj5aFA8+wrpfd7aC/iGo9feNnxDm6donQii7AhWtBtIjowgciQAciQAciQAcnYKYOZvEFB7d5RDFPT+j6CoJ4168TOHPke4nTB2agFkdF7pi1vn6mfz94T1aN/9iax6BVgDHLFh9XQn0nMCR08YshV7AHEHcD0aLwwiTqCexC9g5lj4XVuf4gZmBKCB/yJkBJEjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZAjAZDzD+xTuNG6joBJAAAAAElFTkSuQmCC"},{ name : "R_sfx_robinet_wav", data : "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"},{ name : "R_sfx_help_wav", data : "UklGRvpAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YdZAAAD9NfE15TXaNc41wjW3Nas1nzWTNYg1fDVwNWQ1WTWY8p3Kqcq1ysDKzMrYyuPK78r7ygfLEsseyyrLNctx2LM0qDScNJA0hTR5NG00YTRWNEo0PjQzNCc0GzQQNOvy58vzy/7LCswWzCLMLcw5zEXMUMxczGjMc8x/zGjZajNeM1IzRzM7My8zJDMYMwwzATP1Muky3jLSMsYyPvMxzT3NSM1UzWDNa813zYPNjs2azabNsc29zcnNX9ogMhQyCTL9MfIx5jHaMc8xwzG3MawxoDGUMYkxfTGQ83vOh86Szp7Oqs61zsHOzc7YzuTO8M77zgfPEs9W29cwyzC/MLQwqDCcMJEwhTB6MG4wYjBXMEswPzA0MOPzxc/Rz9zP6M/zz//PC9AW0CLQLtA50EXQUNBc0E7cjS+BL3Yvai9fL1MvRy88LzAvJS8ZLw0vAi/2LusuNvQP0RvRJtEy0T3RSdFV0WDRbNF30YPRj9Ga0abRRd1DLjguLC4hLhUuCS7+LfIt5y3bLdAtxC25La0toS2J9FnSZdJw0nzSh9KT0p7SqtK20sHSzdLY0uTS79I83vos7izjLNcszCzALLQsqSydLJIshix7LG8sZCxYLNz0o9Ou07rTxtPR093T6NP00//TC9QW1CLULdQ51DPfsCulK5krjiuCK3craytgK1QrSCs9KzErJisaKw8rLvXt1PjUBNUP1RvVJ9Uy1T7VSdVV1WDVbNV31YPVK+BnKlsqUCpEKjkqLSoiKhYqCyr/KfQp6CndKdEpximB9TfWQtZO1lnWZdZw1nzWh9aT1p7Wqta11sHWzNYi4R0pEikGKfso7yjkKNgozSjBKLYoqiifKJMoiCh8KNT1gdeM15jXo9ev17rXxtfR193X6Nf01//XCtgW2Bni0yfIJ7wnsSemJ5onjyeDJ3gnbCdhJ1YnSic/JzMnJ/bL2NbY4tjt2PnYBNkQ2RvZJtky2T3ZSdlU2WDZEOOKJn4mcyZoJlwmUSZFJjomLiYjJhgmDCYBJvUl6iV69hXaINos2jfaQ9pO2lnaZdpw2nzah9qS2p7aqdoH5EAlNSUpJR4lEyUHJfwk8CTlJNokziTDJLgkrCShJMz2X9tq23bbgduM25jbo9uv27rbxdvR29zb59vz2//k9yPrI+Aj1CPJI74jsiOnI5wjkCOFI3ojbiNjI1gjH/ep3LTcwNzL3Nbc4tzt3PjcBN0P3RrdJt0x3Tzd9uWtIqIiliKLIoAidCJpIl4iUiJHIjwiMCIlIhoiDiJy9/Pd/t0K3hXeIN4s3jfeQt5O3lneZN5v3nveht7t5mMhWCFNIUEhNiErISAhFCEJIf4g8iDnINwg0CDFIMX3Pd9I31PfX99q33Xfgd+M35ffo9+u37nfxN/Q3+TnGiAPIAMg+B/tH+Ef1h/LH8AftB+pH54fkh+HH3wfGPiH4JLgneCp4LTgv+DL4Nbg4eDs4PjgA+EO4Rnh2+jQHsUeuh6uHqMemB6NHoEedh5rHmAeVB5JHj4eMx5q+NHh3OHn4fPh/uEJ4hTiIOIr4jbiQeJN4ljiY+LT6Ycdex1wHWUdWh1OHUMdOB0tHSIdFh0LHQAd9RzpHL34G+Mm4zHjPONI41PjXuNp43XjgOOL45bjoeOt48rqPRwyHCccGxwQHAUc+hvvG+Mb2BvNG8IbtxurG6AbEPll5HDke+SG5JLkneSo5LPkvuTK5NXk4OTr5PbkwevzGuga3RrSGscavBqwGqUamhqPGoQaeBptGmIaVxpj+a/luuXF5dDl2+Xn5fLl/eUI5hPmHuYq5jXmQOa47KoZnxmUGYgZfRlyGWcZXBlRGUUZOhkvGSQZGRkOGbb5+eb55vvm/Ob95v/mAOcB5wPnBOcF5wfnCOcJ50jt9BjzGPEY8BjvGO0Y7BjqGOkY6BjmGOUY5BjiGOEYvvkS5xPnFecW5xfnGeca5xvnHece5yDnIeci5yTnXO3aGNgY1xjWGNQY0xjSGNAYzxjOGMwYyxjKGMgYxxjF+SznLucv5zDnMucz5zTnNuc35zjnOuc75zznPudv7cAYvhi9GLwYuhi5GLgYthi1GLQYshixGLAYrhitGMz5RudI50nnSudM503nTudQ51HnUudU51XnVudY54PtphikGKMYohigGJ8YnhicGJsYmRiYGJcYlRiUGJMY0vlg52LnY+dk52bnZ+dp52rna+dt527nb+dx53Lnlu2LGIoYiRiHGIYYhRiDGIIYgRh/GH4YfRh7GHoYeRjZ+XvnfOd953/ngOeB54PnhOeF54fniOeJ54vnjOeq7XEYcBhvGG0YbBhrGGkYaBhnGGUYZBhjGGEYYBhfGN/5leeW55fnmeea55vnneee55/noeei56Tnpeem577tVxhWGFUYUxhSGFEYTxhOGE0YSxhKGEkYRxhGGEQY5vmv57Dnsuez57Tntue357jnuue757znvue/58Dn0e09GDwYOhg5GDgYNhg1GDQYMhgxGDAYLhgtGCwYKhjs+cnnyufM583nzufQ59Hn0ufU59Xn1ufY59nn2ufl7SMYIhggGB8YHhgcGBsYGhgYGBcYFhgUGBMYEhgQGPP54+fk5+bn5+fp5+rn6+ft5+7n7+fx5/Ln8+f15/jtCRgIGAYYBRgEGAIYARgAGP4X/Rf8F/oX+Rf4F/YX+fn95//nAOgB6APoBOgF6AfoCOgJ6AvoDOgN6A/oDO7vF+0X7BfrF+kX6BfnF+UX5BfjF+EX4BffF90X3BcA+hfoGega6BvoHege6B/oIegi6CPoJegm6CfoKegg7tUX0xfSF9EXzxfOF80XyxfKF8kXxxfGF8UXwxfCFwf6Mugz6DToNug36DjoOug76DzoPug/6EDoQuhD6DPuuxe5F7gXtxe1F7QXsxexF7AXrxetF6wXqxepF6gXDfpM6E3oTuhQ6FHoUuhU6FXoVuhY6FnoWuhc6F3oR+6gF58XnhecF5sXmheZF5cXlheVF5MXkheRF48XjhcU+mboZ+hp6Groa+ht6G7ob+hw6HLoc+h06Hbod+ha7oYXhReEF4IXgReAF34XfRd8F3oXeRd4F3YXdRd0Fxr6gOiB6IPohOiF6IfoiOiJ6IvojOiN6I/okOiR6G7ubBdrF2oXaBdnF2YXZBdjF2IXYBdfF14XXBdbF1oXIfqa6Jvoneie6J/ooeii6KPopeim6Kfoqeiq6Kvoge5SF1EXUBdOF00XTBdKF0kXSBdGF0UXRBdCF0EXQBcn+rTotui36Ljouui76Lzovui/6MDowejD6MToxeiV7jgXNxc1FzQXMxcxFzAXLxctFywXKxcqFygXJxcmFy76zujQ6NHo0ujU6NXo1ujY6Nno2ujc6N3o3ujg6KnuHhcdFxsXGhcZFxcXFhcVFxMXEhcRFw8XDhcNFwwXNPrp6Oro6+jt6O7o7+jw6PLo8+j06Pbo9+j46ProvO4EFwIXARcAF/8W/Rb8FvsW+Rb4FvcW9Rb0FvMW8RY7+gPpBOkF6QfpCOkJ6QvpDOkN6Q/pEOkR6RLpFOnQ7uoW6BbnFuYW5BbjFuIW4RbfFt4W3RbbFtoW2RbXFkL6Heke6R/pIeki6SPpJekm6SfpKekq6SvpLeku6ePu0BbOFs0WzBbKFskWyBbGFsUWxBbCFsEWwBa/Fr0WSPo36TjpOuk76TzpPuk/6UDpQelD6UTpRelH6Ujp9+61FrQWsxayFrAWrxauFqwWqxaqFqgWpxamFqQWoxZP+lHpUulU6VXpVulY6VnpWulc6V3pXulg6WHpYukL75sWmhaZFpcWlhaVFpQWkhaRFpAWjhaNFowWihaJFlX6a+lt6W7pb+lx6XLpc+l06Xbpd+l46Xrpe+l86R7vgRaAFn8WfRZ8FnsWeRZ4FncWdhZ0FnMWchZwFm8WXPqF6YfpiOmJ6YvpjOmN6Y/pkOmR6ZLplOmV6ZbpMu9nFmYWZRZjFmIWYRZfFl4WXRZbFloWWRZYFlYWVRZi+qDpoemi6aPppemm6afpqemq6avpremu6a/psOlF700WTBZKFkkWSBZHFkUWRBZDFkEWQBY/Fj0WPBY7Fmn6uum76bzpvum/6cDpwunD6cTpxenH6cjpyenL6VnvMxYyFjAWLxYuFiwWKxYqFikWJxYmFiUWIxYiFiEWcPrU6dXp1unY6dnp2unc6d3p3ung6eHp4unj6eXpbO8ZFhgWFhYVFhQWEhYRFhAWDhYNFgwWCxYJFggWBxZ2+u7p7+nx6fLp8+n06fbp9+n46frp++n86f7p/+mA7/8V/RX8FfsV+hX4FfcV9hX0FfMV8hXwFe8V7hXtFX36COoJ6gvqDOoN6g/qEOoR6hLqFOoV6hbqGOoZ6pTv5RXjFeIV4RXfFd4V3RXcFdoV2RXYFdYV1RXUFdMVg/oi6iTqJeom6ifqKeoq6ivqLeou6i/qMOoy6jPqp+/KFckVyBXHFcUVxBXDFcEVwBW/Fb4VvBW7FboVuBWK+jzqPuo/6kDqQupD6kTqRepH6kjqSepL6kzqTeq777AVrxWuFa0VqxWqFakVpxWmFaUVpBWiFaEVoBWeFZD6V+pY6lnqWupc6l3qXupg6mHqYupj6mXqZupn6s7vlhWVFZQVkhWRFZAVjxWNFYwVixWJFYgVhxWGFYQVl/px6nLqc+p16nbqd+p46nrqe+p86n7qf+qA6oHq4u98FXsVehV4FXcVdhV0FXMVchVxFW8VbhVtFWsVahWd+ovqjOqN6o/qkOqR6pPqlOqV6pbqmOqZ6prqnOr272IVYRVfFV4VXRVcFVoVWRVYFVcVVRVUFVMVURVQFaT6peqm6qjqqeqq6qvqrequ6q/qseqy6rPqtOq26gnwSBVHFUUVRBVDFUIVQBU/FT4VPBU7FToVORU3FTYVq/q/6sDqwurD6sTqxurH6sjqyerL6szqzerO6tDqHfAuFS0VKxUqFSkVJxUmFSUVJBUiFSEVIBUfFR0VHBWx+tnq2+rc6t3q3urg6uHq4urj6uXq5urn6unq6uow8BQVEhURFRAVDxUNFQwVCxUKFQgVBxUGFQQVAxUCFbj68+r16vbq9+r56vrq++r86v7q/+oA6wHrA+sE60Tw+hT4FPcU9hT1FPMU8hTxFO8U7hTtFOwU6hTpFOgUvvoO6w/rEOsR6xPrFOsV6xbrGOsZ6xrrHOsd6x7rV/DfFN4U3RTcFNoU2RTYFNcU1RTUFNMU0hTQFM8UzhTF+ijrKesq6yzrLesu6y/rMesy6zPrNOs26zfrOOtr8MUUxBTDFMIUwBS/FL4UvBS7FLoUuRS3FLYUtRS0FMv6QutD60TrRutH60jrSetL60zrTetP61DrUetS63/wqxSqFKkUpxSmFKUUpBSiFKEUoBSfFJ0UnBSbFJoU0vpc613rX+tg62HrYutk62XrZutn62nrautr62zrkvCRFJAUjxSNFIwUixSKFIgUhxSGFIUUgxSCFIEUfxTY+nbrd+t563rre+t8637rf+uA64Hrg+uE64Xrh+um8HcUdhR1FHMUchRxFG8UbhRtFGwUahRpFGgUZxRlFN/6kOuS65PrlOuV65frmOuZ65rrnOud657rn+uh67nwXRRcFFoUWRRYFFcUVRRUFFMUUhRQFE8UThRNFEsU5vqq66zrreuu66/rseuy67PrtOu267fruOu667vrzfBDFEIUQBQ/FD4UPRQ7FDoUORQ4FDYUNRQ0FDIUMRTs+sXrxuvH68jryuvL68zrzevP69Dr0evS69Tr1evh8CkUJxQmFCUUJBQiFCEUIBQfFB0UHBQbFBoUGBQXFPP63+vg6+Hr4uvk6+Xr5uvn6+nr6uvr6+zr7uvv6/TwDxQNFAwUCxQKFAgUBxQGFAUUAxQCFAEUABT+E/0T+fr56/rr++v96/7r/+sA7ALsA+wE7AXsB+wI7AnsCPH0E/MT8hPxE+8T7hPtE+wT6hPpE+gT5xPlE+QT4xMA+xPsFOwV7BfsGOwZ7BrsHOwd7B7sH+wh7CLsI+wb8doT2RPYE9cT1RPUE9MT0hPQE88TzhPNE8sTyhPJEwb7Lewu7DDsMewy7DPsNew27DfsOOw67DvsPOw97C/xwBO/E74TvRO7E7oTuRO4E7YTtRO0E7MTsROwE68TDftH7EnsSuxL7EzsTexP7FDsUexS7FTsVexW7FfsQvGmE6UTpBOiE6EToBOfE50TnBObE5oTmBOXE5YTlRMT+2HsY+xk7GXsZuxo7Gnsauxr7G3sbuxv7HDscuxW8YwTixOKE4gThxOGE4UTgxOCE4ETgBN+E30TfBN7Exr7fOx97H7sf+yB7ILsg+yE7IXsh+yI7InsiuyM7GrxchNxE28TbhNtE2wTahNpE2gTZxNmE2QTYxNiE2ETIfuW7JfsmOyZ7JvsnOyd7J7soOyh7KLso+yl7KbsffFYE1cTVRNUE1MTUhNQE08TThNNE0sTShNJE0gTRhMn+7Dsseyy7LTstey27LfsuOy67LvsvOy97L/swOyR8T4TPBM7EzoTORM4EzYTNRM0EzMTMRMwEy8TLhMsEy77yuzL7MzszuzP7NDs0ezT7NTs1ezW7Njs2eza7KTxJBMiEyETIBMfEx0THBMbExoTGBMXExYTFRMUExITNPvk7OXs5+zo7Ons6uzs7O3s7uzv7PDs8uzz7PTsuPEJEwgTBxMGEwUTAxMCEwETABP+Ev0S/BL7EvkS+BI7+/7s/+wB7QLtA+0E7QbtB+0I7QntC+0M7Q3tDu3M8e8S7hLtEuwS6hLpEugS5xLmEuQS4xLiEuES3xLeEkH7GO0a7RvtHO0d7R/tIO0h7SLtI+0l7SbtJ+0o7d/x1RLUEtMS0hLQEs8SzhLNEssSyhLJEsgSxxLFEsQSSPsz7TTtNe027TftOe067TvtPO0+7T/tQO1B7ULt8/G7EroSuRK3ErYStRK0ErMSsRKwEq8SrhKsEqsSqhJP+03tTu1P7VDtUu1T7VTtVe1W7VjtWe1a7VvtXe0G8qESoBKfEp0SnBKbEpoSmBKXEpYSlRKUEpISkRKQElX7Z+1o7Wntau1s7W3tbu1v7XHtcu1z7XTtde137RryhxKGEoQSgxKCEoESgBJ+En0SfBJ7EnkSeBJ3EnYSXPuB7YLtg+2F7Ybth+2I7Yrti+2M7Y3tju2Q7ZHtLvJtEmwSahJpEmgSZxJlEmQSYxJiEmESXxJeEl0SXBJi+5vtnO2e7Z/toO2h7aLtpO2l7abtp+2p7artq+1B8lMSURJQEk8SThJNEksSShJJEkgSRxJFEkQSQxJCEmn7te227bjtue267bvtve2+7b/twO3B7cPtxO3F7VXyORI3EjYSNRI0EjMSMRIwEi8SLhIsEisSKhIpEigSb/vP7dHt0u3T7dTt1e3X7djt2e3a7dzt3e3e7d/taPIeEh0SHBIbEhoSGBIXEhYSFRIUEhISERIQEg8SDhJ2++rt6+3s7e3t7u3w7fHt8u3z7fTt9u337fjt+e188gQSAxICEgESABL+Ef0R/BH7EfkR+BH3EfYR9RHzEXz7BO4F7gbuB+4J7gruC+4M7g3uD+4Q7hHuEu4T7o/y6hHpEegR5xHlEeQR4xHiEeER3xHeEd0R3BHbEdkRg/se7h/uIO4h7iPuJO4l7ibuJ+4p7iruK+4s7i7uo/LQEc8RzhHNEcsRyhHJEcgRxhHFEcQRwxHCEcARvxGK+zjuOe467jzuPe4+7j/uQO5C7kPuRO5F7kbuSO638rYRtRG0EbIRsRGwEa8RrhGsEasRqhGpEagRphGlEZD7Uu5T7lXuVu5X7ljuWe5b7lzuXe5e7l/uYe5i7srynBGbEZoRmBGXEZYRlRGUEZIRkRGQEY8RjRGMEYsRl/ts7m3ub+5w7nHucu5z7nXudu537njuee577nzu3vKCEYERfxF+EX0RfBF7EXkReBF3EXYRdRFzEXIRcRGd+4buiO6J7orui+6M7o7uj+6Q7pHuku6U7pXulu7x8mgRZxFlEWQRYxFiEWERXxFeEV0RXBFbEVkRWBFXEaT7oe6i7qPupO6l7qfuqO6p7qruq+6t7q7ur+6w7gXzThFMEUsRShFJEUgRRhFFEUQRQxFCEUARPxE+ET0Rqvu77rzuve6+7r/uwe7C7sPuxO7F7sfuyO7J7sruGfMzETIRMREwES8RLhEsESsRKhEpESgRJhElESQRIxGx+9Xu1u7X7tju2u7b7tzu3e7e7uDu4e7i7uPu5O4s8xkRGBEXERYRFRETERIREREQEQ8RDREMEQsRChEJEbf77+7w7vHu8+707vXu9u737vju+u777vzu/e7+7kDz/xD+EP0Q/BD7EPkQ+BD3EPYQ9RDzEPIQ8RDwEO8QvvsJ7wrvC+8N7w7vD+8Q7xHvE+8U7xXvFu8X7xnvU/PlEOQQ4xDiEOAQ3xDeEN0Q3BDaENkQ2BDXENYQ1RDF+yPvJO8m7yfvKO8p7yrvLO8t7y7vL+8w7zHvM+9n88sQyhDJEMcQxhDFEMQQwxDCEMAQvxC+EL0QvBC6EMv7Pe8/70DvQe9C70PvRO9G70fvSO9J70rvTO9N73rzsRCwEK8QrRCsEKsQqhCpEKcQphClEKQQoxCiEKAQ0vtY71nvWu9b71zvXe9f72DvYe9i72PvZe9m72fvjvOXEJYQlBCTEJIQkRCQEI8QjRCMEIsQihCJEIcQhhDY+3Lvc+9073Xvdu9473nveu9773zvfe9/74Dvge+i830QfBB6EHkQeBB3EHYQdBBzEHIQcRBwEG8QbRBsEN/7jO+N747vj++R75Lvk++U75Xvlu+Y75nvmu+b77XzYxBhEGAQXxBeEF0QXBBaEFkQWBBXEFYQVBBTEFIQ5fum76fvqO+p76vvrO+t767vr++x77Lvs++077XvyfNIEEcQRhBFEEQQQxBBEEAQPxA+ED0QPBA6EDkQOBDs+8Dvwe/C78Tvxe/G78fvyO/J78vvzO/N787vz+/c8y4QLRAsECsQKhApECcQJhAlECQQIxAhECAQHxAeEPP72u/b793v3u/f7+Dv4e/i7+Tv5e/m7+fv6O/p7/DzFBATEBIQERAQEA4QDRAMEAsQChAJEAcQBhAFEAQQ+fv07/bv9+/47/nv+u/77/3v/u//7wDwAfAC8ATwBPT6D/kP+A/3D/UP9A/zD/IP8Q/wD+4P7Q/sD+sP6g8A/A/wEPAR8BLwE/AU8BbwF/AY8BnwGvAb8B3wHvAX9OAP3w/eD90P2w/aD9kP2A/XD9YP1A/TD9IP0Q/QDwb8KfAq8CvwLPAt8C7wMPAx8DLwM/A08DXwN/A48Cv0xg/FD8QPwg/BD8APvw++D70Puw+6D7kPuA+3D7YPDfxD8ETwRfBG8EfwSfBK8EvwTPBN8E7wUPBR8FLwPvSsD6sPqQ+oD6cPpg+lD6QPow+hD6APnw+eD50PnA8T/F3wXvBf8GDwYvBj8GTwZfBm8GfwafBq8GvwbPBS9JIPkQ+PD44PjQ+MD4sPig+ID4cPhg+FD4QPgw+BDxr8d/B48Hnwe/B88H3wfvB/8IDwgvCD8ITwhfCG8GX0eA92D3UPdA9zD3IPcQ9vD24PbQ9sD2sPag9pD2cPIPyR8JLwlPCV8Jbwl/CY8JnwmvCc8J3wnvCf8KDwefRdD1wPWw9aD1kPWA9XD1UPVA9TD1IPUQ9QD04PTQ8n/KvwrfCu8K/wsPCx8LLws/C18Lbwt/C48LnwuvCN9EMPQg9BD0APPw8+DzwPOw86DzkPOA83DzYPNA8zDy78xfDH8MjwyfDK8MvwzPDO8M/w0PDR8NLw0/DV8KD0KQ8oDycPJg8lDyQPIg8hDyAPHw8eDx0PGw8aDxkPNPzg8OHw4vDj8OTw5fDn8Ojw6fDq8Ovw7PDt8O/wtPQPDw4PDQ8MDwsPCQ8IDwcPBg8FDwQPAw8BDwAP/w47/Prw+/D88P3w/vAA8QHxAvED8QTxBfEG8QjxCfHH9PUO9A7zDvIO8A7vDu4O7Q7sDusO6g7oDucO5g7lDkH8FPEV8RbxF/EZ8RrxG/Ec8R3xHvEf8SHxIvEj8dv02w7aDtkO1w7WDtUO1A7TDtIO0Q7PDs4OzQ7MDssOSPwu8S/xMPEy8TPxNPE18TbxN/E48TrxO/E88T3x7/TBDsAOvw69DrwOuw66DrkOuA63DrUOtA6zDrIOsQ5O/EjxSfFK8UzxTfFO8U/xUPFR8VPxVPFV8VbxV/EC9acOpg6kDqMOog6hDqAOnw6eDpwOmw6aDpkOmA6XDlX8YvFj8WXxZvFn8WjxafFq8WvxbfFu8W/xcPFx8Rb1jQ6LDooOiQ6IDocOhg6FDoMOgg6BDoAOfw5+Dn0OW/x88X7xf/GA8YHxgvGD8YTxhvGH8YjxifGK8YvxKfVyDnEOcA5vDm4ObQ5sDmsOaQ5oDmcOZg5lDmQOYw5i/JfxmPGZ8Zrxm/Gc8Z3xn/Gg8aHxovGj8aTxpfE99VgOVw5WDlUOVA5TDlIOUA5PDk4OTQ5MDksOSg5IDmn8sfGy8bPxtPG18bbxuPG58brxu/G88b3xvvHA8VD1Pg49DjwOOw46DjkONw42DjUONA4zDjIOMQ4wDi4Ob/zL8czxzfHO8c/x0fHS8dPx1PHV8dbx1/HZ8drxZPUkDiMOIg4hDiAOHg4dDhwOGw4aDhkOGA4XDhUOFA52/OXx5vHn8ejx6vHr8ezx7fHu8e/x8PHy8fPx9PF49QoOCQ4IDgcOBg4EDgMOAg4BDgAO/w3+DfwN+w36DXz8//EA8gHyA/IE8gXyBvIH8gjyCfIK8gzyDfIO8ov18A3vDe4N7Q3rDeoN6Q3oDecN5g3lDeQN4g3hDeANg/wZ8hryHPId8h7yH/Ig8iHyIvIj8iXyJvIn8ijyn/XWDdUN1A3SDdEN0A3PDc4NzQ3MDcsNyQ3IDccNxg2J/DPyNfI28jfyOPI58jryO/I88j7yP/JA8kHyQvKy9bwNuw25DbgNtw22DbUNtA2zDbINsA2vDa4NrQ2sDZD8TvJP8lDyUfJS8lPyVPJV8lfyWPJZ8lryW/Jc8sb1og2gDZ8Nng2dDZwNmw2aDZkNmA2WDZUNlA2TDZINl/xo8mnyavJr8mzybfJu8nDycfJy8nPydPJ18nby2vWHDYYNhQ2EDYMNgg2BDYANfw19DXwNew16DXkNeA2d/ILyg/KE8oXyhvKI8onyivKL8ozyjfKO8o/ykPLt9W0NbA1rDWoNaQ1oDWcNZg1kDWMNYg1hDWANXw1eDaT8nPKd8p7yn/Kh8qLyo/Kk8qXypvKn8qjyqfKr8gH2Uw1SDVENUA1PDU4NTQ1LDUoNSQ1IDUcNRg1FDUQNqvy28rfyuPK68rvyvPK98r7yv/LA8sHywvLE8sXyFPY5DTgNNw02DTUNNA0yDTENMA0vDS4NLQ0sDSsNKg2x/NDy0fLT8tTy1fLW8tfy2PLZ8try2/Ld8t7y3/Io9h8NHg0dDRwNGw0ZDRgNFw0WDRUNFA0TDRINEQ0QDbf86vLs8u3y7vLv8vDy8fLy8vPy9PL28vfy+PL58jv2BQ0EDQMNAg0BDf8M/gz9DPwM+wz6DPkM+Az3DPUMvvwF8wbzB/MI8wnzCvML8wzzDfMP8xDzEfMS8xPzT/brDOoM6QzoDOYM5QzkDOMM4gzhDOAM3wzeDNwM2wzE/B/zIPMh8yLzI/Mk8yXzJ/Mo8ynzKvMr8yzzLfNj9tEM0AzPDM0MzAzLDMoMyQzIDMcMxgzFDMMMwgzBDMv8OfM68zvzPPM98z7zQPNB80LzQ/NE80XzRvNH83b2twy2DLQMswyyDLEMsAyvDK4MrQysDKoMqQyoDKcM0vxT81TzVfNW81fzWfNa81vzXPNd817zX/Ng82HzivacDJsMmgyZDJgMlwyWDJUMlAyTDJEMkAyPDI4MjQzY/G3zbvNv83DzcvNz83TzdfN283fzePN583rze/Od9oIMgQyADH8Mfgx9DHwMewx6DHgMdwx2DHUMdAxzDN/8h/OI84rzi/OM843zjvOP85DzkfOS85PzlfOW87H2aAxnDGYMZQxkDGMMYgxhDGAMXgxdDFwMWwxaDFkM5fyh86PzpPOl86bzp/Oo86nzqvOr86zzrvOv87DzxfZODE0MTAxLDEoMSQxIDEcMRQxEDEMMQgxBDEAMPwzs/LzzvfO+87/zwPPB88Lzw/PE88Xzx/PI88nzyvPY9jQMMwwyDDEMMAwvDC0MLAwrDCoMKQwoDCcMJgwlDPL81vPX89jz2fPa89vz3PPd897z4PPh8+Lz4/Pk8+z2GgwZDBgMFwwWDBQMEwwSDBEMEAwPDA4MDQwMDAsM+fzw8/Hz8vPz8/Tz9fP28/jz+fP68/vz/PP98/7z//YADP8L/gv9C/sL+gv5C/gL9wv2C/UL9AvzC/IL8Qv//Ar0C/QM9A30DvQP9BH0EvQT9BT0FfQW9Bf0GPQT9+YL5QvkC+IL4QvgC98L3gvdC9wL2wvaC9kL2AvXCwb9JPQl9Cb0J/Qp9Cr0K/Qs9C30LvQv9DD0MfQy9Cf3zAvLC8kLyAvHC8YLxQvEC8MLwgvBC8ALvwu+C7wLDf0+9D/0QPRC9EP0RPRF9Eb0R/RI9En0SvRL9Ez0OvexC7ALrwuuC60LrAurC6oLqQuoC6cLpgulC6MLogsT/Vj0WvRb9Fz0XfRe9F/0YPRh9GL0Y/Rk9GX0Z/RO95cLlguVC5QLkwuSC5ELkAuPC44LjQuMC4oLiQuICxr9c/R09HX0dvR39Hj0efR69Hv0fPR99H70gPSB9GH3fQt8C3sLegt5C3gLdwt2C3ULdAtzC3ELcAtvC24LIP2N9I70j/SQ9JH0kvST9JT0lfSW9Jj0mfSa9Jv0dfdjC2ILYQtgC18LXgtdC1wLWwtZC1gLVwtWC1ULVAsn/af0qPSp9Kr0q/Ss9K30rvSv9LH0svSz9LT0tfSI90kLSAtHC0YLRQtEC0MLQgtACz8LPgs9CzwLOws6Cy39wfTC9MP0xPTF9Mb0x/TJ9Mr0y/TM9M30zvTP9Jz3LwsuCy0LLAsrCyoLKQsnCyYLJQskCyMLIgshCyALNP3b9Nz03fTe9N/04fTi9OP05PTl9Ob05/To9On0sPcVCxQLEwsSCxELDwsOCw0LDAsLCwoLCQsICwcLBgs7/fX09vT39Pn0+vT79Pz0/fT+9P/0APUB9QL1A/XD9/sK+gr5CvgK9gr1CvQK8wryCvEK8ArvCu4K7QrsCkH9D/UR9RL1E/UU9RX1FvUX9Rj1GfUa9Rv1HPUd9df34QrgCt4K3QrcCtsK2grZCtgK1wrWCtUK1ArTCtIKSP0q9Sv1LPUt9S71L/Uw9TH1MvUz9TT1NfU29Tf16vfGCsUKxArDCsIKwQrACr8Kvgq9CrwKuwq6CrkKuApO/UT1RfVG9Uf1SPVJ9Ur1S/VM9U31TvVP9VD1UvX+96wKqwqqCqkKqAqnCqYKpQqkCqMKogqhCqAKnwqeClX9XvVf9WD1YfVi9WP1ZPVl9Wb1Z/Vo9Wr1a/Vs9RL4kgqRCpAKjwqOCo0KjAqLCooKiQqICocKhgqFCoMKW/149Xn1evV79Xz1ffV+9X/1gPWC9YP1hPWF9Yb1Jfh4CncKdgp1CnQKcwpyCnEKcApvCm4KbQprCmoKaQpi/ZL1k/WU9ZX1lvWX9Zn1mvWb9Zz1nfWe9Z/1oPU5+F4KXQpcClsKWgpZClgKVwpWClUKVApSClEKUApPCmj9rPWt9a71r/Wx9bL1s/W09bX1tvW39bj1ufW69Uz4RApDCkIKQQpACj8KPgo9CjwKOgo5CjgKNwo2CjUKb/3G9cf1yfXK9cv1zPXN9c71z/XQ9dH10vXT9dT1YPgqCikKKAonCiYKJQokCiIKIQogCh8KHgodChwKGwp2/eH14vXj9eT15fXm9ef16PXp9er16/Xs9e317vVz+BAKDwoOCg0KDAoKCgkKCAoHCgYKBQoECgMKAgoBCnz9+/X89f31/vX/9QD2AfYC9gP2BPYF9gb2B/YI9of49gn1CfQJ8gnxCfAJ7wnuCe0J7AnrCeoJ6QnoCecJg/0V9hb2F/YY9hn2GvYb9hz2HfYe9h/2IPYh9iL2m/jbCdoJ2QnYCdcJ1gnVCdQJ0wnSCdEJ0AnPCc4JzQmJ/S/2MPYx9jL2M/Y09jX2NvY39jj2OfY69jz2Pfau+MEJwAm/Cb4JvQm8CbsJugm5CbgJtwm2CbUJtAmzCZD9SfZK9kv2TPZN9k72T/ZQ9lH2U/ZU9lX2VvZX9sL4pwmmCaUJpAmjCaIJoQmgCZ8JngmdCZwJmwmaCZkJlv1j9mT2ZfZm9mf2aPZq9mv2bPZt9m72b/Zw9nH21fiNCYwJiwmKCYkJiAmHCYYJhQmECYMJggmBCYAJfwmd/X32fvaA9oH2gvaD9oT2hfaG9of2iPaJ9or2i/bp+HMJcglxCXAJbwluCW0JbAlrCWoJaQloCWcJZgllCaP9mPaZ9pr2m/ac9p32nvaf9qD2ofai9qP2pPal9v34WQlYCVcJVglVCVQJUwlSCVEJUAlPCU4JTQlMCUoJqv2y9rP2tPa19rb2t/a49rn2uva79rz2vfa+9r/2EPk/CT4JPQk8CTsJOgk5CTgJNwk2CTUJMwkyCTEJMAmx/cz2zfbO9s/20PbR9tL20/bU9tX21vbX9tj22fYk+SUJJAkjCSIJIQkgCR8JHgkcCRsJGgkZCRgJFwkWCbf95vbn9uj26fbq9uv27Pbt9u727/bw9vH28vbz9jf5CwkKCQkJCAkHCQUJBAkDCQIJAQkACf8I/gj9CPwIvv0A9wH3AvcD9wT3BfcG9wf3CPcJ9wr3C/cM9w33S/nwCO8I7gjtCOwI6wjqCOkI6AjnCOYI5QjkCOMI4gjE/Rr3G/cc9x33Hvcf9yD3Ifci9yT3Jfcm9yf3KPde+dYI1QjUCNMI0gjRCNAIzwjOCM0IzAjLCMoIyQjICMv9NPc19zb3OPc59zr3O/c89z33Pvc/90D3QfdC93L5vAi7CLoIuQi4CLcItgi1CLQIswiyCLEIsAivCK4I0f1P91D3UfdS91P3VPdV91b3V/dY91n3Wvdb91z3hvmiCKEIoAifCJ4InQicCJsImgiZCJgIlwiWCJUIlAjY/Wn3avdr92z3bfdu92/3cPdx93L3c/d093X3dveZ+YgIhwiGCIUIhAiDCIIIgQiACH8Ifgh9CHwIewh6CN79g/eE94X3hveH94j3ifeK94v3jPeN9473j/eQ9635bghtCGwIawhqCGkIaAhnCGYIZQhkCGMIYghhCGAI5f2d9573n/eg96H3ovej96T3pfem96f3qPep96r3wPlUCFMIUghRCFAITwhOCE0ITAhLCEoISQhICEcIRgjs/bf3uPe597r3u/e89733vve/98D3wffC98P3xPfU+ToIOQg4CDcINgg1CDQIMwgyCDEIMAgvCC4ILQgsCPL90ffS99P31PfV99b31/fY99n32vfb99z33ffe9+j5IAgfCB4IHQgcCBsIGggZCBgIFwgWCBUIFAgTCBII+f3r9+z37ffu9+/38Pfx9/L38/f09/b39/f49/n3+/kGCAQIAwgCCAEIAAj/B/4H/Qf8B/sH+gf5B/gH9wf//Qb4B/gI+An4CvgL+Az4DfgO+A/4EPgR+BL4E/gP+usH6gfpB+gH5wfmB+UH5AfjB+IH4QfgB98H3gfdBwb+IPgh+CL4I/gk+CX4Jvgn+Cj4Kfgq+Cv4LPgt+CL60QfQB88HzgfNB8wHywfKB8kHyAfHB8YHxQfEB8MHDP46+Dv4PPg9+D74P/hA+EH4QvhD+ET4RfhG+Ef4Nvq3B7YHtQe0B7MHsgexB7AHrweuB60HrAerB6oHqQcT/lT4VfhW+Ff4WPhZ+Fr4W/hc+F34Xvhf+GD4YfhJ+p0HnAebB5oHmQeYB5cHlgeVB5QHkweSB5EHkAePBxr+bvhv+HD4cfhy+HP4dPh1+Hb4d/h4+Hn4evh7+F36gweCB4EHgAd/B34HfQd8B3sHegd5B3gHdwd2B3UHIP6I+In4iviL+Iz4jfiO+I/4kPiR+JL4k/iU+JX4cfppB2gHZwdmB2UHZAdjB2IHYQdgB18HXgddB1wHWwcn/qL4o/ik+KX4pvin+Kj4qfiq+Kv4rPit+K74r/iE+k8HTgdNB0wHSwdKB0kHSAdHB0YHRQdEB0MHQgdBBy3+vfi++L/4wPjB+ML4w/jD+MT4xfjG+Mf4yPjJ+Jj6NQc0BzMHMgcxBzAHLwcuBy0HLAcrByoHKQcoBycHNP7X+Nj42fja+Nv43Pjd+N743/jg+OH44vjj+OT4q/obBxoHGQcYBxcHFgcVBxQHEwcSBxEHEAcPBw4HDQc6/vH48vjz+PT49fj2+Pf4+Pj5+Pr4+/j8+P34/vi/+gAH/wb+Bv0G/Ab7BvoG+Qb5BvgG9wb2BvUG9AbzBkH+C/kM+Q35DvkP+RD5EfkS+RP5FPkV+Rb5F/kY+dP65gblBuQG4wbiBuEG4AbfBt4G3QbcBtsG2gbaBtkGR/4l+Sb5J/ko+Sn5Kvkr+Sz5Lfku+S/5MPkx+TL55vrMBssGygbJBsgGxwbGBsUGxAbDBsIGwQbABr8GvgZO/j/5QPlB+UL5Q/lE+UX5RvlH+Uj5SflK+Uv5TPn6+rIGsQawBq8GrgatBqwGqwaqBqkGqAanBqYGpQakBlX+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MwIzAjICMQIwAi8CLgItAiwCKwIrAioCKQJ1/9j92f3Z/dr92/3c/d393v3f/eD94f3h/eL94/1r/hsCGgIZAhgCGAIXAhYCFQIUAhMCEgIRAhACEAIPAnz/8v3z/fT99P31/fb99/34/fn9+v37/fz9/P39/X/+AQIAAv8B/gH9Af0B/AH7AfoB+QH4AfcB9gH1AfUBgv8M/g3+Dv4P/g/+EP4R/hL+E/4U/hX+Fv4X/hf+kv7nAeYB5QHkAeMB4gHiAeEB4AHfAd4B3QHcAdsB2wGJ/yb+J/4o/in+Kv4q/iv+LP4t/i7+L/4w/jH+Mv6m/s0BzAHLAcoByQHIAccBxwHGAcUBxAHDAcIBwQHAAY//QP5B/kL+Q/5E/kX+Rf5G/kf+SP5J/kr+S/5M/rn+swGyAbEBsAGvAa4BrQGsAawBqwGqAakBqAGnAaYBlv9a/lv+XP5d/l7+X/5g/mD+Yf5i/mP+ZP5l/mb+zf6ZAZgBlwGWAZUBlAGTAZIBkgGRAZABjwGOAY0BjAGd/3T+df52/nf+eP55/nr+e/57/nz+ff5+/n/+gP7h/n4BfgF9AXwBewF6AXkBeAF3AXcBdgF1AXQBcwFyAaP/j/6Q/pD+kf6S/pP+lP6V/pb+lv6X/pj+mf6a/vT+ZAFjAWMBYgFhAWABXwFeAV0BXAFcAVsBWgFZAVgBqv+p/qr+q/6r/qz+rf6u/q/+sP6x/rH+sv6z/rT+CP9KAUkBSAFIAUcBRgFFAUQBQwFCAUEBQQFAAT8BPgGw/8P+xP7F/sb+xv7H/sj+yf7K/sv+zP7M/s3+zv4b/zABLwEuAS0BLQEsASsBKgEpASgBJwEnASYBJQEkAbf/3f7e/t/+4P7h/uH+4v7j/uT+5f7m/uf+5/7o/i//FgEVARQBEwESARIBEQEQAQ8BDgENAQwBDAELAQoBvf/3/vj++f76/vv+/P78/v3+/v7//gD/Af8C/wL/Qv/8APsA+gD5APgA+AD3APYA9QD0APMA8gDyAPEA8ADE/xH/Ev8T/xT/Ff8W/xf/F/8Y/xn/Gv8b/xz/Hf9W/+IA4QDgAN8A3gDdAN0A3ADbANoA2QDYANcA1wDWAMr/K/8s/y3/Lv8v/zD/Mf8y/zL/M/80/zX/Nv83/2r/yADHAMYAxQDEAMMAwgDCAMEAwAC/AL4AvQC8ALwA0f9G/0b/R/9I/0n/Sv9L/0z/TP9N/07/T/9Q/1H/ff+uAK0ArACrAKoAqQCoAKgApwCmAKUApACjAKIAogDY/2D/Yf9h/2L/Y/9k/2X/Zv9n/2f/aP9p/2r/a/+R/5MAkwCSAJEAkACPAI4AjQCNAIwAiwCKAIkAiACHAN7/ev97/3z/fP99/37/f/+A/4H/gv+C/4P/hP+F/6T/eQB4AHgAdwB2AHUAdABzAHIAcgBxAHAAbwBuAG0A5f+U/5X/lv+X/5f/mP+Z/5r/m/+c/53/nf+e/5//uP9fAF4AXQBdAFwAWwBaAFkAWABYAFcAVgBVAFQAUwDr/67/r/+w/7H/sv+y/7P/tP+1/7b/t/+4/7j/uf/M/0UARABDAEMAQgBBAEAAPwA+AD0APQA8ADsAOgA5APL/yP/J/8r/y//M/83/zf/O/8//0P/R/9L/0//T/9//KwAqACkAKAAoACcAJgAlACQAIwAjACIAIQAgAB8A+P/i/+P/5P/l/+b/5//o/+j/6f/q/+v/7P/t/+3/8/8RABAADwAOAA0ADQAMAAsACgAJAAgACAAHAAYABQD///3//f/+////AAAAAA"},{ name : "R_sfx_door_wav", data : "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WwBWAFUAVABTAFMAUgBRAFAATwBOAE4ATQBMAEwASwBKAEoASQBIAEgASQBJAEoASwBLAEwATABNAE4AUgBXAFsAYABlAGkAbgByAHcAegB8AH0AfwCBAIIAhACGAIcAiQCKAIsAjACNAI4AjwCQAJEAkwCPAIgAggFtAVgBQwEuARoBBQH0APoAAAEFAQsBEQEWARwBIgEoASABFAEIAfsA7wDjANYAygC+ALcAvwDHAM4A1gDeAOYA7gD1AP0ABAELAREBGAEeASUBLAEyATkBOwE3ATMBLgEqASUBIQEdARgBFAEbASMBKwEzATsBQwFKAVIBWgFbAVUBTwFIAUIBOwE1AS4BKAEiAS4BOgFGAVIBXgFqAXYBggGOAYgBdAFgAU0BOQElARIB/gDrANkA1gDTANAAzQDKAMcAmP+Z/5v/m/+b/5r/mv+Z/5n/mP+Y/5f/lv+P/4n/gv98/3X/b/9o/2L/XP9X/1T/UP9M/0j/Rf9B/z3/Of85/0D/Rv9M/1P/Wf9g/2b/bf9z/2//af9k/17/Wf9T/07/SP9D/0H/Rv9K/0//U/9Y/1z/YP9l/2n/b/92/3z/gv+I/47/lP+a/6H/n/+X/4//h/9//3f/b/9n/1//Wf9i/2r/c/98/4X/jv+X/5//qP+k/5j/jf+B/3b/av9e/1P/R/8//0b/p/+q/67/sf+0/7j/u/+//77/u/+4/7b/s/+w/67/q/+o/6b/pv+m/6b/pv+m/6b/pv+m/6b/qP+q/6z/rv+w/7L/tP+2/7j/uf+4/7f/t/+2/7b/tf+1/7T/tP+y/6//rf+r/6n/p/+l/6P/oP+h/6T/p/+r/67/sf+0/7f/uv+9/7r/tv+z/6//rP+o/6X/of+e/5//ov+m/6r/rf+x/7X/uf+8/7//vP+5/7b/s/+x/67/q/+o/6X/pf+n/6n/q/+s/67/sP/yAuEC1wLiAu0C+AIDAw4DGQMkAy8DOQMfA/oC1gKyAo4CagJGAiIC/gH2ASUCVAKCArAC3wINAzsDaQOXA4YDbwNXA0ADKAMRA/kC4gLLAskC5AL+AhgDMwNNA2cDgQObA7UDdgM3A/gCuQJ7AjwC/gG/AYEBdwGXAbgB2AH4ARgCOAJYAngCkgJ4Al4CRAIqAhAC9gHcAcIBqAHBAfUBKAJcAo8CwgL2AikDXAN+A1sDOQMXA/UC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x//E/8L/w//E/8X/xv/H/8j/yv/L/8z/y//K/8n/x//G/8X/w//C/8H/wP8GAAYABgAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABAAEAAQABAAEAAUABQAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQAAwADAAMAAwADAAQABAAFAAUABgAGAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAYABgAGAAUABQAFAAQABAAEAAQABAAFAAUABQAGAAYABgAHAAcABwAHAAcABwAHAAcABwAHABEAEAAPAA4ADQAMAAsACgAJAAgACQAJAAoACwAMAA0ADgAPAA8AEAAPAA8ADgANAA0ADAAMAAsACwALAAwADAANAA0ADgAPAA8AEAAQABAADwAPAA4ADgAOAA0ADQANAA0ADgAOAA4ADwAPABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAADwAPAA4ADQANAAwADAALAAoACgAKAAkACQAJAAkACAAIAAgACAAIAAkACgAKAAsACwAMAAwADQANAAwACwALAAoACQAJAAgAIgAhACQAJwAqAC0AMAAzADYAOQA8AD0APgA/AD8AQABBAEIAQwBDAEMAQAA+ADsAOAA2ADMAMQAuACwALAAsACwAKwArACsAKwArACsAKwApACgAJwAmACQAIwAiACEAIAAjACYAKgAtADAAMwA2ADoAPQA+AD0APAA7ADsAOgA5ADkAOAA3ADYANgA1ADQAMwAzADIAMQAwADAAMQAxADEAMQAyADIAMgAzADIALwAtACoAKAAlACMAIAAeABsAGwAcAB0AHQAeAB8AHwAgAOH/4f/g/9//3v/d/9z/2//a/9n/2P/Z/9r/2//c/93/3f/e/9//4P/g/97/3P/b/9n/2P/W/9X/0//R/8//zf/L/8n/x//F/8P/wf+//7//v/+//7//v//A/8D/wP/A/8H/wv/D/8T/xf/G/8j/yf/K/8v/y//L/8r/yv/K/8n/yf/J/8j/yP/H/8b/xf/E/8P/wf/A/7//vv/B/8X/yf/N/9H/1f/Z/93/4f/j/9//2//X/9P/z//M/8j/xP/A/8P/yP/M/9D/1f/Z/93/4f8AAAAAAAD//////////////////////////////////////////wAAAAAAAP//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////AAAAAAAAAAAAAAAAAADQ/87/y//J/8b/xP/B/7//vP+6/7j/t/+2/7X/tP+z/7L/sP+v/7D/s/+1/7j/uv+8/7//wf/E/8b/x//I/8n/yv/L/8v/zP/N/87/zv/O/87/zv/O/87/zf/N/83/y//F/77/t/+x/6r/o/+d/5b/kP+T/5n/n/+k/6r/sP+2/7v/wf/E/8P/wv/B/8D/v/++/73/vP+7/7j/tf+x/67/q/+o/6T/of+e/57/of+k/6f/qv+t/7H/tP+3/7r/tv+y/67/qf+l/6H/nf+Z/5X/l//3//j/+f/5//r/+//7//z//P/8//z/+//7//v/+v/6//n/+f/5//n/+v/6//r/+v/6//v/+//7//v/+//7//v/+v/6//r/+v/6//r/+v/5//n/+f/5//n/+P/4//j/+f/5//r/+v/6//v/+//8//z//P/8//z//P/8//v/+//7//v/+//7//r/+v/6//n/+f/5//n/+P/5//n/+f/6//r/+v/7//v/+//7//v/+//7//r/+v/6//r/+f/5//r/+v/6//r/+//7//v/+//8//v/+/8TABQAFQAWABcAGAAZABoAGwAcABwAHQAeAB8AIAAhACEAIAAeABwAGwAZABcAFQATABEAEAASABMAFQAWABcAGQAaABwAHQAdAB0AHAAcABsAGwAbABoAGgAZABkAGAAXABcAFgAVABUAFAATABMAEgARABEAEAAPAA4ADgANAA0ADwARABMAFAAWABgAGgAbAB0AGwAaABgAFwAWABQAEwARABAAEAARABIAFAAVABYAFwAYABoAGwAbABsAHAAcABwAHAAdAB0AHQAcABsAGgBEAEAAPQA5ADUAMgAwADMANgA5AD0AQABDAEYASQBNAE4ATwBRAFIAUwBUAFUAVgBXAFcAVgBUAFIAUABOAEwASgBIAEcARwBHAEgASABIAEkASQBKAEoASgBIAEYARQBDAEIAQAA+AD0AOwA9AD4APwBBAEIARABFAEcASABJAEgASABHAEcARwBGAEYARgBFAEUARQBGAEYARgBGAEYARgBGAEQAQAA9ADkANQAyAC4AKgAnACQAJwAqAC0AMAAzADYAOQA8AD8AQQBCAEQARQBHADcAOAA5ADsAOgA3ADQAMAAtACkAJgAjAB8AHAAfACMAJgAqAC4AMgA2ADoAPQA+ADsANwA0ADEALQAqACYAIwAfACIAJQApACwALwAyADUAOAA8AD0APAA8ADsAOwA6ADkAOQA4ADgANwA1ADQAMwAyADEAMAAuAC0AKwApACcAJAAiACAAHgAbABkAGAAaAB0AHwAiACQAJwApACwALgAtACsAKQAmACQAIgAfAB0AGwAZABsAHQAfACEAIgAkACYAKAAqACkAKAAmACUAJAAiACEAIADc/9v/2P/U/9H/zf/K/8b/w/+//7z/vv/C/8X/yP/M/8//0v/V/9n/2f/W/9L/z//M/8j/xf/C/7//u/++/8H/xP/H/8r/zf/Q/9P/1v/X/9f/1//X/9f/1//X/9f/2P/X/9X/0v/P/8z/yv/H/8T/wv+//8D/w//F/8j/y//O/9H/0//W/9n/2v/c/93/3//h/+L/5P/l/+f/5//l/+T/4//i/+H/4P/f/97/3f/d/93/3f/e/97/3v/e/97/3v/e/97/3//f/9//4P/g/+D/4f/h/9r/2v/Z/9n/2P/Y/9f/1//W/9X/1P/T/9L/0f/Q/8//zv/N/83/zf/N/83/zv/O/87/zv/O/8//0f/T/9b/2P/a/93/3//h/+T/4//i/+D/3//d/9v/2v/Y/9f/1f/T/9D/zv/L/8n/xv/E/8L/v/++/73/vP+8/7v/uv+5/7n/uP+4/7r/vP++/8D/w//F/8f/yf/L/8r/yP/H/8X/xP/C/8H/v/++/77/wv/G/8v/z//T/9f/2//f/+P/5P/k/+T/5P/l/+X/5f/m/+b/5v/l/+X/5f/v/+//7v/u/+7/7v/u/+7/7v/u/+7/7v/u/+//7//t/+v/6f/m/+T/4v/g/93/2//Z/9r/3P/d/97/4P/h/+L/4//l/+X/5f/l/+X/5f/l/+X/5f/l/+X/5v/m/+f/5//o/+n/6f/q/+r/6v/q/+r/6v/q/+v/6//r/+v/6//r/+v/7P/s/+z/7f/t/+3/7v/u/+7/7v/u/+7/7//v/+//7//u/+z/6v/o/+f/5f/j/+H/3//d/93/3f/d/93/3f/d/93/3f/d/93/3v/f/9//4P/g/+H/4f8UABMAEgARABAADwAOAA0ADAALAAoACwALAAwADAANAA4ADgAPABAAEAARABIAEwATABQAFQAWABYAFwAWABUAFAASABEAEAAPAA0ADAALAAwADAANAA0ADgAOAA8ADwAQABAAEQASABIAEwAUABQAFQAWABYAFQAUABMAEwASABEAEAAQAA8ADgAOAA0ADQAMAAwACwALAAoACgALAAsADAAMAA0ADQAOAA4ADgAPAA8AEAAQABEAEQASABIAEwATABQAFAAVABUAFgAWABcAFwAYABcAFwAVABUAFAAUABQAEwATABMAEwATABMAEwATABMAEwATABMAEwASABIAEQARABEAEAAQAA8AEAAQABEAEQASABIAEgATABMAEwASABIAEQAQAA8ADgANAAwACwALAAsACwALAAsACwALAAsACwAMAAwADQAOAA4ADwAQABAAEQASABEAEQARABEAEAAQABAAEAAPAA8AEAAQABAAEAAQABAAEQARABEAEAAPAA4ADgANAAwACwALAAoACgALAAwADQAPABAAEQASABMAEwASABEAEAAPAA4ADQAcABoAFwAYABsAHQAfACIAJAAmACkAKwAsACsAKgApACgAJwAmACQAIwAiACMAJAAmACcAKAApACsALAAtAC0ALAAqACgAJwAmACQAIwAhACAAHgAdABwAGgAZABgAFwAVABQAFQAXABkAGwAdAB8AIQAjACYAJwAlACMAIQAfABwAGgAYABYAFAATABMAEwAUABQAFAAUABQAFAAUABUAFgAXABgAGQAaABoAGwAcABwAHQAdAB0AHgAeAB4AHgAfAB8AIAAhACIAIwAkACYAJwAoACkAKAAmANb/2P/a/9z/3v/f/+H/4v/h/+H/4P/f/97/3v/d/9z/2//c/9z/3f/d/93/3v/e/9//3//f/9//3v/e/93/3f/c/9z/3P/b/9z/3P/c/93/3f/e/97/3v/f/9//3v/d/9z/3P/b/9r/2v/Z/9j/2f/a/9v/3P/d/97/3//g/+H/4P/f/93/3P/a/9n/1//W/9T/0//V/9b/1//Y/9n/2v/b/9z/3f/d/97/3//f/+D/4f/h/+L/4//k/+X/5v/n/+j/6f/q/+v/7P/u/+7/7v/u/+7/7v/u/+7/BwAHAAgACAAJAAoACgALAAwADAANAA4ADgAOAA4ADwAPAA8AEAAQABAAEAAPAA8ADgAOAA0ADAAMAAsACwALAAwADQANAA4ADwAPABAAEQARABEAEAAQABAAEAAQABAADwAPAA8ADgANAA0ADAAMAAsACgAKAAkACQAJAAkACQAIAAgACAAIAAcABwAHAAcABwAHAAcABgAGAAYABgAHAAcABwAIAAgACQAJAAkACQAJAAkACQAIAAgACAAHAAcABwAHAAcABwAHAAcABwAHAAcABwAIAAkACQDt/+v/6v/p/+f/5v/l/+X/5v/n/+j/6f/p/+r/6//s/+z/7P/t/+3/7f/t/+7/7v/u/+//7//v//D/8P/w//H/8f/x//L/8v/y//L/8v/y//L/8v/z//P/8//z//L/8v/y//L/8v/y//L/8v/y//L/8v/y//P/8//z//P/8//z//P/8v/y//H/8f/x//D/8P/w/+//7//v/+//7//v/+//7//v/+//8P/x//H/8v/z//P/9P/0//X/9P/z//H/8P/v/+7/7f/s/+v/6//s/+7/7//w//H/8v/0//X/9f/1//X/9f/1//X/9f/1//X/9f/0//P/8v/x//D/7//v/+7/7f/s/+z/7f/t/+3/7f/u/+7/7v/u/+//8P/w//H/8v/z//P/9P/1//X/9P/z//L/8f/w//D/7//u/+3/7f/u/+//8P/x//L/8//0//X/9v/2//b/9v/2//b/9v/2//b/9v/2//b/9v/2//b/9v/2//b/9v/1//T/9P/z//L/8v/x//D/8P/v/+//7//v/+//7//v/+//7//v/+//8P/w//H/8f/x//L/8v/z//P/8//0//T/9P/0//n/+f/5//n/+f/5//n/+f/4//j/+P/4//f/9//3//f/9//3//f/9//3//f/9//3//f/9v/2//b/9v/2//b/9v/2//f/9//4//j/+f/5//n/+v/6//r/+v/5//n/+P/4//j/9//3//f/9//4//j/+f/5//n/+v/6//v/+v/6//r/+v/6//r/+v/5//n/+f/5//n/+f/5//n/+f/5//n/+f/6//r/+v/6//r/+//7//v/+//7//v/+//7//v/+//7//v/+//6//r/+v/6//r/+v/6//r/+v/6//r/+v/6/wEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAMAAwADAAMAAwACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAIAAgACAAIAAgACAAIAAgACAAIAAgADAAMAAwADAAMAAwADAAIAAgACAAIAAgACAAIAAgACAAIAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"},{ name : "R_sfx_footstep2_wav", data : "UklGRhIJAABXQVZFZm10IBAAAAABAAEAIlYAAESsAAACABAAZGF0Ye4IAABLA1AD1QPbA+EDGwQhBCgEDwQVBBsEIQSpA64DswPeAuIC5gLHA8wD0QO0BLoEwATGBJ4DogOnAw0FEwUZBUUDOAMsAywDIAMTAwcDZANWA0gDlwOHA3gDEAMCA/QC7APaA8cDtAPgAdYBzQE1AyMDEgM5AyYDFAOGAncCaAJZAssBvwGzAUsCOgIqAiMCEwIDAhkCBwL2AeQB8QDoAN8AYgFTAUUBFgEJAfwA7wAfAQ8B/wDQAMIAswCXAIsAfgBPAEYAPQA0AC8AJgAcABcACwD///X/6//g/7//r/+f/5D/lv+K/33/Zf9X/0n/jv+G/37/R/88/zH/J/8j/xn/D/+Q/oH+cv7E/rn+rv5x/mT+WP5L/tz+1P7M/pj+j/6F/rn9q/2d/bX9qP2c/Y/9J/4d/hT+3P3S/cj9Ov4y/iv+I/77/fP96v2O/YT9e/3g/NT8yfzt/OP82PzN/Af9/vz0/Ij9gP15/fb76vve++/75PvY+8z79/vs++H7i/uA+3T72fvB+6j7tfue+4b7b/uk/LT8xPwL+yT7PftW+2/7iPuB/Y/9nf2r/SP8O/xS/Lr9yf3X/Qn9Hv0z/fv8Ev0o/T/9R/5o/oj+yP38/TH+0P73/h3/Lf9X/4L/rP/V/wAALABcAIkAtwCKAKUAwADcAIUBsAHaAQICLAI5Am4BaQFjAVICSQJAAjcCWwFWAVABmwGVAY4BmAGRAYoBTQFHAUEBOwGGAX4BdwFCATwBNQF7AXMBawFeAVYBTgFGATwBNAEsAR8BGAEQASQBGwETAbIArACnAKIAuACyAKsAtQCuAKcAgAB7AHUAbABnAGIAXQB8AHUAbgBEAEAAOwA0ADAAKwAnAB8AGwAXAB0AFwARAAsABQD///n/8//t/+f/3P/V/87/3P/Y/9T/s/+t/6b/y//H/8T/wP+H/4H/e/+F/3//ev+m/6L/n/+W/5L/j/+L/4z/if+G/0j/RP8//w//Cf8E/zz/Pv9E/0n/eP98/4D/Sv9Q/1b/Z/9s/3H/lf+Z/57/ov+J/47/lP/A/8T/x/+3/7v/wP+u/7T/uv/A/9//4v/l/+T/6P/s/+r/7//0//n//v8EAAkADwAVABsAFwAaAB4AJgAqAC4AMgAuADEANQBCAEYASgBPAFMAVwA/AEEARABHAFkAXABfAHMAdwB6AJsAoACkAJMAlwCbAJ4AbgBxAHMAuwC/AMMAnwCiAKUA6QDtAPEA9QCRAJMAlgDlAOkA7ADjAOYA6QAMARABEwEXAQQBBwEKAfoA/QAAAcEAwwDFAMcAywDNAM8AHQEfASIB4gDkAOYAdQF4AXcBdQEkASMBIgHDAMIAwgDmAOUA5ABNAUsBSgFJARcBFgEVASIBIQEgAQgBBwEGAVUBVAFSAVEBtwC2ALUA/wD+AP0AwAC/AL8ALAErASoBKAELAQoBCQH9AP0A/AD3APYA9QAIAQcBBgEFATYBNQE0AccAxgDGAKEAoACgAJ8A2wDaANkA2wDbANoAsgCxALAAmgCaAJkAmQCvAK4ArQChAKEAoADJAMgAxwDHAMcAxgDFAIkAiQCIALkAuQC4APAA7wDuAJwAnACbAJoA9gD1APMAggCBAIEAvAC5ALUA6ADkAN8A2wDaANYA0QBoAGYAZACfAJwAmABzAHAAbgBrAKIAngCaAHkAdgBzAH0AeQB2AFYAUwBRAE4AUgBPAE0AaABkAGEAWQBWAFMAUABQAE0ASgAtACsAKQAjACEAUwCNAI4AjwCQAFoAWgBbAJMAlACVAHsAfAB9AJEAkgCTAJQAfgB/AH8AcgByAHMAqwCrAKwAWQBaAFoAWgCVAJYAlgBjAGQAZABrAGsAbACHAIgAiACJAJIAkwCTAHYAdwB4AH0AfgB/AHkAeQB6AHsAsgCzALQAcgBzAHQApgCnAKgAqQCkAKUApgCxALIAswCRAJIAkwBwAHEAcQByAHsAewB8ANYA1wDYAMUAxgDHAN0A3gDfAOAAxADFAMYAlwCXAJgAmQCaAJoAtQC1ALYAtwCUAJUAlQDuAO8A8AC+AL4AvwDSANMA1ADUAKsArACsALQAtAC1AKUApQCmAAsBDAENAQ0B2gDaANsAiACIAIkAEQESARIBEAERARIBEgGhAKIAogD6APoA+wCaAJsAmwCbAKoAqgCrAJgAmACXAJ0AnACaAO8A7ADqAOgAkQCQAI4A7QDqAOgAzADKAMgAvgC8ALoAuACPAI0AjADNAMsAyQDJAMcAxACXAJUAkwCSAL4AvAC5AK0AqwCpAIcAhQCDAHcAdQB0AHIAlgCUAJIAcwByAHAAgAB+AH0AlQCTAJEAjwBxAG8AbgBJAEgARwBoAGcAZQBjAHgAdgB0AGsAaQBnAFMAUgBRADoAOQA4ADcALwAvAC4ARgBFAEMARwBFAEQANgA1ADQAMwBDAEIAQAAsACsAKgA4ADYANQArACoAKQAoAC8ALQAsACQAIgAhACAAHgAdABUAFQAUABMAGQAYABcAFQAUABMADwAOAA0ACwALAAoACQAMAAsACQAHAAYABQAFAAQAAwABAAAA//////7//f/9//z/+//7//f/9v/1//T/9//2//b/8v/x//D/8P/v/+7/6v/p/+j/5//r/+r/6f/u/+7/7f/n/+b/5v/r/+r/6v/p/9n/2f/Y/97/3f/c/9j/1//X/9j/1//W/9b/5v/l/+X/1f/U/9T/1//X/9f/x//H/8b/xv/f/9//3//f/9//3//a/9r/2v/P/8//z//P/8r/yv/K/9r/2v/a/9r/2v/a/9r/4v/i/+L/1v/W/9b/2v/a/9v/y//L/8z/zP/N/83/zf/W/9b/1v/L/8z/zP/g/+H/4f/h/87/z//P/9L/0//T/9P/0//U/97/3//f/9//2P/Y/9n/5P/k/+X/4f/i/+L/6P/o/+j/6f/n/+j/6P/p/+r/6//r/+v/7P/p/+r/6v/r/+3/7f/u/+v/7P/t/+7/7//w//D/9v/3//f/9f/2//f/+f/6//v/+//8//z//f/9//7///8"},{ name : "R_fonts_alterebroOutline_fnt", data : "QkZOVAABFABBbHRlcmVicm8gUGl4ZWwgRm9udAwAFABhbHRlcmVicm9PdXRsaW5lLnBuZw0ACwA/AAAA7wAAAGEATgAFAAkA/v8DAAMAAAAAADIAAABtAAIABgAJAP//AwAFAAAAAABQAAAANgAXAAYACQD//wMABQAAAAAAbAAAAGsAIgADAAkA//8DAAIAAAAAAGgAAABVACIABgAJAP//AwAFAAAAAAAxAAAAaAACAAQACQD//wMAAwAAAAAANAAAAAEADQAGAAkA//8DAAUAAAAAAMgAAAAWAD0ABgAMAP//AAAFAAAAAADbAAAAdAA9AAYADAD//wAABQAAAAAA+gAAABYAWgAGAAoA//8CAAUAAAAAAD4AAAA7AA8ABQAHAP//BQAEAAAAAABnAAAATgAkAAYACQD//wUABQAAAAAAZgAAAEgAIgAFAAkA//8DAAQAAAAAAGoAAABgACIABAALAP//AwADAAAAAADOAAAANwA9AAUADAD+/wAAAgAAAAAAbwAAAAEAMwAGAAcA//8FAAUAAAAAAFIAAABEABcABgAJAP//AwAFAAAAAABZAAAAdwAXAAcACQD//wMABgAAAAAAOAAAAB0ADQAGAAkA//8DAAUAAAAAAE8AAAAvABcABgAJAP//AwAFAAAAAADZAAAAZgA9AAYADAD//wAABQAAAAAAeQAAAEYAMwAGAAkA//8FAAUAAAAAAGUAAABBACQABgAHAP//BQAFAAAAAADRAAAAQwA+AAYACwD//wEABQAAAAAARQAAAGUADQAGAAkA//8DAAUAAAAAAM0AAAAyAD0ABAAMAP//AAACAAAAAADJAAAAHQA9AAYADAD//wAABQAAAAAA6wAAAE8AUAAGAAcA//8FAAUAAAAAAPYAAAAIAF0ABgAHAP//BQAFAAAAAADLAAAAKwA+AAYACwD//wEABQAAAAAAwwAAAAEAPgAGAAsA//8BAAUAAAAAAC0AAABQAAUABQADAP//BgAEAAAAAAA2AAAADwANAAYACQD//wMABQAAAAAATgAAACgAFwAGAAkA//8DAAUAAAAAAHYAAAAwADMABgAHAP//BQAFAAAAAABRAAAAPQAXAAYACQD//wMABQAAAAAATQAAACAAFwAHAAkA//8DAAYAAAAAAEYAAABsAA0ABgAJAP//AwAFAAAAAABeAAAAGQAiAAUABAD//wMABAAAAAAAbQAAAG8AJAAHAAcA//8FAAYAAAAAACQAAAAWAAEABwALAP//AgAGAAAAAABMAAAAGgAXAAUACQD//wMABAAAAAAA5wAAADMAUAAGAAkA//8FAAUAAAAAAPUAAAABAFsABgAJAP//AwAFAAAAAAA5AAAAJAANAAYACQD//wMABQAAAAAARAAAAF4ADQAGAAkA//8DAAUAAAAAANUAAABYAD4ABgALAP//AQAFAAAAAAB6AAAATQAzAAYABwD//wUABQAAAAAA7QAAAFYATQAEAAoA//8CAAIAAAAAAFUAAABaABcABgAJAP//AwAFAAAAAABkAAAAOgAiAAYACQD//wMABQAAAAAAYgAAACwAIgAGAAkA//8DAAUAAAAAAGkAAABcACIAAwAJAP//AwACAAAAAADWAAAAXwA+AAYACwD//wEABQAAAAAArCAAACsAWwAHAAkA//8DAAYAAAAAAMoAAAAkAD0ABgAMAP//AAAFAAAAAADhAAAAFwBNAAYACgD//wIABQAAAAAAPwAAAEEADQAHAAkA//8DAAYAAAAAANwAAAABAEwABgALAP//AQAFAAAAAACwAAAAWAAxAAUABQAAAAMABQAAAAAAMwAAAHQAAgAGAAkA//8DAAUAAAAAAGsAAABlACIABQAJAP//AwAEAAAAAADAAAAAZgAuAAYADAD//wAABQAAAAAA0wAAAEoAPQAGAAwA//8AAAUAAAAAAPkAAAAPAFoABgAKAP//AgAFAAAAAAAgAAAAAQAJAAIAAgD//woAAwAAAAAA4wAAACUATgAGAAkA//8DAAUAAAAAAFoAAAABACIABgAJAP//AwAFAAAAAADkAAAALABOAAYACQD//wMABQAAAAAA4gAAAB4ATQAGAAoA//8CAAUAAAAAACgAAAA0AAEABAALAP//AgADAAAAAADHAAAADwBAAAYACwD//wMABQAAAAAAQwAAAFcADQAGAAkA//8DAAUAAAAAADcAAAAWAA0ABgAJAP//AwAFAAAAAAB1AAAAKQAzAAYABwD//wUABQAAAAAAbgAAAHcAJAAGAAcA//8FAAUAAAAAAMEAAABtAC4ABgAMAP//AAAFAAAAAAA8AAAALwAPAAUABwD//wUABAAAAAAA9AAAAHUATQAGAAoA//8CAAUAAAAAAKEAAABUADEAAwAKAP//AwACAAAAAADEAAAACAA+AAYACwD//wEABQAAAAAA3wAAAAgATgAHAAkA//8DAAYAAAAAAHQAAAAjADEABQAJAP//AwAEAAAAAADzAAAAbgBNAAYACgD//wIABQAAAAAAwgAAAHQALgAGAAwA//8AAAUAAAAAACYAAAAoAAIABwAJAP//AwAGAAAAAAA9AAAANQAPAAUABQD//wUABAAAAAAA1AAAAFEAPQAGAAwA//8AAAUAAAAAAFcAAABoABcABwAJAP//AwAGAAAAAABxAAAADwAzAAYACQD//wUABQAAAAAAOgAAACsAEQADAAUA//8HAAIAAAAAAFQAAABSABcABwAJAP//AwAGAAAAAAAiAAAACAACAAUABAD//wMABAAAAAAASgAAAAwAFwAGAAkA//8DAAUAAAAAAHAAAAAIADMABgAJAP//BQAFAAAAAABLAAAAEwAXAAYACQD//wMABQAAAAAAMAAAAGEAAgAGAAkA//8DAAUAAAAAAPEAAABnAE4ABgAJAP//AwAFAAAAAAD7AAAAHQBaAAYACgD//wIABQAAAAAARwAAAHMADQAGAAkA//8DAAUAAAAAAOoAAABIAE0ABgAKAP//AgAFAAAAAAA1AAAACAANAAYACQD//wMABQAAAAAAQQAAAEkADQAGAAkA//8DAAUAAAAAAL8AAABeADIABwAJAP//BAAGAAAAAADaAAAAbQA9AAYADAD//wAABQAAAAAALwAAAFoAAgAGAAkA//8DAAUAAAAAAEkAAAAIABcAAwAJAP//AwACAAAAAAAsAAAATAAIAAMABAD//wkAAgAAAAAAWwAAAAgAIQAEAAsA//8CAAMAAAAAAHgAAAA/ADMABgAHAP//BQAFAAAAAABhAAAAJQAkAAYABwD//wUABQAAAAAASAAAAAEAFwAGAAkA//8DAAUAAAAAAGMAAAAzACQABgAHAP//BQAFAAAAAAByAAAAFgAzAAUABwD//wUABAAAAAAAIQAAAAQAAgADAAkA//8DAAIAAAAAACUAAAAeAAIACQAJAP//AwAIAAAAAABdAAAAFAAhAAQACwD//wIAAwAAAAAAdwAAADcAMwAHAAcA//8FAAYAAAAAAPwAAAAkAF0ABgAHAP//BQAFAAAAAAApAAAAOQABAAQACwD//wIAAwAAAAAA6QAAAEEATQAGAAoA//8CAAUAAAAAAF8AAAAfACgABQADAP//CQAEAAAAAADoAAAAOgBNAAYACgD//wIABQAAAAAAXAAAAA0AIgAGAAkA//8DAAUAAAAAAHMAAAAcADMABgAHAP//BQAFAAAAAAAqAAAAPgACAAUABQD//wMABAAAAAAA4AAAABAATQAGAAoA//8CAAUAAAAAAC4AAABWAAgAAwADAP//CQACAAAAAAAnAAAAMAACAAMABAD//wMAAgAAAAAAQgAAAFAADQAGAAkA//8DAAUAAAAAAFMAAABLABcABgAJAP//AwAFAAAAAADPAAAAPQA+AAUACwD+/wEAAgAAAAAAWAAAAHAAFwAGAAkA//8DAAUAAAAAACMAAAAOAAMABwAHAP//BAAGAAAAAADuAAAAWwBNAAUACgD+/wIAAgAAAAAAKwAAAEQAAwAHAAcA//8EAAYAAAAAAFYAAABhABcABgAJAP//AwAFAAAAAAAAAAAA"},{ name : "R_sfx_footstep1_wav", data : "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KwAiACEAIAAVABUAFAAeAB0AHAAcACEAIAAfAB0AHAAbABUAFQAUAA4ADgANAA0ACwALAAoADwAPAA4ADgAOAA0ACgAKAAkACQALAAoACgAGAAYABQAHAAYABQAEAAQAAwACAAIAAgABAAAAAAD//////v/+//7//v/9//3/+//7//r/+v/5//n/+v/5//n/+f/4//j/+P/z//P/8v/1//T/9P/v/+//7v/u//P/8//y//P/8//z//P/8//y/+z/7P/r/+v/8P/w//D/6//r/+r/6v/q/+r/5f/l/+T/5P/o/+j/6P/u/+7/7f/n/+f/5//s/+z/7P/r/93/3f/d/+L/4v/h/97/3v/e/9//3v/e/97/6//r/+v/3v/e/97/4f/h/+H/1f/V/9X/1f/o/+j/6P/o/+j/6P/l/+X/5f/d/93/3v/e/9r/2v/a/+b/5v/m/+b/5v/m/+b/7P/s/+z/4//k/+T/5//n/+f/3f/d/93/3v/e/9//3//k/+X/5f/e/97/3v/s/+z/7P/s/+D/4f/h/+P/4//k/+T/5f/l/+z/7P/t/+3/6f/p/+r/8P/w//H/7//w//D/8//z//T/9P/z//T/9P/1//X/9f/1//b/9v/1//X/9v/2//f/9//4//b/9//3//j/+P/5//n//P/8//z/+//8//z//f/9//7//v/+//7/////////AAA"},{ name : "R_fonts_alterebroOutline_png", data : "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"},{ name : "R_fonts_04b03_fnt", data : "QkZOVAABBQAwNGIwMwgACQAwNGIwMy5wbmcIAAYAPwAAAG8AAAAqADgACAAIAP7/AAAFAAAAAABKAAAAYQAWAAgACQD+////BQAAAAAAJQAAACcAAQAJAAkA/v///wYAAAAAAHAAAAAzADgACAAKAP7/AAAFAAAAAABLAAAAagAWAAgACQD+////BQAAAAAAJgAAADEAAQAJAAkA/v///wYAAAAAAHEAAAA8ADgACAAKAP7/AAAFAAAAAABMAAAAcwAWAAcACQD+////BAAAAAAAJwAAADsAAQAFAAYA/v///wIAAAAAAHIAAABFADgABwAIAP7/AAAEAAAAAABNAAAAAQAgAAkACQD+////BgAAAAAAKAAAAEEAAQAGAAkA/v///wMAAAAAAHMAAABNADgACAAIAP7/AAAFAAAAAABOAAAACwAgAAgACQD+////BQAAAAAAKQAAAEgAAQAGAAkA/v///wMAAAAAAHQAAABWADcABwAJAP7///8EAAAAAABPAAAAFAAgAAgACQD+////BQAAAAAAKgAAAE8AAQAHAAcA/v///wQAAAAAAHUAAABeADgACAAIAP7/AAAFAAAAAABQAAAAHQAgAAgACQD+////BQAAAAAAKwAAAFcAAgAHAAcA/v8AAAQAAAAAAHYAAABnADgACAAIAP7/AAAFAAAAAABRAAAAJgAgAAgACgD+////BQAAAAAALAAAAF8ABQAGAAYA/v8DAAMAAAAAAHcAAABwADgACQAIAP7/AAAGAAAAAABSAAAALwAgAAgACQD+////BQAAAAAALQAAAGYAAwAHAAUA/v8BAAQAAAAAAHgAAAABAEQABwAIAP7/AAAEAAAAAABTAAAAOAAgAAgACQD+////BQAAAAAALgAAAG4ABQAFAAUA/v8DAAIAAAAAAHkAAAAJAEQACAAKAP7/AAAFAAAAAABUAAAAQQAgAAcACQD+////BAAAAAAALwAAAHQAAQAJAAkA/v///wYAAAAAAHoAAAASAEQACAAIAP7/AAAFAAAAAAAwAAAAAQAMAAgACQD+////BQAAAAAAVQAAAEkAIAAIAAkA/v///wUAAAAAAHsAAAAbAEMABwAJAP7///8EAAAAAAAxAAAACgAMAAYACQD+////AwAAAAAAVgAAAFIAIAAIAAkA/v///wUAAAAAAHwAAAAjAEMABQAJAP7///8CAAAAAAAyAAAAEQAMAAgACQD+////BQAAAAAAVwAAAFsAIAAJAAkA/v///wYAAAAAAH0AAAApAEMABwAJAP7///8EAAAAAABYAAAAZQAgAAgACQD+////BQAAAAAAMwAAABoADAAIAAkA/v///wUAAAAAAH4AAAAxAEMACAAGAP7///8FAAAAAABZAAAAbgAgAAgACQD+////BQAAAAAANAAAACMADAAIAAkA/v///wUAAAAAAFoAAAB3ACAABwAJAP7///8EAAAAAAA1AAAALAAMAAgACQD+////BQAAAAAAWwAAAAEAKwAGAAkA/v///wMAAAAAADYAAAA1AAwACAAJAP7///8FAAAAAABcAAAACAArAAkACQD+////BgAAAAAANwAAAD4ADAAIAAkA/v///wUAAAAAAF0AAAASACsABgAJAP7///8DAAAAAAA4AAAARwAMAAgACQD+////BQAAAAAAXgAAABkAKwAHAAYA/v///wQAAAAAADkAAABQAAwACAAJAP7///8FAAAAAABfAAAAIQAvAAgABQD+/wMABQAAAAAAOgAAAFkADQAFAAcA/v8AAAIAAAAAAGAAAAAqACsABgAGAP7///8DAAAAAAA7AAAAXwANAAUACAD+/wAAAgAAAAAAYQAAADEALAAIAAgA/v8AAAUAAAAAADwAAABlAAwABwAJAP7///8EAAAAAABiAAAAOgArAAgACQD+////BQAAAAAAPQAAAG0ADQAHAAcA/v8AAAQAAAAAAGMAAABDACwABwAIAP7/AAAEAAAAAAA+AAAAdQAMAAcACQD+////BAAAAAAAZAAAAEsAKwAIAAkA/v///wUAAAAAAD8AAAABABYACAAJAP7///8FAAAAAABlAAAAVAAsAAgACAD+/wAABQAAAAAAQAAAAAoAFgAJAAkA/v///wYAAAAAAGYAAABdACsABwAJAP7///8EAAAAAABBAAAAFAAWAAgACQD+////BQAAAAAAZwAAAGUALAAIAAoA/v8AAAUAAAAAAEIAAAAdABYACAAJAP7///8FAAAAAABoAAAAbgArAAgACQD+////BQAAAAAAQwAAACYAFgAHAAkA/v///wQAAAAAAGkAAAB3ACsABQAJAP7///8CAAAAAABEAAAALgAWAAgACQD+////BQAAAAAAagAAAAEANwAGAAsA/v///wMAAAAAACAAAAABAAYABAAEAP7/BAAEAAAAAABFAAAANwAWAAcACQD+////BAAAAAAAawAAAAgANwAIAAkA/v///wUAAAAAACEAAAAGAAEABQAJAP7///8CAAAAAABGAAAAPwAWAAcACQD+////BAAAAAAAbAAAABEANwAFAAkA/v///wIAAAAAAEcAAABHABYACAAJAP7///8FAAAAAAAiAAAADAABAAcABgD+////BAAAAAAAbQAAABcAOAAJAAgA/v8AAAYAAAAAAEgAAABQABYACAAJAP7///8FAAAAAAAjAAAAFAABAAkACQD+////BgAAAAAAbgAAACEAOAAIAAgA/v8AAAUAAAAAAEkAAABZABYABwAJAP7///8EAAAAAAAkAAAAHgABAAgACgD+////BQAAAAAAAAAAAA"},{ name : "R_sfx_close_wav", data : "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CAAaABwADwAEAPz/+//7//r/+P/3//b/+f/7//3//v/+//7///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"},{ name : "R_sfx_smallHit_wav", data : "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IP/q/tL+F/9f/6v/+/9NAKIA9wBPAagB0gGAASwB2QCGADQA4v+T/0r/CP/e/uH+5f7o/t7+0/7J/r/+tf6q/r3++P4x/2j/nf/P////LwBgAJIAswC1ALUAtACzALIAsQCwAK4ApwCPAF8AMgAIAOL/vP+V/27/Rf8c/xj/SP96/63/4f8WAEsAggC7APUABwHlAMMAngB1AE4AKAADAOH/wP+7/9L/6P/8/w4AHgAvAEMAWABuAH8AiwCVAJkAmwCeAKAAogCjAK4AsACqAKMAmwCSAIEAbwBeAE8AQQAzACcAHQATAAcA+//u/+H/1f/K/9D/3//v//7/DAAbACoAOABHAFUATwA/ADAAIQASAAUA9//r/9//1P/V/9v/4f/n/+3/8//3//z/AAAEAAQAAwACAAAA///+//z/+//5//f/8//u/+r/5v/j/+D/3f/Z/9P/zP/V/+L/8P8AABAAIAAuADsASABUAEoAPQAxACYAGwASAAkAAQD4/+//7f/r/+n/5//l/+L/3//d/9r/2f/b/97/4P/j/+X/5//p/+v/7f/v//f///8IABAAGAAfACcALgA4AEAAOgA0ACwAJQAbABIACgADAPz/9//1//P/8f/v/+3/6v/o/+f/5v/m/+v/7//0//f/+////wQACQAOABAACAAAAPj/8f/q/+L/2//U/87/y//T/9v/4//q//L/+f8BAAgAEAAUABAADAAIAAQAAAD8//j/9P/v/+7/8v/2//r//f8AAAMABgAIAAsADAAMAAsACwALAAsADAAMAAwADAAPABMAGAAcACAAJQApACwALwAyACwAIAAVAAkA///1/+v/4f/Y/83/yf/J/8n/yf/J/8r/y//M/83/zv/V/93/5v/v//j/AQALABUAHgAoACQAGwATAAsAAgD7//T/7f/n/+L/4//l/+j/6v/t//D/8//3//r//v/7//j/9f/y//D/7v/s/+v/6v/m/+X/5P/i/+H/4P/h/+P/5f/m/+j/7f/x//T/9//7//7/AgAGAAoADQAJAAUAAAD8//f/8v/u/+n/5f/j/+r/8f/3//3/AgAGAAkADgATABcAFwAYABgAFgAVABQAEwASABEAEAAMAAcAAgD9//f/8v/t/+n/5f/k/+j/6v/t/+//8v/0//b/+P/7//z//P/8//z//P/8//z//P/8//z//f/+/wAAAgAEAAYACAAKAAsADQALAAgABQADAAAA/v/7//n/9//1//b/+P/5//r//P/9//3//v//////AAAAAAEAAQACAAIAAgADAAMAAwACAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"},{ name : "R_sfx_teleport_ogg", data : "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"},{ name : "R_sfx_pick_wav", data : "UklGRowJAABXQVZFZm10IBAAAAABAAEAIlYAAESsAAACABAAZGF0YWgJAAAAAAAAAAAAACwDBAbYCKgLdQ4+EQMUxRaEGT4c9R6pIVgkBSc5JW0ipB/eHBwaXhejFOsRNw+HDNoJMQeLBOgBSf+u/Bb6gvfx9GPy2e9T7c/qUOjT5Vvj5eBz3gXcbNv93YngE+OZ5RvomuoW7Y/vBPJ29OT2T/m3+xz+fQDbAjUFjQfgCTEMfg7IEA8TUxWTF9AZChxAHnMgoyK0IGIeFBzIGYAXOxX5EroQfw5GDBEK3wexBYUDXQE3/xX99vrb+ML2rPSa8ovwfu517HDqbeht5nDkd+KB4FfgcOKH5Jrmqui36sHsx+7L8MzyyfTE9rv4sPqh/JD+ewBkAkkEKwYLCOcJwAuWDWoPOhEHE9EUmRZdGB4a3RuaHQ4cNhpgGIwWuhTqEhwRUA+GDb4L+Ak0CHEGsQTzAjcBfP/E/Q38Wfqn+Pf2SfWc8/LxSvCk7gDtXuu+6SDohObq5Cfk2OWH5zPp3uqH7C7u0+928RfztfRS9u73h/ke+7P8Rv7Y/2cB9AKABAoGkQcXCZsKHQydDRsPmBASEooTARV2FukXWhm4GTEYqxYoFaYTJhKoECwPsg06DMMKTgncB2sG+wSOAyICuABQ/+r9hvwj+8P5ZPgG96v1UfT58qPxT/D87qvtXOwP68PpeeiG5+boReqh6/zsVe6s7wLxVvKo8/n0R/aU9+D4Kvpy+7j8/f1A/4EAwQH/AjsEdgWvBuYHHAlQCoILswziDRAPOxBmEY4StRPbFP8VDxbWFJ4TaBIzEQEQzw6gDXIMRQsaCvEIyQejBn4FWwQ6AxoC/ADf/8T+qv2S/Hv7ZvpT+UH4MPch9hT1CPT98vTx7fDn7+Lu3+3e7N7rUetm7HrtjO6d76zwuvHG8tHz2vTi9en27ffx+PP59Prz+/D87f3n/uH/2QDPAcQCuAOrBJsFiwZ5B2YIUQk7CiMLCgzwDNUNuA6ZD3kQWBE2EqQSshHBENIP5A74DQ0NIww6C1MKbgmJCKYHxAbkBQUFJwRLA28ClgG9AOb/EP87/mj9lvzF+/b6KPpb+Y/4xff89jT2bvWo9OTzIvNg8qDx4fAj8GfvK+/778vwmfFl8jHz+/PE9Iz1UfYW99r3nPhe+R763vqc+1n8Ff3Q/Yr+Q//7/7EAZwEcAs8CgQMzBOMEkwVBBu4GmgdFCPAImQlBCugKjgszDNcMeg0cDr0OFQ9kDrMNAw1VDKcL+gpPCqQJ+whSCKoHBAdeBrkFFgVzBNEDMQORAvIBVAG3ABsAgP/m/k3+tf0e/Yj88/te+8v6Ofqn+Rf5h/j492v33vZS9sf1PfWz9Cv0pPMd85jysvJI89zzcPQD9ZX1J/a39kb31fdi+O/4e/kG+pD6Gfuh+yn8sPw1/br9Pv7B/kT/xf9GAMUARAHCAUACvAI4A7IDLASlBB4FlQUMBoIG9wZrB98HUgjFCDcJqAkYCocK9gpkC9ILbwv0CnoKAAqICRAJmAgiCKwHNwfDBk8G3AVqBfgEiAQYBKgDOQPLAl4C8QGGARoBsABGAN3/dP8M/6X+P/7Z/XT9D/2r/Ej85vuE+yL7wvpi+gP6pPlG+en4jPgw+NX3evcd98D2ZPYI9qz1ufUa9nz23fY99573/vdd+Lz4G/l5+df5NfqS+u/6S/uo+wP8X/y6/BT9b/3J/SL+fP7U/i3/hf/d/zQAjADiADkBjwHkAToCjwLkAjgDjAPfAzMEhgTYBCsFfQXOBR8GcAbCBhQHZge4BwwIXwizCAcJXAmiCUYJ6giOCDEI0wd2BxgHuQZaBvsFnAU8BdsEegQZBLgDVgP0ApECLgLLAWcBAwGfADoA1f9v/wr/pP49/tb9b/0H/aD8N/zP+2b7/fqT+in6v/lV+er4fvgT+Kf3O/fZ9kz3v/cy+KX4GfmN+QL6dvrr+mH71vtM/ML8Of2v/Sb+nv4V/43/BQB+APYAbwHpAWIC3AJWA9ADSwTFBEAFvAU3BrMGLwesBygIpQg1CLIHLwerBigGpAUgBZwEFwSTAw4DiQIDAn4B+AByAOz/Zf/f/lj+0f1K/cL8Ovyz+yv7ovoa+pH5CPl/+Pb3y/da+On4ePkI+pf6J/u3+0j82Pxp/fn9iv4b/6z/PgDPAGEB8wGFAhcDqQM7BM4EYQXzBYYGGQetB8sHMgeZBgAGZwXOBDQEmwMBA2cCzQEzAZkA//9l/8r+MP6V/fr8YPzF+yr7j/r0+Vj5vfg++N/4gPkh+sL6Y/sE/Kb8R/3o/Yr+K//N/24AEAGyAVQC9QKXAzkE2wR9BR8GwQZjB/cGUAaoBQEFWQSyAwoDYgK7ARMBawDE/xz/dP7M/SX9ffzV+y37hfre+Tb5zPh5+Sf61PqB+y782/yI/TX+4v6P/zwA6QCWAUIC7gKaA0YE8gSdBUgG8wZhBrAF/wROBJ0D7AI8AosB2wArAHz/zP4d/m79v/wR/GL7tPoG+lj5wPl0+if72/uO/EH99P2m/ln/CwC8AG4BHwLQAoEDMQThBJEFQQYMBlYFoQTsAzcDggLOARoBZgCz/wD/Tf6b/ej8N/yF+9T6I/rv+ab6XfsT/Mn8f/00/un+nf9SAAYBuQFtAiAD0gOFBDcF6AV0BbwEBQROA5cC4AEqAXQAvv8J/1T+oP3s/Dj8hPvR+ij64fqa+1L8Cv3C/Xn+MP/n/50AUwEIAr0CcgMmBNoEjQXuBDUEfAPEAgwCVAGdAOb/MP97/sX9Ef1c/Kn79frj+pz7VfwO/cb9ff40/+r/oABVAQoCvgJxAyQE1wTPBBcEXwOnAvABOgGFAND/HP9o/rX9A/1R/KD7D/vG+338M/3o/Z3+Uf8EALYAaAEZAskCeQMoBKoE9QNBA40C2gEoAXcAxv8X/2j+uv0N/WD8tfvV+4j8Of3p/Zj+R//1/6EATQH4AaICSwPzAwcEWAOqAv0BUQGnAP3/VP+s/gX+X/26/Bf8S/z1/J/9R/7v/pX/OgDeAIEBIgLCAmEDxwMiA34C3AE6AZsA/P9f/8P+Kf6Q/fj8YvzV/HL9Df6n/kD/1/9tAAEBlAElArUCRAMOA3gC5QFTAcIAMwCl/xn/jv4F/n399/wW/aP9Lv64/kH/yP9NANEAUwHTAVIC0AKqAikCpwEmAaYAJQCm/yb/p/4p/qv9Lv1y/fL9cf7w/m7/6/9oAOQAXwHaAVMCzAJUAtgBXAHiAGgA7/93/w"},{ name : "R_sfx_select_wav", data : "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0f/N/8r/v/+7/7f/s/+v/6v/qP+k/6T/qP+r/6//s/+2/7r/vv/M/8//0v/V/9j/2//e/+H/5P/n/+r/7f/w//P/9v/5//v///8CAAUACAALAA4AEQAUABcAGgAdACAAIwAnAC4AMQA1ADgAPAA/AEIARgBJAEwAUABTAFYAWgBdAGAAaQBtAHAAdAB3AHoAdgBzAHAAbQBqAGcAZABhAF0AWgBYAFUAUgBOAEsASABFAEIAPwA8ADkANgAzAC8ALAAkACEAHwAcABkAFwAUABEADwAMAAkABwAEAAEA///8//n/9//0//H/7//s/+n/5//k/+H/3//c/9n/1//U/9H/0v/P/83/z//S/9T/1//Z/9z/3//h/+T/5v/p/+v/7f/w//L/9f/4//v//f8AAAMABQAIAAsADQAQABMAFgAYABsAHgAgACMAJgAoACsALgAwADMANgA4ADsAPgBAADsAPQBAAEIARABHAEkASwBOAFAAUgBVAFcAWQBbAF4AYwBiAGEAYQBgAF8AXgBdAFwAWwBaAFkAWQBYAFcAWwBaAFkAWABXAFYAVQBUAFMAUgBSAFEAUABPAE4ATQBTAFIAUQBQAE8ATgBNAEwASwBKAEkASABHAEYARQBEAD8APwA+AD0APAA7ADoAOQA4ADcANgA2ADUAMwAxACkAJwAlACMAIgAgAB4AHAAaABgAFwAVABMAEQAPAA0ADgALAAkABwAFAAMAAQD///3/+//4//b/9P/y//D/7v/u/+z/6v/o/+b/5P/i/+D/3v/c/9v/2f/X/9X/0//L/8n/x//F/8L/wP++/7z/uv+4/7b/t/+4/7n/uv+8/8n/yv/L/8z/zf/O/8//0P/R/9L/0//U/9X/1v/X/9j/0//U/9X/1v/X/9n/2v/b/9z/3f/e/9//4f/i/+P/5P/m/+f/6P/p/+r/6//s/+3/7v/v//D/8f/z//T/9f/1//b/9//5//r/+//8//3//f/9//3//f/+//7//v/+//7//v/+//7/////////////////////////AAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQACAAIAAgACAAIAAgACAAIAAgACAAIAAwADAAMAAwADAAMAAwADAAQABQAGAAcACQAKAAsADAANAA4AEAATABQAFQAXABgAGQAbABwAHQAeACAAIQAiACQAJQAmACQAJQAmACgAKQAqACsALAAtAC4AMAAxADIAMwA0ADUAQQBCAEQARQBGAEgASQBKAEwATQBOAFAAUQBSAFQATQBOAE0ASwBIAEYARABCAEAAPgA7ADkANwA1ADMAMQApACcAJQAjACIAIAAeABwAGgAYABYAFQATABEADwANAAwACgAIAAYABQADAAEA///9//v/+f/3//X/9P/y//D/6//p/+f/5f/j/+H/3//c/9r/2P/W/9T/0v/R/9H/1P/V/9X/1f/W/9b/1v/W/9f/1//X/9j/2P/Y/9n/2f/Y/9n/2f/Z/9r/2v/a/9r/2//b/9v/3P/c/9z/3P/d/97/3v/f/9//3//g/+D/4P/g/+H/4f/h/+H/4v/i/9//3//g/+D/4P/g/+H/4f/h/+L/4v/k/+b/6P/q/+z/8f/z//T/9v/3//n/+v/8//3///8AAAIAAwAFAAYACAAKAAwADgAPABEAEgAUABYAFwAZABsAHAAeAB8AIQAgACEAIwAkACUAJwAoACoAKwAtAC4ALwAxADIANAA1AEAAQgBDAEUARwBIAEoASQBIAEcARQBEAEMAQQBAAD8AOwA6ADkAOAA2ADUANAAzADIAMAAvAC4ALQAsACsAKQAoACYAJQAkACMAIgAhACAAHgAdABwAGwAaABkAGAAWABUAFAATABIAEQAQAA8ADgANAAwACgAJAAgABwAGAAUABAADAAMABAAEAAUABgAGAAcABwAIAAkACQAKAAsADAANAA0ADgAOAA8AEAAQABEAEgASABMAEwAUABUAEgATABMAFAAUABUAFQAWABYAFwAXABgAGAAZABkAGgAZABkAGgAaABsAGwAcABwAHAAdAB0AHgAeAB8AHwAjACMAIwAkACQAJAAkACUAJQAlACUAJQAmACYAJgAmACcAJwAnACcAKAAoACgAKAApACkAKQApACkAKgAqACoAKAAoACgAKAAoACkAKQApACkAKQApACoAKgAqACoAKQApACkAKQAqACoAKgAqACoAKgArACsAKgAqACkAKAApACgAKAAnACYAJgAlACQAJAAjACIAIQAhACAAHwAfAB0AHQAcABsAGwAaABkAGQAYABcAFwAWABUAFQAUABQAFAAUABMAEgASABEAEAAQAA8ADgAOAA0ADAAMAAsACgAKAAkACAAIAAcABgAGAAYABgAGAAYABgAGAAYABgAFAAUABQAFAAUABQAFAAUABQAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAHAAcABwAHAAcABwAHAAcABwAHAAcABwAIAAgACAAIAAgACAAIAAgABwAHAAcABgAGAAYABQAFAAUABAAEAAQAAwADAAMAAgADAAIAAgABAAEAAQAAAAAA/////////v/+//7//f/9//3//f/8//z//P/8//v/+//7//r/+v/6//r/+f/5//j/9//3//f/9v/2//b/9v/1//X/9f/0//T/9P/z//P/8f/x//D/8P/v/+//7v/u/+7/7f/t/+z/7P/r/+v/6v/q/+r/6f/p/+j/6P/o/+f/5//m/+b/5f/l/+X/5P/q/+r/6f/p/+n/6P/o/+j/5//n/+f/5v/m/+b/5v/l/+D/4P/g/9//3//f/97/3v/e/93/3f/d/93/3f/d/+D/4P/g/+D/4P/g/+D/4P/g/+D/4P/g/+D/4P/g/+D/2v/a/9r/2v/a/9r/2v/a/9r/2v/a/9r/2v/a/9r/2v/d/93/3f/d/93/3f/d/93/3f/d/93/3f/d/93/3f/c/9z/3P/c/9z/3P/c/93/3v/e/9//4P/h/+H/4v/j/+b/5//o/+j/6f/q/+r/6//s/+z/7f/u/+7/7//w//D/8P/x//L/8v/z//T/9P/1//b/9v/3//f/+P/5//n/+f/6//r/+//8//z//f/+//7///8AAAAAAQACAAIAAwADAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAIAAgACAAEAAQAAAP/////9//z/+//5//j/9v/1//P/8v/x//L/8f/v/+7/7f/s/+v/6v/q/+z/7v/w//H/8//1//X/9//6//z//v8AAAIABAAGAAgACwANAA8AEQATABMAEQAQABAADwAPAA4ADQANAAwACwALAAoACgAJAAgACAAIAAcABgAGAAUABAADAAEAAAD///7//f/7//r/+f/4//f/9v/1//T/8//y//H/8P/u/+3/7f/v//H/8//1//j/+v/8//7/AAACAAQABgAIAAoADAAOABAAEgAUABYAHAAdAB0AHQAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AFwAXABcAFwAYABgAGAAYABYAFAASABAADgAMAAoACAAIAAUAAwABAP7//P/6//f/9f/z//H/7v/s/+r/6f/p/+z/7P/s/+z/7P/r/+v/6//r/+v/6//r/+v/6//q/+r/6v/q/+r/6v/r/+z/7v/v//H/8v/z//X/9v/3//n/+v/7//3//v///wEAAgAEAAUABwAIAAgACQAKAAoACwAMAAwADQAOAA4ADwAQABAAEQASABIAEwAUABQAFQAUABQAEwASABEAEQAQAA8ADwAOAA0ADQAMAAsACwAKAAkACQAIAAcABwAGAAUABQAEAAQAAwADAAIAAgABAAEAAAAAAAAA//////7//v/9//3//P/8//v/+//9//7///8AAAIAAwAEAAYABwAIAAoACwAMAA4ADwAQABIAEwARABIAEwATABIAEQAPAA4ADQAMAAoACQAIAAcABQAEAAMAAgABAP///v/9//v/+v/5//n/+P/4//j/+P/3//f/9//3//b/9v/2//b/9f/1//X/9f/0//T/9P/0//P/8//z//L/8v/y//L/8f/x//H/8f/w//D/8P/w/+//7//w//D/8P/v/+//8P/y//P/9f/2//j/+f/7//z//f///wAAAgADAAQABgAHAAgACQALAAwADQANAA0ADQANAA4ADgAOAA4ADgAOAA4ADgAOAA4ADwAPAA8ADwAPAA8AEgASABEAEAAPAA4ADQAMAAsACgAJAAgABwAGAAUABAADAAIAAQAAAAAA///+//7///8AAAAAAQACAAIAAwAEAAQABQAGAAYABwAIAAgACQAJAAoACwALAAsACwAKAAkACQAIAAgABwAHAAYABgAFAAUABAAEAAMAAwACAAIAAQABAAAAAAAAAAAAAAD////////////////+//7//v/+//7//v/+//3//f/9//3//f/+//////8AAAEAAQACAAMAAwAEAAUABQAGAAcABwAIAAkACQAKAAsACwALAAoACQAJAAkACAAIAAgABwAHAAYABgAGAAUABQAFAAUABAAEAAQAAwADAAMAAwADAAMAAwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAwACAAIAAQAAAAAA///+//7//f/8//z/+//6//r/+f/4//j/9//3//f/+P/4//n/+v/6//v/+//8//3//f/+//7///8AAAAAAQABAAIAAgADAAMABAAEAAQABAAFAAUABQAFAAUABQAGAAYABgAGAAYABwAHAAcABwAHAAgABwAHAAcABwAHAAYABgAFAAUABAAEAAMAAwACAAIAAQABAAEAAAAAAP////////7//v/+//7//f/9//3//f/8//z//P/8//z//P/8//z/+//7//v/+//7//z//P/9//3//v/+//7//////wAAAAABAAEAAgADAAMABAAEAAUABQAFAAUABQAEAAQABAAEAAMAAwADAAMAAgACAAIAAgABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP//////////////////////////////////////////AAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"},{ name : "R_fonts_alterebro_fnt", data : "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"},{ name : "R_sfx_ambiant_ogg", data : "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"},{ name : "R_tiles_png", data : "iVBORw0KGgoAAAANSUhEUgAAAQAAAAMACAYAAADL7blPAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKBGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNi4wLWMwMDIgNzkuMTY0MzUyLCAyMDIwLzAxLzMwLTE1OjUwOjM4ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iIHhtbG5zOnhtcFJpZ2h0cz0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3JpZ2h0cy8iIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIiB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyIgZGM6Zm9ybWF0PSJpbWFnZS9wbmciIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTMyBXaW5kb3dzIiB4bXA6Q3JlYXRlRGF0ZT0iMjAxMi0wNC0yMVQwNjozNTozNiswMjowMCIgeG1wOk1vZGlmeURhdGU9IjIwMjAtMTItMThUMDg6MjA6NDErMDE6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMjAtMTItMThUMDg6MjA6NDErMDE6MDAiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDoxZTQzMjg5ZS04Njk0LWQyNDgtOWY4Yi02MTZhNTUwZDkzNjkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6YzIyYTIyY2YtNDE3Mi0yODQ5LTgyODAtNTc2MTY4Yzc2MTIwIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InV1aWQ6NEQ2QjY4NzA2QjhCRTExMTk1NEVCRDREMzhDRTFGOTUiIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHBob3Rvc2hvcDpJQ0NQcm9maWxlPSJzUkdCIElFQzYxOTY2LTIuMSIgeG1wUmlnaHRzOk1hcmtlZD0iRmFsc2UiIHRpZmY6T3JpZW50YXRpb249IjEiIHRpZmY6WFJlc29sdXRpb249IjcyMDAwMC8xMDAwMCIgdGlmZjpZUmVzb2x1dGlvbj0iNzIwMDAwLzEwMDAwIiB0aWZmOlJlc29sdXRpb25Vbml0PSIyIiBleGlmOkNvbG9yU3BhY2U9IjEiIGV4aWY6UGl4ZWxYRGltZW5zaW9uPSIyNTYiIGV4aWY6UGl4ZWxZRGltZW5zaW9uPSI3NjgiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDo3NGJiM2ZiYy00N2IzLTg5NDItODZjYi1kMmY4NTk5ZmIxNDgiIHN0RXZ0OndoZW49IjIwMjAtMTItMTdUMTY6NDg6MTUrMDE6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCAyMS4xIChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6YmE4Y2M5YWQtMGNlNi0yODQ1LWFkMTktMjc5MjY2ZjkzNmNiIiBzdEV2dDp3aGVuPSIyMDIwLTEyLTE4VDA4OjIwOjQxKzAxOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgMjEuMSAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNvbnZlcnRlZCIgc3RFdnQ6cGFyYW1ldGVycz0iZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iZGVyaXZlZCIgc3RFdnQ6cGFyYW1ldGVycz0iY29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmciLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmMyMmEyMmNmLTQxNzItMjg0OS04MjgwLTU3NjE2OGM3NjEyMCIgc3RFdnQ6d2hlbj0iMjAyMC0xMi0xOFQwODoyMDo0MSswMTowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIxLjEgKFdpbmRvd3MpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDwvcmRmOlNlcT4gPC94bXBNTTpIaXN0b3J5PiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpiYThjYzlhZC0wY2U2LTI4NDUtYWQxOS0yNzkyNjZmOTM2Y2IiIHN0UmVmOmRvY3VtZW50SUQ9InV1aWQ6NEQ2QjY4NzA2QjhCRTExMTk1NEVCRDREMzhDRTFGOTUiIHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD0idXVpZDo0RDZCNjg3MDZCOEJFMTExOTU0RUJENEQzOENFMUY5NSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Ps+Uox8AAMsTSURBVHja7P1nkGRZmh0GVnFATE9XpQ6tI1yEaxXuHlprrSNDZ6TWslLrytK6qru6uqu6e2a6ZzAKg+kZCAIEQNhw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EAAQAAEAARAAEAABAAEQABAAAQABEAAQAAEAARAAEAABAAEQABAAAQABEAAQAAEAARAAEAABAAEQABAAAQABEAAQAAEAARAAEAABAAEQABAAAQABEAAQAAEAARAAEAABAAEQABCAsQbgpfEDAPaHHwIIACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAC4IcAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAgACAAPghgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAIAB+CCAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIAAgAIACAAAACAAgAIACAAAACAAgAIACAAAACAAgAIACAAAACAAgAIACAAAACAAgAIACAAAACAAgAIACAAAACAAgAIACAAAACAAgAIACAAAACAAgACAAgAIAAAAIACAAgAIAAAAIACAAgAIAAAAIACAAgAIAAAAIACAAgAIAAAAIACAAgAIAAAAIACAAgAIAAAAIACAAgAIAAAAIACAAgAIAAAAIACAAIAPD/0n8CGQczw4V27hYAAAAASUVORK5CYII"},{ name : "R_sfx_success_wav", data : "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HgAYABMADQAIAAIA/f/4//L/7f/o/+P/3f/e/+T/6f/u//T/+f/+/wMACAANABIAFgAbACAAHgAaABUAEAALAAYAAQD9//j/9P/v/+r/5v/h/+P/6P/t//H/9v/6////AwAHAAwAEAAUABkAHQAbABYAEgAOAAkABQABAP3/+f/1//H/7f/p/+X/5//r/+//8//3//v///8DAAcACwAOABIAFgAZABcAEwAPAAsACAAEAAAA/f/5//b/8//w/+z/6f/s/+//8//2//n//P8AAAMABgAJAAwADwASABUAEgAPAAwACQAGAAMAAAD9//r/9//1//L/7//s/+//8v/1//j/+//9/wAAAwAFAAgACgANAA8AEgAPAAwACgAHAAUAAgAAAP3/+//5//b/9P/y//D/8//1//f/+v/8//7/AAACAAQABgAJAAoADAAQAA4ACwAJAAYABAACAAAA/f/7//n/9//1//P/8v/0//b/+P/7//3//v8AAAIABAAGAAgACQALAAwACgAIAAYABAADAAEA///+//z/+//6//j/9//2//j/+v/7//z//v///wAAAgADAAQABQAGAAcABwAGAAUABAADAAIAAQAAAP///v/9//z/+//7//v//P/9//3//v///wAAAAABAAEAAgACAAMAAwADAAMAAgABAAEAAQAAAAAAAAD/////////////////////AAAAAAAAAAAAAA"}];
haxe_ds_ObjectMap.count = 0;
haxe_MainLoop.add(hxd_System.updateCursor,-1);
var hx__registerFont;
hx__registerFont = function(name,data) {
	var s = window.document.createElement("style");
	s.type = "text/css";
	s.innerHTML = "@font-face{ font-family: " + name + "; src: url('data:font/ttf;base64," + data + "') format('truetype'); }";
	window.document.getElementsByTagName("head")[0].appendChild(s);
	var div = window.document.createElement("div");
	div.style.fontFamily = name;
	div.style.opacity = 0;
	div.style.width = "1px";
	div.style.height = "1px";
	div.style.position = "fixed";
	div.style.bottom = "0px";
	div.style.right = "0px";
	div.innerHTML = ".";
	div.className = "hx__loadFont";
	window.document.body.appendChild(div);
};
hx__registerFont("R_fonts_04B_03_TTF","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BQkFBggFCAgGCAgGCAgDBQgDCQgICAgGCAYICAkGCAgGAwYIBgAAAA0KBwAHBwMHCggKCgMFBQcHBQcDCggFCAgICAgICAgDAwcHBwgKCAgHCAcHCAgHCAgHCggICAgICAcICAoICAcFCgUHCAUICAcICAcICAMFCAMKCAgICAcIBwgICgcICAcDBwgHAAAADgsHAAcHBAcLCQsLBAUFBwcFBwQLCQUJCQkJCQkJCQQEBwcHCQsJCQcJBwcJCQcJCQcLCQkJCQkJBwkJCwkJBwULBQcJBQkJBwkJBwkJBAUJBAsJCQkJBwkHCQkLBwkJBwQHCQcAAAAPCwgACAgECAsJCwsEBgYICAYIBAsJBgkJCQkJCQkJBAQICAgJCwkJCAkICAkJCAkJCAsJCQkJCQkICQkLCQkIBgsGCAkGCQkICQkICQkEBgkECwkJCQkICQgJCQsICQkIBAgJCAAAABAMCAAICAQIDAoMDAQGBggIBggEDAoGCgoKCgoKCgoEBAgICAoMCgoICggICgoICgoIDAoKCgoKCggKCgwKCggGDAYICgYKCggKCggKCgQGCgQMCgoKCggKCAoKDAgKCggECAoIAAAAEQ0JAAkJBAkNCw0NBAYGCQkGCQQNCwYLCwsLCwsLCwQECQkJCw0LCwkLCQkLCwkLCwkNCwsLCwsLCQsLDQsLCQYNBgkLBgsLCQsLCQsLBAYLBA0LCwsLCQsJCwsNCQsLCQQJCwkAAAASDgkACQkFCQ4LDg4FBwcJCQcJBQ4LBwsLCwsLCwsLBQUJCQkLDgsLCQsJCQsLCQsLCQ4LCwsLCwsJCwsOCwsJBw4HCQsHCwsJCwsJCwsFBwsFDgsLCwsJCwkLCw4JCwsJBQkLCQAAABMOCgAKCgUKDgwODgUHBwoKBwoFDgwHDAwMDAwMDAwFBQoKCgwODAwKDAoKDAwKDAwKDgwMDAwMDAoMDA4MDAoHDgcKDAcMDAoMDAoMDAUHDAUODAwMDAoMCgwMDgoMDAoFCgwKAAAAFA8KAAoKBQoPDQ8PBQgICgoICgUPDQgNDQ0NDQ0NDQUFCgoKDQ8NDQoNCgoNDQoNDQoPDQ0NDQ0NCg0NDw0NCggPCAoNCA0NCg0NCg0NBQgNBQ8NDQ0NCg0KDQ0PCg0NCgUKDQoAAAAVEAsACwsFCxANEBAFCAgLCwgLBRANCA0NDQ0NDQ0NBQULCwsNEA0NCw0LCw0NCw0NCxANDQ0NDQ0LDQ0QDQ0LCBAICw0IDQ0LDQ0LDQ0FCA0FEA0NDQ0LDQsNDRALDQ0LBQsNCwAAABYRCwALCwYLEQ4REQYICAsLCAsGEQ4IDg4ODg4ODg4GBgsLCw4RDg4LDgsLDg4LDg4LEQ4ODg4ODgsODhEODgsIEQgLDggODgsODgsODgYIDgYRDg4ODgsOCw4OEQsODgsGCw4LAAAAFxEMAAwMBgwRDhERBgkJDAwJDAYRDgkODg4ODg4ODgYGDAwMDhEODgwODAwODgwODgwRDg4ODg4ODA4OEQ4ODAkRCQwOCQ4ODA4ODA4OBgkOBhEODg4ODA4MDg4RDA4ODAYMDgwAAAAYEgwADAwGDBIPEhIGCQkMDAkMBhIPCQ8PDw8PDw8PBgYMDAwPEg8PDA8MDA8PDA8PDBIPDw8PDw8MDw8SDw8MCRIJDA8JDw8MDw8MDw8GCQ8GEg8PDw8MDwwPDxIMDw8MBgwPDAAAAAAAAiYBkAAFAAECvAKKAAAAjwK8AooAAAHFADIBAwAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBbHRzAEAAICAQAu7/BgAAAu4A+gAAAAEAAAABAABS+rcfXw889QAAA+gAAAAAuqZ4/QAAAAC6pnj9AAD/BgJxAu4AAAADAAIAAQAAAAAAAQAAAu7/BgAAAu4AAAA+AnEAAQAAAAAAAAAAAAAAAAAAAGMAAQAAAGMAIAAFAAAAAAACAAgAQAAKAAAAYACnAAEAAQ==");
js_Boot.__toStr = ({ }).toString;
dn_heaps_assets_SfxDirectory._CACHE = new haxe_ds_StringMap();
dn_heaps_Sfx.FILEPATH_TO_UID = new haxe_ds_StringMap();
dn_heaps_Sfx.UNIQ = 0;
dn_heaps_Sfx.SPATIAL_LISTENER_X = 0.;
dn_heaps_Sfx.SPATIAL_LISTENER_Y = 0.;
dn_heaps_Sfx.SPATIAL_LISTENER_RANGE = 1.;
dn_heaps_Sfx.ON_PLAY_CB = new haxe_ds_IntMap();
dn_heaps_Sfx.SOUND_VOLUMES_OVERRIDE = new haxe_ds_IntMap();
dn_heaps_Sfx.SOUND_DEFAULT_GROUPS = new haxe_ds_IntMap();
dn_heaps_Sfx.GLOBAL_GROUPS = new haxe_ds_IntMap();
dn_heaps_Sfx.DEFAULT_GROUP_ID = 0;
Assets.SOUNDS = (function($this) {
	var $r;
	var ambiant = function(quickPlayVolume) {
		if(!Object.prototype.hasOwnProperty.call(dn_heaps_assets_SfxDirectory._CACHE.h,"sfx/ambiant.ogg")) {
			var this1 = dn_heaps_assets_SfxDirectory._CACHE;
			var value = hxd_Res.load("sfx/ambiant.ogg").toSound();
			this1.h["sfx/ambiant.ogg"] = value;
		}
		var snd = dn_heaps_assets_SfxDirectory._CACHE.h["sfx/ambiant.ogg"];
		if(quickPlayVolume != null) {
			var s = new dn_heaps_Sfx(snd);
			return s.play(null,quickPlayVolume);
		} else {
			return new dn_heaps_Sfx(snd);
		}
	};
	var close = function(quickPlayVolume) {
		if(!Object.prototype.hasOwnProperty.call(dn_heaps_assets_SfxDirectory._CACHE.h,"sfx/close.wav")) {
			var this1 = dn_heaps_assets_SfxDirectory._CACHE;
			var value = hxd_Res.load("sfx/close.wav").toSound();
			this1.h["sfx/close.wav"] = value;
		}
		var snd = dn_heaps_assets_SfxDirectory._CACHE.h["sfx/close.wav"];
		if(quickPlayVolume != null) {
			var s = new dn_heaps_Sfx(snd);
			return s.play(null,quickPlayVolume);
		} else {
			return new dn_heaps_Sfx(snd);
		}
	};
	var door = function(quickPlayVolume) {
		if(!Object.prototype.hasOwnProperty.call(dn_heaps_assets_SfxDirectory._CACHE.h,"sfx/door.wav")) {
			var this1 = dn_heaps_assets_SfxDirectory._CACHE;
			var value = hxd_Res.load("sfx/door.wav").toSound();
			this1.h["sfx/door.wav"] = value;
		}
		var snd = dn_heaps_assets_SfxDirectory._CACHE.h["sfx/door.wav"];
		if(quickPlayVolume != null) {
			var s = new dn_heaps_Sfx(snd);
			return s.play(null,quickPlayVolume);
		} else {
			return new dn_heaps_Sfx(snd);
		}
	};
	var footstep1 = function(quickPlayVolume) {
		if(!Object.prototype.hasOwnProperty.call(dn_heaps_assets_SfxDirectory._CACHE.h,"sfx/footstep1.wav")) {
			var this1 = dn_heaps_assets_SfxDirectory._CACHE;
			var value = hxd_Res.load("sfx/footstep1.wav").toSound();
			this1.h["sfx/footstep1.wav"] = value;
		}
		var snd = dn_heaps_assets_SfxDirectory._CACHE.h["sfx/footstep1.wav"];
		if(quickPlayVolume != null) {
			var s = new dn_heaps_Sfx(snd);
			return s.play(null,quickPlayVolume);
		} else {
			return new dn_heaps_Sfx(snd);
		}
	};
	var footstep2 = function(quickPlayVolume) {
		if(!Object.prototype.hasOwnProperty.call(dn_heaps_assets_SfxDirectory._CACHE.h,"sfx/footstep2.wav")) {
			var this1 = dn_heaps_assets_SfxDirectory._CACHE;
			var value = hxd_Res.load("sfx/footstep2.wav").toSound();
			this1.h["sfx/footstep2.wav"] = value;
		}
		var snd = dn_heaps_assets_SfxDirectory._CACHE.h["sfx/footstep2.wav"];
		if(quickPlayVolume != null) {
			var s = new dn_heaps_Sfx(snd);
			return s.play(null,quickPlayVolume);
		} else {
			return new dn_heaps_Sfx(snd);
		}
	};
	var help = function(quickPlayVolume) {
		if(!Object.prototype.hasOwnProperty.call(dn_heaps_assets_SfxDirectory._CACHE.h,"sfx/help.wav")) {
			var this1 = dn_heaps_assets_SfxDirectory._CACHE;
			var value = hxd_Res.load("sfx/help.wav").toSound();
			this1.h["sfx/help.wav"] = value;
		}
		var snd = dn_heaps_assets_SfxDirectory._CACHE.h["sfx/help.wav"];
		if(quickPlayVolume != null) {
			var s = new dn_heaps_Sfx(snd);
			return s.play(null,quickPlayVolume);
		} else {
			return new dn_heaps_Sfx(snd);
		}
	};
	var hit = function(quickPlayVolume) {
		if(!Object.prototype.hasOwnProperty.call(dn_heaps_assets_SfxDirectory._CACHE.h,"sfx/hit.wav")) {
			var this1 = dn_heaps_assets_SfxDirectory._CACHE;
			var value = hxd_Res.load("sfx/hit.wav").toSound();
			this1.h["sfx/hit.wav"] = value;
		}
		var snd = dn_heaps_assets_SfxDirectory._CACHE.h["sfx/hit.wav"];
		if(quickPlayVolume != null) {
			var s = new dn_heaps_Sfx(snd);
			return s.play(null,quickPlayVolume);
		} else {
			return new dn_heaps_Sfx(snd);
		}
	};
	var pick = function(quickPlayVolume) {
		if(!Object.prototype.hasOwnProperty.call(dn_heaps_assets_SfxDirectory._CACHE.h,"sfx/pick.wav")) {
			var this1 = dn_heaps_assets_SfxDirectory._CACHE;
			var value = hxd_Res.load("sfx/pick.wav").toSound();
			this1.h["sfx/pick.wav"] = value;
		}
		var snd = dn_heaps_assets_SfxDirectory._CACHE.h["sfx/pick.wav"];
		if(quickPlayVolume != null) {
			var s = new dn_heaps_Sfx(snd);
			return s.play(null,quickPlayVolume);
		} else {
			return new dn_heaps_Sfx(snd);
		}
	};
	var robinet = function(quickPlayVolume) {
		if(!Object.prototype.hasOwnProperty.call(dn_heaps_assets_SfxDirectory._CACHE.h,"sfx/robinet.wav")) {
			var this1 = dn_heaps_assets_SfxDirectory._CACHE;
			var value = hxd_Res.load("sfx/robinet.wav").toSound();
			this1.h["sfx/robinet.wav"] = value;
		}
		var snd = dn_heaps_assets_SfxDirectory._CACHE.h["sfx/robinet.wav"];
		if(quickPlayVolume != null) {
			var s = new dn_heaps_Sfx(snd);
			return s.play(null,quickPlayVolume);
		} else {
			return new dn_heaps_Sfx(snd);
		}
	};
	var select = function(quickPlayVolume) {
		if(!Object.prototype.hasOwnProperty.call(dn_heaps_assets_SfxDirectory._CACHE.h,"sfx/select.wav")) {
			var this1 = dn_heaps_assets_SfxDirectory._CACHE;
			var value = hxd_Res.load("sfx/select.wav").toSound();
			this1.h["sfx/select.wav"] = value;
		}
		var snd = dn_heaps_assets_SfxDirectory._CACHE.h["sfx/select.wav"];
		if(quickPlayVolume != null) {
			var s = new dn_heaps_Sfx(snd);
			return s.play(null,quickPlayVolume);
		} else {
			return new dn_heaps_Sfx(snd);
		}
	};
	var smallHit = function(quickPlayVolume) {
		if(!Object.prototype.hasOwnProperty.call(dn_heaps_assets_SfxDirectory._CACHE.h,"sfx/smallHit.wav")) {
			var this1 = dn_heaps_assets_SfxDirectory._CACHE;
			var value = hxd_Res.load("sfx/smallHit.wav").toSound();
			this1.h["sfx/smallHit.wav"] = value;
		}
		var snd = dn_heaps_assets_SfxDirectory._CACHE.h["sfx/smallHit.wav"];
		if(quickPlayVolume != null) {
			var s = new dn_heaps_Sfx(snd);
			return s.play(null,quickPlayVolume);
		} else {
			return new dn_heaps_Sfx(snd);
		}
	};
	var success = function(quickPlayVolume) {
		if(!Object.prototype.hasOwnProperty.call(dn_heaps_assets_SfxDirectory._CACHE.h,"sfx/success.wav")) {
			var this1 = dn_heaps_assets_SfxDirectory._CACHE;
			var value = hxd_Res.load("sfx/success.wav").toSound();
			this1.h["sfx/success.wav"] = value;
		}
		var snd = dn_heaps_assets_SfxDirectory._CACHE.h["sfx/success.wav"];
		if(quickPlayVolume != null) {
			var s = new dn_heaps_Sfx(snd);
			return s.play(null,quickPlayVolume);
		} else {
			return new dn_heaps_Sfx(snd);
		}
	};
	var teleport = function(quickPlayVolume) {
		if(!Object.prototype.hasOwnProperty.call(dn_heaps_assets_SfxDirectory._CACHE.h,"sfx/teleport.ogg")) {
			var this1 = dn_heaps_assets_SfxDirectory._CACHE;
			var value = hxd_Res.load("sfx/teleport.ogg").toSound();
			this1.h["sfx/teleport.ogg"] = value;
		}
		var snd = dn_heaps_assets_SfxDirectory._CACHE.h["sfx/teleport.ogg"];
		if(quickPlayVolume != null) {
			var s = new dn_heaps_Sfx(snd);
			return s.play(null,quickPlayVolume);
		} else {
			return new dn_heaps_Sfx(snd);
		}
	};
	$r = { ambiant : ambiant, close : close, door : door, footstep1 : footstep1, footstep2 : footstep2, help : help, hit : hit, pick : pick, robinet : robinet, select : select, smallHit : smallHit, success : success, teleport : teleport, footstep : new dn_heaps_RandomSfxList(null,["sfx/footstep1.wav","sfx/footstep2.wav"]), _precacheAllSounds : function() {
		var this1 = dn_heaps_assets_SfxDirectory._CACHE;
		var value = hxd_Res.load("sfx/ambiant.ogg").toSound();
		this1.h["sfx/ambiant.ogg"] = value;
		var this1 = dn_heaps_assets_SfxDirectory._CACHE;
		var value = hxd_Res.load("sfx/close.wav").toSound();
		this1.h["sfx/close.wav"] = value;
		var this1 = dn_heaps_assets_SfxDirectory._CACHE;
		var value = hxd_Res.load("sfx/door.wav").toSound();
		this1.h["sfx/door.wav"] = value;
		var this1 = dn_heaps_assets_SfxDirectory._CACHE;
		var value = hxd_Res.load("sfx/footstep1.wav").toSound();
		this1.h["sfx/footstep1.wav"] = value;
		var this1 = dn_heaps_assets_SfxDirectory._CACHE;
		var value = hxd_Res.load("sfx/footstep2.wav").toSound();
		this1.h["sfx/footstep2.wav"] = value;
		var this1 = dn_heaps_assets_SfxDirectory._CACHE;
		var value = hxd_Res.load("sfx/help.wav").toSound();
		this1.h["sfx/help.wav"] = value;
		var this1 = dn_heaps_assets_SfxDirectory._CACHE;
		var value = hxd_Res.load("sfx/hit.wav").toSound();
		this1.h["sfx/hit.wav"] = value;
		var this1 = dn_heaps_assets_SfxDirectory._CACHE;
		var value = hxd_Res.load("sfx/pick.wav").toSound();
		this1.h["sfx/pick.wav"] = value;
		var this1 = dn_heaps_assets_SfxDirectory._CACHE;
		var value = hxd_Res.load("sfx/robinet.wav").toSound();
		this1.h["sfx/robinet.wav"] = value;
		var this1 = dn_heaps_assets_SfxDirectory._CACHE;
		var value = hxd_Res.load("sfx/select.wav").toSound();
		this1.h["sfx/select.wav"] = value;
		var this1 = dn_heaps_assets_SfxDirectory._CACHE;
		var value = hxd_Res.load("sfx/smallHit.wav").toSound();
		this1.h["sfx/smallHit.wav"] = value;
		var this1 = dn_heaps_assets_SfxDirectory._CACHE;
		var value = hxd_Res.load("sfx/success.wav").toSound();
		this1.h["sfx/success.wav"] = value;
		var this1 = dn_heaps_assets_SfxDirectory._CACHE;
		var value = hxd_Res.load("sfx/teleport.ogg").toSound();
		this1.h["sfx/teleport.ogg"] = value;
	}};
	return $r;
}(this));
Const.GRID = 8;
Const.BG_COLOR = 1381653;
Const.GAMEZONE_WID = 118;
Const.WID = 140;
Const.HEI = 180;
Const.SCALE = 1;
h2d_filter_Filter.defaultUseScreenResolution = false;
h3d_shader_ScreenShader.SRC = "HXSLF2gzZC5zaGFkZXIuU2NyZWVuU2hhZGVyBwEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACghfX2luaXRfXw4GAAALBnZlcnRleA4GAAACAgoAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAALAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAA";
_$DistortFilter_InternalShader.SRC = "HXSLHV9EaXN0b3J0RmlsdGVyLkludGVybmFsU2hhZGVyEgEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACgN0ZXgKAgAACwhub2lzZVRleAoCAAAMBHRpbWUDAgAADQlpbnRlbnNpdHkDAgAADgZzcGVlZFgDAgAADwh3YXZlTGVuWAMCAAAQB29mZnNldFgDAgAAEQZzcGVlZFkDAgAAEgh3YXZlTGVuWQMCAAATB29mZnNldFkDAgAAFAhfX2luaXRfXw4GAAAVBnZlcnRleA4GAAAWCGZyYWdtZW50DgYAAAMCFAAABQIGBAIHBQwCCAUMBQwGBAIJBQoCAwUKBQoAABUAAAUBBgQCBgUMCQMqDgQKAgIFCgAAAwYBCgICBQoEAAMCBAMDAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBQwAARYAAAUFCBcCdXYFCgQAAAIJBQoACBgFbm9pc2UFDAQAAAkDIQ4CAgsKAhcFCgUMAAaACgIXBQoAAAMGAQYBCQMDDgEGAAYABgIGAQEDH4XrUbgeGUADCgIXBQoEAAMDAg8DAwYBAgwDAg4DAwMGAQoCGAUMAAADAQMAAAAAAAAAQAMDAwMCEAMDAg0DAwMGgAoCFwUKBAADBgEGAQkDAw4BBgAGAAYAAQMAAAAAAADwPwMGAgYBAQMfhetRuB4ZQAMKAhcFCgAAAwMCEgMDAwYBAgwDAhEDAwMGAQoCGAUMBAADAQMAAAAAAAAAQAMDAwMCEwMDAg0DAwMGBAIIBQwJAyEOAgIKCgIXBQoFDAUMAA";
dn_Process.MAX_PROCESSES = 1024;
dn_Process.FIXED_UPDATE_FPS = 30;
dn_Process.CUSTOM_STAGE_WIDTH = -1;
dn_Process.CUSTOM_STAGE_HEIGHT = -1;
dn_Process.UNIQ_ID = 0;
dn_Process.ROOTS = new dn_struct_FixedArray("RootProcesses",dn_Process.MAX_PROCESSES);
dn_Process.BEGINNING_OF_FRAME_CALLBACKS = new dn_struct_FixedArray(null,256);
dn_Process.END_OF_FRAME_CALLBACKS = new dn_struct_FixedArray(null,256);
dn_Process.RESIZE_REQUESTED = true;
dn_Process.PROFILING = false;
dn_Process.PROFILER_TIMES = new haxe_ds_StringMap();
Game.INAMES = (function($this) {
	var $r;
	var _g = new haxe_ds_StringMap();
	_g.h["picture"] = "Old picture";
	_g.h["picPart1"] = "Ripped photo (1/3)";
	_g.h["picPart2"] = "Ripped photo (2/3)";
	_g.h["picPart3"] = "Ripped photo (3/3)";
	_g.h["chestKey"] = "Small copper key";
	_g.h["knife"] = "Blunt knife";
	_g.h["ring"] = "Wedding ring";
	_g.h["cupKey"] = "Large iron key";
	_g.h["broom"] = "Broom";
	_g.h["finalLetter"] = "A letter";
	$r = _g;
	return $r;
}(this));
Game.EXTENDED = true;
Game.LOOK = "Look";
Game.PICK = "Take";
Game.USE = "Use";
Game.OPEN = "Open";
Game.CLOSE = "Close";
Game.REMEMBER = "Remember";
Game.HELP = "I'm stuck!";
Game.ABOUT = "About";
Xml.Element = 0;
Xml.PCData = 1;
Xml.CData = 2;
Xml.Comment = 3;
Xml.DocType = 4;
Xml.ProcessingInstruction = 5;
Xml.Document = 6;
dn_Cooldown.__meta__ = { obj : { indexes : ["test","jump","a","b","c"]}};
dn_Cooldown.DEFAULT_COUNT_LIMIT = 512;
dn_Tweenie.DEFAULT_DURATION = 1000.0;
dn_data_GetText.VERBOSE = false;
dn_data_GetText.CONTEXT_DISAMB_SEP = "||@";
dn_data_GetText.COMMENT_REG = new EReg("(\\|\\|\\?(.*?))($|\\|\\|)","i");
dn_data_GetText.CONTEXT_DISAMB_REG = new EReg("(\\|\\|@(.*?))($|\\|\\|)","i");
dn_data_GetText.TRANSLATOR_NOTE_REG = new EReg("(\\|\\|!(.*?))($|\\|\\|)","i");
dn_heaps_filter__$OverlayTexture_OverlayBlendShader.SRC = "HXSLMmRuLmhlYXBzLmZpbHRlci5fT3ZlcmxheVRleHR1cmUuT3ZlcmxheUJsZW5kU2hhZGVyDQEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACgd0ZXh0dXJlCgIAAAsHb3ZlcmxheQoCAAAMBWFscGhhAwIAAA0HdXZTY2FsZQUKAgAADghfX2luaXRfXw4GAAAPBnZlcnRleA4GAAAQDGJsZW5kT3ZlcmxheQ4GAAARCGZyYWdtZW50DgYAAAQCDgAABQIGBAIHBQwCCAUMBQwGBAIJBQoCAwUKBQoAAA8AAAUBBgQCBgUMCQMqDgQKAgIFCgAAAwYBCgICBQoEAAMCBAMDAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBQwAAxACEgRiYXNlBQsEAAATBWJsZW5kBQsEAAAFCwUBDQkDGA4DBgMBAwAAAAAAAPA/AwYBBgEBAwAAAAAAAABAAwQGAwEDAAAAAAAA8D8DAhIFCwULBQsFCwQGAwEDAAAAAAAA8D8DAhMFCwULBQsFCwULBgEGAQEDAAAAAAAAAEADAhIFCwULAhMFCwULCQMZDgICEgULCQMpDgEBAwAAAAAAAOA/AwULBQsFCwAAAREAAAUDCBQLc291cmNlQ29sb3IFDAQAAAkDIQ4CAgoKAgMFCgUMAAgVDG92ZXJsYXlDb2xvcgUMBAAACQMYDgMJAyoOAQEDAAAAAAAA4D8DBQwJAyEOAgILCgYBAgMFCgINBQoFCgUMAgwDBQwABgQKAggFDJMDBQwJAyoOAgkCEA4CCgIUBQySAAULCgIVBQySAAULBQsKAhQFDAwAAwUMBQwA";
dn_heaps_filter__$PixelOutline_InternalShader.SRC = "HXSLLGRuLmhlYXBzLmZpbHRlci5fUGl4ZWxPdXRsaW5lLkludGVybmFsU2hhZGVyEAEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACgd0ZXh0dXJlCgIAAAsJdGV4ZWxTaXplBQoCAAAMDG91dGxpbmVDb2xvcgUMAgAADRFrbm9ja091dFRocmVzaG9sZAMCAAAOB2xlZnRNdWwDAgAADwhyaWdodE11bAMCAAAQBnRvcE11bAMCAAARCWJvdHRvbU11bAMCAAASCF9faW5pdF9fDgYAABMGdmVydGV4DgYAABQIZnJhZ21lbnQOBgAAAwISAAAFAgYEAgcFDAIIBQwFDAYEAgkFCgIDBQoFCgAAEwAABQEGBAIGBQwJAyoOBAoCAgUKAAADBgEKAgIFCgQAAwIEAwMBAwAAAAAAAAAAAwEDAAAAAAAA8D8DBQwFDAABFAAABQQIFQhjdXJDb2xvcgUMBAAACQMhDgICCgoCAwUKBQwACBYGb25FZGdlAwQAAAQGAQQGAwEDAAAAAAAA8D8DCgIVBQwMAAMDAwkDFg4CBgEKCQMhDgICCgoJAygOAgYACgIDBQoAAAMKAgsFCgAAAwMKAgMFCgQAAwUKBQwMAAMCDgMDCQMWDgIGAQoJAyEOAgIKCgkDKA4CBgMKAgMFCgAAAwoCCwUKAAADAwoCAwUKBAADBQoFDAwAAwIPAwMJAxYOAgYBCgkDIQ4CAgoKCQMoDgIKAgMFCgAAAwYACgIDBQoEAAMKAgsFCgQAAwMFCgUMDAADAhADAwYBCgkDIQ4CAgoKCQMoDgIKAgMFCgAAAwYDCgIDBQoEAAMKAgsFCgQAAwMFCgUMDAADAhEDAwMDAwMDAAgXAWEDBAAACQMWDgIGAQIWAwoCDAUMDAADAwkDFQ4CAg0DCgIVBQwMAAMDAwAGBAIHBQwJAyoOAgYBCQMYDgMKAhUFDJIABQsKAgwFDJIABQsCFgMFCwIXAwULAhcDBQwFDAA";
dn_heaps_slib_AnimManager.ANYTHING = "*";
h2d_Object.tmpPoint = new h2d_col_Point();
dn_heaps_slib_SpriteLib.DISABLE_ANIM_UPDATES = false;
dn_legacy_Controller.UNIQ_ID = 0;
dn_legacy_Controller.LONG_PRESS = 0.35;
dn_legacy_Controller.SHORT_PRESS = 0.17;
dn_legacy_Controller.ALL = [];
hxd_Pad.CONFIG_JS_STD = { A : 0, B : 1, X : 2, Y : 3, LB : 4, RB : 5, LT : 6, RT : 7, back : 8, start : 9, analogClick : 10, ranalogClick : 11, dpadUp : 12, dpadDown : 13, dpadLeft : 14, dpadRight : 15, analogX : 17, analogY : 18, ranalogX : 19, ranalogY : 20, names : ["A","B","X","Y","LB","RB","LT","RT","Select","Start","LCLK","RCLK","DUp","DDown","DLeft","DRight","LX","LY","RX","RY"]};
hxd_Pad.CONFIG_JS_DS4 = { A : 0, B : 1, X : 2, Y : 3, LB : 4, RB : 5, LT : 6, RT : 7, back : 8, start : 9, analogClick : 10, ranalogClick : 11, dpadUp : 12, dpadDown : 13, dpadLeft : 14, dpadRight : 15, analogX : 18, analogY : 19, ranalogX : 20, ranalogY : 21, names : ["A","B","X","Y","LB","RB","LT","RT","Select","Start","LCLK","RCLK","DUp","DDown","DLeft","DRight","LX","LY","RX","RY"]};
hxd_Pad.CONFIG_JS_DS4_FF = { A : 1, B : 2, X : 0, Y : 3, LB : 4, RB : 5, LT : 6, RT : 7, back : 8, start : 9, analogClick : 10, ranalogClick : 11, dpadUp : 9000, dpadDown : 9000, dpadLeft : 9000, dpadRight : 9000, analogX : 18, analogY : 19, ranalogX : 20, ranalogY : 23, names : ["A","B","X","Y","LB","RB","LT","RT","Select","Start","LCLK","RCLK","DUp","DDown","DLeft","DRight","LX","LY","RX","RY"]};
hxd_Pad.DEFAULT_CONFIG = hxd_Pad.CONFIG_JS_STD;
hxd_Pad.initDone = false;
hxd_Pad.pads = new haxe_ds_IntMap();
dn_legacy_GamePad.ALL = [];
dn_legacy_GamePad.MAPPING = [hxd_Pad.DEFAULT_CONFIG.A,hxd_Pad.DEFAULT_CONFIG.B,hxd_Pad.DEFAULT_CONFIG.X,hxd_Pad.DEFAULT_CONFIG.Y,hxd_Pad.DEFAULT_CONFIG.back,hxd_Pad.DEFAULT_CONFIG.start,hxd_Pad.DEFAULT_CONFIG.LT,hxd_Pad.DEFAULT_CONFIG.RT,hxd_Pad.DEFAULT_CONFIG.LB,hxd_Pad.DEFAULT_CONFIG.RB,hxd_Pad.DEFAULT_CONFIG.analogClick,hxd_Pad.DEFAULT_CONFIG.ranalogClick,hxd_Pad.DEFAULT_CONFIG.dpadUp,hxd_Pad.DEFAULT_CONFIG.dpadDown,hxd_Pad.DEFAULT_CONFIG.dpadLeft,hxd_Pad.DEFAULT_CONFIG.dpadRight,hxd_Pad.DEFAULT_CONFIG.analogX,hxd_Pad.DEFAULT_CONFIG.analogX,hxd_Pad.DEFAULT_CONFIG.analogX,hxd_Pad.DEFAULT_CONFIG.analogY,hxd_Pad.DEFAULT_CONFIG.analogY,hxd_Pad.DEFAULT_CONFIG.analogY,hxd_Pad.DEFAULT_CONFIG.ranalogX,hxd_Pad.DEFAULT_CONFIG.ranalogX,hxd_Pad.DEFAULT_CONFIG.ranalogX,hxd_Pad.DEFAULT_CONFIG.ranalogY,hxd_Pad.DEFAULT_CONFIG.ranalogY,hxd_Pad.DEFAULT_CONFIG.ranalogY];
format_mp3_MPEG.Reserved = 1;
format_mp3_MPEG.V1_Bitrates = [[format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad],[format_mp3_Bitrate.BR_Free,format_mp3_Bitrate.BR_32,format_mp3_Bitrate.BR_40,format_mp3_Bitrate.BR_48,format_mp3_Bitrate.BR_56,format_mp3_Bitrate.BR_64,format_mp3_Bitrate.BR_80,format_mp3_Bitrate.BR_96,format_mp3_Bitrate.BR_112,format_mp3_Bitrate.BR_128,format_mp3_Bitrate.BR_160,format_mp3_Bitrate.BR_192,format_mp3_Bitrate.BR_224,format_mp3_Bitrate.BR_256,format_mp3_Bitrate.BR_320,format_mp3_Bitrate.BR_Bad],[format_mp3_Bitrate.BR_Free,format_mp3_Bitrate.BR_32,format_mp3_Bitrate.BR_48,format_mp3_Bitrate.BR_56,format_mp3_Bitrate.BR_64,format_mp3_Bitrate.BR_80,format_mp3_Bitrate.BR_96,format_mp3_Bitrate.BR_112,format_mp3_Bitrate.BR_128,format_mp3_Bitrate.BR_160,format_mp3_Bitrate.BR_192,format_mp3_Bitrate.BR_224,format_mp3_Bitrate.BR_256,format_mp3_Bitrate.BR_320,format_mp3_Bitrate.BR_384,format_mp3_Bitrate.BR_Bad],[format_mp3_Bitrate.BR_Free,format_mp3_Bitrate.BR_32,format_mp3_Bitrate.BR_64,format_mp3_Bitrate.BR_96,format_mp3_Bitrate.BR_128,format_mp3_Bitrate.BR_160,format_mp3_Bitrate.BR_192,format_mp3_Bitrate.BR_224,format_mp3_Bitrate.BR_256,format_mp3_Bitrate.BR_288,format_mp3_Bitrate.BR_320,format_mp3_Bitrate.BR_352,format_mp3_Bitrate.BR_384,format_mp3_Bitrate.BR_416,format_mp3_Bitrate.BR_448,format_mp3_Bitrate.BR_Bad]];
format_mp3_MPEG.V2_Bitrates = [[format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad],[format_mp3_Bitrate.BR_Free,format_mp3_Bitrate.BR_8,format_mp3_Bitrate.BR_16,format_mp3_Bitrate.BR_24,format_mp3_Bitrate.BR_32,format_mp3_Bitrate.BR_40,format_mp3_Bitrate.BR_48,format_mp3_Bitrate.BR_56,format_mp3_Bitrate.BR_64,format_mp3_Bitrate.BR_80,format_mp3_Bitrate.BR_96,format_mp3_Bitrate.BR_112,format_mp3_Bitrate.BR_128,format_mp3_Bitrate.BR_144,format_mp3_Bitrate.BR_160,format_mp3_Bitrate.BR_Bad],[format_mp3_Bitrate.BR_Free,format_mp3_Bitrate.BR_8,format_mp3_Bitrate.BR_16,format_mp3_Bitrate.BR_24,format_mp3_Bitrate.BR_32,format_mp3_Bitrate.BR_40,format_mp3_Bitrate.BR_48,format_mp3_Bitrate.BR_56,format_mp3_Bitrate.BR_64,format_mp3_Bitrate.BR_80,format_mp3_Bitrate.BR_96,format_mp3_Bitrate.BR_112,format_mp3_Bitrate.BR_128,format_mp3_Bitrate.BR_144,format_mp3_Bitrate.BR_160,format_mp3_Bitrate.BR_Bad],[format_mp3_Bitrate.BR_Free,format_mp3_Bitrate.BR_32,format_mp3_Bitrate.BR_48,format_mp3_Bitrate.BR_56,format_mp3_Bitrate.BR_64,format_mp3_Bitrate.BR_80,format_mp3_Bitrate.BR_96,format_mp3_Bitrate.BR_112,format_mp3_Bitrate.BR_128,format_mp3_Bitrate.BR_144,format_mp3_Bitrate.BR_160,format_mp3_Bitrate.BR_176,format_mp3_Bitrate.BR_192,format_mp3_Bitrate.BR_224,format_mp3_Bitrate.BR_256,format_mp3_Bitrate.BR_Bad]];
format_mp3_MPEG.SamplingRates = [[format_mp3_SamplingRate.SR_11025,format_mp3_SamplingRate.SR_12000,format_mp3_SamplingRate.SR_8000,format_mp3_SamplingRate.SR_Bad],[format_mp3_SamplingRate.SR_Bad,format_mp3_SamplingRate.SR_Bad,format_mp3_SamplingRate.SR_Bad,format_mp3_SamplingRate.SR_Bad],[format_mp3_SamplingRate.SR_22050,format_mp3_SamplingRate.SR_24000,format_mp3_SamplingRate.SR_12000,format_mp3_SamplingRate.SR_Bad],[format_mp3_SamplingRate.SR_44100,format_mp3_SamplingRate.SR_48000,format_mp3_SamplingRate.SR_32000,format_mp3_SamplingRate.SR_Bad]];
format_mp3_CLayer.LReserved = 0;
h3d_Buffer.GUID = 0;
h3d_Engine.SOFTWARE_DRIVER = false;
h3d_Engine.ANTIALIASING = 0;
h3d_impl_InputNames.UID = 0;
h3d_impl_InputNames.CACHE = new haxe_ds_StringMap();
h3d_impl_GlDriver.ALLOW_WEBGL2 = true;
h3d_impl_GlDriver.BLACK = new h3d_Vector(0,0,0,0);
h3d_impl_GlDriver.outOfMemoryCheck = false;
h3d_impl_GlDriver.TFILTERS = [[[9728,9728],[9729,9729]],[[9728,9984],[9729,9985]],[[9728,9986],[9729,9987]]];
h3d_impl_GlDriver.TWRAP = [33071,10497];
h3d_impl_GlDriver.FACES = [0,1028,1029,1032];
h3d_impl_GlDriver.BLEND = [1,0,770,768,772,774,771,769,773,775,32769,32771,32770,32772,776];
h3d_impl_GlDriver.COMPARE = [519,512,514,517,516,518,513,515];
h3d_impl_GlDriver.STENCIL_OP = [7680,0,7681,7682,34055,7683,34056,5386];
h3d_impl_GlDriver.OP = [32774,32778,32779,32775,32776];
h3d_impl_GlDriver.CUBE_FACES = [34069,34070,34071,34072,34073,34074];
h3d_impl_GlDriver.CBUFFERS = (function($this) {
	var $r;
	var _g = [];
	{
		var _g1 = 0;
		while(_g1 < 32) {
			var i = _g1++;
			var _g2 = [];
			var _g3 = 0;
			var _g4 = i;
			while(_g3 < _g4) {
				var k = _g3++;
				_g2.push(36064 + k);
			}
			_g.push(_g2);
		}
	}
	$r = _g;
	return $r;
}(this));
h3d_impl_MemoryManager.ALL_FLAGS = h3d_BufferFlag.__empty_constructs__.slice();
h3d_mat_Defaults.defaultKillAlphaThreshold = 0.5;
h3d_mat_Defaults.loadingTextureColor = -65281;
h3d_mat_MaterialSetup.current = new h3d_mat_MaterialSetup("Default");
h3d_mat_Texture.UID = 0;
h3d_mat_Texture.PREVENT_AUTO_DISPOSE = 2147483647;
h3d_mat_Texture.nativeFormat = hxd_PixelFormat.RGBA;
h3d_pass_Blur.__meta__ = { obj : { ignore : ["shader"]}};
h3d_pass__$Border_BorderShader.SRC = "HXSLHWgzZC5wYXNzLl9Cb3JkZXIuQm9yZGVyU2hhZGVyCQEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACgVjb2xvcgUMAgAACwhfX2luaXRfXw4GAAAMBnZlcnRleA4GAAANCGZyYWdtZW50DgYAAAMCCwAABQIGBAIHBQwCCAUMBQwGBAIJBQoCAwUKBQoAAAwAAAUBBgQCBgUMCQMqDgQKAgIFCgAAAwYBCgICBQoEAAMCBAMDAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBQwAAQ0AAAUBBgQCCAUMAgoFDAUMAA";
h3d_pass_ColorMatrixShader.SRC = "HXSLGmgzZC5wYXNzLkNvbG9yTWF0cml4U2hhZGVyFQEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACgd0ZXh0dXJlCgIAAAsGbWF0cml4BwIAAAwIdXNlQWxwaGECAgABAAAAAAANB3VzZU1hc2sCAgABAAAAAAAOCm1hc2tJbnZlcnQCAgABAAAAAAAPD2hhc1NlY29uZE1hdHJpeAICAAEAAAAAABAHbWF0cml4MgcCAAARBG1hc2sKAgAAEghtYXNrTWF0QQULAgAAEwhtYXNrTWF0QgULAgAAFAltYXNrUG93ZXIDAgAAFQttYXNrQ2hhbm5lbAUMAgAAFghfX2luaXRfXw4GAAAXBnZlcnRleA4GAAAYBWFwcGx5DgYAABkIZnJhZ21lbnQOBgAABAIWAAAFAgYEAgcFDAIIBQwFDAYEAgkFCgIDBQoFCgAAFwAABQEGBAIGBQwJAyoOBAoCAgUKAAADBgEKAgIFCgQAAwIEAwMBAwAAAAAAAAAAAwEDAAAAAAAA8D8DBQwFDAADGAIaBWNvbG9yBQwEAAAbA21hdAcEAAAFDAUBDQsCDAIGAQIaBQwCGwcFDAYBCQMqDgIKAhoFDJIABQsBAwAAAAAAAPA/AwUMAhsHBQwFDAAAARkAAAUBCwINAgUFCBwFY29sb3IFDAQAAAkDIQ4CAgoKAgMFCgUMAAgdAnV2BQsEAAAJAykOAgIDBQoBAwAAAAAAAPA/AwULAAgeAWsDBAAACQMIDgIJAx0OAgkDIQ4CAhEKCQMoDgIJAx0OAgIdBQsCEgULAwkDHQ4CAh0FCwITBQsDBQoFDAIVBQwDAhQDAwAIHwZjb2xvcjIFDAQAAAsCDwIJAhgOAgIcBQwCEAcFDAIcBQwFDAAGBAIHBQwLAg4CCQMYDgMCHwUMCQIYDgICHAUMAgsHBQwCHgMFDAkDGA4DCQIYDgICHAUMAgsHBQwCHwUMAh4DBQwFDAUMAAYEAgcFDAkCGA4CCQMhDgICCgoCAwUKBQwCCwcFDAUMAAA";
h3d_pass__$Copy_ArrayCopyShader.SRC = "HXSLHmgzZC5wYXNzLl9Db3B5LkFycmF5Q29weVNoYWRlcgoBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoHdGV4dHVyZQsCAAALBWxheWVyAQIAAAwIX19pbml0X18OBgAADQZ2ZXJ0ZXgOBgAADghmcmFnbWVudA4GAAADAgwAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAANAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEOAAAFAQYEAggFDAkDIQ4CAgoLCQMpDgICCQUKCQMmDgECCwEDBQsFDAUMAA";
h3d_pass__$Copy_CopyShader.SRC = "HXSLGWgzZC5wYXNzLl9Db3B5LkNvcHlTaGFkZXIJAQVpbnB1dA0BAgIIcG9zaXRpb24FCgEBAAMCdXYFCgEBAAEAAAQFZmxpcFkDAgAABQZvdXRwdXQNAgIGCHBvc2l0aW9uBQwEBQAHBWNvbG9yBQwEBQAEAAAICnBpeGVsQ29sb3IFDAQAAAkMY2FsY3VsYXRlZFVWBQoEAAAKB3RleHR1cmUKAgAACwhfX2luaXRfXw4GAAAMBnZlcnRleA4GAAANCGZyYWdtZW50DgYAAAMCCwAABQIGBAIHBQwCCAUMBQwGBAIJBQoCAwUKBQoAAAwAAAUBBgQCBgUMCQMqDgQKAgIFCgAAAwYBCgICBQoEAAMCBAMDAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBQwAAQ0AAAUBBgQCCAUMCQMhDgICCgoCCQUKBQwFDAA";
h3d_pass__$CubeCopy_CubeCopyShader.SRC = "HXSLIWgzZC5wYXNzLl9DdWJlQ29weS5DdWJlQ29weVNoYWRlcgoBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoHdGV4dHVyZQwCAAALA21hdAYCAAAMCF9faW5pdF9fDgYAAA0GdmVydGV4DgYAAA4IZnJhZ21lbnQOBgAAAwIMAAAFAgYEAgcFDAIIBQwFDAYEAgkFCgIDBQoFCgAADQAABQEGBAIGBQwJAyoOBAoCAgUKAAADBgEKAgIFCgQAAwIEAwMBAwAAAAAAAAAAAwEDAAAAAAAA8D8DBQwFDAABDgAABQIIDwJ1dgUKBAAABgMGAQIJBQoBAwAAAAAAAABAAwUKAQMAAAAAAADwPwMFCgAGBAIIBQwJAyEOAgIKDAkDHw4BBgEJAykOAgIPBQoBAwAAAAAAAPA/AwULAgsGBQsFCwUMBQwA";
h3d_pass__$HardwarePick_FixedColor.SRC = "HXSLIWgzZC5wYXNzLl9IYXJkd2FyZVBpY2suRml4ZWRDb2xvcgUBB2NvbG9ySUQFDAIAAAIIdmlld3BvcnQFDAIAAAMGb3V0cHV0DQECBAhwb3NpdGlvbgUMBAMABQdjb2xvcklEBQwEAwAEAAAGBnZlcnRleA4GAAAHCGZyYWdtZW50DgYAAAIABgAABQEGBAIEBQwGAQQGAAIEBQwGAQkDKg4DCgICBQwRAAUKAQMAAAAAAAAAAAMBAwAAAAAAAAAAAwUMCgIEBQwMAAMFDAUMBQwJAyoOAwoCAgUMOQAFCgEDAAAAAAAA8D8DAQMAAAAAAADwPwMFDAUMBQwAAQcAAAUBBgQCBQUMAgEFDAUMAA";
h3d_pass_ShaderManager.STRICT = true;
h3d_shader_AmbientLight.SRC = "HXSLF2gzZC5zaGFkZXIuQW1iaWVudExpZ2h0CgEGZ2xvYmFsDQECAgxhbWJpZW50TGlnaHQFCwABAAMQcGVyUGl4ZWxMaWdodGluZwIAAQEAAAAAAAAAAAQKcGl4ZWxDb2xvcgUMBAAABQ9saWdodFBpeGVsQ29sb3IFCwQAAAYKbGlnaHRDb2xvcgULBAAABwhhZGRpdGl2ZQICAAEAAAAAAAgIX19pbml0X18OBgAACRBfX2luaXRfX2ZyYWdtZW50DgYAAAoJY2FsY0xpZ2h0DgYAAAsGdmVydGV4DgYAAAwIZnJhZ21lbnQOBgAABQIIAAAFAQYEAgYFCwsCBwICAgULCQMpDgEBAwAAAAAAAAAAAwULBQsFCwACCQAABQEGBAIFBQsLAgcCAgIFCwkDKQ4BAQMAAAAAAAAAAAMFCwULBQsAAwoBDQpsaWdodENvbG9yBQsEAAAFCwUBDQsCBwICDQULBAYAAgIFCwYBCQMWDgIEBgMBAwAAAAAAAPA/AwICBQsFCwULAQMAAAAAAAAAAAMFCwINBQsFCwULBQsFCwAAAAsAAAUBCwcCAgMCAgaBCgIEBQySAAULCQIKDgECBgULBQsFCwAAAAEMAAAFAQsCAwIGgQoCBAUMkgAFCwkCCg4BAgUFCwULBQsAAAA";
h3d_shader_Base2d.SRC = "HXSLEWgzZC5zaGFkZXIuQmFzZTJkGwEFaW5wdXQNAQMCCHBvc2l0aW9uBQoBAQADAnV2BQoBAQAEBWNvbG9yBQwBAQABAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgEdGltZQMAAAAJBnpWYWx1ZQMCAAAKB3RleHR1cmUKAgAACw5zcHJpdGVQb3NpdGlvbgUMBAAADBBhYnNvbHV0ZVBvc2l0aW9uBQwEAAANCnBpeGVsQ29sb3IFDAQAAA4MdGV4dHVyZUNvbG9yBQwEAAAPDGNhbGN1bGF0ZWRVVgUKAwAAEAppc1JlbGF0aXZlAgIAAQAAAAAAEQVjb2xvcgUMAgAAEg9hYnNvbHV0ZU1hdHJpeEEFCwIAABMPYWJzb2x1dGVNYXRyaXhCBQsCAAAUDWZpbHRlck1hdHJpeEEFCwIAABUNZmlsdGVyTWF0cml4QgULAgAAFghoYXNVVlBvcwICAAEAAAAAABcFdXZQb3MFDAIAABgJa2lsbEFscGhhAgIAAQAAAAAAGQpwaXhlbEFsaWduAgIAAQAAAAAAGhBoYWxmUGl4ZWxJbnZlcnNlBQoCAAAbCXZpZXdwb3J0QQULAgAAHAl2aWV3cG9ydEIFCwIAAB0Ob3V0cHV0UG9zaXRpb24FDAQAAB4IX19pbml0X18OBgAAHwZ2ZXJ0ZXgOBgAAIAhmcmFnbWVudA4GAAADAh4AAAUGBgQCCwUMCQMqDgMCAgUKAgkDAQMAAAAAAADwPwMFDAUMCwIQAgUDBgQKAgwFDAAAAwkDHQ4CCQMpDgIKAgsFDBEABQoBAwAAAAAAAPA/AwULAhIFCwMDBgQKAgwFDAQAAwkDHQ4CCQMpDgIKAgsFDBEABQoBAwAAAAAAAPA/AwULAhMFCwMDBgQKAgwFDDkABQoKAgsFDDkABQoFCgAGBAIMBQwCCwUMBQwABgQCDwUKCwIWAgYABgECAwUKCgIXBQw5AAUKBQoKAhcFDBEABQoFCgIDBQoFCgUKBgQCDQUMCwIQAgYBAhEFDAIEBQwFDAIEBQwFDAUMBgQCDgUMCQMhDgICCgoCDwUKBQwFDAaBAg0FDAIOBQwFDAAAHwAABQUIIQN0bXAFCwQAAAkDKQ4CCgIMBQwRAAUKAQMAAAAAAADwPwMFCwAGBAIhBQsJAykOAwkDHQ4CAiEFCwIUBQsDCQMdDgICIQULAhUFCwMBAwAAAAAAAPA/AwULBQsGBAIdBQwJAyoOAwkDHQ4CAiEFCwIbBQsDCQMdDgICIQULAhwFCwMKAgwFDDkABQoFDAUMCwIZAgaDCgIdBQwRAAUKAhoFCgUKAAAGBAIGBQwCHQUMBQwAASAAAAUCCwYOAhgCBgkKAg0FDAwAAwED/Knx0k1iUD8DAgIMAAAABgQCBwUMAg0FDAUMAA";
h3d_shader_BaseMesh.SRC = "HXSLE2gzZC5zaGFkZXIuQmFzZU1lc2gXAQZjYW1lcmENAQoCBHZpZXcHAAEAAwRwcm9qBwABAAQIcG9zaXRpb24FCwABAAUIcHJvakZsaXADAAEABghwcm9qRGlhZwULAAEABwh2aWV3UHJvagcAAQAID2ludmVyc2VWaWV3UHJvagcAAQAJBXpOZWFyAwABAAoEekZhcgMAAQALA2RpcgULAwEAAAAADAZnbG9iYWwNAgQNBHRpbWUDAAwADglwaXhlbFNpemUFCgAMAA8JbW9kZWxWaWV3BwAMAQMQEG1vZGVsVmlld0ludmVyc2UHAAwBAwAAABEFaW5wdXQNAwISCHBvc2l0aW9uBQsBEQATBm5vcm1hbAULAREAAQAAFAZvdXRwdXQNBAUVCHBvc2l0aW9uBQwEFAAWBWNvbG9yBQwEFAAXBWRlcHRoAwQUABgGbm9ybWFsBQsEFAAZCXdvcmxkRGlzdAMEFAAEAAAaEHJlbGF0aXZlUG9zaXRpb24FCwQAABsTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAHBhwaXhlbFRyYW5zZm9ybWVkUG9zaXRpb24FCwQAAB0RdHJhbnNmb3JtZWROb3JtYWwFCwQAAB4RcHJvamVjdGVkUG9zaXRpb24FDAQAAB8KcGl4ZWxDb2xvcgUMBAAAIAVkZXB0aAMEAAAhCHNjcmVlblVWBQoEAAAiCXNwZWNQb3dlcgMEAAAjCXNwZWNDb2xvcgULBAAAJAl3b3JsZERpc3QDBAAAJQVjb2xvcgUMAgAAJg1zcGVjdWxhclBvd2VyAwIAAQcAAAAAAAAAAAAAAAAAAFlAJw5zcGVjdWxhckFtb3VudAMCAAEHAAAAAAAAAAAAAAAAAAAkQCgNc3BlY3VsYXJDb2xvcgULAgAAKQhfX2luaXRfXw4GAAAqEF9faW5pdF9fZnJhZ21lbnQOBgAAKwZ2ZXJ0ZXgOBgAALAhmcmFnbWVudA4GAAAEAikAAAULBgQCGgULAhIFCwULBgQCGwULBgECGgULCQM0DgECDwcIBQsFCwYEAh4FDAYBCQMqDgICGwULAQMAAAAAAADwPwMFDAIHBwUMBQwGBAIdBQsJAx8OAQQGAQITBQsJAzIOAQIPBwYFCwULBQsFCwYEAgsFCwkDHw4BBAYDAgQFCwIbBQsFCwULBQsFCwYEAh8FDAIlBQwFDAYEAiIDAiYDAwYEAiMFCwYBAigFCwInAwULBQsGBAIhBQoJAzoOAQYCCgIeBQwRAAUKCgIeBQwMAAMFCgUKBQoGBAIgAwYCCgIeBQwIAAMKAh4FDAwAAwMDBgQCJAMGAgkDGw4BBgMCGwULAgQFCwULAwIKAwMDAAIqAAAFBQYEAh0FCwkDHw4BAh0FCwULBQsGBAIhBQoJAzoOAQYCCgIeBQwRAAUKCgIeBQwMAAMFCgUKBQoGBAIgAwYCCgIeBQwIAAMKAh4FDAwAAwMDBgQCIgMCJgMDBgQCIwULBgECKAULAicDBQsFCwAAKwAABQIGBAIVBQwGAQIeBQwJAyoOBAEDAAAAAAAA8D8DAgUDAQMAAAAAAADwPwMBAwAAAAAAAPA/AwUMBQwFDAYEAhwFCwIbBQsFCwABLAAABQQGBAIWBQwCHwUMBQwGBAIXAwIgAwMGBAIYBQsCHQULBQsGBAIZAwIkAwMA";
h3d_shader_Blur.SRC = "HXSLD2gzZC5zaGFkZXIuQmx1choBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoVY2FtZXJhSW52ZXJzZVZpZXdQcm9qBwIAAAsHdGV4dHVyZQoCAAAMDGRlcHRoVGV4dHVyZQoCAAANB1F1YWxpdHkBAgABAAAAAAAOB2lzRGVwdGgCAgABAAAAAAAPBnZhbHVlcw8DDQIAABAHb2Zmc2V0cw8DDQIAABEFcGl4ZWwFCgIAABINaGFzRml4ZWRDb2xvcgICAAEAAAAAABMQc21vb3RoRml4ZWRDb2xvcgICAAEAAAAAABQKZml4ZWRDb2xvcgUMAgAAFRBpc0RlcHRoRGVwZW5kYW50AgIAAQAAAAAAFgloYXNOb3JtYWwCAgABAAAAAAAXDW5vcm1hbFRleHR1cmUKAgAAGAZpc0N1YmUCAgABAAAAAAAZC2N1YmVUZXh0dXJlDAIAABoHY3ViZURpcgYCAAAbCF9faW5pdF9fDgYAABwGdmVydGV4DgYAAB0IZnJhZ21lbnQOBgAAHgtnZXRQb3NpdGlvbg4GAAAEAhsAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAAcAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEdAAAFAgsCFQIFBggfBHBjdXIFCwQAAAkCHg4BAgMFCgULAAggBGNjdXIFDAQAAAkDIQ4CAgsKAgMFCgUMAAghBWNvbG9yBQwEAAAJAyoOBAEDAAAAAAAAAAADAQMAAAAAAAAAAAMBAwAAAAAAAAAAAwEDAAAAAAAAAAADBQwACCIEbmN1cgULBAAACQM5DgEJAyEOAgIXCgIDBQoFDAULABUGdW5yb2xsAA4jAWkBBAAABhUGAAcDAg0BAQECAQAAAAEBAg0BDwEAAAUICCQCdXYFCgQAAAYAAgMFCgYBAhEFChECEA8DDQsGCQIjAQECAAAAAAECBwMCIwEBAiMBAQMFCgUKAAglAWMFDAQAAAkDIQ4CAgsKAiQFCgUMAAgmAXAFCwQAAAkCHg4BAiQFCgULAAgnAWQDBAAACQMdDgIEBgMCJgULAh8FCwULBQsGAwImBQsCHwULBQsDAAgoAW4FCwQAAAkDOQ4BCQMhDgICFwoCJAUKBQwFCwAGBAIlBQwJAxgOAwIgBQwCJQUMCQMdDgICIgULAigFCwMFDAUMBgQCJQUMCQMYDgMCJQUMAiAFDAkDFQ4CBAYBCQMWDgIEBgMCJwMBA/yp8dJNYlA/AwMDAQMAAAAAAAAAAAMDAQMAAAAAAGr4QAMDAwEDAAAAAAAA8D8DAwUMBQwGgAIhBQwGAQIlBQwRAg8PAw0LBgkCIwEBAgAAAAABAgcDAiMBAQIjAQEDBQwFDAAAAAYEAggFDAIhBQwFDAALAg4CBQMIKQN2YWwDBAAAAQMAAAAAAAAAAAMAFQZ1bnJvbGwADioBaQEEAAAGFQYABwMCDQEBAQIBAAAAAQECDQEPAQAABQELAhgCBoACKQMGAQkDNw4BCQMhDgICGQwGAQkDKQ4CBgMGAQQGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIqAQECAAAAAAECBwMCKgEBAioBAQMFCgkDJg4BAioBAwUKBQoFCgEDAAAAAAAAAEADBQoBAwAAAAAAAPA/AwUKAQMAAAAAAADwPwMFCwIaBgULBQwDEQIPDwMNCwYJAioBAQIAAAAAAQIHAwIqAQECKgEBAwMDBoACKQMGAQkDNw4BCQMhDgICCwoGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIqAQECAAAAAAECBwMCKgEBAioBAQMFCgkDJg4BAioBAwUKBQoFDAMRAg8PAw0LBgkCKgEBAgAAAAABAgcDAioBAQIqAQEDAwMAAAAABgQCCAUMCQM2DgEJAxUOAgIpAwEDyxpQyv//7z8DAwUMBQwABQMIKwVjb2xvcgUMBAAACQMqDgQBAwAAAAAAAAAAAwEDAAAAAAAAAAADAQMAAAAAAAAAAAMBAwAAAAAAAAAAAwUMABUGdW5yb2xsAA4sAWkBBAAABhUGAAcDAg0BAQECAQAAAAEBAg0BDwEAAAUBCwIYAgaAAisFDAYBCQMhDgICGQwGAQkDKQ4CBgMGAQQGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIsAQECAAAAAAECBwMCLAEBAiwBAQMFCgkDJg4BAiwBAwUKBQoFCgEDAAAAAAAAAEADBQoBAwAAAAAAAPA/AwUKAQMAAAAAAADwPwMFCwIaBgULBQwRAg8PAw0LBgkCLAEBAgAAAAABAgcDAiwBAQIsAQEDBQwFDAaAAisFDAYBCQMhDgICCwoGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIsAQECAAAAAAECBwMCLAEBAiwBAQMFCgkDJg4BAiwBAwUKBQoFDBECDw8DDQsGCQIsAQECAAAAAAECBwMCLAEBAiwBAQMFDAUMAAAAAAYEAggFDAIrBQwFDAAAAAsCEgIFAgsCEwIGgQoCCAUMDAADCgIUBQwMAAMDBgQKAggFDAwAAwYBCgIUBQwMAAMJAyYOAQYHCgIIBQwMAAMBAwAAAAAAAAAAAwIDAwMABgQKAggFDJIABQsGAQoCFAUMkgAFCwoCCAUMDAADBQsFCwAAAAADHgEtAnV2BQoEAAAFCwUECC4FZGVwdGgDBAAACQM3DgEJAyEOAgIMCgItBQoFDAMACC8EdGVtcAUMBAAABgEJAyoOAwkDOw4BAi0FCgUKAi4DAQMAAAAAAADwPwMFDAIKBwUMAAgwCG9yaWdpbldTBQsEAAAGAgoCLwUMkgAFCwoCLwUMDAADBQsADQIwBQsAAA";
h3d_shader_ColorAdd.SRC = "HXSLE2gzZC5zaGFkZXIuQ29sb3JBZGQDAQpwaXhlbENvbG9yBQwEAAACBWNvbG9yBQsCAAADCGZyYWdtZW50DgYAAAEBAwAABQEGgAoCAQUMkgAFCwICBQsFCwA";
h3d_shader_ColorKey.SRC = "HXSLE2gzZC5zaGFkZXIuQ29sb3JLZXkDAQhjb2xvcktleQUMAgAAAgx0ZXh0dXJlQ29sb3IFDAQAAAMIZnJhZ21lbnQOBgAAAQEDAAAFAggEBWNkaWZmBQwEAAAGAwICBQwCAQUMBQwACwYJCQMdDgICBAUMAgQFDAMBA/Fo44i1+OQ+AwIMAAAAAA";
h3d_shader_ColorMatrix.SRC = "HXSLFmgzZC5zaGFkZXIuQ29sb3JNYXRyaXgDAQpwaXhlbENvbG9yBQwEAAACBm1hdHJpeAcCAAADCGZyYWdtZW50DgYAAAEBAwAABQEGBAIBBQwJAyoOAgoEBgEJAyoOAgoCAQUMkgAFCwEDAAAAAAAA8D8DBQwCAgcFDAUMkgAFCwoEBgECAQUMAgIHBQwFDAwAAwUMBQwA";
h3d_shader_DirShadow.SRC = "HXSLFGgzZC5zaGFkZXIuRGlyU2hhZG93EAEGZW5hYmxlAgIAAQAAAAAAAgdVU0VfRVNNAgIAAQAAAAAAAwtzaGFkb3dQb3dlcgMCAAAEB1VTRV9QQ0YCAgABAAAAAAAFC1BDRl9TQU1QTEVTAQIAAQAAAAAABghwY2ZTY2FsZQMCAAAHCXNoYWRvd1JlcwUKAgAACAlzaGFkb3dNYXARAQIAAAkKc2hhZG93UHJvaggCAAAKCnNoYWRvd0JpYXMDAgAACxN0cmFuc2Zvcm1lZFBvc2l0aW9uBQsEAAAMBnNoYWRvdwMEAAANCWRpclNoYWRvdwMEAAAOC3BvaXNzb25EaXNrDwUMBQIAAA8EcmFuZA4GAAAQCGZyYWdtZW50DgYAAAIDDwERAXYDBAAAAwUCCBICZHADBAAACQMdDgIJAyoOAQIRAwUMCQMqDgQBA18pyxDH+ilAAwED9P3UeOmOU0ADAQOiRbbz/ZRGQAMBA1CNl24Sq1dAAwUMAwANCQMTDgEGAQkDAg4BAhIDAwEDUPwYc9Fd5UADAwMAAAEQAAAFAgsCAQIFAQsCBAIFCwYEAgwDAQMAAAAAAADwPwMDCBMJdGV4ZWxTaXplBQoEAAAGAgEDAAAAAAAA8D8DAgcFCgUKAAgUCXNoYWRvd1BvcwULBAAABgECCwULAgkIBQsACBUIc2hhZG93VXYFCgQAAAkDOg4BCgIUBQsRAAUKBQoACBYEek1heAMEAAAJAzUOAQoCFAULCAADAwAIFwNyb3QDBAAABgEGAQkCDw4BBgAGAAoCCwULAAADCgILBQsEAAMDCgILBQsIAAMDAwEDH4XrUbgeCUADAwEDAAAAAAAAAEADAwAIGARjb3NSAwQAAAkDAw4BAhcDAwAIGQRzaW5SAwQAAAkDAg4BAhcDAwAIGg5zYW1wbGVTdHJlbmd0aAMEAAAGAgEDAAAAAAAA8D8DCQMmDgECBQEDAwAIGwhvZmZTY2FsZQUKBAAABgECEwUKAgYDBQoADhwBaQEEAAAGFQECAAAAAAECBQEPAQAABQQIHQZvZmZzZXQFCgQAAAYBChECDg8FDAUCHAEFDBEABQoCGwUKBQoABgQCHQUKCQMoDgIGAwYBAhgDCgIdBQoAAAMDBgECGQMKAh0FCgQAAwMDBgAGAQIYAwoCHQUKBAADAwYBAhkDCgIdBQoAAAMDAwUKBQoIHgVkZXB0aAMEAAAJA0AOAwIIEQEGAAIVBQoCHQUKBQoBAwAAAAAAAAAAAwMABoMCDAMLBAYHBgMCFgMCCgMDAh4DAgICGgMBAwAAAAAAAAAAAwMDAAAACwICAgUFCB8Jc2hhZG93UG9zBQsEAAAGAQILBQsCCQgFCwAIIAVkZXB0aAMEAAAJAz8OAgIIEQEJAzoOAQoCHwULEQAFCgUKAwAIIQR6TWF4AwQAAAkDNQ4BCgIfBQsIAAMDAAgiBWRlbHRhAwQAAAYDCQMVDgIEBgACIAMCCgMDAwIhAwMCIQMDAAYEAgwDCQM1DgEJAwkOAQYBAgMDAiIDAwMDAwAFBAgjCXNoYWRvd1BvcwULBAAABgECCwULAgkIBQsACCQIc2hhZG93VXYFCgQAAAkDOg4BCgIjBQsRAAUKBQoACCUFZGVwdGgDBAAACQM/DgICCBEBCgIkBQoRAAUKAwAGBAIMAwsGBwYDCQM1DgEKAiMFCwgAAwMCCgMDAiUDAgEDAAAAAAAAAAADAQMAAAAAAADwPwMDAwAAAAAAAAYEAg0DAgwDAwA";
h3d_shader_GenTexture.SRC = "HXSLFWgzZC5zaGFkZXIuR2VuVGV4dHVyZQoBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoEbW9kZQECAAEAAAAAAAsFY29sb3IFDAIAAAwIX19pbml0X18OBgAADQZ2ZXJ0ZXgOBgAADghmcmFnbWVudA4GAAADAgwAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAANAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEOAAAFARMEAgoBAQEBAQIAAAAAAQUBBgQCCAUMCwYHCQMbDgEKAgYFDBEABQoDAQMAAAAAAADwPwMCCQMqDgEBAwAAAAAAAAAAAwUMAgsFDAUMBQwAAAAA";
h3d_shader_LineShader.SRC = "HXSLFWgzZC5zaGFkZXIuTGluZVNoYWRlcgwBBmNhbWVyYQ0BAwIEdmlldwcAAQADBHByb2oHAAEABAh2aWV3UHJvagcAAQAAAAAFBmdsb2JhbA0CAgYJcGl4ZWxTaXplBQoABQAHCW1vZGVsVmlldwcABQEDAAAACAVpbnB1dA0DAwkIcG9zaXRpb24FCwEIAAoGbm9ybWFsBQsBCAALAnV2BQoBCAABAAAMBm91dHB1dA0EAQ0IcG9zaXRpb24FDAQMAAQAAA4RdHJhbnNmb3JtZWROb3JtYWwFCwQAAA8TdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAEBFwcm9qZWN0ZWRQb3NpdGlvbgUMBAAAEQtsZW5ndGhTY2FsZQMCAAASBXdpZHRoAwIAABMEcGRpcgUMBAAAFAhfX2luaXRfXw4GAAAVBnZlcnRleA4GAAACAhQAAAUBBQUIFgNkaXIFCwQAAAYBAgoFCwkDMg4BAgcHBgULAAYEAhMFDAYBCQMqDgIGAQIWBQsJAzIOAQICBwYFCwEDAAAAAAAA8D8DBQwCAwcFDAUMBoEKAhMFDBEABQoGAgEDAAAAAAAA8D8DCQMNDgEGAAYBCgITBQwAAAMKAhMFDAAAAwMGAQoCEwUMBAADCgITBQwEAAMDAwMDBQoGgAIPBQsGAQYBAhYFCwoCCwUKAAADBQsCEQMFCwULBgQCDgULCQMfDgECFgULBQsFCwAAABUAAAUBBoAKAhAFDBEABQoGAQYBBgEGAQQGAQoCEwUMBQAFCgkDKA4CAQMAAAAAAADwPwMBAwAAAAAAAPC/AwUKBQoFCgQGAwoCCwUKBAADAQMAAAAAAADgPwMDAwUKCgIQBQwIAAMFCgIGBQoFCgISAwUKBQoA";
h3d_shader_MinMaxShader.SRC = "HXSLF2gzZC5zaGFkZXIuTWluTWF4U2hhZGVyCwEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACgR0ZXhBCgIAAAsEdGV4QgoCAAAMBWlzTWF4AgIAAQAAAAAADQhfX2luaXRfXw4GAAAOBnZlcnRleA4GAAAPCGZyYWdtZW50DgYAAAMCDQAABQIGBAIHBQwCCAUMBQwGBAIJBQoCAwUKBQoAAA4AAAUBBgQCBgUMCQMqDgQKAgIFCgAAAwYBCgICBQoEAAMCBAMDAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBQwAAQ8AAAUDCBABYQUMBAAACQMhDgICCgoCCQUKBQwACBEBYgUMBAAACQMhDgICCwoCCQUKBQwABgQCCAUMCwIMAgkDFg4CAhAFDAIRBQwFDAkDFQ4CAhAFDAIRBQwFDAUMBQwA";
h3d_shader_CubeMinMaxShader.SRC = "HXSLG2gzZC5zaGFkZXIuQ3ViZU1pbk1heFNoYWRlcgwBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoEdGV4QQwCAAALBHRleEIMAgAADAVpc01heAICAAEAAAAAAA0DbWF0BgIAAA4IX19pbml0X18OBgAADwZ2ZXJ0ZXgOBgAAEAhmcmFnbWVudA4GAAADAg4AAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAAPAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEQAAAFBQgRAnV2BQoEAAAGAwYBAgkFCgEDAAAAAAAAAEADBQoBAwAAAAAAAPA/AwUKAAgSA2RpcgULBAAABgEJAykOAgIRBQoBAwAAAAAAAPA/AwULAg0GBQsACBMBYQUMBAAACQMhDgICCgwCEgULBQwACBQBYgUMBAAACQMhDgICCwwCEgULBQwABgQCCAUMCwIMAgkDFg4CAhMFDAIUBQwFDAkDFQ4CAhMFDAIUBQwFDAUMBQwA";
h3d_shader_NormalMap.SRC = "HXSLFGgzZC5zaGFkZXIuTm9ybWFsTWFwCgEGY2FtZXJhDQECAghwb3NpdGlvbgULAAEAAwNkaXIFCwMBAAAAAAQGZ2xvYmFsDQIBBQltb2RlbFZpZXcHAAQBAwAAAAYFaW5wdXQNAwIHBm5vcm1hbAULAQYACAd0YW5nZW50BQsBBgABAAAJB3RleHR1cmUKAgAACgxjYWxjdWxhdGVkVVYFCgQAAAsTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAADBF0cmFuc2Zvcm1lZE5vcm1hbAULBAAADRJ0cmFuc2Zvcm1lZFRhbmdlbnQFDAMAAA4OX19pbml0X192ZXJ0ZXgOBgAADwhmcmFnbWVudA4GAAACAg4AAAUBBgQCDQUMCQMqDgIGAQIIBQsJAzIOAQIFBwYFCwsGBwkDHQ4CAggFCwIIBQsDAQMAAAAAAADgPwMCAQMAAAAAAADwPwMBAwAAAAAAAPC/AwMFDAUMAAEPAAAFBQgQAW4FCwQAAAIMBQsACBECbmYFCwQAAAkDOQ4BCQMhDgICCQoCCgUKBQwFCwAIEgR0YW5YBQsEAAAJAx8OAQoCDQUMkgAFCwULAAgTBHRhblkFCwQAAAYBCQMeDgICEAULAhIFCwULBwMKAg0FDAwAAwMFCwAGBAIMBQsJAx8OAQQGAAYABgEKAhEFCwAAAwISBQsFCwYBCgIRBQsEAAMCEwULBQsFCwYBCgIRBQsIAAMCEAULBQsFCwULBQsFCwA";
h3d_shader_Shadow.SRC = "HXSLEWgzZC5zaGFkZXIuU2hhZG93BgEGc2hhZG93DQEFAgNtYXARAQABAAMEcHJvaggAAQAEBWNvbG9yBQsAAQAFBXBvd2VyAwABAAYEYmlhcwMAAQAAAAAHCnBpeGVsQ29sb3IFDAQAAAgTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAACRhwaXhlbFRyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAoJc2hhZG93UG9zBQsEAAEBCwhmcmFnbWVudA4GAAABAQsAAAUGCAwJc2hhZG93UG9zBQsEAAAGAQIJBQsCAwgFCwAIDQVkZXB0aAMEAAAJAz8OAgICEQEJAzoOAQoCDAULEQAFCgUKAwAIDgR6TWF4AwQAAAkDNQ4BCgIMBQsIAAMDAAgPBWRlbHRhAwQAAAYDCQMVDgIEBgACDQMCBgMDAwIOAwMCDgMDAAgQBXNoYWRlAwQAAAkDNQ4BCQMJDgEGAQIFAwIPAwMDAwAGgQoCBwUMkgAFCwYABgEEBgMBAwAAAAAAAPA/AwIQAwMDCgIEBQuSAAULBQsCEAMFCwULAA";
h3d_shader_SignedDistanceField.SRC = "HXSLHmgzZC5zaGFkZXIuU2lnbmVkRGlzdGFuY2VGaWVsZA8BBWlucHV0DQEDAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEABAVjb2xvcgUMAQEAAQAABQZvdXRwdXQNAgIGCHBvc2l0aW9uBQwEBQAHBWNvbG9yBQwEBQAEAAAIBHRpbWUDAAAACQ5zcHJpdGVQb3NpdGlvbgUMBAAAChBhYnNvbHV0ZVBvc2l0aW9uBQwEAAALCnBpeGVsQ29sb3IFDAQAAAwMdGV4dHVyZUNvbG9yBQwEAAANDGNhbGN1bGF0ZWRVVgUKAwAADg5vdXRwdXRQb3NpdGlvbgUMBAAADwdjaGFubmVsAQIAAQAAAAAAEA1hdXRvU21vb3RoaW5nAgIAAQAAAAAAEQthbHBoYUN1dG9mZgMCAAASCXNtb290aGluZwMCAAATBm1lZGlhbg4GAAAUCGZyYWdtZW50DgYAAAIDEwMVAXIDBAAAFgFnAwQAABcBYgMEAAADBQENCQMWDgIJAxUOAgIVAwIWAwMJAxUOAgkDFg4CAhUDAhYDAwIXAwMDAAABFAAABQUIGA10ZXh0dXJlU2FtcGxlBQwEAAACDAUMAAgZCGRpc3RhbmNlAwQAAAAABgQCGQMLBgUCDwEBAgAAAAABAgoCGAUMAAADCwYFAg8BAQIBAAAAAQIKAhgFDAQAAwsGBQIPAQECAgAAAAECCgIYBQwIAAMLBgUCDwEBAgMAAAABAgoCGAUMDAADCQITDgMKAhgFDAAAAwoCGAUMBAADCgIYBQwIAAMDAwMDAwMIGglzbW9vdGhWYWwDBAAACwIQAgkDDw4BBgEJAz4OAQIZAwMBAwAAAAAAAOA/AwMDAhIDAwAGBAIMBQwJAyoOBAEDAAAAAAAA8D8DAQMAAAAAAADwPwMBAwAAAAAAAPA/AwkDGg4DBgMCEQMCGgMDBgACEQMCGgMDAhkDAwUMBQwA";
h3d_shader_SkinBase.SRC = "HXSLE2gzZC5zaGFkZXIuU2tpbkJhc2UGARByZWxhdGl2ZVBvc2l0aW9uBQsEAAACE3RyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAMRdHJhbnNmb3JtZWROb3JtYWwFCwQAAAQITWF4Qm9uZXMBAgABAAAAAAAFEWZvdXJCb25lc0J5VmVydGV4AgIAAQAAAAAABg1ib25lc01hdHJpeGVzDwgEAgABCAA";
h3d_shader_Skin.SRC = "HXSLD2gzZC5zaGFkZXIuU2tpbgkBEHJlbGF0aXZlUG9zaXRpb24FCwQAAAITdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAAxF0cmFuc2Zvcm1lZE5vcm1hbAULBAAABAhNYXhCb25lcwECAAEAAAAAAAURZm91ckJvbmVzQnlWZXJ0ZXgCAgABAAAAAAAGDWJvbmVzTWF0cml4ZXMPCAQCAAEIBwVpbnB1dA0BBAgIcG9zaXRpb24FCwEHAAkGbm9ybWFsBQsBBwAKB3dlaWdodHMFCwEHAAsHaW5kZXhlcwkEAAAAAQcAAQAADBJ0cmFuc2Zvcm1lZFRhbmdlbnQFDAQAAA0GdmVydGV4DgYAAAEADQAABQQGBAICBQsGAAYABgEEBgECAQULEQIGDwgECQMlDgEKAgsJBAAAAAAAAwEIBQsFCwoCCgULAAADBQsGAQQGAQIBBQsRAgYPCAQJAyUOAQoCCwkEAAAABAADAQgFCwULCgIKBQsEAAMFCwULBgEEBgECAQULEQIGDwgECQMlDgEKAgsJBAAAAAgAAwEIBQsFCwoCCgULCAADBQsFCwULBgQCAwULBgAGAAYBBAYBAgkFCwkDMg4BEQIGDwgECQMlDgEKAgsJBAAAAAAAAwEIBgULBQsKAgoFCwAAAwULBgEEBgECCQULCQMyDgERAgYPCAQJAyUOAQoCCwkEAAAABAADAQgGBQsFCwoCCgULBAADBQsFCwYBBAYBAgkFCwkDMg4BEQIGDwgECQMlDgEKAgsJBAAAAAgAAwEIBgULBQsKAgoFCwgAAwULBQsFCwsCBQIFAwgOAnc0AwQAAAYDAQMAAAAAAADwPwMEBgAGAAoCCgULAAADCgIKBQsEAAMDCgIKBQsIAAMDAwMABoACAgULBgEEBgECAQULEQIGDwgECQMlDgEKAgsJBAAAAAwAAwEIBQsFCwIOAwULBQsGgAIDBQsGAQQGAQIJBQsJAzIOARECBg8IBAkDJQ4BCgILCQQAAAAIAAMBCAYFCwULAg4DBQsFCwAAAAYEAgMFCwkDHw4BAgMFCwULBQsA";
h3d_shader_SkinTangent.SRC = "HXSLFmgzZC5zaGFkZXIuU2tpblRhbmdlbnQJARByZWxhdGl2ZVBvc2l0aW9uBQsEAAACE3RyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAMRdHJhbnNmb3JtZWROb3JtYWwFCwQAAAQITWF4Qm9uZXMBAgABAAAAAAAFEWZvdXJCb25lc0J5VmVydGV4AgIAAQAAAAAABg1ib25lc01hdHJpeGVzDwgEAgABCAcFaW5wdXQNAQUICHBvc2l0aW9uBQsBBwAJBm5vcm1hbAULAQcACgd0YW5nZW50BQsBBwALB3dlaWdodHMFCwEHAAwHaW5kZXhlcwkEAAAAAQcAAQAADRJ0cmFuc2Zvcm1lZFRhbmdlbnQFDAQAAA4GdmVydGV4DgYAAAEADgAABQYGBAICBQsGAAYABgEEBgECAQULEQIGDwgECQMlDgEKAgwJBAAAAAAAAwEIBQsFCwoCCwULAAADBQsGAQQGAQIBBQsRAgYPCAQJAyUOAQoCDAkEAAAABAADAQgFCwULCgILBQsEAAMFCwULBgEEBgECAQULEQIGDwgECQMlDgEKAgwJBAAAAAgAAwEIBQsFCwoCCwULCAADBQsFCwULBgQCAwULBgAGAAYBBAYBAgkFCwkDMg4BEQIGDwgECQMlDgEKAgwJBAAAAAAAAwEIBgULBQsKAgsFCwAAAwULBgEEBgECCQULCQMyDgERAgYPCAQJAyUOAQoCDAkEAAAABAADAQgGBQsFCwoCCwULBAADBQsFCwYBBAYBAgkFCwkDMg4BEQIGDwgECQMlDgEKAgwJBAAAAAgAAwEIBgULBQsKAgsFCwgAAwULBQsFCwYECgINBQySAAULBgAGAAYBBAYBCgIKBQuSAAULCQMyDgERAgYPCAQJAyUOAQoCDAkEAAAAAAADAQgGBQsFCwoCCwULAAADBQsGAQQGAQoCCgULkgAFCwkDMg4BEQIGDwgECQMlDgEKAgwJBAAAAAQAAwEIBgULBQsKAgsFCwQAAwULBQsGAQQGAQoCCgULkgAFCwkDMg4BEQIGDwgECQMlDgEKAgwJBAAAAAgAAwEIBgULBQsKAgsFCwgAAwULBQsFCwsCBQIFBAgPAnc0AwQAAAYDAQMAAAAAAADwPwMEBgAGAAoCCwULAAADCgILBQsEAAMDCgILBQsIAAMDAwMABoACAgULBgEEBgECAQULEQIGDwgECQMlDgEKAgwJBAAAAAwAAwEIBQsFCwIPAwULBQsGgAIDBQsGAQQGAQIJBQsJAzIOARECBg8IBAkDJQ4BCgIMCQQAAAAIAAMBCAYFCwULAg8DBQsFCwaACgINBQySAAULBgEEBgEKAgoFC5IABQsJAzIOARECBg8IBAkDJQ4BCgIMCQQAAAAMAAMBCAYFCwULAg8DBQsFCwAAAAYEAgMFCwkDHw4BAgMFCwULBQsGBAoCDQUMkgAFCwkDHw4BCgINBQySAAULBQsFCwA";
h3d_shader_SpecularTexture.SRC = "HXSLGmgzZC5zaGFkZXIuU3BlY3VsYXJUZXh0dXJlBAEHdGV4dHVyZQoCAAACDGNhbGN1bGF0ZWRVVgUKBAAAAwlzcGVjQ29sb3IFCwQAAAQIZnJhZ21lbnQOBgAAAQEEAAAFAQaBAgMFCwoJAyEOAgIBCgICBQoFDJIABQsFCwA";
h3d_shader_Texture.SRC = "HXSLEmgzZC5zaGFkZXIuVGV4dHVyZQsBBWlucHV0DQEBAgJ1dgUKAQEAAQAAAwhhZGRpdGl2ZQICAAEAAAAAAAQJa2lsbEFscGhhAgIAAQAAAAAABQ1zcGVjdWxhckFscGhhAgIAAQAAAAAABhJraWxsQWxwaGFUaHJlc2hvbGQDAgABBwAAAAAAAAAAAAAAAAAA8D8HB3RleHR1cmUKAgAACAxjYWxjdWxhdGVkVVYFCgQAAAkKcGl4ZWxDb2xvcgUMBAAACglzcGVjQ29sb3IFCwQAAAsGdmVydGV4DgYAAAwIZnJhZ21lbnQOBgAAAgALAAAFAQYEAggFCgICBQoFCgABDAAABQQIDQFjBQwEAAAJAyEOAgIHCgIIBQoFDAALBg4CBAIGCQYDCgINBQwMAAMCBgMDAQMAAAAAAAAAAAMCAgwAAAALAgMCBoACCQUMAg0FDAUMBoECCQUMAg0FDAUMAAsCBQIGgQIKBQsKAg0FDP4ABQsFCwAAAA";
h3d_shader_UVDelta.SRC = "HXSLEmgzZC5zaGFkZXIuVVZEZWx0YQQBB3V2RGVsdGEFCgIAAAIHdXZTY2FsZQUKAgAAAwxjYWxjdWxhdGVkVVYFCgQAAAQGdmVydGV4DgYAAAEABAAABQEGBAIDBQoGAAYBAgMFCgICBQoFCgIBBQoFCgUKAA";
h3d_shader_VertexColorAlpha.SRC = "HXSLG2gzZC5zaGFkZXIuVmVydGV4Q29sb3JBbHBoYQQBBWlucHV0DQEBAgVjb2xvcgUMAQEAAQAAAwpwaXhlbENvbG9yBQwEAAAECGFkZGl0aXZlAgIAAQAAAAAABQhmcmFnbWVudA4GAAABAQUAAAUBCwIEAgaAAgMFDAICBQwFDAaBAgMFDAICBQwFDAAA";
h3d_shader_VolumeDecal.SRC = "HXSLFmgzZC5zaGFkZXIuVm9sdW1lRGVjYWwYAQZjYW1lcmENAQoCBHZpZXcHAAEAAwRwcm9qBwABAAQIcG9zaXRpb24FCwABAAUIcHJvakZsaXADAAEABghwcm9qRGlhZwULAAEABwh2aWV3UHJvagcAAQAID2ludmVyc2VWaWV3UHJvagcAAQAJBXpOZWFyAwABAAoEekZhcgMAAQALA2RpcgULAwEAAAAADAZnbG9iYWwNAgQNBHRpbWUDAAwADglwaXhlbFNpemUFCgAMAA8JbW9kZWxWaWV3BwAMAQMQEG1vZGVsVmlld0ludmVyc2UHAAwBAwAAABEFaW5wdXQNAwISCHBvc2l0aW9uBQsBEQATBm5vcm1hbAULAREAAQAAFAZvdXRwdXQNBAUVCHBvc2l0aW9uBQwEFAAWBWNvbG9yBQwEFAAXBWRlcHRoAwQUABgGbm9ybWFsBQsEFAAZCXdvcmxkRGlzdAMEFAAEAAAaEHJlbGF0aXZlUG9zaXRpb24FCwQAABsTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAHBhwaXhlbFRyYW5zZm9ybWVkUG9zaXRpb24FCwQAAB0RdHJhbnNmb3JtZWROb3JtYWwFCwQAAB4RcHJvamVjdGVkUG9zaXRpb24FDAQAAB8KcGl4ZWxDb2xvcgUMBAAAIAVkZXB0aAMEAAAhCHNjcmVlblVWBQoEAAAiCXNwZWNQb3dlcgMEAAAjCXNwZWNDb2xvcgULBAAAJAl3b3JsZERpc3QDBAAAJQhkZXB0aE1hcBEBAAAAJgVzY2FsZQUKAgAAJwZub3JtYWwFCwIAACgHdGFuZ2VudAULAgAAKQppc0NlbnRlcmVkAgIAAQAAAAAAKgxjYWxjdWxhdGVkVVYFCgQAACsSdHJhbnNmb3JtZWRUYW5nZW50BQwEAAAsDl9faW5pdF9fdmVydGV4DgYAAC0IZnJhZ21lbnQOBgAAAgIsAAAFAgYEAh0FCwkDHw4BBAYBAicFCwkDMg4BAg8HBgULBQsFCwULBgQCKwUMCQMqDgIJAx8OAQQGAQIoBQsJAzIOAQIPBwYFCwULBQsBAwAAAAAAAPA/AwUMBQwAAS0AAAUJCC4GbWF0cml4BwQAAAYBAggHAhAHBwAILwlzY3JlZW5Qb3MFCgQAAAYCCgIeBQwRAAUKCgIeBQwMAAMFCgAIMANydXYFDAQAAAkDKg4DAi8FCgkDPw4CAiURAQkDOg4BAi8FCgUKAwEDAAAAAAAA8D8DBQwACDEEd3BvcwUMBAAABgECMAUMAi4HBQwACDIEcHBvcwUMBAAABgECMAUMAggHBQwABgQCHAULBgIKAjIFDJIABQsKAjIFDAwAAwULBQsGBAIqBQoGAQImBQoEBgIKAjEFDBEABQoKAjEFDAwAAwUKBQoFCgUKCwIpAgaAAioFCgEDAAAAAAAA4D8DBQoAAAsGCQkDFQ4CCQMVDgIKAioFCgAAAwoCKgUKBAADAwkDFQ4CBgMBAwAAAAAAAPA/AwoCKgUKAAADAwYDAQMAAAAAAADwPwMKAioFCgQAAwMDAwEDAAAAAAAAAAADAgwAAAAA";
haxe_EntryPoint.pending = [];
haxe_EntryPoint.threadCount = 0;
haxe_Unserializer.DEFAULT_RESOLVER = new haxe__$Unserializer_DefaultResolver();
haxe_Unserializer.BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:";
haxe_crypto_Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
haxe_crypto_Base64.BYTES = haxe_io_Bytes.ofString(haxe_crypto_Base64.CHARS);
haxe_io_FPHelper.helper = new DataView(new ArrayBuffer(8));
haxe_xml_Parser.escapes = (function($this) {
	var $r;
	var h = new haxe_ds_StringMap();
	h.h["lt"] = "<";
	h.h["gt"] = ">";
	h.h["amp"] = "&";
	h.h["quot"] = "\"";
	h.h["apos"] = "'";
	$r = h;
	return $r;
}(this));
haxe_zip_InflateImpl.LEN_EXTRA_BITS_TBL = [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,-1,-1];
haxe_zip_InflateImpl.LEN_BASE_VAL_TBL = [3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258];
haxe_zip_InflateImpl.DIST_EXTRA_BITS_TBL = [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,-1,-1];
haxe_zip_InflateImpl.DIST_BASE_VAL_TBL = [1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577];
haxe_zip_InflateImpl.CODE_LENGTHS_POS = [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
hxd_Charset.complementChars = (function($this) {
	var $r;
	var str = "ヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻";
	var _g = new haxe_ds_IntMap();
	{
		var _g1 = 0;
		var _g2 = str.length;
		while(_g1 < _g2) {
			var i = _g1++;
			_g.h[HxOverrides.cca(str,i)] = true;
		}
	}
	$r = _g;
	return $r;
}(this));
hxd_Key.initDone = false;
hxd_Key.keyPressed = [];
hxd_Key.ALLOW_KEY_REPEAT = false;
hxd_Timer.wantedFPS = 60.;
hxd_Timer.maxDeltaTime = 0.5;
hxd_Timer.smoothFactor = 0.95;
hxd_Timer.lastTimeStamp = HxOverrides.now() / 1000;
hxd_Timer.elapsedTime = 0.;
hxd_Timer.frameCount = 0;
hxd_Timer.dt = 1 / hxd_Timer.wantedFPS;
hxd_Timer.currentDT = 1 / hxd_Timer.wantedFPS;
hxd_System.setCursor = hxd_System.setNativeCursor;
hxd_System.loopInit = false;
hxd_System.fpsLimit = -1;
hxd_fs_EmbedFileSystem.invalidChars = new EReg("[^A-Za-z0-9_]","g");
hxd_res_Resource.LIVE_UPDATE = false;
hxd_res_Image.DEFAULT_FILTER = h3d_mat_Filter.Linear;
hxd_res_Image.ENABLE_AUTO_WATCH = true;
hxd_res_Image.BLACK_1x1 = hxd_Pixels.alloc(1,1,hxd_PixelFormat.RGBA);
hxd_res_Image.LOG_TEXTURE_LOAD = false;
hxd_res_Sound.ENABLE_AUTO_WATCH = true;
hxd_snd_Channel.ID = 0;
hxd_snd_Source.ID = 0;
hxd_snd_Manager.STREAM_DURATION = 5.;
hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT = 44100;
hxd_snd_Manager.BUFFER_QUEUE_LENGTH = 2;
hxd_snd_Manager.MAX_SOURCES = 16;
hxd_snd_Manager.SOUND_BUFFER_CACHE_SIZE = 256;
hxd_snd_Manager.VIRTUAL_VOLUME_THRESHOLD = 1e-5;
hxd_snd_Manager.BUFFER_STREAM_SPLIT = 16;
hxsl_Tools.UID = 0;
hxsl_Tools.SWIZ = hxsl_Component.__empty_constructs__.slice();
hxsl_Tools.MAX_CHANNELS_BITS = 3;
hxsl_BatchShader.SRC = "HXSLEGh4c2wuQmF0Y2hTaGFkZXIDAQ9CYXRjaF9IYXNPZmZzZXQCAgABAAAAAAACC0JhdGNoX0NvdW50AQIAAQAAAAEAAwxCYXRjaF9CdWZmZXIQBQwCAgAAAA";
hxsl_GlslOut.KWD_LIST = ["input","output","discard","sample","dvec2","dvec3","dvec4","hvec2","hvec3","hvec4","fvec2","fvec3","fvec4","int","float","bool","long","short","double","half","fixed","unsigned","superp","lowp","mediump","highp","precision","invariant","discard","struct","asm","union","template","this","packed","goto","sizeof","namespace","noline","volatile","external","flat","input","output","out","attribute","const","uniform","varying","inout","void"];
hxsl_GlslOut.KWDS = (function($this) {
	var $r;
	var _g = new haxe_ds_StringMap();
	{
		var _g1 = 0;
		var _g2 = hxsl_GlslOut.KWD_LIST;
		while(_g1 < _g2.length) {
			var k = _g2[_g1];
			++_g1;
			_g.h[k] = true;
		}
	}
	$r = _g;
	return $r;
}(this));
hxsl_GlslOut.GLOBALS = (function($this) {
	var $r;
	var gl = [];
	{
		var _g = 0;
		var _g1 = hxsl_TGlobal.__empty_constructs__.slice();
		while(_g < _g1.length) {
			var g = _g1[_g];
			++_g;
			var n = "" + Std.string(g);
			n = n.charAt(0).toLowerCase() + HxOverrides.substr(n,1,null);
			gl[g._hx_index] = n;
		}
	}
	gl[hxsl_TGlobal.ToInt._hx_index] = "int";
	gl[hxsl_TGlobal.ToFloat._hx_index] = "float";
	gl[hxsl_TGlobal.ToBool._hx_index] = "bool";
	gl[hxsl_TGlobal.LReflect._hx_index] = "reflect";
	gl[hxsl_TGlobal.Mat3x4._hx_index] = "_mat3x4";
	gl[hxsl_TGlobal.VertexID._hx_index] = "gl_VertexID";
	gl[hxsl_TGlobal.InstanceID._hx_index] = "gl_InstanceID";
	gl[hxsl_TGlobal.IVec2._hx_index] = "ivec2";
	gl[hxsl_TGlobal.IVec3._hx_index] = "ivec3";
	gl[hxsl_TGlobal.IVec4._hx_index] = "ivec4";
	gl[hxsl_TGlobal.BVec2._hx_index] = "bvec2";
	gl[hxsl_TGlobal.BVec3._hx_index] = "bvec3";
	gl[hxsl_TGlobal.BVec4._hx_index] = "bvec4";
	gl[hxsl_TGlobal.FragCoord._hx_index] = "gl_FragCoord";
	gl[hxsl_TGlobal.FrontFacing._hx_index] = "gl_FrontFacing";
	{
		var _g = 0;
		while(_g < gl.length) {
			var g = gl[_g];
			++_g;
			hxsl_GlslOut.KWDS.h[g] = true;
		}
	}
	$r = gl;
	return $r;
}(this));
hxsl_GlslOut.MAT34 = "struct _mat3x4 { vec4 a; vec4 b; vec4 c; };";
hxsl__$Linker_ShaderInfos.UID = 0;
hxsl_Printer.SWIZ = ["x","y","z","w"];
hxsl_RuntimeShader.UID = 0;
hxsl_Serializer.TVECS = new haxe_ds_IntMap();
hxsl_Serializer.BOPS = (function($this) {
	var $r;
	var ops = haxe_macro_Binop.__empty_constructs__.slice();
	ops.splice(haxe_macro_Binop.OpAssignOp(null)._hx_index,0,null);
	$r = ops;
	return $r;
}(this));
hxsl_Serializer.UNOPS = haxe_macro_Unop.__empty_constructs__.slice();
hxsl_Serializer.TGLOBALS = hxsl_TGlobal.__empty_constructs__.slice();
hxsl_Serializer.TSWIZ = new haxe_ds_IntMap();
hxsl_Serializer.REGS = [hxsl_Component.X,hxsl_Component.Y,hxsl_Component.Z,hxsl_Component.W];
hxsl_Serializer.VKINDS = hxsl_VarKind.__empty_constructs__.slice();
hxsl_Serializer.PRECS = hxsl_Prec.__empty_constructs__.slice();
hxsl_Serializer.FKIND = hxsl_FunctionKind.__empty_constructs__.slice();
hxsl_Serializer.SIGN = 9139229;
hxsl_ShaderList.MAX_LIST_SIZE = 0;
hxsl_ShaderList.ALLOW_DUPLICATES = true;
hxsl_ShaderInstance.UID = 0;
hxsl_SharedShader.UNROLL_LOOPS = false;
stb_format_vorbis_VorbisTools.INVERSE_DB_TABLE = [1.0649863e-07,1.1341951e-07,1.2079015e-07,1.2863978e-07,1.3699951e-07,1.4590251e-07,1.5538408e-07,1.6548181e-07,1.7623575e-07,1.8768855e-07,1.9988561e-07,2.1287530e-07,2.2670913e-07,2.4144197e-07,2.5713223e-07,2.7384213e-07,2.9163793e-07,3.1059021e-07,3.3077411e-07,3.5226968e-07,3.7516214e-07,3.9954229e-07,4.2550680e-07,4.5315863e-07,4.8260743e-07,5.1396998e-07,5.4737065e-07,5.8294187e-07,6.2082472e-07,6.6116941e-07,7.0413592e-07,7.4989464e-07,7.9862701e-07,8.5052630e-07,9.0579828e-07,9.6466216e-07,1.0273513e-06,1.0941144e-06,1.1652161e-06,1.2409384e-06,1.3215816e-06,1.4074654e-06,1.4989305e-06,1.5963394e-06,1.7000785e-06,1.8105592e-06,1.9282195e-06,2.0535261e-06,2.1869758e-06,2.3290978e-06,2.4804557e-06,2.6416497e-06,2.8133190e-06,2.9961443e-06,3.1908506e-06,3.3982101e-06,3.6190449e-06,3.8542308e-06,4.1047004e-06,4.3714470e-06,4.6555282e-06,4.9580707e-06,5.2802740e-06,5.6234160e-06,5.9888572e-06,6.3780469e-06,6.7925283e-06,7.2339451e-06,7.7040476e-06,8.2047000e-06,8.7378876e-06,9.3057248e-06,9.9104632e-06,1.0554501e-05,1.1240392e-05,1.1970856e-05,1.2748789e-05,1.3577278e-05,1.4459606e-05,1.5399272e-05,1.6400004e-05,1.7465768e-05,1.8600792e-05,1.9809576e-05,2.1096914e-05,2.2467911e-05,2.3928002e-05,2.5482978e-05,2.7139006e-05,2.8902651e-05,3.0780908e-05,3.2781225e-05,3.4911534e-05,3.7180282e-05,3.9596466e-05,4.2169667e-05,4.4910090e-05,4.7828601e-05,5.0936773e-05,5.4246931e-05,5.7772202e-05,6.1526565e-05,6.5524908e-05,6.9783085e-05,7.4317983e-05,7.9147585e-05,8.4291040e-05,8.9768747e-05,9.5602426e-05,0.00010181521,0.00010843174,0.00011547824,0.00012298267,0.00013097477,0.00013948625,0.00014855085,0.00015820453,0.00016848555,0.00017943469,0.00019109536,0.00020351382,0.00021673929,0.00023082423,0.00024582449,0.00026179955,0.00027881276,0.00029693158,0.00031622787,0.00033677814,0.00035866388,0.00038197188,0.00040679456,0.00043323036,0.00046138411,0.00049136745,0.00052329927,0.00055730621,0.00059352311,0.00063209358,0.00067317058,0.00071691700,0.00076350630,0.00081312324,0.00086596457,0.00092223983,0.00098217216,0.0010459992,0.0011139742,0.0011863665,0.0012634633,0.0013455702,0.0014330129,0.0015261382,0.0016253153,0.0017309374,0.0018434235,0.0019632195,0.0020908006,0.0022266726,0.0023713743,0.0025254795,0.0026895994,0.0028643847,0.0030505286,0.0032487691,0.0034598925,0.0036847358,0.0039241906,0.0041792066,0.0044507950,0.0047400328,0.0050480668,0.0053761186,0.0057254891,0.0060975636,0.0064938176,0.0069158225,0.0073652516,0.0078438871,0.0083536271,0.0088964928,0.009474637,0.010090352,0.010746080,0.011444421,0.012188144,0.012980198,0.013823725,0.014722068,0.015678791,0.016697687,0.017782797,0.018938423,0.020169149,0.021479854,0.022875735,0.024362330,0.025945531,0.027631618,0.029427276,0.031339626,0.033376252,0.035545228,0.037855157,0.040315199,0.042935108,0.045725273,0.048696758,0.051861348,0.055231591,0.058820850,0.062643361,0.066714279,0.071049749,0.075666962,0.080584227,0.085821044,0.091398179,0.097337747,0.10366330,0.11039993,0.11757434,0.12521498,0.13335215,0.14201813,0.15124727,0.16107617,0.17154380,0.18269168,0.19456402,0.20720788,0.22067342,0.23501402,0.25028656,0.26655159,0.28387361,0.30232132,0.32196786,0.34289114,0.36517414,0.38890521,0.41417847,0.44109412,0.46975890,0.50028648,0.53279791,0.56742212,0.60429640,0.64356699,0.68538959,0.72993007,0.77736504,0.82788260,0.88168307,0.9389798,1.0];
{
	Boot.main();
	haxe_EntryPoint.run();
}
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
